var Vre=Object.defineProperty;var jre=(t,e,n)=>e in t?Vre(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var Zo=(t,e,n)=>jre(t,typeof e!="symbol"?e+"":e,n);function Xre(t,e){for(var n=0;n<e.length;n++){const r=e[n];if(typeof r!="string"&&!Array.isArray(r)){for(const i in r)if(i!=="default"&&!(i in t)){const s=Object.getOwnPropertyDescriptor(r,i);s&&Object.defineProperty(t,i,s.get?s:{enumerable:!0,get:()=>r[i]})}}}return Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))r(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&r(a)}).observe(document,{childList:!0,subtree:!0});function n(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerPolicy&&(s.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?s.credentials="include":i.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(i){if(i.ep)return;i.ep=!0;const s=n(i);fetch(i.href,s)}})();function N5(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var R5={exports:{}},rT={},F5={exports:{}},qn={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var N1=Symbol.for("react.element"),Kre=Symbol.for("react.portal"),qre=Symbol.for("react.fragment"),Jre=Symbol.for("react.strict_mode"),Yre=Symbol.for("react.profiler"),Zre=Symbol.for("react.provider"),Qre=Symbol.for("react.context"),eie=Symbol.for("react.forward_ref"),tie=Symbol.for("react.suspense"),nie=Symbol.for("react.memo"),rie=Symbol.for("react.lazy"),xz=Symbol.iterator;function iie(t){return t===null||typeof t!="object"?null:(t=xz&&t[xz]||t["@@iterator"],typeof t=="function"?t:null)}var D5={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},P5=Object.assign,L5={};function u0(t,e,n){this.props=t,this.context=e,this.refs=L5,this.updater=n||D5}u0.prototype.isReactComponent={};u0.prototype.setState=function(t,e){if(typeof t!="object"&&typeof t!="function"&&t!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,t,e,"setState")};u0.prototype.forceUpdate=function(t){this.updater.enqueueForceUpdate(this,t,"forceUpdate")};function O5(){}O5.prototype=u0.prototype;function pD(t,e,n){this.props=t,this.context=e,this.refs=L5,this.updater=n||D5}var fD=pD.prototype=new O5;fD.constructor=pD;P5(fD,u0.prototype);fD.isPureReactComponent=!0;var bz=Array.isArray,B5=Object.prototype.hasOwnProperty,mD={current:null},U5={key:!0,ref:!0,__self:!0,__source:!0};function $5(t,e,n){var r,i={},s=null,a=null;if(e!=null)for(r in e.ref!==void 0&&(a=e.ref),e.key!==void 0&&(s=""+e.key),e)B5.call(e,r)&&!U5.hasOwnProperty(r)&&(i[r]=e[r]);var o=arguments.length-2;if(o===1)i.children=n;else if(1<o){for(var l=Array(o),u=0;u<o;u++)l[u]=arguments[u+2];i.children=l}if(t&&t.defaultProps)for(r in o=t.defaultProps,o)i[r]===void 0&&(i[r]=o[r]);return{$$typeof:N1,type:t,key:s,ref:a,props:i,_owner:mD.current}}function sie(t,e){return{$$typeof:N1,type:t.type,key:e,ref:t.ref,props:t.props,_owner:t._owner}}function gD(t){return typeof t=="object"&&t!==null&&t.$$typeof===N1}function aie(t){var e={"=":"=0",":":"=2"};return"$"+t.replace(/[=:]/g,function(n){return e[n]})}var wz=/\/+/g;function T2(t,e){return typeof t=="object"&&t!==null&&t.key!=null?aie(""+t.key):e.toString(36)}function FA(t,e,n,r,i){var s=typeof t;(s==="undefined"||s==="boolean")&&(t=null);var a=!1;if(t===null)a=!0;else switch(s){case"string":case"number":a=!0;break;case"object":switch(t.$$typeof){case N1:case Kre:a=!0}}if(a)return a=t,i=i(a),t=r===""?"."+T2(a,0):r,bz(i)?(n="",t!=null&&(n=t.replace(wz,"$&/")+"/"),FA(i,e,n,"",function(u){return u})):i!=null&&(gD(i)&&(i=sie(i,n+(!i.key||a&&a.key===i.key?"":(""+i.key).replace(wz,"$&/")+"/")+t)),e.push(i)),1;if(a=0,r=r===""?".":r+":",bz(t))for(var o=0;o<t.length;o++){s=t[o];var l=r+T2(s,o);a+=FA(s,e,n,l,i)}else if(l=iie(t),typeof l=="function")for(t=l.call(t),o=0;!(s=t.next()).done;)s=s.value,l=r+T2(s,o++),a+=FA(s,e,n,l,i);else if(s==="object")throw e=String(t),Error("Objects are not valid as a React child (found: "+(e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return a}function Z_(t,e,n){if(t==null)return t;var r=[],i=0;return FA(t,r,"","",function(s){return e.call(n,s,i++)}),r}function oie(t){if(t._status===-1){var e=t._result;e=e(),e.then(function(n){(t._status===0||t._status===-1)&&(t._status=1,t._result=n)},function(n){(t._status===0||t._status===-1)&&(t._status=2,t._result=n)}),t._status===-1&&(t._status=0,t._result=e)}if(t._status===1)return t._result.default;throw t._result}var fa={current:null},DA={transition:null},lie={ReactCurrentDispatcher:fa,ReactCurrentBatchConfig:DA,ReactCurrentOwner:mD};function z5(){throw Error("act(...) is not supported in production builds of React.")}qn.Children={map:Z_,forEach:function(t,e,n){Z_(t,function(){e.apply(this,arguments)},n)},count:function(t){var e=0;return Z_(t,function(){e++}),e},toArray:function(t){return Z_(t,function(e){return e})||[]},only:function(t){if(!gD(t))throw Error("React.Children.only expected to receive a single React element child.");return t}};qn.Component=u0;qn.Fragment=qre;qn.Profiler=Yre;qn.PureComponent=pD;qn.StrictMode=Jre;qn.Suspense=tie;qn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=lie;qn.act=z5;qn.cloneElement=function(t,e,n){if(t==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+t+".");var r=P5({},t.props),i=t.key,s=t.ref,a=t._owner;if(e!=null){if(e.ref!==void 0&&(s=e.ref,a=mD.current),e.key!==void 0&&(i=""+e.key),t.type&&t.type.defaultProps)var o=t.type.defaultProps;for(l in e)B5.call(e,l)&&!U5.hasOwnProperty(l)&&(r[l]=e[l]===void 0&&o!==void 0?o[l]:e[l])}var l=arguments.length-2;if(l===1)r.children=n;else if(1<l){o=Array(l);for(var u=0;u<l;u++)o[u]=arguments[u+2];r.children=o}return{$$typeof:N1,type:t.type,key:i,ref:s,props:r,_owner:a}};qn.createContext=function(t){return t={$$typeof:Qre,_currentValue:t,_currentValue2:t,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},t.Provider={$$typeof:Zre,_context:t},t.Consumer=t};qn.createElement=$5;qn.createFactory=function(t){var e=$5.bind(null,t);return e.type=t,e};qn.createRef=function(){return{current:null}};qn.forwardRef=function(t){return{$$typeof:eie,render:t}};qn.isValidElement=gD;qn.lazy=function(t){return{$$typeof:rie,_payload:{_status:-1,_result:t},_init:oie}};qn.memo=function(t,e){return{$$typeof:nie,type:t,compare:e===void 0?null:e}};qn.startTransition=function(t){var e=DA.transition;DA.transition={};try{t()}finally{DA.transition=e}};qn.unstable_act=z5;qn.useCallback=function(t,e){return fa.current.useCallback(t,e)};qn.useContext=function(t){return fa.current.useContext(t)};qn.useDebugValue=function(){};qn.useDeferredValue=function(t){return fa.current.useDeferredValue(t)};qn.useEffect=function(t,e){return fa.current.useEffect(t,e)};qn.useId=function(){return fa.current.useId()};qn.useImperativeHandle=function(t,e,n){return fa.current.useImperativeHandle(t,e,n)};qn.useInsertionEffect=function(t,e){return fa.current.useInsertionEffect(t,e)};qn.useLayoutEffect=function(t,e){return fa.current.useLayoutEffect(t,e)};qn.useMemo=function(t,e){return fa.current.useMemo(t,e)};qn.useReducer=function(t,e,n){return fa.current.useReducer(t,e,n)};qn.useRef=function(t){return fa.current.useRef(t)};qn.useState=function(t){return fa.current.useState(t)};qn.useSyncExternalStore=function(t,e,n){return fa.current.useSyncExternalStore(t,e,n)};qn.useTransition=function(){return fa.current.useTransition()};qn.version="18.3.1";F5.exports=qn;var ne=F5.exports;const G5=N5(ne),uie=Xre({__proto__:null,default:G5},[ne]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var cie=ne,die=Symbol.for("react.element"),hie=Symbol.for("react.fragment"),pie=Object.prototype.hasOwnProperty,fie=cie.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,mie={key:!0,ref:!0,__self:!0,__source:!0};function H5(t,e,n){var r,i={},s=null,a=null;n!==void 0&&(s=""+n),e.key!==void 0&&(s=""+e.key),e.ref!==void 0&&(a=e.ref);for(r in e)pie.call(e,r)&&!mie.hasOwnProperty(r)&&(i[r]=e[r]);if(t&&t.defaultProps)for(r in e=t.defaultProps,e)i[r]===void 0&&(i[r]=e[r]);return{$$typeof:die,type:t,key:s,ref:a,props:i,_owner:fie.current}}rT.Fragment=hie;rT.jsx=H5;rT.jsxs=H5;R5.exports=rT;var D=R5.exports,W5={exports:{}},po={},V5={exports:{}},j5={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(t){function e(O,j){var X=O.length;O.push(j);e:for(;0<X;){var te=X-1>>>1,le=O[te];if(0<i(le,j))O[te]=j,O[X]=le,X=te;else break e}}function n(O){return O.length===0?null:O[0]}function r(O){if(O.length===0)return null;var j=O[0],X=O.pop();if(X!==j){O[0]=X;e:for(var te=0,le=O.length,ge=le>>>1;te<ge;){var ie=2*(te+1)-1,we=O[ie],Ce=ie+1,Re=O[Ce];if(0>i(we,X))Ce<le&&0>i(Re,we)?(O[te]=Re,O[Ce]=X,te=Ce):(O[te]=we,O[ie]=X,te=ie);else if(Ce<le&&0>i(Re,X))O[te]=Re,O[Ce]=X,te=Ce;else break e}}return j}function i(O,j){var X=O.sortIndex-j.sortIndex;return X!==0?X:O.id-j.id}if(typeof performance=="object"&&typeof performance.now=="function"){var s=performance;t.unstable_now=function(){return s.now()}}else{var a=Date,o=a.now();t.unstable_now=function(){return a.now()-o}}var l=[],u=[],c=1,d=null,h=3,p=!1,f=!1,g=!1,y=typeof setTimeout=="function"?setTimeout:null,m=typeof clearTimeout=="function"?clearTimeout:null,b=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function w(O){for(var j=n(u);j!==null;){if(j.callback===null)r(u);else if(j.startTime<=O)r(u),j.sortIndex=j.expirationTime,e(l,j);else break;j=n(u)}}function _(O){if(g=!1,w(O),!f)if(n(l)!==null)f=!0,K(S);else{var j=n(u);j!==null&&Q(_,j.startTime-O)}}function S(O,j){f=!1,g&&(g=!1,m(T),T=-1),p=!0;var X=h;try{for(w(j),d=n(l);d!==null&&(!(d.expirationTime>j)||O&&!R());){var te=d.callback;if(typeof te=="function"){d.callback=null,h=d.priorityLevel;var le=te(d.expirationTime<=j);j=t.unstable_now(),typeof le=="function"?d.callback=le:d===n(l)&&r(l),w(j)}else r(l);d=n(l)}if(d!==null)var ge=!0;else{var ie=n(u);ie!==null&&Q(_,ie.startTime-j),ge=!1}return ge}finally{d=null,h=X,p=!1}}var E=!1,C=null,T=-1,M=5,k=-1;function R(){return!(t.unstable_now()-k<M)}function N(){if(C!==null){var O=t.unstable_now();k=O;var j=!0;try{j=C(!0,O)}finally{j?B():(E=!1,C=null)}}else E=!1}var B;if(typeof b=="function")B=function(){b(N)};else if(typeof MessageChannel<"u"){var z=new MessageChannel,V=z.port2;z.port1.onmessage=N,B=function(){V.postMessage(null)}}else B=function(){y(N,0)};function K(O){C=O,E||(E=!0,B())}function Q(O,j){T=y(function(){O(t.unstable_now())},j)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(O){O.callback=null},t.unstable_continueExecution=function(){f||p||(f=!0,K(S))},t.unstable_forceFrameRate=function(O){0>O||125<O?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):M=0<O?Math.floor(1e3/O):5},t.unstable_getCurrentPriorityLevel=function(){return h},t.unstable_getFirstCallbackNode=function(){return n(l)},t.unstable_next=function(O){switch(h){case 1:case 2:case 3:var j=3;break;default:j=h}var X=h;h=j;try{return O()}finally{h=X}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(O,j){switch(O){case 1:case 2:case 3:case 4:case 5:break;default:O=3}var X=h;h=O;try{return j()}finally{h=X}},t.unstable_scheduleCallback=function(O,j,X){var te=t.unstable_now();switch(typeof X=="object"&&X!==null?(X=X.delay,X=typeof X=="number"&&0<X?te+X:te):X=te,O){case 1:var le=-1;break;case 2:le=250;break;case 5:le=1073741823;break;case 4:le=1e4;break;default:le=5e3}return le=X+le,O={id:c++,callback:j,priorityLevel:O,startTime:X,expirationTime:le,sortIndex:-1},X>te?(O.sortIndex=X,e(u,O),n(l)===null&&O===n(u)&&(g?(m(T),T=-1):g=!0,Q(_,X-te))):(O.sortIndex=le,e(l,O),f||p||(f=!0,K(S))),O},t.unstable_shouldYield=R,t.unstable_wrapCallback=function(O){var j=h;return function(){var X=h;h=j;try{return O.apply(this,arguments)}finally{h=X}}}})(j5);V5.exports=j5;var gie=V5.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var yie=ne,lo=gie;function yt(t){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+t,n=1;n<arguments.length;n++)e+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+t+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var X5=new Set,Db={};function ff(t,e){Iy(t,e),Iy(t+"Capture",e)}function Iy(t,e){for(Db[t]=e,t=0;t<e.length;t++)X5.add(e[t])}var nc=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),ON=Object.prototype.hasOwnProperty,vie=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,_z={},Sz={};function xie(t){return ON.call(Sz,t)?!0:ON.call(_z,t)?!1:vie.test(t)?Sz[t]=!0:(_z[t]=!0,!1)}function bie(t,e,n,r){if(n!==null&&n.type===0)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return r?!1:n!==null?!n.acceptsBooleans:(t=t.toLowerCase().slice(0,5),t!=="data-"&&t!=="aria-");default:return!1}}function wie(t,e,n,r){if(e===null||typeof e>"u"||bie(t,e,n,r))return!0;if(r)return!1;if(n!==null)switch(n.type){case 3:return!e;case 4:return e===!1;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}function ma(t,e,n,r,i,s,a){this.acceptsBooleans=e===2||e===3||e===4,this.attributeName=r,this.attributeNamespace=i,this.mustUseProperty=n,this.propertyName=t,this.type=e,this.sanitizeURL=s,this.removeEmptyString=a}var xs={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t){xs[t]=new ma(t,0,!1,t,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(t){var e=t[0];xs[e]=new ma(e,1,!1,t[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(t){xs[t]=new ma(t,2,!1,t.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(t){xs[t]=new ma(t,2,!1,t,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t){xs[t]=new ma(t,3,!1,t.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(t){xs[t]=new ma(t,3,!0,t,null,!1,!1)});["capture","download"].forEach(function(t){xs[t]=new ma(t,4,!1,t,null,!1,!1)});["cols","rows","size","span"].forEach(function(t){xs[t]=new ma(t,6,!1,t,null,!1,!1)});["rowSpan","start"].forEach(function(t){xs[t]=new ma(t,5,!1,t.toLowerCase(),null,!1,!1)});var yD=/[\-:]([a-z])/g;function vD(t){return t[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t){var e=t.replace(yD,vD);xs[e]=new ma(e,1,!1,t,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t){var e=t.replace(yD,vD);xs[e]=new ma(e,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(t){var e=t.replace(yD,vD);xs[e]=new ma(e,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(t){xs[t]=new ma(t,1,!1,t.toLowerCase(),null,!1,!1)});xs.xlinkHref=new ma("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(t){xs[t]=new ma(t,1,!1,t.toLowerCase(),null,!0,!0)});function xD(t,e,n,r){var i=xs.hasOwnProperty(e)?xs[e]:null;(i!==null?i.type!==0:r||!(2<e.length)||e[0]!=="o"&&e[0]!=="O"||e[1]!=="n"&&e[1]!=="N")&&(wie(e,n,i,r)&&(n=null),r||i===null?xie(e)&&(n===null?t.removeAttribute(e):t.setAttribute(e,""+n)):i.mustUseProperty?t[i.propertyName]=n===null?i.type===3?!1:"":n:(e=i.attributeName,r=i.attributeNamespace,n===null?t.removeAttribute(e):(i=i.type,n=i===3||i===4&&n===!0?"":""+n,r?t.setAttributeNS(r,e,n):t.setAttribute(e,n))))}var hc=yie.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,Q_=Symbol.for("react.element"),Kg=Symbol.for("react.portal"),qg=Symbol.for("react.fragment"),bD=Symbol.for("react.strict_mode"),BN=Symbol.for("react.profiler"),K5=Symbol.for("react.provider"),q5=Symbol.for("react.context"),wD=Symbol.for("react.forward_ref"),UN=Symbol.for("react.suspense"),$N=Symbol.for("react.suspense_list"),_D=Symbol.for("react.memo"),qc=Symbol.for("react.lazy"),J5=Symbol.for("react.offscreen"),Az=Symbol.iterator;function ox(t){return t===null||typeof t!="object"?null:(t=Az&&t[Az]||t["@@iterator"],typeof t=="function"?t:null)}var ri=Object.assign,C2;function Wx(t){if(C2===void 0)try{throw Error()}catch(n){var e=n.stack.trim().match(/\n( *(at )?)/);C2=e&&e[1]||""}return`
`+C2+t}var M2=!1;function k2(t,e){if(!t||M2)return"";M2=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(e,[])}catch(u){var r=u}Reflect.construct(t,[],e)}else{try{e.call()}catch(u){r=u}t.call(e.prototype)}else{try{throw Error()}catch(u){r=u}t()}}catch(u){if(u&&r&&typeof u.stack=="string"){for(var i=u.stack.split(`
`),s=r.stack.split(`
`),a=i.length-1,o=s.length-1;1<=a&&0<=o&&i[a]!==s[o];)o--;for(;1<=a&&0<=o;a--,o--)if(i[a]!==s[o]){if(a!==1||o!==1)do if(a--,o--,0>o||i[a]!==s[o]){var l=`
`+i[a].replace(" at new "," at ");return t.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",t.displayName)),l}while(1<=a&&0<=o);break}}}finally{M2=!1,Error.prepareStackTrace=n}return(t=t?t.displayName||t.name:"")?Wx(t):""}function _ie(t){switch(t.tag){case 5:return Wx(t.type);case 16:return Wx("Lazy");case 13:return Wx("Suspense");case 19:return Wx("SuspenseList");case 0:case 2:case 15:return t=k2(t.type,!1),t;case 11:return t=k2(t.type.render,!1),t;case 1:return t=k2(t.type,!0),t;default:return""}}function zN(t){if(t==null)return null;if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t;switch(t){case qg:return"Fragment";case Kg:return"Portal";case BN:return"Profiler";case bD:return"StrictMode";case UN:return"Suspense";case $N:return"SuspenseList"}if(typeof t=="object")switch(t.$$typeof){case q5:return(t.displayName||"Context")+".Consumer";case K5:return(t._context.displayName||"Context")+".Provider";case wD:var e=t.render;return t=t.displayName,t||(t=e.displayName||e.name||"",t=t!==""?"ForwardRef("+t+")":"ForwardRef"),t;case _D:return e=t.displayName||null,e!==null?e:zN(t.type)||"Memo";case qc:e=t._payload,t=t._init;try{return zN(t(e))}catch{}}return null}function Sie(t){var e=t.type;switch(t.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return t=e.render,t=t.displayName||t.name||"",e.displayName||(t!==""?"ForwardRef("+t+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return zN(e);case 8:return e===bD?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e}return null}function Id(t){switch(typeof t){case"boolean":case"number":case"string":case"undefined":return t;case"object":return t;default:return""}}function Y5(t){var e=t.type;return(t=t.nodeName)&&t.toLowerCase()==="input"&&(e==="checkbox"||e==="radio")}function Aie(t){var e=Y5(t)?"checked":"value",n=Object.getOwnPropertyDescriptor(t.constructor.prototype,e),r=""+t[e];if(!t.hasOwnProperty(e)&&typeof n<"u"&&typeof n.get=="function"&&typeof n.set=="function"){var i=n.get,s=n.set;return Object.defineProperty(t,e,{configurable:!0,get:function(){return i.call(this)},set:function(a){r=""+a,s.call(this,a)}}),Object.defineProperty(t,e,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(a){r=""+a},stopTracking:function(){t._valueTracker=null,delete t[e]}}}}function eS(t){t._valueTracker||(t._valueTracker=Aie(t))}function Z5(t){if(!t)return!1;var e=t._valueTracker;if(!e)return!0;var n=e.getValue(),r="";return t&&(r=Y5(t)?t.checked?"true":"false":t.value),t=r,t!==n?(e.setValue(t),!0):!1}function oE(t){if(t=t||(typeof document<"u"?document:void 0),typeof t>"u")return null;try{return t.activeElement||t.body}catch{return t.body}}function GN(t,e){var n=e.checked;return ri({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:n??t._wrapperState.initialChecked})}function Ez(t,e){var n=e.defaultValue==null?"":e.defaultValue,r=e.checked!=null?e.checked:e.defaultChecked;n=Id(e.value!=null?e.value:n),t._wrapperState={initialChecked:r,initialValue:n,controlled:e.type==="checkbox"||e.type==="radio"?e.checked!=null:e.value!=null}}function Q5(t,e){e=e.checked,e!=null&&xD(t,"checked",e,!1)}function HN(t,e){Q5(t,e);var n=Id(e.value),r=e.type;if(n!=null)r==="number"?(n===0&&t.value===""||t.value!=n)&&(t.value=""+n):t.value!==""+n&&(t.value=""+n);else if(r==="submit"||r==="reset"){t.removeAttribute("value");return}e.hasOwnProperty("value")?WN(t,e.type,n):e.hasOwnProperty("defaultValue")&&WN(t,e.type,Id(e.defaultValue)),e.checked==null&&e.defaultChecked!=null&&(t.defaultChecked=!!e.defaultChecked)}function Iz(t,e,n){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var r=e.type;if(!(r!=="submit"&&r!=="reset"||e.value!==void 0&&e.value!==null))return;e=""+t._wrapperState.initialValue,n||e===t.value||(t.value=e),t.defaultValue=e}n=t.name,n!==""&&(t.name=""),t.defaultChecked=!!t._wrapperState.initialChecked,n!==""&&(t.name=n)}function WN(t,e,n){(e!=="number"||oE(t.ownerDocument)!==t)&&(n==null?t.defaultValue=""+t._wrapperState.initialValue:t.defaultValue!==""+n&&(t.defaultValue=""+n))}var Vx=Array.isArray;function cy(t,e,n,r){if(t=t.options,e){e={};for(var i=0;i<n.length;i++)e["$"+n[i]]=!0;for(n=0;n<t.length;n++)i=e.hasOwnProperty("$"+t[n].value),t[n].selected!==i&&(t[n].selected=i),i&&r&&(t[n].defaultSelected=!0)}else{for(n=""+Id(n),e=null,i=0;i<t.length;i++){if(t[i].value===n){t[i].selected=!0,r&&(t[i].defaultSelected=!0);return}e!==null||t[i].disabled||(e=t[i])}e!==null&&(e.selected=!0)}}function VN(t,e){if(e.dangerouslySetInnerHTML!=null)throw Error(yt(91));return ri({},e,{value:void 0,defaultValue:void 0,children:""+t._wrapperState.initialValue})}function Tz(t,e){var n=e.value;if(n==null){if(n=e.children,e=e.defaultValue,n!=null){if(e!=null)throw Error(yt(92));if(Vx(n)){if(1<n.length)throw Error(yt(93));n=n[0]}e=n}e==null&&(e=""),n=e}t._wrapperState={initialValue:Id(n)}}function e6(t,e){var n=Id(e.value),r=Id(e.defaultValue);n!=null&&(n=""+n,n!==t.value&&(t.value=n),e.defaultValue==null&&t.defaultValue!==n&&(t.defaultValue=n)),r!=null&&(t.defaultValue=""+r)}function Cz(t){var e=t.textContent;e===t._wrapperState.initialValue&&e!==""&&e!==null&&(t.value=e)}function t6(t){switch(t){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function jN(t,e){return t==null||t==="http://www.w3.org/1999/xhtml"?t6(e):t==="http://www.w3.org/2000/svg"&&e==="foreignObject"?"http://www.w3.org/1999/xhtml":t}var tS,n6=function(t){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(e,n,r,i){MSApp.execUnsafeLocalFunction(function(){return t(e,n,r,i)})}:t}(function(t,e){if(t.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in t)t.innerHTML=e;else{for(tS=tS||document.createElement("div"),tS.innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=tS.firstChild;t.firstChild;)t.removeChild(t.firstChild);for(;e.firstChild;)t.appendChild(e.firstChild)}});function Pb(t,e){if(e){var n=t.firstChild;if(n&&n===t.lastChild&&n.nodeType===3){n.nodeValue=e;return}}t.textContent=e}var ub={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Eie=["Webkit","ms","Moz","O"];Object.keys(ub).forEach(function(t){Eie.forEach(function(e){e=e+t.charAt(0).toUpperCase()+t.substring(1),ub[e]=ub[t]})});function r6(t,e,n){return e==null||typeof e=="boolean"||e===""?"":n||typeof e!="number"||e===0||ub.hasOwnProperty(t)&&ub[t]?(""+e).trim():e+"px"}function i6(t,e){t=t.style;for(var n in e)if(e.hasOwnProperty(n)){var r=n.indexOf("--")===0,i=r6(n,e[n],r);n==="float"&&(n="cssFloat"),r?t.setProperty(n,i):t[n]=i}}var Iie=ri({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function XN(t,e){if(e){if(Iie[t]&&(e.children!=null||e.dangerouslySetInnerHTML!=null))throw Error(yt(137,t));if(e.dangerouslySetInnerHTML!=null){if(e.children!=null)throw Error(yt(60));if(typeof e.dangerouslySetInnerHTML!="object"||!("__html"in e.dangerouslySetInnerHTML))throw Error(yt(61))}if(e.style!=null&&typeof e.style!="object")throw Error(yt(62))}}function KN(t,e){if(t.indexOf("-")===-1)return typeof e.is=="string";switch(t){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var qN=null;function SD(t){return t=t.target||t.srcElement||window,t.correspondingUseElement&&(t=t.correspondingUseElement),t.nodeType===3?t.parentNode:t}var JN=null,dy=null,hy=null;function Mz(t){if(t=D1(t)){if(typeof JN!="function")throw Error(yt(280));var e=t.stateNode;e&&(e=lT(e),JN(t.stateNode,t.type,e))}}function s6(t){dy?hy?hy.push(t):hy=[t]:dy=t}function a6(){if(dy){var t=dy,e=hy;if(hy=dy=null,Mz(t),e)for(t=0;t<e.length;t++)Mz(e[t])}}function o6(t,e){return t(e)}function l6(){}var N2=!1;function u6(t,e,n){if(N2)return t(e,n);N2=!0;try{return o6(t,e,n)}finally{N2=!1,(dy!==null||hy!==null)&&(l6(),a6())}}function Lb(t,e){var n=t.stateNode;if(n===null)return null;var r=lT(n);if(r===null)return null;n=r[e];e:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(t=t.type,r=!(t==="button"||t==="input"||t==="select"||t==="textarea")),t=!r;break e;default:t=!1}if(t)return null;if(n&&typeof n!="function")throw Error(yt(231,e,typeof n));return n}var YN=!1;if(nc)try{var lx={};Object.defineProperty(lx,"passive",{get:function(){YN=!0}}),window.addEventListener("test",lx,lx),window.removeEventListener("test",lx,lx)}catch{YN=!1}function Tie(t,e,n,r,i,s,a,o,l){var u=Array.prototype.slice.call(arguments,3);try{e.apply(n,u)}catch(c){this.onError(c)}}var cb=!1,lE=null,uE=!1,ZN=null,Cie={onError:function(t){cb=!0,lE=t}};function Mie(t,e,n,r,i,s,a,o,l){cb=!1,lE=null,Tie.apply(Cie,arguments)}function kie(t,e,n,r,i,s,a,o,l){if(Mie.apply(this,arguments),cb){if(cb){var u=lE;cb=!1,lE=null}else throw Error(yt(198));uE||(uE=!0,ZN=u)}}function mf(t){var e=t,n=t;if(t.alternate)for(;e.return;)e=e.return;else{t=e;do e=t,e.flags&4098&&(n=e.return),t=e.return;while(t)}return e.tag===3?n:null}function c6(t){if(t.tag===13){var e=t.memoizedState;if(e===null&&(t=t.alternate,t!==null&&(e=t.memoizedState)),e!==null)return e.dehydrated}return null}function kz(t){if(mf(t)!==t)throw Error(yt(188))}function Nie(t){var e=t.alternate;if(!e){if(e=mf(t),e===null)throw Error(yt(188));return e!==t?null:t}for(var n=t,r=e;;){var i=n.return;if(i===null)break;var s=i.alternate;if(s===null){if(r=i.return,r!==null){n=r;continue}break}if(i.child===s.child){for(s=i.child;s;){if(s===n)return kz(i),t;if(s===r)return kz(i),e;s=s.sibling}throw Error(yt(188))}if(n.return!==r.return)n=i,r=s;else{for(var a=!1,o=i.child;o;){if(o===n){a=!0,n=i,r=s;break}if(o===r){a=!0,r=i,n=s;break}o=o.sibling}if(!a){for(o=s.child;o;){if(o===n){a=!0,n=s,r=i;break}if(o===r){a=!0,r=s,n=i;break}o=o.sibling}if(!a)throw Error(yt(189))}}if(n.alternate!==r)throw Error(yt(190))}if(n.tag!==3)throw Error(yt(188));return n.stateNode.current===n?t:e}function d6(t){return t=Nie(t),t!==null?h6(t):null}function h6(t){if(t.tag===5||t.tag===6)return t;for(t=t.child;t!==null;){var e=h6(t);if(e!==null)return e;t=t.sibling}return null}var p6=lo.unstable_scheduleCallback,Nz=lo.unstable_cancelCallback,Rie=lo.unstable_shouldYield,Fie=lo.unstable_requestPaint,mi=lo.unstable_now,Die=lo.unstable_getCurrentPriorityLevel,AD=lo.unstable_ImmediatePriority,f6=lo.unstable_UserBlockingPriority,cE=lo.unstable_NormalPriority,Pie=lo.unstable_LowPriority,m6=lo.unstable_IdlePriority,iT=null,eu=null;function Lie(t){if(eu&&typeof eu.onCommitFiberRoot=="function")try{eu.onCommitFiberRoot(iT,t,void 0,(t.current.flags&128)===128)}catch{}}var ml=Math.clz32?Math.clz32:Uie,Oie=Math.log,Bie=Math.LN2;function Uie(t){return t>>>=0,t===0?32:31-(Oie(t)/Bie|0)|0}var nS=64,rS=4194304;function jx(t){switch(t&-t){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return t&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return t}}function dE(t,e){var n=t.pendingLanes;if(n===0)return 0;var r=0,i=t.suspendedLanes,s=t.pingedLanes,a=n&268435455;if(a!==0){var o=a&~i;o!==0?r=jx(o):(s&=a,s!==0&&(r=jx(s)))}else a=n&~i,a!==0?r=jx(a):s!==0&&(r=jx(s));if(r===0)return 0;if(e!==0&&e!==r&&!(e&i)&&(i=r&-r,s=e&-e,i>=s||i===16&&(s&4194240)!==0))return e;if(r&4&&(r|=n&16),e=t.entangledLanes,e!==0)for(t=t.entanglements,e&=r;0<e;)n=31-ml(e),i=1<<n,r|=t[n],e&=~i;return r}function $ie(t,e){switch(t){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function zie(t,e){for(var n=t.suspendedLanes,r=t.pingedLanes,i=t.expirationTimes,s=t.pendingLanes;0<s;){var a=31-ml(s),o=1<<a,l=i[a];l===-1?(!(o&n)||o&r)&&(i[a]=$ie(o,e)):l<=e&&(t.expiredLanes|=o),s&=~o}}function QN(t){return t=t.pendingLanes&-1073741825,t!==0?t:t&1073741824?1073741824:0}function g6(){var t=nS;return nS<<=1,!(nS&4194240)&&(nS=64),t}function R2(t){for(var e=[],n=0;31>n;n++)e.push(t);return e}function R1(t,e,n){t.pendingLanes|=e,e!==536870912&&(t.suspendedLanes=0,t.pingedLanes=0),t=t.eventTimes,e=31-ml(e),t[e]=n}function Gie(t,e){var n=t.pendingLanes&~e;t.pendingLanes=e,t.suspendedLanes=0,t.pingedLanes=0,t.expiredLanes&=e,t.mutableReadLanes&=e,t.entangledLanes&=e,e=t.entanglements;var r=t.eventTimes;for(t=t.expirationTimes;0<n;){var i=31-ml(n),s=1<<i;e[i]=0,r[i]=-1,t[i]=-1,n&=~s}}function ED(t,e){var n=t.entangledLanes|=e;for(t=t.entanglements;n;){var r=31-ml(n),i=1<<r;i&e|t[r]&e&&(t[r]|=e),n&=~i}}var br=0;function y6(t){return t&=-t,1<t?4<t?t&268435455?16:536870912:4:1}var v6,ID,x6,b6,w6,eR=!1,iS=[],pd=null,fd=null,md=null,Ob=new Map,Bb=new Map,ed=[],Hie="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Rz(t,e){switch(t){case"focusin":case"focusout":pd=null;break;case"dragenter":case"dragleave":fd=null;break;case"mouseover":case"mouseout":md=null;break;case"pointerover":case"pointerout":Ob.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":Bb.delete(e.pointerId)}}function ux(t,e,n,r,i,s){return t===null||t.nativeEvent!==s?(t={blockedOn:e,domEventName:n,eventSystemFlags:r,nativeEvent:s,targetContainers:[i]},e!==null&&(e=D1(e),e!==null&&ID(e)),t):(t.eventSystemFlags|=r,e=t.targetContainers,i!==null&&e.indexOf(i)===-1&&e.push(i),t)}function Wie(t,e,n,r,i){switch(e){case"focusin":return pd=ux(pd,t,e,n,r,i),!0;case"dragenter":return fd=ux(fd,t,e,n,r,i),!0;case"mouseover":return md=ux(md,t,e,n,r,i),!0;case"pointerover":var s=i.pointerId;return Ob.set(s,ux(Ob.get(s)||null,t,e,n,r,i)),!0;case"gotpointercapture":return s=i.pointerId,Bb.set(s,ux(Bb.get(s)||null,t,e,n,r,i)),!0}return!1}function _6(t){var e=up(t.target);if(e!==null){var n=mf(e);if(n!==null){if(e=n.tag,e===13){if(e=c6(n),e!==null){t.blockedOn=e,w6(t.priority,function(){x6(n)});return}}else if(e===3&&n.stateNode.current.memoizedState.isDehydrated){t.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}t.blockedOn=null}function PA(t){if(t.blockedOn!==null)return!1;for(var e=t.targetContainers;0<e.length;){var n=tR(t.domEventName,t.eventSystemFlags,e[0],t.nativeEvent);if(n===null){n=t.nativeEvent;var r=new n.constructor(n.type,n);qN=r,n.target.dispatchEvent(r),qN=null}else return e=D1(n),e!==null&&ID(e),t.blockedOn=n,!1;e.shift()}return!0}function Fz(t,e,n){PA(t)&&n.delete(e)}function Vie(){eR=!1,pd!==null&&PA(pd)&&(pd=null),fd!==null&&PA(fd)&&(fd=null),md!==null&&PA(md)&&(md=null),Ob.forEach(Fz),Bb.forEach(Fz)}function cx(t,e){t.blockedOn===e&&(t.blockedOn=null,eR||(eR=!0,lo.unstable_scheduleCallback(lo.unstable_NormalPriority,Vie)))}function Ub(t){function e(i){return cx(i,t)}if(0<iS.length){cx(iS[0],t);for(var n=1;n<iS.length;n++){var r=iS[n];r.blockedOn===t&&(r.blockedOn=null)}}for(pd!==null&&cx(pd,t),fd!==null&&cx(fd,t),md!==null&&cx(md,t),Ob.forEach(e),Bb.forEach(e),n=0;n<ed.length;n++)r=ed[n],r.blockedOn===t&&(r.blockedOn=null);for(;0<ed.length&&(n=ed[0],n.blockedOn===null);)_6(n),n.blockedOn===null&&ed.shift()}var py=hc.ReactCurrentBatchConfig,hE=!0;function jie(t,e,n,r){var i=br,s=py.transition;py.transition=null;try{br=1,TD(t,e,n,r)}finally{br=i,py.transition=s}}function Xie(t,e,n,r){var i=br,s=py.transition;py.transition=null;try{br=4,TD(t,e,n,r)}finally{br=i,py.transition=s}}function TD(t,e,n,r){if(hE){var i=tR(t,e,n,r);if(i===null)G2(t,e,r,pE,n),Rz(t,r);else if(Wie(i,t,e,n,r))r.stopPropagation();else if(Rz(t,r),e&4&&-1<Hie.indexOf(t)){for(;i!==null;){var s=D1(i);if(s!==null&&v6(s),s=tR(t,e,n,r),s===null&&G2(t,e,r,pE,n),s===i)break;i=s}i!==null&&r.stopPropagation()}else G2(t,e,r,null,n)}}var pE=null;function tR(t,e,n,r){if(pE=null,t=SD(r),t=up(t),t!==null)if(e=mf(t),e===null)t=null;else if(n=e.tag,n===13){if(t=c6(e),t!==null)return t;t=null}else if(n===3){if(e.stateNode.current.memoizedState.isDehydrated)return e.tag===3?e.stateNode.containerInfo:null;t=null}else e!==t&&(t=null);return pE=t,null}function S6(t){switch(t){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Die()){case AD:return 1;case f6:return 4;case cE:case Pie:return 16;case m6:return 536870912;default:return 16}default:return 16}}var id=null,CD=null,LA=null;function A6(){if(LA)return LA;var t,e=CD,n=e.length,r,i="value"in id?id.value:id.textContent,s=i.length;for(t=0;t<n&&e[t]===i[t];t++);var a=n-t;for(r=1;r<=a&&e[n-r]===i[s-r];r++);return LA=i.slice(t,1<r?1-r:void 0)}function OA(t){var e=t.keyCode;return"charCode"in t?(t=t.charCode,t===0&&e===13&&(t=13)):t=e,t===10&&(t=13),32<=t||t===13?t:0}function sS(){return!0}function Dz(){return!1}function fo(t){function e(n,r,i,s,a){this._reactName=n,this._targetInst=i,this.type=r,this.nativeEvent=s,this.target=a,this.currentTarget=null;for(var o in t)t.hasOwnProperty(o)&&(n=t[o],this[o]=n?n(s):s[o]);return this.isDefaultPrevented=(s.defaultPrevented!=null?s.defaultPrevented:s.returnValue===!1)?sS:Dz,this.isPropagationStopped=Dz,this}return ri(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=sS)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=sS)},persist:function(){},isPersistent:sS}),e}var c0={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(t){return t.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},MD=fo(c0),F1=ri({},c0,{view:0,detail:0}),Kie=fo(F1),F2,D2,dx,sT=ri({},F1,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:kD,button:0,buttons:0,relatedTarget:function(t){return t.relatedTarget===void 0?t.fromElement===t.srcElement?t.toElement:t.fromElement:t.relatedTarget},movementX:function(t){return"movementX"in t?t.movementX:(t!==dx&&(dx&&t.type==="mousemove"?(F2=t.screenX-dx.screenX,D2=t.screenY-dx.screenY):D2=F2=0,dx=t),F2)},movementY:function(t){return"movementY"in t?t.movementY:D2}}),Pz=fo(sT),qie=ri({},sT,{dataTransfer:0}),Jie=fo(qie),Yie=ri({},F1,{relatedTarget:0}),P2=fo(Yie),Zie=ri({},c0,{animationName:0,elapsedTime:0,pseudoElement:0}),Qie=fo(Zie),ese=ri({},c0,{clipboardData:function(t){return"clipboardData"in t?t.clipboardData:window.clipboardData}}),tse=fo(ese),nse=ri({},c0,{data:0}),Lz=fo(nse),rse={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},ise={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},sse={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function ase(t){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(t):(t=sse[t])?!!e[t]:!1}function kD(){return ase}var ose=ri({},F1,{key:function(t){if(t.key){var e=rse[t.key]||t.key;if(e!=="Unidentified")return e}return t.type==="keypress"?(t=OA(t),t===13?"Enter":String.fromCharCode(t)):t.type==="keydown"||t.type==="keyup"?ise[t.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:kD,charCode:function(t){return t.type==="keypress"?OA(t):0},keyCode:function(t){return t.type==="keydown"||t.type==="keyup"?t.keyCode:0},which:function(t){return t.type==="keypress"?OA(t):t.type==="keydown"||t.type==="keyup"?t.keyCode:0}}),lse=fo(ose),use=ri({},sT,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Oz=fo(use),cse=ri({},F1,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:kD}),dse=fo(cse),hse=ri({},c0,{propertyName:0,elapsedTime:0,pseudoElement:0}),pse=fo(hse),fse=ri({},sT,{deltaX:function(t){return"deltaX"in t?t.deltaX:"wheelDeltaX"in t?-t.wheelDeltaX:0},deltaY:function(t){return"deltaY"in t?t.deltaY:"wheelDeltaY"in t?-t.wheelDeltaY:"wheelDelta"in t?-t.wheelDelta:0},deltaZ:0,deltaMode:0}),mse=fo(fse),gse=[9,13,27,32],ND=nc&&"CompositionEvent"in window,db=null;nc&&"documentMode"in document&&(db=document.documentMode);var yse=nc&&"TextEvent"in window&&!db,E6=nc&&(!ND||db&&8<db&&11>=db),Bz=" ",Uz=!1;function I6(t,e){switch(t){case"keyup":return gse.indexOf(e.keyCode)!==-1;case"keydown":return e.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function T6(t){return t=t.detail,typeof t=="object"&&"data"in t?t.data:null}var Jg=!1;function vse(t,e){switch(t){case"compositionend":return T6(e);case"keypress":return e.which!==32?null:(Uz=!0,Bz);case"textInput":return t=e.data,t===Bz&&Uz?null:t;default:return null}}function xse(t,e){if(Jg)return t==="compositionend"||!ND&&I6(t,e)?(t=A6(),LA=CD=id=null,Jg=!1,t):null;switch(t){case"paste":return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return E6&&e.locale!=="ko"?null:e.data;default:return null}}var bse={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function $z(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return e==="input"?!!bse[t.type]:e==="textarea"}function C6(t,e,n,r){s6(r),e=fE(e,"onChange"),0<e.length&&(n=new MD("onChange","change",null,n,r),t.push({event:n,listeners:e}))}var hb=null,$b=null;function wse(t){U6(t,0)}function aT(t){var e=Qg(t);if(Z5(e))return t}function _se(t,e){if(t==="change")return e}var M6=!1;if(nc){var L2;if(nc){var O2="oninput"in document;if(!O2){var zz=document.createElement("div");zz.setAttribute("oninput","return;"),O2=typeof zz.oninput=="function"}L2=O2}else L2=!1;M6=L2&&(!document.documentMode||9<document.documentMode)}function Gz(){hb&&(hb.detachEvent("onpropertychange",k6),$b=hb=null)}function k6(t){if(t.propertyName==="value"&&aT($b)){var e=[];C6(e,$b,t,SD(t)),u6(wse,e)}}function Sse(t,e,n){t==="focusin"?(Gz(),hb=e,$b=n,hb.attachEvent("onpropertychange",k6)):t==="focusout"&&Gz()}function Ase(t){if(t==="selectionchange"||t==="keyup"||t==="keydown")return aT($b)}function Ese(t,e){if(t==="click")return aT(e)}function Ise(t,e){if(t==="input"||t==="change")return aT(e)}function Tse(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var wl=typeof Object.is=="function"?Object.is:Tse;function zb(t,e){if(wl(t,e))return!0;if(typeof t!="object"||t===null||typeof e!="object"||e===null)return!1;var n=Object.keys(t),r=Object.keys(e);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var i=n[r];if(!ON.call(e,i)||!wl(t[i],e[i]))return!1}return!0}function Hz(t){for(;t&&t.firstChild;)t=t.firstChild;return t}function Wz(t,e){var n=Hz(t);t=0;for(var r;n;){if(n.nodeType===3){if(r=t+n.textContent.length,t<=e&&r>=e)return{node:n,offset:e-t};t=r}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=Hz(n)}}function N6(t,e){return t&&e?t===e?!0:t&&t.nodeType===3?!1:e&&e.nodeType===3?N6(t,e.parentNode):"contains"in t?t.contains(e):t.compareDocumentPosition?!!(t.compareDocumentPosition(e)&16):!1:!1}function R6(){for(var t=window,e=oE();e instanceof t.HTMLIFrameElement;){try{var n=typeof e.contentWindow.location.href=="string"}catch{n=!1}if(n)t=e.contentWindow;else break;e=oE(t.document)}return e}function RD(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return e&&(e==="input"&&(t.type==="text"||t.type==="search"||t.type==="tel"||t.type==="url"||t.type==="password")||e==="textarea"||t.contentEditable==="true")}function Cse(t){var e=R6(),n=t.focusedElem,r=t.selectionRange;if(e!==n&&n&&n.ownerDocument&&N6(n.ownerDocument.documentElement,n)){if(r!==null&&RD(n)){if(e=r.start,t=r.end,t===void 0&&(t=e),"selectionStart"in n)n.selectionStart=e,n.selectionEnd=Math.min(t,n.value.length);else if(t=(e=n.ownerDocument||document)&&e.defaultView||window,t.getSelection){t=t.getSelection();var i=n.textContent.length,s=Math.min(r.start,i);r=r.end===void 0?s:Math.min(r.end,i),!t.extend&&s>r&&(i=r,r=s,s=i),i=Wz(n,s);var a=Wz(n,r);i&&a&&(t.rangeCount!==1||t.anchorNode!==i.node||t.anchorOffset!==i.offset||t.focusNode!==a.node||t.focusOffset!==a.offset)&&(e=e.createRange(),e.setStart(i.node,i.offset),t.removeAllRanges(),s>r?(t.addRange(e),t.extend(a.node,a.offset)):(e.setEnd(a.node,a.offset),t.addRange(e)))}}for(e=[],t=n;t=t.parentNode;)t.nodeType===1&&e.push({element:t,left:t.scrollLeft,top:t.scrollTop});for(typeof n.focus=="function"&&n.focus(),n=0;n<e.length;n++)t=e[n],t.element.scrollLeft=t.left,t.element.scrollTop=t.top}}var Mse=nc&&"documentMode"in document&&11>=document.documentMode,Yg=null,nR=null,pb=null,rR=!1;function Vz(t,e,n){var r=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;rR||Yg==null||Yg!==oE(r)||(r=Yg,"selectionStart"in r&&RD(r)?r={start:r.selectionStart,end:r.selectionEnd}:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection(),r={anchorNode:r.anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset}),pb&&zb(pb,r)||(pb=r,r=fE(nR,"onSelect"),0<r.length&&(e=new MD("onSelect","select",null,e,n),t.push({event:e,listeners:r}),e.target=Yg)))}function aS(t,e){var n={};return n[t.toLowerCase()]=e.toLowerCase(),n["Webkit"+t]="webkit"+e,n["Moz"+t]="moz"+e,n}var Zg={animationend:aS("Animation","AnimationEnd"),animationiteration:aS("Animation","AnimationIteration"),animationstart:aS("Animation","AnimationStart"),transitionend:aS("Transition","TransitionEnd")},B2={},F6={};nc&&(F6=document.createElement("div").style,"AnimationEvent"in window||(delete Zg.animationend.animation,delete Zg.animationiteration.animation,delete Zg.animationstart.animation),"TransitionEvent"in window||delete Zg.transitionend.transition);function oT(t){if(B2[t])return B2[t];if(!Zg[t])return t;var e=Zg[t],n;for(n in e)if(e.hasOwnProperty(n)&&n in F6)return B2[t]=e[n];return t}var D6=oT("animationend"),P6=oT("animationiteration"),L6=oT("animationstart"),O6=oT("transitionend"),B6=new Map,jz="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function jd(t,e){B6.set(t,e),ff(e,[t])}for(var U2=0;U2<jz.length;U2++){var $2=jz[U2],kse=$2.toLowerCase(),Nse=$2[0].toUpperCase()+$2.slice(1);jd(kse,"on"+Nse)}jd(D6,"onAnimationEnd");jd(P6,"onAnimationIteration");jd(L6,"onAnimationStart");jd("dblclick","onDoubleClick");jd("focusin","onFocus");jd("focusout","onBlur");jd(O6,"onTransitionEnd");Iy("onMouseEnter",["mouseout","mouseover"]);Iy("onMouseLeave",["mouseout","mouseover"]);Iy("onPointerEnter",["pointerout","pointerover"]);Iy("onPointerLeave",["pointerout","pointerover"]);ff("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));ff("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));ff("onBeforeInput",["compositionend","keypress","textInput","paste"]);ff("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));ff("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));ff("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Xx="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Rse=new Set("cancel close invalid load scroll toggle".split(" ").concat(Xx));function Xz(t,e,n){var r=t.type||"unknown-event";t.currentTarget=n,kie(r,e,void 0,t),t.currentTarget=null}function U6(t,e){e=(e&4)!==0;for(var n=0;n<t.length;n++){var r=t[n],i=r.event;r=r.listeners;e:{var s=void 0;if(e)for(var a=r.length-1;0<=a;a--){var o=r[a],l=o.instance,u=o.currentTarget;if(o=o.listener,l!==s&&i.isPropagationStopped())break e;Xz(i,o,u),s=l}else for(a=0;a<r.length;a++){if(o=r[a],l=o.instance,u=o.currentTarget,o=o.listener,l!==s&&i.isPropagationStopped())break e;Xz(i,o,u),s=l}}}if(uE)throw t=ZN,uE=!1,ZN=null,t}function Pr(t,e){var n=e[lR];n===void 0&&(n=e[lR]=new Set);var r=t+"__bubble";n.has(r)||($6(e,t,2,!1),n.add(r))}function z2(t,e,n){var r=0;e&&(r|=4),$6(n,t,r,e)}var oS="_reactListening"+Math.random().toString(36).slice(2);function Gb(t){if(!t[oS]){t[oS]=!0,X5.forEach(function(n){n!=="selectionchange"&&(Rse.has(n)||z2(n,!1,t),z2(n,!0,t))});var e=t.nodeType===9?t:t.ownerDocument;e===null||e[oS]||(e[oS]=!0,z2("selectionchange",!1,e))}}function $6(t,e,n,r){switch(S6(e)){case 1:var i=jie;break;case 4:i=Xie;break;default:i=TD}n=i.bind(null,e,n,t),i=void 0,!YN||e!=="touchstart"&&e!=="touchmove"&&e!=="wheel"||(i=!0),r?i!==void 0?t.addEventListener(e,n,{capture:!0,passive:i}):t.addEventListener(e,n,!0):i!==void 0?t.addEventListener(e,n,{passive:i}):t.addEventListener(e,n,!1)}function G2(t,e,n,r,i){var s=r;if(!(e&1)&&!(e&2)&&r!==null)e:for(;;){if(r===null)return;var a=r.tag;if(a===3||a===4){var o=r.stateNode.containerInfo;if(o===i||o.nodeType===8&&o.parentNode===i)break;if(a===4)for(a=r.return;a!==null;){var l=a.tag;if((l===3||l===4)&&(l=a.stateNode.containerInfo,l===i||l.nodeType===8&&l.parentNode===i))return;a=a.return}for(;o!==null;){if(a=up(o),a===null)return;if(l=a.tag,l===5||l===6){r=s=a;continue e}o=o.parentNode}}r=r.return}u6(function(){var u=s,c=SD(n),d=[];e:{var h=B6.get(t);if(h!==void 0){var p=MD,f=t;switch(t){case"keypress":if(OA(n)===0)break e;case"keydown":case"keyup":p=lse;break;case"focusin":f="focus",p=P2;break;case"focusout":f="blur",p=P2;break;case"beforeblur":case"afterblur":p=P2;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":p=Pz;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":p=Jie;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":p=dse;break;case D6:case P6:case L6:p=Qie;break;case O6:p=pse;break;case"scroll":p=Kie;break;case"wheel":p=mse;break;case"copy":case"cut":case"paste":p=tse;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":p=Oz}var g=(e&4)!==0,y=!g&&t==="scroll",m=g?h!==null?h+"Capture":null:h;g=[];for(var b=u,w;b!==null;){w=b;var _=w.stateNode;if(w.tag===5&&_!==null&&(w=_,m!==null&&(_=Lb(b,m),_!=null&&g.push(Hb(b,_,w)))),y)break;b=b.return}0<g.length&&(h=new p(h,f,null,n,c),d.push({event:h,listeners:g}))}}if(!(e&7)){e:{if(h=t==="mouseover"||t==="pointerover",p=t==="mouseout"||t==="pointerout",h&&n!==qN&&(f=n.relatedTarget||n.fromElement)&&(up(f)||f[rc]))break e;if((p||h)&&(h=c.window===c?c:(h=c.ownerDocument)?h.defaultView||h.parentWindow:window,p?(f=n.relatedTarget||n.toElement,p=u,f=f?up(f):null,f!==null&&(y=mf(f),f!==y||f.tag!==5&&f.tag!==6)&&(f=null)):(p=null,f=u),p!==f)){if(g=Pz,_="onMouseLeave",m="onMouseEnter",b="mouse",(t==="pointerout"||t==="pointerover")&&(g=Oz,_="onPointerLeave",m="onPointerEnter",b="pointer"),y=p==null?h:Qg(p),w=f==null?h:Qg(f),h=new g(_,b+"leave",p,n,c),h.target=y,h.relatedTarget=w,_=null,up(c)===u&&(g=new g(m,b+"enter",f,n,c),g.target=w,g.relatedTarget=y,_=g),y=_,p&&f)t:{for(g=p,m=f,b=0,w=g;w;w=mg(w))b++;for(w=0,_=m;_;_=mg(_))w++;for(;0<b-w;)g=mg(g),b--;for(;0<w-b;)m=mg(m),w--;for(;b--;){if(g===m||m!==null&&g===m.alternate)break t;g=mg(g),m=mg(m)}g=null}else g=null;p!==null&&Kz(d,h,p,g,!1),f!==null&&y!==null&&Kz(d,y,f,g,!0)}}e:{if(h=u?Qg(u):window,p=h.nodeName&&h.nodeName.toLowerCase(),p==="select"||p==="input"&&h.type==="file")var S=_se;else if($z(h))if(M6)S=Ise;else{S=Ase;var E=Sse}else(p=h.nodeName)&&p.toLowerCase()==="input"&&(h.type==="checkbox"||h.type==="radio")&&(S=Ese);if(S&&(S=S(t,u))){C6(d,S,n,c);break e}E&&E(t,h,u),t==="focusout"&&(E=h._wrapperState)&&E.controlled&&h.type==="number"&&WN(h,"number",h.value)}switch(E=u?Qg(u):window,t){case"focusin":($z(E)||E.contentEditable==="true")&&(Yg=E,nR=u,pb=null);break;case"focusout":pb=nR=Yg=null;break;case"mousedown":rR=!0;break;case"contextmenu":case"mouseup":case"dragend":rR=!1,Vz(d,n,c);break;case"selectionchange":if(Mse)break;case"keydown":case"keyup":Vz(d,n,c)}var C;if(ND)e:{switch(t){case"compositionstart":var T="onCompositionStart";break e;case"compositionend":T="onCompositionEnd";break e;case"compositionupdate":T="onCompositionUpdate";break e}T=void 0}else Jg?I6(t,n)&&(T="onCompositionEnd"):t==="keydown"&&n.keyCode===229&&(T="onCompositionStart");T&&(E6&&n.locale!=="ko"&&(Jg||T!=="onCompositionStart"?T==="onCompositionEnd"&&Jg&&(C=A6()):(id=c,CD="value"in id?id.value:id.textContent,Jg=!0)),E=fE(u,T),0<E.length&&(T=new Lz(T,t,null,n,c),d.push({event:T,listeners:E}),C?T.data=C:(C=T6(n),C!==null&&(T.data=C)))),(C=yse?vse(t,n):xse(t,n))&&(u=fE(u,"onBeforeInput"),0<u.length&&(c=new Lz("onBeforeInput","beforeinput",null,n,c),d.push({event:c,listeners:u}),c.data=C))}U6(d,e)})}function Hb(t,e,n){return{instance:t,listener:e,currentTarget:n}}function fE(t,e){for(var n=e+"Capture",r=[];t!==null;){var i=t,s=i.stateNode;i.tag===5&&s!==null&&(i=s,s=Lb(t,n),s!=null&&r.unshift(Hb(t,s,i)),s=Lb(t,e),s!=null&&r.push(Hb(t,s,i))),t=t.return}return r}function mg(t){if(t===null)return null;do t=t.return;while(t&&t.tag!==5);return t||null}function Kz(t,e,n,r,i){for(var s=e._reactName,a=[];n!==null&&n!==r;){var o=n,l=o.alternate,u=o.stateNode;if(l!==null&&l===r)break;o.tag===5&&u!==null&&(o=u,i?(l=Lb(n,s),l!=null&&a.unshift(Hb(n,l,o))):i||(l=Lb(n,s),l!=null&&a.push(Hb(n,l,o)))),n=n.return}a.length!==0&&t.push({event:e,listeners:a})}var Fse=/\r\n?/g,Dse=/\u0000|\uFFFD/g;function qz(t){return(typeof t=="string"?t:""+t).replace(Fse,`
`).replace(Dse,"")}function lS(t,e,n){if(e=qz(e),qz(t)!==e&&n)throw Error(yt(425))}function mE(){}var iR=null,sR=null;function aR(t,e){return t==="textarea"||t==="noscript"||typeof e.children=="string"||typeof e.children=="number"||typeof e.dangerouslySetInnerHTML=="object"&&e.dangerouslySetInnerHTML!==null&&e.dangerouslySetInnerHTML.__html!=null}var oR=typeof setTimeout=="function"?setTimeout:void 0,Pse=typeof clearTimeout=="function"?clearTimeout:void 0,Jz=typeof Promise=="function"?Promise:void 0,Lse=typeof queueMicrotask=="function"?queueMicrotask:typeof Jz<"u"?function(t){return Jz.resolve(null).then(t).catch(Ose)}:oR;function Ose(t){setTimeout(function(){throw t})}function H2(t,e){var n=e,r=0;do{var i=n.nextSibling;if(t.removeChild(n),i&&i.nodeType===8)if(n=i.data,n==="/$"){if(r===0){t.removeChild(i),Ub(e);return}r--}else n!=="$"&&n!=="$?"&&n!=="$!"||r++;n=i}while(n);Ub(e)}function gd(t){for(;t!=null;t=t.nextSibling){var e=t.nodeType;if(e===1||e===3)break;if(e===8){if(e=t.data,e==="$"||e==="$!"||e==="$?")break;if(e==="/$")return null}}return t}function Yz(t){t=t.previousSibling;for(var e=0;t;){if(t.nodeType===8){var n=t.data;if(n==="$"||n==="$!"||n==="$?"){if(e===0)return t;e--}else n==="/$"&&e++}t=t.previousSibling}return null}var d0=Math.random().toString(36).slice(2),ql="__reactFiber$"+d0,Wb="__reactProps$"+d0,rc="__reactContainer$"+d0,lR="__reactEvents$"+d0,Bse="__reactListeners$"+d0,Use="__reactHandles$"+d0;function up(t){var e=t[ql];if(e)return e;for(var n=t.parentNode;n;){if(e=n[rc]||n[ql]){if(n=e.alternate,e.child!==null||n!==null&&n.child!==null)for(t=Yz(t);t!==null;){if(n=t[ql])return n;t=Yz(t)}return e}t=n,n=t.parentNode}return null}function D1(t){return t=t[ql]||t[rc],!t||t.tag!==5&&t.tag!==6&&t.tag!==13&&t.tag!==3?null:t}function Qg(t){if(t.tag===5||t.tag===6)return t.stateNode;throw Error(yt(33))}function lT(t){return t[Wb]||null}var uR=[],ey=-1;function Xd(t){return{current:t}}function Or(t){0>ey||(t.current=uR[ey],uR[ey]=null,ey--)}function Fr(t,e){ey++,uR[ey]=t.current,t.current=e}var Td={},$s=Xd(Td),Ra=Xd(!1),Fp=Td;function Ty(t,e){var n=t.type.contextTypes;if(!n)return Td;var r=t.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===e)return r.__reactInternalMemoizedMaskedChildContext;var i={},s;for(s in n)i[s]=e[s];return r&&(t=t.stateNode,t.__reactInternalMemoizedUnmaskedChildContext=e,t.__reactInternalMemoizedMaskedChildContext=i),i}function Fa(t){return t=t.childContextTypes,t!=null}function gE(){Or(Ra),Or($s)}function Zz(t,e,n){if($s.current!==Td)throw Error(yt(168));Fr($s,e),Fr(Ra,n)}function z6(t,e,n){var r=t.stateNode;if(e=e.childContextTypes,typeof r.getChildContext!="function")return n;r=r.getChildContext();for(var i in r)if(!(i in e))throw Error(yt(108,Sie(t)||"Unknown",i));return ri({},n,r)}function yE(t){return t=(t=t.stateNode)&&t.__reactInternalMemoizedMergedChildContext||Td,Fp=$s.current,Fr($s,t),Fr(Ra,Ra.current),!0}function Qz(t,e,n){var r=t.stateNode;if(!r)throw Error(yt(169));n?(t=z6(t,e,Fp),r.__reactInternalMemoizedMergedChildContext=t,Or(Ra),Or($s),Fr($s,t)):Or(Ra),Fr(Ra,n)}var Ou=null,uT=!1,W2=!1;function G6(t){Ou===null?Ou=[t]:Ou.push(t)}function $se(t){uT=!0,G6(t)}function Kd(){if(!W2&&Ou!==null){W2=!0;var t=0,e=br;try{var n=Ou;for(br=1;t<n.length;t++){var r=n[t];do r=r(!0);while(r!==null)}Ou=null,uT=!1}catch(i){throw Ou!==null&&(Ou=Ou.slice(t+1)),p6(AD,Kd),i}finally{br=e,W2=!1}}return null}var ty=[],ny=0,vE=null,xE=0,Fo=[],Do=0,Dp=null,Wu=1,Vu="";function Vh(t,e){ty[ny++]=xE,ty[ny++]=vE,vE=t,xE=e}function H6(t,e,n){Fo[Do++]=Wu,Fo[Do++]=Vu,Fo[Do++]=Dp,Dp=t;var r=Wu;t=Vu;var i=32-ml(r)-1;r&=~(1<<i),n+=1;var s=32-ml(e)+i;if(30<s){var a=i-i%5;s=(r&(1<<a)-1).toString(32),r>>=a,i-=a,Wu=1<<32-ml(e)+i|n<<i|r,Vu=s+t}else Wu=1<<s|n<<i|r,Vu=t}function FD(t){t.return!==null&&(Vh(t,1),H6(t,1,0))}function DD(t){for(;t===vE;)vE=ty[--ny],ty[ny]=null,xE=ty[--ny],ty[ny]=null;for(;t===Dp;)Dp=Fo[--Do],Fo[Do]=null,Vu=Fo[--Do],Fo[Do]=null,Wu=Fo[--Do],Fo[Do]=null}var so=null,Qa=null,Hr=!1,dl=null;function W6(t,e){var n=Lo(5,null,null,0);n.elementType="DELETED",n.stateNode=e,n.return=t,e=t.deletions,e===null?(t.deletions=[n],t.flags|=16):e.push(n)}function e4(t,e){switch(t.tag){case 5:var n=t.type;return e=e.nodeType!==1||n.toLowerCase()!==e.nodeName.toLowerCase()?null:e,e!==null?(t.stateNode=e,so=t,Qa=gd(e.firstChild),!0):!1;case 6:return e=t.pendingProps===""||e.nodeType!==3?null:e,e!==null?(t.stateNode=e,so=t,Qa=null,!0):!1;case 13:return e=e.nodeType!==8?null:e,e!==null?(n=Dp!==null?{id:Wu,overflow:Vu}:null,t.memoizedState={dehydrated:e,treeContext:n,retryLane:1073741824},n=Lo(18,null,null,0),n.stateNode=e,n.return=t,t.child=n,so=t,Qa=null,!0):!1;default:return!1}}function cR(t){return(t.mode&1)!==0&&(t.flags&128)===0}function dR(t){if(Hr){var e=Qa;if(e){var n=e;if(!e4(t,e)){if(cR(t))throw Error(yt(418));e=gd(n.nextSibling);var r=so;e&&e4(t,e)?W6(r,n):(t.flags=t.flags&-4097|2,Hr=!1,so=t)}}else{if(cR(t))throw Error(yt(418));t.flags=t.flags&-4097|2,Hr=!1,so=t}}}function t4(t){for(t=t.return;t!==null&&t.tag!==5&&t.tag!==3&&t.tag!==13;)t=t.return;so=t}function uS(t){if(t!==so)return!1;if(!Hr)return t4(t),Hr=!0,!1;var e;if((e=t.tag!==3)&&!(e=t.tag!==5)&&(e=t.type,e=e!=="head"&&e!=="body"&&!aR(t.type,t.memoizedProps)),e&&(e=Qa)){if(cR(t))throw V6(),Error(yt(418));for(;e;)W6(t,e),e=gd(e.nextSibling)}if(t4(t),t.tag===13){if(t=t.memoizedState,t=t!==null?t.dehydrated:null,!t)throw Error(yt(317));e:{for(t=t.nextSibling,e=0;t;){if(t.nodeType===8){var n=t.data;if(n==="/$"){if(e===0){Qa=gd(t.nextSibling);break e}e--}else n!=="$"&&n!=="$!"&&n!=="$?"||e++}t=t.nextSibling}Qa=null}}else Qa=so?gd(t.stateNode.nextSibling):null;return!0}function V6(){for(var t=Qa;t;)t=gd(t.nextSibling)}function Cy(){Qa=so=null,Hr=!1}function PD(t){dl===null?dl=[t]:dl.push(t)}var zse=hc.ReactCurrentBatchConfig;function hx(t,e,n){if(t=n.ref,t!==null&&typeof t!="function"&&typeof t!="object"){if(n._owner){if(n=n._owner,n){if(n.tag!==1)throw Error(yt(309));var r=n.stateNode}if(!r)throw Error(yt(147,t));var i=r,s=""+t;return e!==null&&e.ref!==null&&typeof e.ref=="function"&&e.ref._stringRef===s?e.ref:(e=function(a){var o=i.refs;a===null?delete o[s]:o[s]=a},e._stringRef=s,e)}if(typeof t!="string")throw Error(yt(284));if(!n._owner)throw Error(yt(290,t))}return t}function cS(t,e){throw t=Object.prototype.toString.call(e),Error(yt(31,t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t))}function n4(t){var e=t._init;return e(t._payload)}function j6(t){function e(m,b){if(t){var w=m.deletions;w===null?(m.deletions=[b],m.flags|=16):w.push(b)}}function n(m,b){if(!t)return null;for(;b!==null;)e(m,b),b=b.sibling;return null}function r(m,b){for(m=new Map;b!==null;)b.key!==null?m.set(b.key,b):m.set(b.index,b),b=b.sibling;return m}function i(m,b){return m=bd(m,b),m.index=0,m.sibling=null,m}function s(m,b,w){return m.index=w,t?(w=m.alternate,w!==null?(w=w.index,w<b?(m.flags|=2,b):w):(m.flags|=2,b)):(m.flags|=1048576,b)}function a(m){return t&&m.alternate===null&&(m.flags|=2),m}function o(m,b,w,_){return b===null||b.tag!==6?(b=Y2(w,m.mode,_),b.return=m,b):(b=i(b,w),b.return=m,b)}function l(m,b,w,_){var S=w.type;return S===qg?c(m,b,w.props.children,_,w.key):b!==null&&(b.elementType===S||typeof S=="object"&&S!==null&&S.$$typeof===qc&&n4(S)===b.type)?(_=i(b,w.props),_.ref=hx(m,b,w),_.return=m,_):(_=WA(w.type,w.key,w.props,null,m.mode,_),_.ref=hx(m,b,w),_.return=m,_)}function u(m,b,w,_){return b===null||b.tag!==4||b.stateNode.containerInfo!==w.containerInfo||b.stateNode.implementation!==w.implementation?(b=Z2(w,m.mode,_),b.return=m,b):(b=i(b,w.children||[]),b.return=m,b)}function c(m,b,w,_,S){return b===null||b.tag!==7?(b=_p(w,m.mode,_,S),b.return=m,b):(b=i(b,w),b.return=m,b)}function d(m,b,w){if(typeof b=="string"&&b!==""||typeof b=="number")return b=Y2(""+b,m.mode,w),b.return=m,b;if(typeof b=="object"&&b!==null){switch(b.$$typeof){case Q_:return w=WA(b.type,b.key,b.props,null,m.mode,w),w.ref=hx(m,null,b),w.return=m,w;case Kg:return b=Z2(b,m.mode,w),b.return=m,b;case qc:var _=b._init;return d(m,_(b._payload),w)}if(Vx(b)||ox(b))return b=_p(b,m.mode,w,null),b.return=m,b;cS(m,b)}return null}function h(m,b,w,_){var S=b!==null?b.key:null;if(typeof w=="string"&&w!==""||typeof w=="number")return S!==null?null:o(m,b,""+w,_);if(typeof w=="object"&&w!==null){switch(w.$$typeof){case Q_:return w.key===S?l(m,b,w,_):null;case Kg:return w.key===S?u(m,b,w,_):null;case qc:return S=w._init,h(m,b,S(w._payload),_)}if(Vx(w)||ox(w))return S!==null?null:c(m,b,w,_,null);cS(m,w)}return null}function p(m,b,w,_,S){if(typeof _=="string"&&_!==""||typeof _=="number")return m=m.get(w)||null,o(b,m,""+_,S);if(typeof _=="object"&&_!==null){switch(_.$$typeof){case Q_:return m=m.get(_.key===null?w:_.key)||null,l(b,m,_,S);case Kg:return m=m.get(_.key===null?w:_.key)||null,u(b,m,_,S);case qc:var E=_._init;return p(m,b,w,E(_._payload),S)}if(Vx(_)||ox(_))return m=m.get(w)||null,c(b,m,_,S,null);cS(b,_)}return null}function f(m,b,w,_){for(var S=null,E=null,C=b,T=b=0,M=null;C!==null&&T<w.length;T++){C.index>T?(M=C,C=null):M=C.sibling;var k=h(m,C,w[T],_);if(k===null){C===null&&(C=M);break}t&&C&&k.alternate===null&&e(m,C),b=s(k,b,T),E===null?S=k:E.sibling=k,E=k,C=M}if(T===w.length)return n(m,C),Hr&&Vh(m,T),S;if(C===null){for(;T<w.length;T++)C=d(m,w[T],_),C!==null&&(b=s(C,b,T),E===null?S=C:E.sibling=C,E=C);return Hr&&Vh(m,T),S}for(C=r(m,C);T<w.length;T++)M=p(C,m,T,w[T],_),M!==null&&(t&&M.alternate!==null&&C.delete(M.key===null?T:M.key),b=s(M,b,T),E===null?S=M:E.sibling=M,E=M);return t&&C.forEach(function(R){return e(m,R)}),Hr&&Vh(m,T),S}function g(m,b,w,_){var S=ox(w);if(typeof S!="function")throw Error(yt(150));if(w=S.call(w),w==null)throw Error(yt(151));for(var E=S=null,C=b,T=b=0,M=null,k=w.next();C!==null&&!k.done;T++,k=w.next()){C.index>T?(M=C,C=null):M=C.sibling;var R=h(m,C,k.value,_);if(R===null){C===null&&(C=M);break}t&&C&&R.alternate===null&&e(m,C),b=s(R,b,T),E===null?S=R:E.sibling=R,E=R,C=M}if(k.done)return n(m,C),Hr&&Vh(m,T),S;if(C===null){for(;!k.done;T++,k=w.next())k=d(m,k.value,_),k!==null&&(b=s(k,b,T),E===null?S=k:E.sibling=k,E=k);return Hr&&Vh(m,T),S}for(C=r(m,C);!k.done;T++,k=w.next())k=p(C,m,T,k.value,_),k!==null&&(t&&k.alternate!==null&&C.delete(k.key===null?T:k.key),b=s(k,b,T),E===null?S=k:E.sibling=k,E=k);return t&&C.forEach(function(N){return e(m,N)}),Hr&&Vh(m,T),S}function y(m,b,w,_){if(typeof w=="object"&&w!==null&&w.type===qg&&w.key===null&&(w=w.props.children),typeof w=="object"&&w!==null){switch(w.$$typeof){case Q_:e:{for(var S=w.key,E=b;E!==null;){if(E.key===S){if(S=w.type,S===qg){if(E.tag===7){n(m,E.sibling),b=i(E,w.props.children),b.return=m,m=b;break e}}else if(E.elementType===S||typeof S=="object"&&S!==null&&S.$$typeof===qc&&n4(S)===E.type){n(m,E.sibling),b=i(E,w.props),b.ref=hx(m,E,w),b.return=m,m=b;break e}n(m,E);break}else e(m,E);E=E.sibling}w.type===qg?(b=_p(w.props.children,m.mode,_,w.key),b.return=m,m=b):(_=WA(w.type,w.key,w.props,null,m.mode,_),_.ref=hx(m,b,w),_.return=m,m=_)}return a(m);case Kg:e:{for(E=w.key;b!==null;){if(b.key===E)if(b.tag===4&&b.stateNode.containerInfo===w.containerInfo&&b.stateNode.implementation===w.implementation){n(m,b.sibling),b=i(b,w.children||[]),b.return=m,m=b;break e}else{n(m,b);break}else e(m,b);b=b.sibling}b=Z2(w,m.mode,_),b.return=m,m=b}return a(m);case qc:return E=w._init,y(m,b,E(w._payload),_)}if(Vx(w))return f(m,b,w,_);if(ox(w))return g(m,b,w,_);cS(m,w)}return typeof w=="string"&&w!==""||typeof w=="number"?(w=""+w,b!==null&&b.tag===6?(n(m,b.sibling),b=i(b,w),b.return=m,m=b):(n(m,b),b=Y2(w,m.mode,_),b.return=m,m=b),a(m)):n(m,b)}return y}var My=j6(!0),X6=j6(!1),bE=Xd(null),wE=null,ry=null,LD=null;function OD(){LD=ry=wE=null}function BD(t){var e=bE.current;Or(bE),t._currentValue=e}function hR(t,e,n){for(;t!==null;){var r=t.alternate;if((t.childLanes&e)!==e?(t.childLanes|=e,r!==null&&(r.childLanes|=e)):r!==null&&(r.childLanes&e)!==e&&(r.childLanes|=e),t===n)break;t=t.return}}function fy(t,e){wE=t,LD=ry=null,t=t.dependencies,t!==null&&t.firstContext!==null&&(t.lanes&e&&(Ca=!0),t.firstContext=null)}function $o(t){var e=t._currentValue;if(LD!==t)if(t={context:t,memoizedValue:e,next:null},ry===null){if(wE===null)throw Error(yt(308));ry=t,wE.dependencies={lanes:0,firstContext:t}}else ry=ry.next=t;return e}var cp=null;function UD(t){cp===null?cp=[t]:cp.push(t)}function K6(t,e,n,r){var i=e.interleaved;return i===null?(n.next=n,UD(e)):(n.next=i.next,i.next=n),e.interleaved=n,ic(t,r)}function ic(t,e){t.lanes|=e;var n=t.alternate;for(n!==null&&(n.lanes|=e),n=t,t=t.return;t!==null;)t.childLanes|=e,n=t.alternate,n!==null&&(n.childLanes|=e),n=t,t=t.return;return n.tag===3?n.stateNode:null}var Jc=!1;function $D(t){t.updateQueue={baseState:t.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function q6(t,e){t=t.updateQueue,e.updateQueue===t&&(e.updateQueue={baseState:t.baseState,firstBaseUpdate:t.firstBaseUpdate,lastBaseUpdate:t.lastBaseUpdate,shared:t.shared,effects:t.effects})}function qu(t,e){return{eventTime:t,lane:e,tag:0,payload:null,callback:null,next:null}}function yd(t,e,n){var r=t.updateQueue;if(r===null)return null;if(r=r.shared,sr&2){var i=r.pending;return i===null?e.next=e:(e.next=i.next,i.next=e),r.pending=e,ic(t,n)}return i=r.interleaved,i===null?(e.next=e,UD(r)):(e.next=i.next,i.next=e),r.interleaved=e,ic(t,n)}function BA(t,e,n){if(e=e.updateQueue,e!==null&&(e=e.shared,(n&4194240)!==0)){var r=e.lanes;r&=t.pendingLanes,n|=r,e.lanes=n,ED(t,n)}}function r4(t,e){var n=t.updateQueue,r=t.alternate;if(r!==null&&(r=r.updateQueue,n===r)){var i=null,s=null;if(n=n.firstBaseUpdate,n!==null){do{var a={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};s===null?i=s=a:s=s.next=a,n=n.next}while(n!==null);s===null?i=s=e:s=s.next=e}else i=s=e;n={baseState:r.baseState,firstBaseUpdate:i,lastBaseUpdate:s,shared:r.shared,effects:r.effects},t.updateQueue=n;return}t=n.lastBaseUpdate,t===null?n.firstBaseUpdate=e:t.next=e,n.lastBaseUpdate=e}function _E(t,e,n,r){var i=t.updateQueue;Jc=!1;var s=i.firstBaseUpdate,a=i.lastBaseUpdate,o=i.shared.pending;if(o!==null){i.shared.pending=null;var l=o,u=l.next;l.next=null,a===null?s=u:a.next=u,a=l;var c=t.alternate;c!==null&&(c=c.updateQueue,o=c.lastBaseUpdate,o!==a&&(o===null?c.firstBaseUpdate=u:o.next=u,c.lastBaseUpdate=l))}if(s!==null){var d=i.baseState;a=0,c=u=l=null,o=s;do{var h=o.lane,p=o.eventTime;if((r&h)===h){c!==null&&(c=c.next={eventTime:p,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var f=t,g=o;switch(h=e,p=n,g.tag){case 1:if(f=g.payload,typeof f=="function"){d=f.call(p,d,h);break e}d=f;break e;case 3:f.flags=f.flags&-65537|128;case 0:if(f=g.payload,h=typeof f=="function"?f.call(p,d,h):f,h==null)break e;d=ri({},d,h);break e;case 2:Jc=!0}}o.callback!==null&&o.lane!==0&&(t.flags|=64,h=i.effects,h===null?i.effects=[o]:h.push(o))}else p={eventTime:p,lane:h,tag:o.tag,payload:o.payload,callback:o.callback,next:null},c===null?(u=c=p,l=d):c=c.next=p,a|=h;if(o=o.next,o===null){if(o=i.shared.pending,o===null)break;h=o,o=h.next,h.next=null,i.lastBaseUpdate=h,i.shared.pending=null}}while(!0);if(c===null&&(l=d),i.baseState=l,i.firstBaseUpdate=u,i.lastBaseUpdate=c,e=i.shared.interleaved,e!==null){i=e;do a|=i.lane,i=i.next;while(i!==e)}else s===null&&(i.shared.lanes=0);Lp|=a,t.lanes=a,t.memoizedState=d}}function i4(t,e,n){if(t=e.effects,e.effects=null,t!==null)for(e=0;e<t.length;e++){var r=t[e],i=r.callback;if(i!==null){if(r.callback=null,r=n,typeof i!="function")throw Error(yt(191,i));i.call(r)}}}var P1={},tu=Xd(P1),Vb=Xd(P1),jb=Xd(P1);function dp(t){if(t===P1)throw Error(yt(174));return t}function zD(t,e){switch(Fr(jb,e),Fr(Vb,t),Fr(tu,P1),t=e.nodeType,t){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:jN(null,"");break;default:t=t===8?e.parentNode:e,e=t.namespaceURI||null,t=t.tagName,e=jN(e,t)}Or(tu),Fr(tu,e)}function ky(){Or(tu),Or(Vb),Or(jb)}function J6(t){dp(jb.current);var e=dp(tu.current),n=jN(e,t.type);e!==n&&(Fr(Vb,t),Fr(tu,n))}function GD(t){Vb.current===t&&(Or(tu),Or(Vb))}var Zr=Xd(0);function SE(t){for(var e=t;e!==null;){if(e.tag===13){var n=e.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||n.data==="$?"||n.data==="$!"))return e}else if(e.tag===19&&e.memoizedProps.revealOrder!==void 0){if(e.flags&128)return e}else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break;for(;e.sibling===null;){if(e.return===null||e.return===t)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var V2=[];function HD(){for(var t=0;t<V2.length;t++)V2[t]._workInProgressVersionPrimary=null;V2.length=0}var UA=hc.ReactCurrentDispatcher,j2=hc.ReactCurrentBatchConfig,Pp=0,ni=null,Bi=null,as=null,AE=!1,fb=!1,Xb=0,Gse=0;function Ms(){throw Error(yt(321))}function WD(t,e){if(e===null)return!1;for(var n=0;n<e.length&&n<t.length;n++)if(!wl(t[n],e[n]))return!1;return!0}function VD(t,e,n,r,i,s){if(Pp=s,ni=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,UA.current=t===null||t.memoizedState===null?jse:Xse,t=n(r,i),fb){s=0;do{if(fb=!1,Xb=0,25<=s)throw Error(yt(301));s+=1,as=Bi=null,e.updateQueue=null,UA.current=Kse,t=n(r,i)}while(fb)}if(UA.current=EE,e=Bi!==null&&Bi.next!==null,Pp=0,as=Bi=ni=null,AE=!1,e)throw Error(yt(300));return t}function jD(){var t=Xb!==0;return Xb=0,t}function Hl(){var t={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return as===null?ni.memoizedState=as=t:as=as.next=t,as}function zo(){if(Bi===null){var t=ni.alternate;t=t!==null?t.memoizedState:null}else t=Bi.next;var e=as===null?ni.memoizedState:as.next;if(e!==null)as=e,Bi=t;else{if(t===null)throw Error(yt(310));Bi=t,t={memoizedState:Bi.memoizedState,baseState:Bi.baseState,baseQueue:Bi.baseQueue,queue:Bi.queue,next:null},as===null?ni.memoizedState=as=t:as=as.next=t}return as}function Kb(t,e){return typeof e=="function"?e(t):e}function X2(t){var e=zo(),n=e.queue;if(n===null)throw Error(yt(311));n.lastRenderedReducer=t;var r=Bi,i=r.baseQueue,s=n.pending;if(s!==null){if(i!==null){var a=i.next;i.next=s.next,s.next=a}r.baseQueue=i=s,n.pending=null}if(i!==null){s=i.next,r=r.baseState;var o=a=null,l=null,u=s;do{var c=u.lane;if((Pp&c)===c)l!==null&&(l=l.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),r=u.hasEagerState?u.eagerState:t(r,u.action);else{var d={lane:c,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};l===null?(o=l=d,a=r):l=l.next=d,ni.lanes|=c,Lp|=c}u=u.next}while(u!==null&&u!==s);l===null?a=r:l.next=o,wl(r,e.memoizedState)||(Ca=!0),e.memoizedState=r,e.baseState=a,e.baseQueue=l,n.lastRenderedState=r}if(t=n.interleaved,t!==null){i=t;do s=i.lane,ni.lanes|=s,Lp|=s,i=i.next;while(i!==t)}else i===null&&(n.lanes=0);return[e.memoizedState,n.dispatch]}function K2(t){var e=zo(),n=e.queue;if(n===null)throw Error(yt(311));n.lastRenderedReducer=t;var r=n.dispatch,i=n.pending,s=e.memoizedState;if(i!==null){n.pending=null;var a=i=i.next;do s=t(s,a.action),a=a.next;while(a!==i);wl(s,e.memoizedState)||(Ca=!0),e.memoizedState=s,e.baseQueue===null&&(e.baseState=s),n.lastRenderedState=s}return[s,r]}function Y6(){}function Z6(t,e){var n=ni,r=zo(),i=e(),s=!wl(r.memoizedState,i);if(s&&(r.memoizedState=i,Ca=!0),r=r.queue,XD(t8.bind(null,n,r,t),[t]),r.getSnapshot!==e||s||as!==null&&as.memoizedState.tag&1){if(n.flags|=2048,qb(9,e8.bind(null,n,r,i,e),void 0,null),cs===null)throw Error(yt(349));Pp&30||Q6(n,e,i)}return i}function Q6(t,e,n){t.flags|=16384,t={getSnapshot:e,value:n},e=ni.updateQueue,e===null?(e={lastEffect:null,stores:null},ni.updateQueue=e,e.stores=[t]):(n=e.stores,n===null?e.stores=[t]:n.push(t))}function e8(t,e,n,r){e.value=n,e.getSnapshot=r,n8(e)&&r8(t)}function t8(t,e,n){return n(function(){n8(e)&&r8(t)})}function n8(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!wl(t,n)}catch{return!0}}function r8(t){var e=ic(t,1);e!==null&&gl(e,t,1,-1)}function s4(t){var e=Hl();return typeof t=="function"&&(t=t()),e.memoizedState=e.baseState=t,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Kb,lastRenderedState:t},e.queue=t,t=t.dispatch=Vse.bind(null,ni,t),[e.memoizedState,t]}function qb(t,e,n,r){return t={tag:t,create:e,destroy:n,deps:r,next:null},e=ni.updateQueue,e===null?(e={lastEffect:null,stores:null},ni.updateQueue=e,e.lastEffect=t.next=t):(n=e.lastEffect,n===null?e.lastEffect=t.next=t:(r=n.next,n.next=t,t.next=r,e.lastEffect=t)),t}function i8(){return zo().memoizedState}function $A(t,e,n,r){var i=Hl();ni.flags|=t,i.memoizedState=qb(1|e,n,void 0,r===void 0?null:r)}function cT(t,e,n,r){var i=zo();r=r===void 0?null:r;var s=void 0;if(Bi!==null){var a=Bi.memoizedState;if(s=a.destroy,r!==null&&WD(r,a.deps)){i.memoizedState=qb(e,n,s,r);return}}ni.flags|=t,i.memoizedState=qb(1|e,n,s,r)}function a4(t,e){return $A(8390656,8,t,e)}function XD(t,e){return cT(2048,8,t,e)}function s8(t,e){return cT(4,2,t,e)}function a8(t,e){return cT(4,4,t,e)}function o8(t,e){if(typeof e=="function")return t=t(),e(t),function(){e(null)};if(e!=null)return t=t(),e.current=t,function(){e.current=null}}function l8(t,e,n){return n=n!=null?n.concat([t]):null,cT(4,4,o8.bind(null,e,t),n)}function KD(){}function u8(t,e){var n=zo();e=e===void 0?null:e;var r=n.memoizedState;return r!==null&&e!==null&&WD(e,r[1])?r[0]:(n.memoizedState=[t,e],t)}function c8(t,e){var n=zo();e=e===void 0?null:e;var r=n.memoizedState;return r!==null&&e!==null&&WD(e,r[1])?r[0]:(t=t(),n.memoizedState=[t,e],t)}function d8(t,e,n){return Pp&21?(wl(n,e)||(n=g6(),ni.lanes|=n,Lp|=n,t.baseState=!0),e):(t.baseState&&(t.baseState=!1,Ca=!0),t.memoizedState=n)}function Hse(t,e){var n=br;br=n!==0&&4>n?n:4,t(!0);var r=j2.transition;j2.transition={};try{t(!1),e()}finally{br=n,j2.transition=r}}function h8(){return zo().memoizedState}function Wse(t,e,n){var r=xd(t);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},p8(t))f8(e,n);else if(n=K6(t,e,n,r),n!==null){var i=ia();gl(n,t,r,i),m8(n,e,r)}}function Vse(t,e,n){var r=xd(t),i={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(p8(t))f8(e,i);else{var s=t.alternate;if(t.lanes===0&&(s===null||s.lanes===0)&&(s=e.lastRenderedReducer,s!==null))try{var a=e.lastRenderedState,o=s(a,n);if(i.hasEagerState=!0,i.eagerState=o,wl(o,a)){var l=e.interleaved;l===null?(i.next=i,UD(e)):(i.next=l.next,l.next=i),e.interleaved=i;return}}catch{}finally{}n=K6(t,e,i,r),n!==null&&(i=ia(),gl(n,t,r,i),m8(n,e,r))}}function p8(t){var e=t.alternate;return t===ni||e!==null&&e===ni}function f8(t,e){fb=AE=!0;var n=t.pending;n===null?e.next=e:(e.next=n.next,n.next=e),t.pending=e}function m8(t,e,n){if(n&4194240){var r=e.lanes;r&=t.pendingLanes,n|=r,e.lanes=n,ED(t,n)}}var EE={readContext:$o,useCallback:Ms,useContext:Ms,useEffect:Ms,useImperativeHandle:Ms,useInsertionEffect:Ms,useLayoutEffect:Ms,useMemo:Ms,useReducer:Ms,useRef:Ms,useState:Ms,useDebugValue:Ms,useDeferredValue:Ms,useTransition:Ms,useMutableSource:Ms,useSyncExternalStore:Ms,useId:Ms,unstable_isNewReconciler:!1},jse={readContext:$o,useCallback:function(t,e){return Hl().memoizedState=[t,e===void 0?null:e],t},useContext:$o,useEffect:a4,useImperativeHandle:function(t,e,n){return n=n!=null?n.concat([t]):null,$A(4194308,4,o8.bind(null,e,t),n)},useLayoutEffect:function(t,e){return $A(4194308,4,t,e)},useInsertionEffect:function(t,e){return $A(4,2,t,e)},useMemo:function(t,e){var n=Hl();return e=e===void 0?null:e,t=t(),n.memoizedState=[t,e],t},useReducer:function(t,e,n){var r=Hl();return e=n!==void 0?n(e):e,r.memoizedState=r.baseState=e,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:t,lastRenderedState:e},r.queue=t,t=t.dispatch=Wse.bind(null,ni,t),[r.memoizedState,t]},useRef:function(t){var e=Hl();return t={current:t},e.memoizedState=t},useState:s4,useDebugValue:KD,useDeferredValue:function(t){return Hl().memoizedState=t},useTransition:function(){var t=s4(!1),e=t[0];return t=Hse.bind(null,t[1]),Hl().memoizedState=t,[e,t]},useMutableSource:function(){},useSyncExternalStore:function(t,e,n){var r=ni,i=Hl();if(Hr){if(n===void 0)throw Error(yt(407));n=n()}else{if(n=e(),cs===null)throw Error(yt(349));Pp&30||Q6(r,e,n)}i.memoizedState=n;var s={value:n,getSnapshot:e};return i.queue=s,a4(t8.bind(null,r,s,t),[t]),r.flags|=2048,qb(9,e8.bind(null,r,s,n,e),void 0,null),n},useId:function(){var t=Hl(),e=cs.identifierPrefix;if(Hr){var n=Vu,r=Wu;n=(r&~(1<<32-ml(r)-1)).toString(32)+n,e=":"+e+"R"+n,n=Xb++,0<n&&(e+="H"+n.toString(32)),e+=":"}else n=Gse++,e=":"+e+"r"+n.toString(32)+":";return t.memoizedState=e},unstable_isNewReconciler:!1},Xse={readContext:$o,useCallback:u8,useContext:$o,useEffect:XD,useImperativeHandle:l8,useInsertionEffect:s8,useLayoutEffect:a8,useMemo:c8,useReducer:X2,useRef:i8,useState:function(){return X2(Kb)},useDebugValue:KD,useDeferredValue:function(t){var e=zo();return d8(e,Bi.memoizedState,t)},useTransition:function(){var t=X2(Kb)[0],e=zo().memoizedState;return[t,e]},useMutableSource:Y6,useSyncExternalStore:Z6,useId:h8,unstable_isNewReconciler:!1},Kse={readContext:$o,useCallback:u8,useContext:$o,useEffect:XD,useImperativeHandle:l8,useInsertionEffect:s8,useLayoutEffect:a8,useMemo:c8,useReducer:K2,useRef:i8,useState:function(){return K2(Kb)},useDebugValue:KD,useDeferredValue:function(t){var e=zo();return Bi===null?e.memoizedState=t:d8(e,Bi.memoizedState,t)},useTransition:function(){var t=K2(Kb)[0],e=zo().memoizedState;return[t,e]},useMutableSource:Y6,useSyncExternalStore:Z6,useId:h8,unstable_isNewReconciler:!1};function ll(t,e){if(t&&t.defaultProps){e=ri({},e),t=t.defaultProps;for(var n in t)e[n]===void 0&&(e[n]=t[n]);return e}return e}function pR(t,e,n,r){e=t.memoizedState,n=n(r,e),n=n==null?e:ri({},e,n),t.memoizedState=n,t.lanes===0&&(t.updateQueue.baseState=n)}var dT={isMounted:function(t){return(t=t._reactInternals)?mf(t)===t:!1},enqueueSetState:function(t,e,n){t=t._reactInternals;var r=ia(),i=xd(t),s=qu(r,i);s.payload=e,n!=null&&(s.callback=n),e=yd(t,s,i),e!==null&&(gl(e,t,i,r),BA(e,t,i))},enqueueReplaceState:function(t,e,n){t=t._reactInternals;var r=ia(),i=xd(t),s=qu(r,i);s.tag=1,s.payload=e,n!=null&&(s.callback=n),e=yd(t,s,i),e!==null&&(gl(e,t,i,r),BA(e,t,i))},enqueueForceUpdate:function(t,e){t=t._reactInternals;var n=ia(),r=xd(t),i=qu(n,r);i.tag=2,e!=null&&(i.callback=e),e=yd(t,i,r),e!==null&&(gl(e,t,r,n),BA(e,t,r))}};function o4(t,e,n,r,i,s,a){return t=t.stateNode,typeof t.shouldComponentUpdate=="function"?t.shouldComponentUpdate(r,s,a):e.prototype&&e.prototype.isPureReactComponent?!zb(n,r)||!zb(i,s):!0}function g8(t,e,n){var r=!1,i=Td,s=e.contextType;return typeof s=="object"&&s!==null?s=$o(s):(i=Fa(e)?Fp:$s.current,r=e.contextTypes,s=(r=r!=null)?Ty(t,i):Td),e=new e(n,s),t.memoizedState=e.state!==null&&e.state!==void 0?e.state:null,e.updater=dT,t.stateNode=e,e._reactInternals=t,r&&(t=t.stateNode,t.__reactInternalMemoizedUnmaskedChildContext=i,t.__reactInternalMemoizedMaskedChildContext=s),e}function l4(t,e,n,r){t=e.state,typeof e.componentWillReceiveProps=="function"&&e.componentWillReceiveProps(n,r),typeof e.UNSAFE_componentWillReceiveProps=="function"&&e.UNSAFE_componentWillReceiveProps(n,r),e.state!==t&&dT.enqueueReplaceState(e,e.state,null)}function fR(t,e,n,r){var i=t.stateNode;i.props=n,i.state=t.memoizedState,i.refs={},$D(t);var s=e.contextType;typeof s=="object"&&s!==null?i.context=$o(s):(s=Fa(e)?Fp:$s.current,i.context=Ty(t,s)),i.state=t.memoizedState,s=e.getDerivedStateFromProps,typeof s=="function"&&(pR(t,e,s,n),i.state=t.memoizedState),typeof e.getDerivedStateFromProps=="function"||typeof i.getSnapshotBeforeUpdate=="function"||typeof i.UNSAFE_componentWillMount!="function"&&typeof i.componentWillMount!="function"||(e=i.state,typeof i.componentWillMount=="function"&&i.componentWillMount(),typeof i.UNSAFE_componentWillMount=="function"&&i.UNSAFE_componentWillMount(),e!==i.state&&dT.enqueueReplaceState(i,i.state,null),_E(t,n,i,r),i.state=t.memoizedState),typeof i.componentDidMount=="function"&&(t.flags|=4194308)}function Ny(t,e){try{var n="",r=e;do n+=_ie(r),r=r.return;while(r);var i=n}catch(s){i=`
Error generating stack: `+s.message+`
`+s.stack}return{value:t,source:e,stack:i,digest:null}}function q2(t,e,n){return{value:t,source:null,stack:n??null,digest:e??null}}function mR(t,e){try{console.error(e.value)}catch(n){setTimeout(function(){throw n})}}var qse=typeof WeakMap=="function"?WeakMap:Map;function y8(t,e,n){n=qu(-1,n),n.tag=3,n.payload={element:null};var r=e.value;return n.callback=function(){TE||(TE=!0,ER=r),mR(t,e)},n}function v8(t,e,n){n=qu(-1,n),n.tag=3;var r=t.type.getDerivedStateFromError;if(typeof r=="function"){var i=e.value;n.payload=function(){return r(i)},n.callback=function(){mR(t,e)}}var s=t.stateNode;return s!==null&&typeof s.componentDidCatch=="function"&&(n.callback=function(){mR(t,e),typeof r!="function"&&(vd===null?vd=new Set([this]):vd.add(this));var a=e.stack;this.componentDidCatch(e.value,{componentStack:a!==null?a:""})}),n}function u4(t,e,n){var r=t.pingCache;if(r===null){r=t.pingCache=new qse;var i=new Set;r.set(e,i)}else i=r.get(e),i===void 0&&(i=new Set,r.set(e,i));i.has(n)||(i.add(n),t=uae.bind(null,t,e,n),e.then(t,t))}function c4(t){do{var e;if((e=t.tag===13)&&(e=t.memoizedState,e=e!==null?e.dehydrated!==null:!0),e)return t;t=t.return}while(t!==null);return null}function d4(t,e,n,r,i){return t.mode&1?(t.flags|=65536,t.lanes=i,t):(t===e?t.flags|=65536:(t.flags|=128,n.flags|=131072,n.flags&=-52805,n.tag===1&&(n.alternate===null?n.tag=17:(e=qu(-1,1),e.tag=2,yd(n,e,1))),n.lanes|=1),t)}var Jse=hc.ReactCurrentOwner,Ca=!1;function Qs(t,e,n,r){e.child=t===null?X6(e,null,n,r):My(e,t.child,n,r)}function h4(t,e,n,r,i){n=n.render;var s=e.ref;return fy(e,i),r=VD(t,e,n,r,s,i),n=jD(),t!==null&&!Ca?(e.updateQueue=t.updateQueue,e.flags&=-2053,t.lanes&=~i,sc(t,e,i)):(Hr&&n&&FD(e),e.flags|=1,Qs(t,e,r,i),e.child)}function p4(t,e,n,r,i){if(t===null){var s=n.type;return typeof s=="function"&&!nP(s)&&s.defaultProps===void 0&&n.compare===null&&n.defaultProps===void 0?(e.tag=15,e.type=s,x8(t,e,s,r,i)):(t=WA(n.type,null,r,e,e.mode,i),t.ref=e.ref,t.return=e,e.child=t)}if(s=t.child,!(t.lanes&i)){var a=s.memoizedProps;if(n=n.compare,n=n!==null?n:zb,n(a,r)&&t.ref===e.ref)return sc(t,e,i)}return e.flags|=1,t=bd(s,r),t.ref=e.ref,t.return=e,e.child=t}function x8(t,e,n,r,i){if(t!==null){var s=t.memoizedProps;if(zb(s,r)&&t.ref===e.ref)if(Ca=!1,e.pendingProps=r=s,(t.lanes&i)!==0)t.flags&131072&&(Ca=!0);else return e.lanes=t.lanes,sc(t,e,i)}return gR(t,e,n,r,i)}function b8(t,e,n){var r=e.pendingProps,i=r.children,s=t!==null?t.memoizedState:null;if(r.mode==="hidden")if(!(e.mode&1))e.memoizedState={baseLanes:0,cachePool:null,transitions:null},Fr(sy,Za),Za|=n;else{if(!(n&1073741824))return t=s!==null?s.baseLanes|n:n,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:t,cachePool:null,transitions:null},e.updateQueue=null,Fr(sy,Za),Za|=t,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=s!==null?s.baseLanes:n,Fr(sy,Za),Za|=r}else s!==null?(r=s.baseLanes|n,e.memoizedState=null):r=n,Fr(sy,Za),Za|=r;return Qs(t,e,i,n),e.child}function w8(t,e){var n=e.ref;(t===null&&n!==null||t!==null&&t.ref!==n)&&(e.flags|=512,e.flags|=2097152)}function gR(t,e,n,r,i){var s=Fa(n)?Fp:$s.current;return s=Ty(e,s),fy(e,i),n=VD(t,e,n,r,s,i),r=jD(),t!==null&&!Ca?(e.updateQueue=t.updateQueue,e.flags&=-2053,t.lanes&=~i,sc(t,e,i)):(Hr&&r&&FD(e),e.flags|=1,Qs(t,e,n,i),e.child)}function f4(t,e,n,r,i){if(Fa(n)){var s=!0;yE(e)}else s=!1;if(fy(e,i),e.stateNode===null)zA(t,e),g8(e,n,r),fR(e,n,r,i),r=!0;else if(t===null){var a=e.stateNode,o=e.memoizedProps;a.props=o;var l=a.context,u=n.contextType;typeof u=="object"&&u!==null?u=$o(u):(u=Fa(n)?Fp:$s.current,u=Ty(e,u));var c=n.getDerivedStateFromProps,d=typeof c=="function"||typeof a.getSnapshotBeforeUpdate=="function";d||typeof a.UNSAFE_componentWillReceiveProps!="function"&&typeof a.componentWillReceiveProps!="function"||(o!==r||l!==u)&&l4(e,a,r,u),Jc=!1;var h=e.memoizedState;a.state=h,_E(e,r,a,i),l=e.memoizedState,o!==r||h!==l||Ra.current||Jc?(typeof c=="function"&&(pR(e,n,c,r),l=e.memoizedState),(o=Jc||o4(e,n,o,r,h,l,u))?(d||typeof a.UNSAFE_componentWillMount!="function"&&typeof a.componentWillMount!="function"||(typeof a.componentWillMount=="function"&&a.componentWillMount(),typeof a.UNSAFE_componentWillMount=="function"&&a.UNSAFE_componentWillMount()),typeof a.componentDidMount=="function"&&(e.flags|=4194308)):(typeof a.componentDidMount=="function"&&(e.flags|=4194308),e.memoizedProps=r,e.memoizedState=l),a.props=r,a.state=l,a.context=u,r=o):(typeof a.componentDidMount=="function"&&(e.flags|=4194308),r=!1)}else{a=e.stateNode,q6(t,e),o=e.memoizedProps,u=e.type===e.elementType?o:ll(e.type,o),a.props=u,d=e.pendingProps,h=a.context,l=n.contextType,typeof l=="object"&&l!==null?l=$o(l):(l=Fa(n)?Fp:$s.current,l=Ty(e,l));var p=n.getDerivedStateFromProps;(c=typeof p=="function"||typeof a.getSnapshotBeforeUpdate=="function")||typeof a.UNSAFE_componentWillReceiveProps!="function"&&typeof a.componentWillReceiveProps!="function"||(o!==d||h!==l)&&l4(e,a,r,l),Jc=!1,h=e.memoizedState,a.state=h,_E(e,r,a,i);var f=e.memoizedState;o!==d||h!==f||Ra.current||Jc?(typeof p=="function"&&(pR(e,n,p,r),f=e.memoizedState),(u=Jc||o4(e,n,u,r,h,f,l)||!1)?(c||typeof a.UNSAFE_componentWillUpdate!="function"&&typeof a.componentWillUpdate!="function"||(typeof a.componentWillUpdate=="function"&&a.componentWillUpdate(r,f,l),typeof a.UNSAFE_componentWillUpdate=="function"&&a.UNSAFE_componentWillUpdate(r,f,l)),typeof a.componentDidUpdate=="function"&&(e.flags|=4),typeof a.getSnapshotBeforeUpdate=="function"&&(e.flags|=1024)):(typeof a.componentDidUpdate!="function"||o===t.memoizedProps&&h===t.memoizedState||(e.flags|=4),typeof a.getSnapshotBeforeUpdate!="function"||o===t.memoizedProps&&h===t.memoizedState||(e.flags|=1024),e.memoizedProps=r,e.memoizedState=f),a.props=r,a.state=f,a.context=l,r=u):(typeof a.componentDidUpdate!="function"||o===t.memoizedProps&&h===t.memoizedState||(e.flags|=4),typeof a.getSnapshotBeforeUpdate!="function"||o===t.memoizedProps&&h===t.memoizedState||(e.flags|=1024),r=!1)}return yR(t,e,n,r,s,i)}function yR(t,e,n,r,i,s){w8(t,e);var a=(e.flags&128)!==0;if(!r&&!a)return i&&Qz(e,n,!1),sc(t,e,s);r=e.stateNode,Jse.current=e;var o=a&&typeof n.getDerivedStateFromError!="function"?null:r.render();return e.flags|=1,t!==null&&a?(e.child=My(e,t.child,null,s),e.child=My(e,null,o,s)):Qs(t,e,o,s),e.memoizedState=r.state,i&&Qz(e,n,!0),e.child}function _8(t){var e=t.stateNode;e.pendingContext?Zz(t,e.pendingContext,e.pendingContext!==e.context):e.context&&Zz(t,e.context,!1),zD(t,e.containerInfo)}function m4(t,e,n,r,i){return Cy(),PD(i),e.flags|=256,Qs(t,e,n,r),e.child}var vR={dehydrated:null,treeContext:null,retryLane:0};function xR(t){return{baseLanes:t,cachePool:null,transitions:null}}function S8(t,e,n){var r=e.pendingProps,i=Zr.current,s=!1,a=(e.flags&128)!==0,o;if((o=a)||(o=t!==null&&t.memoizedState===null?!1:(i&2)!==0),o?(s=!0,e.flags&=-129):(t===null||t.memoizedState!==null)&&(i|=1),Fr(Zr,i&1),t===null)return dR(e),t=e.memoizedState,t!==null&&(t=t.dehydrated,t!==null)?(e.mode&1?t.data==="$!"?e.lanes=8:e.lanes=1073741824:e.lanes=1,null):(a=r.children,t=r.fallback,s?(r=e.mode,s=e.child,a={mode:"hidden",children:a},!(r&1)&&s!==null?(s.childLanes=0,s.pendingProps=a):s=fT(a,r,0,null),t=_p(t,r,n,null),s.return=e,t.return=e,s.sibling=t,e.child=s,e.child.memoizedState=xR(n),e.memoizedState=vR,t):qD(e,a));if(i=t.memoizedState,i!==null&&(o=i.dehydrated,o!==null))return Yse(t,e,a,r,o,i,n);if(s){s=r.fallback,a=e.mode,i=t.child,o=i.sibling;var l={mode:"hidden",children:r.children};return!(a&1)&&e.child!==i?(r=e.child,r.childLanes=0,r.pendingProps=l,e.deletions=null):(r=bd(i,l),r.subtreeFlags=i.subtreeFlags&14680064),o!==null?s=bd(o,s):(s=_p(s,a,n,null),s.flags|=2),s.return=e,r.return=e,r.sibling=s,e.child=r,r=s,s=e.child,a=t.child.memoizedState,a=a===null?xR(n):{baseLanes:a.baseLanes|n,cachePool:null,transitions:a.transitions},s.memoizedState=a,s.childLanes=t.childLanes&~n,e.memoizedState=vR,r}return s=t.child,t=s.sibling,r=bd(s,{mode:"visible",children:r.children}),!(e.mode&1)&&(r.lanes=n),r.return=e,r.sibling=null,t!==null&&(n=e.deletions,n===null?(e.deletions=[t],e.flags|=16):n.push(t)),e.child=r,e.memoizedState=null,r}function qD(t,e){return e=fT({mode:"visible",children:e},t.mode,0,null),e.return=t,t.child=e}function dS(t,e,n,r){return r!==null&&PD(r),My(e,t.child,null,n),t=qD(e,e.pendingProps.children),t.flags|=2,e.memoizedState=null,t}function Yse(t,e,n,r,i,s,a){if(n)return e.flags&256?(e.flags&=-257,r=q2(Error(yt(422))),dS(t,e,a,r)):e.memoizedState!==null?(e.child=t.child,e.flags|=128,null):(s=r.fallback,i=e.mode,r=fT({mode:"visible",children:r.children},i,0,null),s=_p(s,i,a,null),s.flags|=2,r.return=e,s.return=e,r.sibling=s,e.child=r,e.mode&1&&My(e,t.child,null,a),e.child.memoizedState=xR(a),e.memoizedState=vR,s);if(!(e.mode&1))return dS(t,e,a,null);if(i.data==="$!"){if(r=i.nextSibling&&i.nextSibling.dataset,r)var o=r.dgst;return r=o,s=Error(yt(419)),r=q2(s,r,void 0),dS(t,e,a,r)}if(o=(a&t.childLanes)!==0,Ca||o){if(r=cs,r!==null){switch(a&-a){case 4:i=2;break;case 16:i=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:i=32;break;case 536870912:i=268435456;break;default:i=0}i=i&(r.suspendedLanes|a)?0:i,i!==0&&i!==s.retryLane&&(s.retryLane=i,ic(t,i),gl(r,t,i,-1))}return tP(),r=q2(Error(yt(421))),dS(t,e,a,r)}return i.data==="$?"?(e.flags|=128,e.child=t.child,e=cae.bind(null,t),i._reactRetry=e,null):(t=s.treeContext,Qa=gd(i.nextSibling),so=e,Hr=!0,dl=null,t!==null&&(Fo[Do++]=Wu,Fo[Do++]=Vu,Fo[Do++]=Dp,Wu=t.id,Vu=t.overflow,Dp=e),e=qD(e,r.children),e.flags|=4096,e)}function g4(t,e,n){t.lanes|=e;var r=t.alternate;r!==null&&(r.lanes|=e),hR(t.return,e,n)}function J2(t,e,n,r,i){var s=t.memoizedState;s===null?t.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:i}:(s.isBackwards=e,s.rendering=null,s.renderingStartTime=0,s.last=r,s.tail=n,s.tailMode=i)}function A8(t,e,n){var r=e.pendingProps,i=r.revealOrder,s=r.tail;if(Qs(t,e,r.children,n),r=Zr.current,r&2)r=r&1|2,e.flags|=128;else{if(t!==null&&t.flags&128)e:for(t=e.child;t!==null;){if(t.tag===13)t.memoizedState!==null&&g4(t,n,e);else if(t.tag===19)g4(t,n,e);else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break e;for(;t.sibling===null;){if(t.return===null||t.return===e)break e;t=t.return}t.sibling.return=t.return,t=t.sibling}r&=1}if(Fr(Zr,r),!(e.mode&1))e.memoizedState=null;else switch(i){case"forwards":for(n=e.child,i=null;n!==null;)t=n.alternate,t!==null&&SE(t)===null&&(i=n),n=n.sibling;n=i,n===null?(i=e.child,e.child=null):(i=n.sibling,n.sibling=null),J2(e,!1,i,n,s);break;case"backwards":for(n=null,i=e.child,e.child=null;i!==null;){if(t=i.alternate,t!==null&&SE(t)===null){e.child=i;break}t=i.sibling,i.sibling=n,n=i,i=t}J2(e,!0,n,null,s);break;case"together":J2(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function zA(t,e){!(e.mode&1)&&t!==null&&(t.alternate=null,e.alternate=null,e.flags|=2)}function sc(t,e,n){if(t!==null&&(e.dependencies=t.dependencies),Lp|=e.lanes,!(n&e.childLanes))return null;if(t!==null&&e.child!==t.child)throw Error(yt(153));if(e.child!==null){for(t=e.child,n=bd(t,t.pendingProps),e.child=n,n.return=e;t.sibling!==null;)t=t.sibling,n=n.sibling=bd(t,t.pendingProps),n.return=e;n.sibling=null}return e.child}function Zse(t,e,n){switch(e.tag){case 3:_8(e),Cy();break;case 5:J6(e);break;case 1:Fa(e.type)&&yE(e);break;case 4:zD(e,e.stateNode.containerInfo);break;case 10:var r=e.type._context,i=e.memoizedProps.value;Fr(bE,r._currentValue),r._currentValue=i;break;case 13:if(r=e.memoizedState,r!==null)return r.dehydrated!==null?(Fr(Zr,Zr.current&1),e.flags|=128,null):n&e.child.childLanes?S8(t,e,n):(Fr(Zr,Zr.current&1),t=sc(t,e,n),t!==null?t.sibling:null);Fr(Zr,Zr.current&1);break;case 19:if(r=(n&e.childLanes)!==0,t.flags&128){if(r)return A8(t,e,n);e.flags|=128}if(i=e.memoizedState,i!==null&&(i.rendering=null,i.tail=null,i.lastEffect=null),Fr(Zr,Zr.current),r)break;return null;case 22:case 23:return e.lanes=0,b8(t,e,n)}return sc(t,e,n)}var E8,bR,I8,T8;E8=function(t,e){for(var n=e.child;n!==null;){if(n.tag===5||n.tag===6)t.appendChild(n.stateNode);else if(n.tag!==4&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===e)break;for(;n.sibling===null;){if(n.return===null||n.return===e)return;n=n.return}n.sibling.return=n.return,n=n.sibling}};bR=function(){};I8=function(t,e,n,r){var i=t.memoizedProps;if(i!==r){t=e.stateNode,dp(tu.current);var s=null;switch(n){case"input":i=GN(t,i),r=GN(t,r),s=[];break;case"select":i=ri({},i,{value:void 0}),r=ri({},r,{value:void 0}),s=[];break;case"textarea":i=VN(t,i),r=VN(t,r),s=[];break;default:typeof i.onClick!="function"&&typeof r.onClick=="function"&&(t.onclick=mE)}XN(n,r);var a;n=null;for(u in i)if(!r.hasOwnProperty(u)&&i.hasOwnProperty(u)&&i[u]!=null)if(u==="style"){var o=i[u];for(a in o)o.hasOwnProperty(a)&&(n||(n={}),n[a]="")}else u!=="dangerouslySetInnerHTML"&&u!=="children"&&u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&u!=="autoFocus"&&(Db.hasOwnProperty(u)?s||(s=[]):(s=s||[]).push(u,null));for(u in r){var l=r[u];if(o=i!=null?i[u]:void 0,r.hasOwnProperty(u)&&l!==o&&(l!=null||o!=null))if(u==="style")if(o){for(a in o)!o.hasOwnProperty(a)||l&&l.hasOwnProperty(a)||(n||(n={}),n[a]="");for(a in l)l.hasOwnProperty(a)&&o[a]!==l[a]&&(n||(n={}),n[a]=l[a])}else n||(s||(s=[]),s.push(u,n)),n=l;else u==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,o=o?o.__html:void 0,l!=null&&o!==l&&(s=s||[]).push(u,l)):u==="children"?typeof l!="string"&&typeof l!="number"||(s=s||[]).push(u,""+l):u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&(Db.hasOwnProperty(u)?(l!=null&&u==="onScroll"&&Pr("scroll",t),s||o===l||(s=[])):(s=s||[]).push(u,l))}n&&(s=s||[]).push("style",n);var u=s;(e.updateQueue=u)&&(e.flags|=4)}};T8=function(t,e,n,r){n!==r&&(e.flags|=4)};function px(t,e){if(!Hr)switch(t.tailMode){case"hidden":e=t.tail;for(var n=null;e!==null;)e.alternate!==null&&(n=e),e=e.sibling;n===null?t.tail=null:n.sibling=null;break;case"collapsed":n=t.tail;for(var r=null;n!==null;)n.alternate!==null&&(r=n),n=n.sibling;r===null?e||t.tail===null?t.tail=null:t.tail.sibling=null:r.sibling=null}}function ks(t){var e=t.alternate!==null&&t.alternate.child===t.child,n=0,r=0;if(e)for(var i=t.child;i!==null;)n|=i.lanes|i.childLanes,r|=i.subtreeFlags&14680064,r|=i.flags&14680064,i.return=t,i=i.sibling;else for(i=t.child;i!==null;)n|=i.lanes|i.childLanes,r|=i.subtreeFlags,r|=i.flags,i.return=t,i=i.sibling;return t.subtreeFlags|=r,t.childLanes=n,e}function Qse(t,e,n){var r=e.pendingProps;switch(DD(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return ks(e),null;case 1:return Fa(e.type)&&gE(),ks(e),null;case 3:return r=e.stateNode,ky(),Or(Ra),Or($s),HD(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),(t===null||t.child===null)&&(uS(e)?e.flags|=4:t===null||t.memoizedState.isDehydrated&&!(e.flags&256)||(e.flags|=1024,dl!==null&&(CR(dl),dl=null))),bR(t,e),ks(e),null;case 5:GD(e);var i=dp(jb.current);if(n=e.type,t!==null&&e.stateNode!=null)I8(t,e,n,r,i),t.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!r){if(e.stateNode===null)throw Error(yt(166));return ks(e),null}if(t=dp(tu.current),uS(e)){r=e.stateNode,n=e.type;var s=e.memoizedProps;switch(r[ql]=e,r[Wb]=s,t=(e.mode&1)!==0,n){case"dialog":Pr("cancel",r),Pr("close",r);break;case"iframe":case"object":case"embed":Pr("load",r);break;case"video":case"audio":for(i=0;i<Xx.length;i++)Pr(Xx[i],r);break;case"source":Pr("error",r);break;case"img":case"image":case"link":Pr("error",r),Pr("load",r);break;case"details":Pr("toggle",r);break;case"input":Ez(r,s),Pr("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!s.multiple},Pr("invalid",r);break;case"textarea":Tz(r,s),Pr("invalid",r)}XN(n,s),i=null;for(var a in s)if(s.hasOwnProperty(a)){var o=s[a];a==="children"?typeof o=="string"?r.textContent!==o&&(s.suppressHydrationWarning!==!0&&lS(r.textContent,o,t),i=["children",o]):typeof o=="number"&&r.textContent!==""+o&&(s.suppressHydrationWarning!==!0&&lS(r.textContent,o,t),i=["children",""+o]):Db.hasOwnProperty(a)&&o!=null&&a==="onScroll"&&Pr("scroll",r)}switch(n){case"input":eS(r),Iz(r,s,!0);break;case"textarea":eS(r),Cz(r);break;case"select":case"option":break;default:typeof s.onClick=="function"&&(r.onclick=mE)}r=i,e.updateQueue=r,r!==null&&(e.flags|=4)}else{a=i.nodeType===9?i:i.ownerDocument,t==="http://www.w3.org/1999/xhtml"&&(t=t6(n)),t==="http://www.w3.org/1999/xhtml"?n==="script"?(t=a.createElement("div"),t.innerHTML="<script><\/script>",t=t.removeChild(t.firstChild)):typeof r.is=="string"?t=a.createElement(n,{is:r.is}):(t=a.createElement(n),n==="select"&&(a=t,r.multiple?a.multiple=!0:r.size&&(a.size=r.size))):t=a.createElementNS(t,n),t[ql]=e,t[Wb]=r,E8(t,e,!1,!1),e.stateNode=t;e:{switch(a=KN(n,r),n){case"dialog":Pr("cancel",t),Pr("close",t),i=r;break;case"iframe":case"object":case"embed":Pr("load",t),i=r;break;case"video":case"audio":for(i=0;i<Xx.length;i++)Pr(Xx[i],t);i=r;break;case"source":Pr("error",t),i=r;break;case"img":case"image":case"link":Pr("error",t),Pr("load",t),i=r;break;case"details":Pr("toggle",t),i=r;break;case"input":Ez(t,r),i=GN(t,r),Pr("invalid",t);break;case"option":i=r;break;case"select":t._wrapperState={wasMultiple:!!r.multiple},i=ri({},r,{value:void 0}),Pr("invalid",t);break;case"textarea":Tz(t,r),i=VN(t,r),Pr("invalid",t);break;default:i=r}XN(n,i),o=i;for(s in o)if(o.hasOwnProperty(s)){var l=o[s];s==="style"?i6(t,l):s==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,l!=null&&n6(t,l)):s==="children"?typeof l=="string"?(n!=="textarea"||l!=="")&&Pb(t,l):typeof l=="number"&&Pb(t,""+l):s!=="suppressContentEditableWarning"&&s!=="suppressHydrationWarning"&&s!=="autoFocus"&&(Db.hasOwnProperty(s)?l!=null&&s==="onScroll"&&Pr("scroll",t):l!=null&&xD(t,s,l,a))}switch(n){case"input":eS(t),Iz(t,r,!1);break;case"textarea":eS(t),Cz(t);break;case"option":r.value!=null&&t.setAttribute("value",""+Id(r.value));break;case"select":t.multiple=!!r.multiple,s=r.value,s!=null?cy(t,!!r.multiple,s,!1):r.defaultValue!=null&&cy(t,!!r.multiple,r.defaultValue,!0);break;default:typeof i.onClick=="function"&&(t.onclick=mE)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(e.flags|=4)}e.ref!==null&&(e.flags|=512,e.flags|=2097152)}return ks(e),null;case 6:if(t&&e.stateNode!=null)T8(t,e,t.memoizedProps,r);else{if(typeof r!="string"&&e.stateNode===null)throw Error(yt(166));if(n=dp(jb.current),dp(tu.current),uS(e)){if(r=e.stateNode,n=e.memoizedProps,r[ql]=e,(s=r.nodeValue!==n)&&(t=so,t!==null))switch(t.tag){case 3:lS(r.nodeValue,n,(t.mode&1)!==0);break;case 5:t.memoizedProps.suppressHydrationWarning!==!0&&lS(r.nodeValue,n,(t.mode&1)!==0)}s&&(e.flags|=4)}else r=(n.nodeType===9?n:n.ownerDocument).createTextNode(r),r[ql]=e,e.stateNode=r}return ks(e),null;case 13:if(Or(Zr),r=e.memoizedState,t===null||t.memoizedState!==null&&t.memoizedState.dehydrated!==null){if(Hr&&Qa!==null&&e.mode&1&&!(e.flags&128))V6(),Cy(),e.flags|=98560,s=!1;else if(s=uS(e),r!==null&&r.dehydrated!==null){if(t===null){if(!s)throw Error(yt(318));if(s=e.memoizedState,s=s!==null?s.dehydrated:null,!s)throw Error(yt(317));s[ql]=e}else Cy(),!(e.flags&128)&&(e.memoizedState=null),e.flags|=4;ks(e),s=!1}else dl!==null&&(CR(dl),dl=null),s=!0;if(!s)return e.flags&65536?e:null}return e.flags&128?(e.lanes=n,e):(r=r!==null,r!==(t!==null&&t.memoizedState!==null)&&r&&(e.child.flags|=8192,e.mode&1&&(t===null||Zr.current&1?Hi===0&&(Hi=3):tP())),e.updateQueue!==null&&(e.flags|=4),ks(e),null);case 4:return ky(),bR(t,e),t===null&&Gb(e.stateNode.containerInfo),ks(e),null;case 10:return BD(e.type._context),ks(e),null;case 17:return Fa(e.type)&&gE(),ks(e),null;case 19:if(Or(Zr),s=e.memoizedState,s===null)return ks(e),null;if(r=(e.flags&128)!==0,a=s.rendering,a===null)if(r)px(s,!1);else{if(Hi!==0||t!==null&&t.flags&128)for(t=e.child;t!==null;){if(a=SE(t),a!==null){for(e.flags|=128,px(s,!1),r=a.updateQueue,r!==null&&(e.updateQueue=r,e.flags|=4),e.subtreeFlags=0,r=n,n=e.child;n!==null;)s=n,t=r,s.flags&=14680066,a=s.alternate,a===null?(s.childLanes=0,s.lanes=t,s.child=null,s.subtreeFlags=0,s.memoizedProps=null,s.memoizedState=null,s.updateQueue=null,s.dependencies=null,s.stateNode=null):(s.childLanes=a.childLanes,s.lanes=a.lanes,s.child=a.child,s.subtreeFlags=0,s.deletions=null,s.memoizedProps=a.memoizedProps,s.memoizedState=a.memoizedState,s.updateQueue=a.updateQueue,s.type=a.type,t=a.dependencies,s.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext}),n=n.sibling;return Fr(Zr,Zr.current&1|2),e.child}t=t.sibling}s.tail!==null&&mi()>Ry&&(e.flags|=128,r=!0,px(s,!1),e.lanes=4194304)}else{if(!r)if(t=SE(a),t!==null){if(e.flags|=128,r=!0,n=t.updateQueue,n!==null&&(e.updateQueue=n,e.flags|=4),px(s,!0),s.tail===null&&s.tailMode==="hidden"&&!a.alternate&&!Hr)return ks(e),null}else 2*mi()-s.renderingStartTime>Ry&&n!==1073741824&&(e.flags|=128,r=!0,px(s,!1),e.lanes=4194304);s.isBackwards?(a.sibling=e.child,e.child=a):(n=s.last,n!==null?n.sibling=a:e.child=a,s.last=a)}return s.tail!==null?(e=s.tail,s.rendering=e,s.tail=e.sibling,s.renderingStartTime=mi(),e.sibling=null,n=Zr.current,Fr(Zr,r?n&1|2:n&1),e):(ks(e),null);case 22:case 23:return eP(),r=e.memoizedState!==null,t!==null&&t.memoizedState!==null!==r&&(e.flags|=8192),r&&e.mode&1?Za&1073741824&&(ks(e),e.subtreeFlags&6&&(e.flags|=8192)):ks(e),null;case 24:return null;case 25:return null}throw Error(yt(156,e.tag))}function eae(t,e){switch(DD(e),e.tag){case 1:return Fa(e.type)&&gE(),t=e.flags,t&65536?(e.flags=t&-65537|128,e):null;case 3:return ky(),Or(Ra),Or($s),HD(),t=e.flags,t&65536&&!(t&128)?(e.flags=t&-65537|128,e):null;case 5:return GD(e),null;case 13:if(Or(Zr),t=e.memoizedState,t!==null&&t.dehydrated!==null){if(e.alternate===null)throw Error(yt(340));Cy()}return t=e.flags,t&65536?(e.flags=t&-65537|128,e):null;case 19:return Or(Zr),null;case 4:return ky(),null;case 10:return BD(e.type._context),null;case 22:case 23:return eP(),null;case 24:return null;default:return null}}var hS=!1,Ps=!1,tae=typeof WeakSet=="function"?WeakSet:Set,qt=null;function iy(t,e){var n=t.ref;if(n!==null)if(typeof n=="function")try{n(null)}catch(r){li(t,e,r)}else n.current=null}function wR(t,e,n){try{n()}catch(r){li(t,e,r)}}var y4=!1;function nae(t,e){if(iR=hE,t=R6(),RD(t)){if("selectionStart"in t)var n={start:t.selectionStart,end:t.selectionEnd};else e:{n=(n=t.ownerDocument)&&n.defaultView||window;var r=n.getSelection&&n.getSelection();if(r&&r.rangeCount!==0){n=r.anchorNode;var i=r.anchorOffset,s=r.focusNode;r=r.focusOffset;try{n.nodeType,s.nodeType}catch{n=null;break e}var a=0,o=-1,l=-1,u=0,c=0,d=t,h=null;t:for(;;){for(var p;d!==n||i!==0&&d.nodeType!==3||(o=a+i),d!==s||r!==0&&d.nodeType!==3||(l=a+r),d.nodeType===3&&(a+=d.nodeValue.length),(p=d.firstChild)!==null;)h=d,d=p;for(;;){if(d===t)break t;if(h===n&&++u===i&&(o=a),h===s&&++c===r&&(l=a),(p=d.nextSibling)!==null)break;d=h,h=d.parentNode}d=p}n=o===-1||l===-1?null:{start:o,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(sR={focusedElem:t,selectionRange:n},hE=!1,qt=e;qt!==null;)if(e=qt,t=e.child,(e.subtreeFlags&1028)!==0&&t!==null)t.return=e,qt=t;else for(;qt!==null;){e=qt;try{var f=e.alternate;if(e.flags&1024)switch(e.tag){case 0:case 11:case 15:break;case 1:if(f!==null){var g=f.memoizedProps,y=f.memoizedState,m=e.stateNode,b=m.getSnapshotBeforeUpdate(e.elementType===e.type?g:ll(e.type,g),y);m.__reactInternalSnapshotBeforeUpdate=b}break;case 3:var w=e.stateNode.containerInfo;w.nodeType===1?w.textContent="":w.nodeType===9&&w.documentElement&&w.removeChild(w.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(yt(163))}}catch(_){li(e,e.return,_)}if(t=e.sibling,t!==null){t.return=e.return,qt=t;break}qt=e.return}return f=y4,y4=!1,f}function mb(t,e,n){var r=e.updateQueue;if(r=r!==null?r.lastEffect:null,r!==null){var i=r=r.next;do{if((i.tag&t)===t){var s=i.destroy;i.destroy=void 0,s!==void 0&&wR(e,n,s)}i=i.next}while(i!==r)}}function hT(t,e){if(e=e.updateQueue,e=e!==null?e.lastEffect:null,e!==null){var n=e=e.next;do{if((n.tag&t)===t){var r=n.create;n.destroy=r()}n=n.next}while(n!==e)}}function _R(t){var e=t.ref;if(e!==null){var n=t.stateNode;switch(t.tag){case 5:t=n;break;default:t=n}typeof e=="function"?e(t):e.current=t}}function C8(t){var e=t.alternate;e!==null&&(t.alternate=null,C8(e)),t.child=null,t.deletions=null,t.sibling=null,t.tag===5&&(e=t.stateNode,e!==null&&(delete e[ql],delete e[Wb],delete e[lR],delete e[Bse],delete e[Use])),t.stateNode=null,t.return=null,t.dependencies=null,t.memoizedProps=null,t.memoizedState=null,t.pendingProps=null,t.stateNode=null,t.updateQueue=null}function M8(t){return t.tag===5||t.tag===3||t.tag===4}function v4(t){e:for(;;){for(;t.sibling===null;){if(t.return===null||M8(t.return))return null;t=t.return}for(t.sibling.return=t.return,t=t.sibling;t.tag!==5&&t.tag!==6&&t.tag!==18;){if(t.flags&2||t.child===null||t.tag===4)continue e;t.child.return=t,t=t.child}if(!(t.flags&2))return t.stateNode}}function SR(t,e,n){var r=t.tag;if(r===5||r===6)t=t.stateNode,e?n.nodeType===8?n.parentNode.insertBefore(t,e):n.insertBefore(t,e):(n.nodeType===8?(e=n.parentNode,e.insertBefore(t,n)):(e=n,e.appendChild(t)),n=n._reactRootContainer,n!=null||e.onclick!==null||(e.onclick=mE));else if(r!==4&&(t=t.child,t!==null))for(SR(t,e,n),t=t.sibling;t!==null;)SR(t,e,n),t=t.sibling}function AR(t,e,n){var r=t.tag;if(r===5||r===6)t=t.stateNode,e?n.insertBefore(t,e):n.appendChild(t);else if(r!==4&&(t=t.child,t!==null))for(AR(t,e,n),t=t.sibling;t!==null;)AR(t,e,n),t=t.sibling}var ms=null,cl=!1;function Rc(t,e,n){for(n=n.child;n!==null;)k8(t,e,n),n=n.sibling}function k8(t,e,n){if(eu&&typeof eu.onCommitFiberUnmount=="function")try{eu.onCommitFiberUnmount(iT,n)}catch{}switch(n.tag){case 5:Ps||iy(n,e);case 6:var r=ms,i=cl;ms=null,Rc(t,e,n),ms=r,cl=i,ms!==null&&(cl?(t=ms,n=n.stateNode,t.nodeType===8?t.parentNode.removeChild(n):t.removeChild(n)):ms.removeChild(n.stateNode));break;case 18:ms!==null&&(cl?(t=ms,n=n.stateNode,t.nodeType===8?H2(t.parentNode,n):t.nodeType===1&&H2(t,n),Ub(t)):H2(ms,n.stateNode));break;case 4:r=ms,i=cl,ms=n.stateNode.containerInfo,cl=!0,Rc(t,e,n),ms=r,cl=i;break;case 0:case 11:case 14:case 15:if(!Ps&&(r=n.updateQueue,r!==null&&(r=r.lastEffect,r!==null))){i=r=r.next;do{var s=i,a=s.destroy;s=s.tag,a!==void 0&&(s&2||s&4)&&wR(n,e,a),i=i.next}while(i!==r)}Rc(t,e,n);break;case 1:if(!Ps&&(iy(n,e),r=n.stateNode,typeof r.componentWillUnmount=="function"))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(o){li(n,e,o)}Rc(t,e,n);break;case 21:Rc(t,e,n);break;case 22:n.mode&1?(Ps=(r=Ps)||n.memoizedState!==null,Rc(t,e,n),Ps=r):Rc(t,e,n);break;default:Rc(t,e,n)}}function x4(t){var e=t.updateQueue;if(e!==null){t.updateQueue=null;var n=t.stateNode;n===null&&(n=t.stateNode=new tae),e.forEach(function(r){var i=dae.bind(null,t,r);n.has(r)||(n.add(r),r.then(i,i))})}}function Qo(t,e){var n=e.deletions;if(n!==null)for(var r=0;r<n.length;r++){var i=n[r];try{var s=t,a=e,o=a;e:for(;o!==null;){switch(o.tag){case 5:ms=o.stateNode,cl=!1;break e;case 3:ms=o.stateNode.containerInfo,cl=!0;break e;case 4:ms=o.stateNode.containerInfo,cl=!0;break e}o=o.return}if(ms===null)throw Error(yt(160));k8(s,a,i),ms=null,cl=!1;var l=i.alternate;l!==null&&(l.return=null),i.return=null}catch(u){li(i,e,u)}}if(e.subtreeFlags&12854)for(e=e.child;e!==null;)N8(e,t),e=e.sibling}function N8(t,e){var n=t.alternate,r=t.flags;switch(t.tag){case 0:case 11:case 14:case 15:if(Qo(e,t),Ol(t),r&4){try{mb(3,t,t.return),hT(3,t)}catch(g){li(t,t.return,g)}try{mb(5,t,t.return)}catch(g){li(t,t.return,g)}}break;case 1:Qo(e,t),Ol(t),r&512&&n!==null&&iy(n,n.return);break;case 5:if(Qo(e,t),Ol(t),r&512&&n!==null&&iy(n,n.return),t.flags&32){var i=t.stateNode;try{Pb(i,"")}catch(g){li(t,t.return,g)}}if(r&4&&(i=t.stateNode,i!=null)){var s=t.memoizedProps,a=n!==null?n.memoizedProps:s,o=t.type,l=t.updateQueue;if(t.updateQueue=null,l!==null)try{o==="input"&&s.type==="radio"&&s.name!=null&&Q5(i,s),KN(o,a);var u=KN(o,s);for(a=0;a<l.length;a+=2){var c=l[a],d=l[a+1];c==="style"?i6(i,d):c==="dangerouslySetInnerHTML"?n6(i,d):c==="children"?Pb(i,d):xD(i,c,d,u)}switch(o){case"input":HN(i,s);break;case"textarea":e6(i,s);break;case"select":var h=i._wrapperState.wasMultiple;i._wrapperState.wasMultiple=!!s.multiple;var p=s.value;p!=null?cy(i,!!s.multiple,p,!1):h!==!!s.multiple&&(s.defaultValue!=null?cy(i,!!s.multiple,s.defaultValue,!0):cy(i,!!s.multiple,s.multiple?[]:"",!1))}i[Wb]=s}catch(g){li(t,t.return,g)}}break;case 6:if(Qo(e,t),Ol(t),r&4){if(t.stateNode===null)throw Error(yt(162));i=t.stateNode,s=t.memoizedProps;try{i.nodeValue=s}catch(g){li(t,t.return,g)}}break;case 3:if(Qo(e,t),Ol(t),r&4&&n!==null&&n.memoizedState.isDehydrated)try{Ub(e.containerInfo)}catch(g){li(t,t.return,g)}break;case 4:Qo(e,t),Ol(t);break;case 13:Qo(e,t),Ol(t),i=t.child,i.flags&8192&&(s=i.memoizedState!==null,i.stateNode.isHidden=s,!s||i.alternate!==null&&i.alternate.memoizedState!==null||(ZD=mi())),r&4&&x4(t);break;case 22:if(c=n!==null&&n.memoizedState!==null,t.mode&1?(Ps=(u=Ps)||c,Qo(e,t),Ps=u):Qo(e,t),Ol(t),r&8192){if(u=t.memoizedState!==null,(t.stateNode.isHidden=u)&&!c&&t.mode&1)for(qt=t,c=t.child;c!==null;){for(d=qt=c;qt!==null;){switch(h=qt,p=h.child,h.tag){case 0:case 11:case 14:case 15:mb(4,h,h.return);break;case 1:iy(h,h.return);var f=h.stateNode;if(typeof f.componentWillUnmount=="function"){r=h,n=h.return;try{e=r,f.props=e.memoizedProps,f.state=e.memoizedState,f.componentWillUnmount()}catch(g){li(r,n,g)}}break;case 5:iy(h,h.return);break;case 22:if(h.memoizedState!==null){w4(d);continue}}p!==null?(p.return=h,qt=p):w4(d)}c=c.sibling}e:for(c=null,d=t;;){if(d.tag===5){if(c===null){c=d;try{i=d.stateNode,u?(s=i.style,typeof s.setProperty=="function"?s.setProperty("display","none","important"):s.display="none"):(o=d.stateNode,l=d.memoizedProps.style,a=l!=null&&l.hasOwnProperty("display")?l.display:null,o.style.display=r6("display",a))}catch(g){li(t,t.return,g)}}}else if(d.tag===6){if(c===null)try{d.stateNode.nodeValue=u?"":d.memoizedProps}catch(g){li(t,t.return,g)}}else if((d.tag!==22&&d.tag!==23||d.memoizedState===null||d===t)&&d.child!==null){d.child.return=d,d=d.child;continue}if(d===t)break e;for(;d.sibling===null;){if(d.return===null||d.return===t)break e;c===d&&(c=null),d=d.return}c===d&&(c=null),d.sibling.return=d.return,d=d.sibling}}break;case 19:Qo(e,t),Ol(t),r&4&&x4(t);break;case 21:break;default:Qo(e,t),Ol(t)}}function Ol(t){var e=t.flags;if(e&2){try{e:{for(var n=t.return;n!==null;){if(M8(n)){var r=n;break e}n=n.return}throw Error(yt(160))}switch(r.tag){case 5:var i=r.stateNode;r.flags&32&&(Pb(i,""),r.flags&=-33);var s=v4(t);AR(t,s,i);break;case 3:case 4:var a=r.stateNode.containerInfo,o=v4(t);SR(t,o,a);break;default:throw Error(yt(161))}}catch(l){li(t,t.return,l)}t.flags&=-3}e&4096&&(t.flags&=-4097)}function rae(t,e,n){qt=t,R8(t)}function R8(t,e,n){for(var r=(t.mode&1)!==0;qt!==null;){var i=qt,s=i.child;if(i.tag===22&&r){var a=i.memoizedState!==null||hS;if(!a){var o=i.alternate,l=o!==null&&o.memoizedState!==null||Ps;o=hS;var u=Ps;if(hS=a,(Ps=l)&&!u)for(qt=i;qt!==null;)a=qt,l=a.child,a.tag===22&&a.memoizedState!==null?_4(i):l!==null?(l.return=a,qt=l):_4(i);for(;s!==null;)qt=s,R8(s),s=s.sibling;qt=i,hS=o,Ps=u}b4(t)}else i.subtreeFlags&8772&&s!==null?(s.return=i,qt=s):b4(t)}}function b4(t){for(;qt!==null;){var e=qt;if(e.flags&8772){var n=e.alternate;try{if(e.flags&8772)switch(e.tag){case 0:case 11:case 15:Ps||hT(5,e);break;case 1:var r=e.stateNode;if(e.flags&4&&!Ps)if(n===null)r.componentDidMount();else{var i=e.elementType===e.type?n.memoizedProps:ll(e.type,n.memoizedProps);r.componentDidUpdate(i,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var s=e.updateQueue;s!==null&&i4(e,s,r);break;case 3:var a=e.updateQueue;if(a!==null){if(n=null,e.child!==null)switch(e.child.tag){case 5:n=e.child.stateNode;break;case 1:n=e.child.stateNode}i4(e,a,n)}break;case 5:var o=e.stateNode;if(n===null&&e.flags&4){n=o;var l=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&n.focus();break;case"img":l.src&&(n.src=l.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(e.memoizedState===null){var u=e.alternate;if(u!==null){var c=u.memoizedState;if(c!==null){var d=c.dehydrated;d!==null&&Ub(d)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(yt(163))}Ps||e.flags&512&&_R(e)}catch(h){li(e,e.return,h)}}if(e===t){qt=null;break}if(n=e.sibling,n!==null){n.return=e.return,qt=n;break}qt=e.return}}function w4(t){for(;qt!==null;){var e=qt;if(e===t){qt=null;break}var n=e.sibling;if(n!==null){n.return=e.return,qt=n;break}qt=e.return}}function _4(t){for(;qt!==null;){var e=qt;try{switch(e.tag){case 0:case 11:case 15:var n=e.return;try{hT(4,e)}catch(l){li(e,n,l)}break;case 1:var r=e.stateNode;if(typeof r.componentDidMount=="function"){var i=e.return;try{r.componentDidMount()}catch(l){li(e,i,l)}}var s=e.return;try{_R(e)}catch(l){li(e,s,l)}break;case 5:var a=e.return;try{_R(e)}catch(l){li(e,a,l)}}}catch(l){li(e,e.return,l)}if(e===t){qt=null;break}var o=e.sibling;if(o!==null){o.return=e.return,qt=o;break}qt=e.return}}var iae=Math.ceil,IE=hc.ReactCurrentDispatcher,JD=hc.ReactCurrentOwner,Bo=hc.ReactCurrentBatchConfig,sr=0,cs=null,Ti=null,ys=0,Za=0,sy=Xd(0),Hi=0,Jb=null,Lp=0,pT=0,YD=0,gb=null,Ea=null,ZD=0,Ry=1/0,Pu=null,TE=!1,ER=null,vd=null,pS=!1,sd=null,CE=0,yb=0,IR=null,GA=-1,HA=0;function ia(){return sr&6?mi():GA!==-1?GA:GA=mi()}function xd(t){return t.mode&1?sr&2&&ys!==0?ys&-ys:zse.transition!==null?(HA===0&&(HA=g6()),HA):(t=br,t!==0||(t=window.event,t=t===void 0?16:S6(t.type)),t):1}function gl(t,e,n,r){if(50<yb)throw yb=0,IR=null,Error(yt(185));R1(t,n,r),(!(sr&2)||t!==cs)&&(t===cs&&(!(sr&2)&&(pT|=n),Hi===4&&td(t,ys)),Da(t,r),n===1&&sr===0&&!(e.mode&1)&&(Ry=mi()+500,uT&&Kd()))}function Da(t,e){var n=t.callbackNode;zie(t,e);var r=dE(t,t===cs?ys:0);if(r===0)n!==null&&Nz(n),t.callbackNode=null,t.callbackPriority=0;else if(e=r&-r,t.callbackPriority!==e){if(n!=null&&Nz(n),e===1)t.tag===0?$se(S4.bind(null,t)):G6(S4.bind(null,t)),Lse(function(){!(sr&6)&&Kd()}),n=null;else{switch(y6(r)){case 1:n=AD;break;case 4:n=f6;break;case 16:n=cE;break;case 536870912:n=m6;break;default:n=cE}n=$8(n,F8.bind(null,t))}t.callbackPriority=e,t.callbackNode=n}}function F8(t,e){if(GA=-1,HA=0,sr&6)throw Error(yt(327));var n=t.callbackNode;if(my()&&t.callbackNode!==n)return null;var r=dE(t,t===cs?ys:0);if(r===0)return null;if(r&30||r&t.expiredLanes||e)e=ME(t,r);else{e=r;var i=sr;sr|=2;var s=P8();(cs!==t||ys!==e)&&(Pu=null,Ry=mi()+500,wp(t,e));do try{oae();break}catch(o){D8(t,o)}while(!0);OD(),IE.current=s,sr=i,Ti!==null?e=0:(cs=null,ys=0,e=Hi)}if(e!==0){if(e===2&&(i=QN(t),i!==0&&(r=i,e=TR(t,i))),e===1)throw n=Jb,wp(t,0),td(t,r),Da(t,mi()),n;if(e===6)td(t,r);else{if(i=t.current.alternate,!(r&30)&&!sae(i)&&(e=ME(t,r),e===2&&(s=QN(t),s!==0&&(r=s,e=TR(t,s))),e===1))throw n=Jb,wp(t,0),td(t,r),Da(t,mi()),n;switch(t.finishedWork=i,t.finishedLanes=r,e){case 0:case 1:throw Error(yt(345));case 2:jh(t,Ea,Pu);break;case 3:if(td(t,r),(r&130023424)===r&&(e=ZD+500-mi(),10<e)){if(dE(t,0)!==0)break;if(i=t.suspendedLanes,(i&r)!==r){ia(),t.pingedLanes|=t.suspendedLanes&i;break}t.timeoutHandle=oR(jh.bind(null,t,Ea,Pu),e);break}jh(t,Ea,Pu);break;case 4:if(td(t,r),(r&4194240)===r)break;for(e=t.eventTimes,i=-1;0<r;){var a=31-ml(r);s=1<<a,a=e[a],a>i&&(i=a),r&=~s}if(r=i,r=mi()-r,r=(120>r?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*iae(r/1960))-r,10<r){t.timeoutHandle=oR(jh.bind(null,t,Ea,Pu),r);break}jh(t,Ea,Pu);break;case 5:jh(t,Ea,Pu);break;default:throw Error(yt(329))}}}return Da(t,mi()),t.callbackNode===n?F8.bind(null,t):null}function TR(t,e){var n=gb;return t.current.memoizedState.isDehydrated&&(wp(t,e).flags|=256),t=ME(t,e),t!==2&&(e=Ea,Ea=n,e!==null&&CR(e)),t}function CR(t){Ea===null?Ea=t:Ea.push.apply(Ea,t)}function sae(t){for(var e=t;;){if(e.flags&16384){var n=e.updateQueue;if(n!==null&&(n=n.stores,n!==null))for(var r=0;r<n.length;r++){var i=n[r],s=i.getSnapshot;i=i.value;try{if(!wl(s(),i))return!1}catch{return!1}}}if(n=e.child,e.subtreeFlags&16384&&n!==null)n.return=e,e=n;else{if(e===t)break;for(;e.sibling===null;){if(e.return===null||e.return===t)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}function td(t,e){for(e&=~YD,e&=~pT,t.suspendedLanes|=e,t.pingedLanes&=~e,t=t.expirationTimes;0<e;){var n=31-ml(e),r=1<<n;t[n]=-1,e&=~r}}function S4(t){if(sr&6)throw Error(yt(327));my();var e=dE(t,0);if(!(e&1))return Da(t,mi()),null;var n=ME(t,e);if(t.tag!==0&&n===2){var r=QN(t);r!==0&&(e=r,n=TR(t,r))}if(n===1)throw n=Jb,wp(t,0),td(t,e),Da(t,mi()),n;if(n===6)throw Error(yt(345));return t.finishedWork=t.current.alternate,t.finishedLanes=e,jh(t,Ea,Pu),Da(t,mi()),null}function QD(t,e){var n=sr;sr|=1;try{return t(e)}finally{sr=n,sr===0&&(Ry=mi()+500,uT&&Kd())}}function Op(t){sd!==null&&sd.tag===0&&!(sr&6)&&my();var e=sr;sr|=1;var n=Bo.transition,r=br;try{if(Bo.transition=null,br=1,t)return t()}finally{br=r,Bo.transition=n,sr=e,!(sr&6)&&Kd()}}function eP(){Za=sy.current,Or(sy)}function wp(t,e){t.finishedWork=null,t.finishedLanes=0;var n=t.timeoutHandle;if(n!==-1&&(t.timeoutHandle=-1,Pse(n)),Ti!==null)for(n=Ti.return;n!==null;){var r=n;switch(DD(r),r.tag){case 1:r=r.type.childContextTypes,r!=null&&gE();break;case 3:ky(),Or(Ra),Or($s),HD();break;case 5:GD(r);break;case 4:ky();break;case 13:Or(Zr);break;case 19:Or(Zr);break;case 10:BD(r.type._context);break;case 22:case 23:eP()}n=n.return}if(cs=t,Ti=t=bd(t.current,null),ys=Za=e,Hi=0,Jb=null,YD=pT=Lp=0,Ea=gb=null,cp!==null){for(e=0;e<cp.length;e++)if(n=cp[e],r=n.interleaved,r!==null){n.interleaved=null;var i=r.next,s=n.pending;if(s!==null){var a=s.next;s.next=i,r.next=a}n.pending=r}cp=null}return t}function D8(t,e){do{var n=Ti;try{if(OD(),UA.current=EE,AE){for(var r=ni.memoizedState;r!==null;){var i=r.queue;i!==null&&(i.pending=null),r=r.next}AE=!1}if(Pp=0,as=Bi=ni=null,fb=!1,Xb=0,JD.current=null,n===null||n.return===null){Hi=1,Jb=e,Ti=null;break}e:{var s=t,a=n.return,o=n,l=e;if(e=ys,o.flags|=32768,l!==null&&typeof l=="object"&&typeof l.then=="function"){var u=l,c=o,d=c.tag;if(!(c.mode&1)&&(d===0||d===11||d===15)){var h=c.alternate;h?(c.updateQueue=h.updateQueue,c.memoizedState=h.memoizedState,c.lanes=h.lanes):(c.updateQueue=null,c.memoizedState=null)}var p=c4(a);if(p!==null){p.flags&=-257,d4(p,a,o,s,e),p.mode&1&&u4(s,u,e),e=p,l=u;var f=e.updateQueue;if(f===null){var g=new Set;g.add(l),e.updateQueue=g}else f.add(l);break e}else{if(!(e&1)){u4(s,u,e),tP();break e}l=Error(yt(426))}}else if(Hr&&o.mode&1){var y=c4(a);if(y!==null){!(y.flags&65536)&&(y.flags|=256),d4(y,a,o,s,e),PD(Ny(l,o));break e}}s=l=Ny(l,o),Hi!==4&&(Hi=2),gb===null?gb=[s]:gb.push(s),s=a;do{switch(s.tag){case 3:s.flags|=65536,e&=-e,s.lanes|=e;var m=y8(s,l,e);r4(s,m);break e;case 1:o=l;var b=s.type,w=s.stateNode;if(!(s.flags&128)&&(typeof b.getDerivedStateFromError=="function"||w!==null&&typeof w.componentDidCatch=="function"&&(vd===null||!vd.has(w)))){s.flags|=65536,e&=-e,s.lanes|=e;var _=v8(s,o,e);r4(s,_);break e}}s=s.return}while(s!==null)}O8(n)}catch(S){e=S,Ti===n&&n!==null&&(Ti=n=n.return);continue}break}while(!0)}function P8(){var t=IE.current;return IE.current=EE,t===null?EE:t}function tP(){(Hi===0||Hi===3||Hi===2)&&(Hi=4),cs===null||!(Lp&268435455)&&!(pT&268435455)||td(cs,ys)}function ME(t,e){var n=sr;sr|=2;var r=P8();(cs!==t||ys!==e)&&(Pu=null,wp(t,e));do try{aae();break}catch(i){D8(t,i)}while(!0);if(OD(),sr=n,IE.current=r,Ti!==null)throw Error(yt(261));return cs=null,ys=0,Hi}function aae(){for(;Ti!==null;)L8(Ti)}function oae(){for(;Ti!==null&&!Rie();)L8(Ti)}function L8(t){var e=U8(t.alternate,t,Za);t.memoizedProps=t.pendingProps,e===null?O8(t):Ti=e,JD.current=null}function O8(t){var e=t;do{var n=e.alternate;if(t=e.return,e.flags&32768){if(n=eae(n,e),n!==null){n.flags&=32767,Ti=n;return}if(t!==null)t.flags|=32768,t.subtreeFlags=0,t.deletions=null;else{Hi=6,Ti=null;return}}else if(n=Qse(n,e,Za),n!==null){Ti=n;return}if(e=e.sibling,e!==null){Ti=e;return}Ti=e=t}while(e!==null);Hi===0&&(Hi=5)}function jh(t,e,n){var r=br,i=Bo.transition;try{Bo.transition=null,br=1,lae(t,e,n,r)}finally{Bo.transition=i,br=r}return null}function lae(t,e,n,r){do my();while(sd!==null);if(sr&6)throw Error(yt(327));n=t.finishedWork;var i=t.finishedLanes;if(n===null)return null;if(t.finishedWork=null,t.finishedLanes=0,n===t.current)throw Error(yt(177));t.callbackNode=null,t.callbackPriority=0;var s=n.lanes|n.childLanes;if(Gie(t,s),t===cs&&(Ti=cs=null,ys=0),!(n.subtreeFlags&2064)&&!(n.flags&2064)||pS||(pS=!0,$8(cE,function(){return my(),null})),s=(n.flags&15990)!==0,n.subtreeFlags&15990||s){s=Bo.transition,Bo.transition=null;var a=br;br=1;var o=sr;sr|=4,JD.current=null,nae(t,n),N8(n,t),Cse(sR),hE=!!iR,sR=iR=null,t.current=n,rae(n),Fie(),sr=o,br=a,Bo.transition=s}else t.current=n;if(pS&&(pS=!1,sd=t,CE=i),s=t.pendingLanes,s===0&&(vd=null),Lie(n.stateNode),Da(t,mi()),e!==null)for(r=t.onRecoverableError,n=0;n<e.length;n++)i=e[n],r(i.value,{componentStack:i.stack,digest:i.digest});if(TE)throw TE=!1,t=ER,ER=null,t;return CE&1&&t.tag!==0&&my(),s=t.pendingLanes,s&1?t===IR?yb++:(yb=0,IR=t):yb=0,Kd(),null}function my(){if(sd!==null){var t=y6(CE),e=Bo.transition,n=br;try{if(Bo.transition=null,br=16>t?16:t,sd===null)var r=!1;else{if(t=sd,sd=null,CE=0,sr&6)throw Error(yt(331));var i=sr;for(sr|=4,qt=t.current;qt!==null;){var s=qt,a=s.child;if(qt.flags&16){var o=s.deletions;if(o!==null){for(var l=0;l<o.length;l++){var u=o[l];for(qt=u;qt!==null;){var c=qt;switch(c.tag){case 0:case 11:case 15:mb(8,c,s)}var d=c.child;if(d!==null)d.return=c,qt=d;else for(;qt!==null;){c=qt;var h=c.sibling,p=c.return;if(C8(c),c===u){qt=null;break}if(h!==null){h.return=p,qt=h;break}qt=p}}}var f=s.alternate;if(f!==null){var g=f.child;if(g!==null){f.child=null;do{var y=g.sibling;g.sibling=null,g=y}while(g!==null)}}qt=s}}if(s.subtreeFlags&2064&&a!==null)a.return=s,qt=a;else e:for(;qt!==null;){if(s=qt,s.flags&2048)switch(s.tag){case 0:case 11:case 15:mb(9,s,s.return)}var m=s.sibling;if(m!==null){m.return=s.return,qt=m;break e}qt=s.return}}var b=t.current;for(qt=b;qt!==null;){a=qt;var w=a.child;if(a.subtreeFlags&2064&&w!==null)w.return=a,qt=w;else e:for(a=b;qt!==null;){if(o=qt,o.flags&2048)try{switch(o.tag){case 0:case 11:case 15:hT(9,o)}}catch(S){li(o,o.return,S)}if(o===a){qt=null;break e}var _=o.sibling;if(_!==null){_.return=o.return,qt=_;break e}qt=o.return}}if(sr=i,Kd(),eu&&typeof eu.onPostCommitFiberRoot=="function")try{eu.onPostCommitFiberRoot(iT,t)}catch{}r=!0}return r}finally{br=n,Bo.transition=e}}return!1}function A4(t,e,n){e=Ny(n,e),e=y8(t,e,1),t=yd(t,e,1),e=ia(),t!==null&&(R1(t,1,e),Da(t,e))}function li(t,e,n){if(t.tag===3)A4(t,t,n);else for(;e!==null;){if(e.tag===3){A4(e,t,n);break}else if(e.tag===1){var r=e.stateNode;if(typeof e.type.getDerivedStateFromError=="function"||typeof r.componentDidCatch=="function"&&(vd===null||!vd.has(r))){t=Ny(n,t),t=v8(e,t,1),e=yd(e,t,1),t=ia(),e!==null&&(R1(e,1,t),Da(e,t));break}}e=e.return}}function uae(t,e,n){var r=t.pingCache;r!==null&&r.delete(e),e=ia(),t.pingedLanes|=t.suspendedLanes&n,cs===t&&(ys&n)===n&&(Hi===4||Hi===3&&(ys&130023424)===ys&&500>mi()-ZD?wp(t,0):YD|=n),Da(t,e)}function B8(t,e){e===0&&(t.mode&1?(e=rS,rS<<=1,!(rS&130023424)&&(rS=4194304)):e=1);var n=ia();t=ic(t,e),t!==null&&(R1(t,e,n),Da(t,n))}function cae(t){var e=t.memoizedState,n=0;e!==null&&(n=e.retryLane),B8(t,n)}function dae(t,e){var n=0;switch(t.tag){case 13:var r=t.stateNode,i=t.memoizedState;i!==null&&(n=i.retryLane);break;case 19:r=t.stateNode;break;default:throw Error(yt(314))}r!==null&&r.delete(e),B8(t,n)}var U8;U8=function(t,e,n){if(t!==null)if(t.memoizedProps!==e.pendingProps||Ra.current)Ca=!0;else{if(!(t.lanes&n)&&!(e.flags&128))return Ca=!1,Zse(t,e,n);Ca=!!(t.flags&131072)}else Ca=!1,Hr&&e.flags&1048576&&H6(e,xE,e.index);switch(e.lanes=0,e.tag){case 2:var r=e.type;zA(t,e),t=e.pendingProps;var i=Ty(e,$s.current);fy(e,n),i=VD(null,e,r,t,i,n);var s=jD();return e.flags|=1,typeof i=="object"&&i!==null&&typeof i.render=="function"&&i.$$typeof===void 0?(e.tag=1,e.memoizedState=null,e.updateQueue=null,Fa(r)?(s=!0,yE(e)):s=!1,e.memoizedState=i.state!==null&&i.state!==void 0?i.state:null,$D(e),i.updater=dT,e.stateNode=i,i._reactInternals=e,fR(e,r,t,n),e=yR(null,e,r,!0,s,n)):(e.tag=0,Hr&&s&&FD(e),Qs(null,e,i,n),e=e.child),e;case 16:r=e.elementType;e:{switch(zA(t,e),t=e.pendingProps,i=r._init,r=i(r._payload),e.type=r,i=e.tag=pae(r),t=ll(r,t),i){case 0:e=gR(null,e,r,t,n);break e;case 1:e=f4(null,e,r,t,n);break e;case 11:e=h4(null,e,r,t,n);break e;case 14:e=p4(null,e,r,ll(r.type,t),n);break e}throw Error(yt(306,r,""))}return e;case 0:return r=e.type,i=e.pendingProps,i=e.elementType===r?i:ll(r,i),gR(t,e,r,i,n);case 1:return r=e.type,i=e.pendingProps,i=e.elementType===r?i:ll(r,i),f4(t,e,r,i,n);case 3:e:{if(_8(e),t===null)throw Error(yt(387));r=e.pendingProps,s=e.memoizedState,i=s.element,q6(t,e),_E(e,r,null,n);var a=e.memoizedState;if(r=a.element,s.isDehydrated)if(s={element:r,isDehydrated:!1,cache:a.cache,pendingSuspenseBoundaries:a.pendingSuspenseBoundaries,transitions:a.transitions},e.updateQueue.baseState=s,e.memoizedState=s,e.flags&256){i=Ny(Error(yt(423)),e),e=m4(t,e,r,n,i);break e}else if(r!==i){i=Ny(Error(yt(424)),e),e=m4(t,e,r,n,i);break e}else for(Qa=gd(e.stateNode.containerInfo.firstChild),so=e,Hr=!0,dl=null,n=X6(e,null,r,n),e.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling;else{if(Cy(),r===i){e=sc(t,e,n);break e}Qs(t,e,r,n)}e=e.child}return e;case 5:return J6(e),t===null&&dR(e),r=e.type,i=e.pendingProps,s=t!==null?t.memoizedProps:null,a=i.children,aR(r,i)?a=null:s!==null&&aR(r,s)&&(e.flags|=32),w8(t,e),Qs(t,e,a,n),e.child;case 6:return t===null&&dR(e),null;case 13:return S8(t,e,n);case 4:return zD(e,e.stateNode.containerInfo),r=e.pendingProps,t===null?e.child=My(e,null,r,n):Qs(t,e,r,n),e.child;case 11:return r=e.type,i=e.pendingProps,i=e.elementType===r?i:ll(r,i),h4(t,e,r,i,n);case 7:return Qs(t,e,e.pendingProps,n),e.child;case 8:return Qs(t,e,e.pendingProps.children,n),e.child;case 12:return Qs(t,e,e.pendingProps.children,n),e.child;case 10:e:{if(r=e.type._context,i=e.pendingProps,s=e.memoizedProps,a=i.value,Fr(bE,r._currentValue),r._currentValue=a,s!==null)if(wl(s.value,a)){if(s.children===i.children&&!Ra.current){e=sc(t,e,n);break e}}else for(s=e.child,s!==null&&(s.return=e);s!==null;){var o=s.dependencies;if(o!==null){a=s.child;for(var l=o.firstContext;l!==null;){if(l.context===r){if(s.tag===1){l=qu(-1,n&-n),l.tag=2;var u=s.updateQueue;if(u!==null){u=u.shared;var c=u.pending;c===null?l.next=l:(l.next=c.next,c.next=l),u.pending=l}}s.lanes|=n,l=s.alternate,l!==null&&(l.lanes|=n),hR(s.return,n,e),o.lanes|=n;break}l=l.next}}else if(s.tag===10)a=s.type===e.type?null:s.child;else if(s.tag===18){if(a=s.return,a===null)throw Error(yt(341));a.lanes|=n,o=a.alternate,o!==null&&(o.lanes|=n),hR(a,n,e),a=s.sibling}else a=s.child;if(a!==null)a.return=s;else for(a=s;a!==null;){if(a===e){a=null;break}if(s=a.sibling,s!==null){s.return=a.return,a=s;break}a=a.return}s=a}Qs(t,e,i.children,n),e=e.child}return e;case 9:return i=e.type,r=e.pendingProps.children,fy(e,n),i=$o(i),r=r(i),e.flags|=1,Qs(t,e,r,n),e.child;case 14:return r=e.type,i=ll(r,e.pendingProps),i=ll(r.type,i),p4(t,e,r,i,n);case 15:return x8(t,e,e.type,e.pendingProps,n);case 17:return r=e.type,i=e.pendingProps,i=e.elementType===r?i:ll(r,i),zA(t,e),e.tag=1,Fa(r)?(t=!0,yE(e)):t=!1,fy(e,n),g8(e,r,i),fR(e,r,i,n),yR(null,e,r,!0,t,n);case 19:return A8(t,e,n);case 22:return b8(t,e,n)}throw Error(yt(156,e.tag))};function $8(t,e){return p6(t,e)}function hae(t,e,n,r){this.tag=t,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Lo(t,e,n,r){return new hae(t,e,n,r)}function nP(t){return t=t.prototype,!(!t||!t.isReactComponent)}function pae(t){if(typeof t=="function")return nP(t)?1:0;if(t!=null){if(t=t.$$typeof,t===wD)return 11;if(t===_D)return 14}return 2}function bd(t,e){var n=t.alternate;return n===null?(n=Lo(t.tag,e,t.key,t.mode),n.elementType=t.elementType,n.type=t.type,n.stateNode=t.stateNode,n.alternate=t,t.alternate=n):(n.pendingProps=e,n.type=t.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=t.flags&14680064,n.childLanes=t.childLanes,n.lanes=t.lanes,n.child=t.child,n.memoizedProps=t.memoizedProps,n.memoizedState=t.memoizedState,n.updateQueue=t.updateQueue,e=t.dependencies,n.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext},n.sibling=t.sibling,n.index=t.index,n.ref=t.ref,n}function WA(t,e,n,r,i,s){var a=2;if(r=t,typeof t=="function")nP(t)&&(a=1);else if(typeof t=="string")a=5;else e:switch(t){case qg:return _p(n.children,i,s,e);case bD:a=8,i|=8;break;case BN:return t=Lo(12,n,e,i|2),t.elementType=BN,t.lanes=s,t;case UN:return t=Lo(13,n,e,i),t.elementType=UN,t.lanes=s,t;case $N:return t=Lo(19,n,e,i),t.elementType=$N,t.lanes=s,t;case J5:return fT(n,i,s,e);default:if(typeof t=="object"&&t!==null)switch(t.$$typeof){case K5:a=10;break e;case q5:a=9;break e;case wD:a=11;break e;case _D:a=14;break e;case qc:a=16,r=null;break e}throw Error(yt(130,t==null?t:typeof t,""))}return e=Lo(a,n,e,i),e.elementType=t,e.type=r,e.lanes=s,e}function _p(t,e,n,r){return t=Lo(7,t,r,e),t.lanes=n,t}function fT(t,e,n,r){return t=Lo(22,t,r,e),t.elementType=J5,t.lanes=n,t.stateNode={isHidden:!1},t}function Y2(t,e,n){return t=Lo(6,t,null,e),t.lanes=n,t}function Z2(t,e,n){return e=Lo(4,t.children!==null?t.children:[],t.key,e),e.lanes=n,e.stateNode={containerInfo:t.containerInfo,pendingChildren:null,implementation:t.implementation},e}function fae(t,e,n,r,i){this.tag=e,this.containerInfo=t,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=R2(0),this.expirationTimes=R2(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=R2(0),this.identifierPrefix=r,this.onRecoverableError=i,this.mutableSourceEagerHydrationData=null}function rP(t,e,n,r,i,s,a,o,l){return t=new fae(t,e,n,o,l),e===1?(e=1,s===!0&&(e|=8)):e=0,s=Lo(3,null,null,e),t.current=s,s.stateNode=t,s.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},$D(s),t}function mae(t,e,n){var r=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:Kg,key:r==null?null:""+r,children:t,containerInfo:e,implementation:n}}function z8(t){if(!t)return Td;t=t._reactInternals;e:{if(mf(t)!==t||t.tag!==1)throw Error(yt(170));var e=t;do{switch(e.tag){case 3:e=e.stateNode.context;break e;case 1:if(Fa(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break e}}e=e.return}while(e!==null);throw Error(yt(171))}if(t.tag===1){var n=t.type;if(Fa(n))return z6(t,n,e)}return e}function G8(t,e,n,r,i,s,a,o,l){return t=rP(n,r,!0,t,i,s,a,o,l),t.context=z8(null),n=t.current,r=ia(),i=xd(n),s=qu(r,i),s.callback=e??null,yd(n,s,i),t.current.lanes=i,R1(t,i,r),Da(t,r),t}function mT(t,e,n,r){var i=e.current,s=ia(),a=xd(i);return n=z8(n),e.context===null?e.context=n:e.pendingContext=n,e=qu(s,a),e.payload={element:t},r=r===void 0?null:r,r!==null&&(e.callback=r),t=yd(i,e,a),t!==null&&(gl(t,i,a,s),BA(t,i,a)),a}function kE(t){if(t=t.current,!t.child)return null;switch(t.child.tag){case 5:return t.child.stateNode;default:return t.child.stateNode}}function E4(t,e){if(t=t.memoizedState,t!==null&&t.dehydrated!==null){var n=t.retryLane;t.retryLane=n!==0&&n<e?n:e}}function iP(t,e){E4(t,e),(t=t.alternate)&&E4(t,e)}function gae(){return null}var H8=typeof reportError=="function"?reportError:function(t){console.error(t)};function sP(t){this._internalRoot=t}gT.prototype.render=sP.prototype.render=function(t){var e=this._internalRoot;if(e===null)throw Error(yt(409));mT(t,e,null,null)};gT.prototype.unmount=sP.prototype.unmount=function(){var t=this._internalRoot;if(t!==null){this._internalRoot=null;var e=t.containerInfo;Op(function(){mT(null,t,null,null)}),e[rc]=null}};function gT(t){this._internalRoot=t}gT.prototype.unstable_scheduleHydration=function(t){if(t){var e=b6();t={blockedOn:null,target:t,priority:e};for(var n=0;n<ed.length&&e!==0&&e<ed[n].priority;n++);ed.splice(n,0,t),n===0&&_6(t)}};function aP(t){return!(!t||t.nodeType!==1&&t.nodeType!==9&&t.nodeType!==11)}function yT(t){return!(!t||t.nodeType!==1&&t.nodeType!==9&&t.nodeType!==11&&(t.nodeType!==8||t.nodeValue!==" react-mount-point-unstable "))}function I4(){}function yae(t,e,n,r,i){if(i){if(typeof r=="function"){var s=r;r=function(){var u=kE(a);s.call(u)}}var a=G8(e,r,t,0,null,!1,!1,"",I4);return t._reactRootContainer=a,t[rc]=a.current,Gb(t.nodeType===8?t.parentNode:t),Op(),a}for(;i=t.lastChild;)t.removeChild(i);if(typeof r=="function"){var o=r;r=function(){var u=kE(l);o.call(u)}}var l=rP(t,0,!1,null,null,!1,!1,"",I4);return t._reactRootContainer=l,t[rc]=l.current,Gb(t.nodeType===8?t.parentNode:t),Op(function(){mT(e,l,n,r)}),l}function vT(t,e,n,r,i){var s=n._reactRootContainer;if(s){var a=s;if(typeof i=="function"){var o=i;i=function(){var l=kE(a);o.call(l)}}mT(e,a,t,i)}else a=yae(n,e,t,i,r);return kE(a)}v6=function(t){switch(t.tag){case 3:var e=t.stateNode;if(e.current.memoizedState.isDehydrated){var n=jx(e.pendingLanes);n!==0&&(ED(e,n|1),Da(e,mi()),!(sr&6)&&(Ry=mi()+500,Kd()))}break;case 13:Op(function(){var r=ic(t,1);if(r!==null){var i=ia();gl(r,t,1,i)}}),iP(t,1)}};ID=function(t){if(t.tag===13){var e=ic(t,134217728);if(e!==null){var n=ia();gl(e,t,134217728,n)}iP(t,134217728)}};x6=function(t){if(t.tag===13){var e=xd(t),n=ic(t,e);if(n!==null){var r=ia();gl(n,t,e,r)}iP(t,e)}};b6=function(){return br};w6=function(t,e){var n=br;try{return br=t,e()}finally{br=n}};JN=function(t,e,n){switch(e){case"input":if(HN(t,n),e=n.name,n.type==="radio"&&e!=null){for(n=t;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<n.length;e++){var r=n[e];if(r!==t&&r.form===t.form){var i=lT(r);if(!i)throw Error(yt(90));Z5(r),HN(r,i)}}}break;case"textarea":e6(t,n);break;case"select":e=n.value,e!=null&&cy(t,!!n.multiple,e,!1)}};o6=QD;l6=Op;var vae={usingClientEntryPoint:!1,Events:[D1,Qg,lT,s6,a6,QD]},fx={findFiberByHostInstance:up,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},xae={bundleType:fx.bundleType,version:fx.version,rendererPackageName:fx.rendererPackageName,rendererConfig:fx.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:hc.ReactCurrentDispatcher,findHostInstanceByFiber:function(t){return t=d6(t),t===null?null:t.stateNode},findFiberByHostInstance:fx.findFiberByHostInstance||gae,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var fS=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!fS.isDisabled&&fS.supportsFiber)try{iT=fS.inject(xae),eu=fS}catch{}}po.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=vae;po.createPortal=function(t,e){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!aP(e))throw Error(yt(200));return mae(t,e,null,n)};po.createRoot=function(t,e){if(!aP(t))throw Error(yt(299));var n=!1,r="",i=H8;return e!=null&&(e.unstable_strictMode===!0&&(n=!0),e.identifierPrefix!==void 0&&(r=e.identifierPrefix),e.onRecoverableError!==void 0&&(i=e.onRecoverableError)),e=rP(t,1,!1,null,null,n,!1,r,i),t[rc]=e.current,Gb(t.nodeType===8?t.parentNode:t),new sP(e)};po.findDOMNode=function(t){if(t==null)return null;if(t.nodeType===1)return t;var e=t._reactInternals;if(e===void 0)throw typeof t.render=="function"?Error(yt(188)):(t=Object.keys(t).join(","),Error(yt(268,t)));return t=d6(e),t=t===null?null:t.stateNode,t};po.flushSync=function(t){return Op(t)};po.hydrate=function(t,e,n){if(!yT(e))throw Error(yt(200));return vT(null,t,e,!0,n)};po.hydrateRoot=function(t,e,n){if(!aP(t))throw Error(yt(405));var r=n!=null&&n.hydratedSources||null,i=!1,s="",a=H8;if(n!=null&&(n.unstable_strictMode===!0&&(i=!0),n.identifierPrefix!==void 0&&(s=n.identifierPrefix),n.onRecoverableError!==void 0&&(a=n.onRecoverableError)),e=G8(e,null,t,1,n??null,i,!1,s,a),t[rc]=e.current,Gb(t),r)for(t=0;t<r.length;t++)n=r[t],i=n._getVersion,i=i(n._source),e.mutableSourceEagerHydrationData==null?e.mutableSourceEagerHydrationData=[n,i]:e.mutableSourceEagerHydrationData.push(n,i);return new gT(e)};po.render=function(t,e,n){if(!yT(e))throw Error(yt(200));return vT(null,t,e,!1,n)};po.unmountComponentAtNode=function(t){if(!yT(t))throw Error(yt(40));return t._reactRootContainer?(Op(function(){vT(null,null,t,!1,function(){t._reactRootContainer=null,t[rc]=null})}),!0):!1};po.unstable_batchedUpdates=QD;po.unstable_renderSubtreeIntoContainer=function(t,e,n,r){if(!yT(n))throw Error(yt(200));if(t==null||t._reactInternals===void 0)throw Error(yt(38));return vT(t,e,n,!1,r)};po.version="18.3.1-next-f1338f8080-20240426";function W8(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(W8)}catch(t){console.error(t)}}W8(),W5.exports=po;var bae=W5.exports,V8,T4=bae;V8=T4.createRoot,T4.hydrateRoot;/**
 * @remix-run/router v1.21.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Yb(){return Yb=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},Yb.apply(this,arguments)}var ad;(function(t){t.Pop="POP",t.Push="PUSH",t.Replace="REPLACE"})(ad||(ad={}));const C4="popstate";function wae(t){t===void 0&&(t={});function e(i,s){let{pathname:a="/",search:o="",hash:l=""}=gf(i.location.hash.substr(1));return!a.startsWith("/")&&!a.startsWith(".")&&(a="/"+a),MR("",{pathname:a,search:o,hash:l},s.state&&s.state.usr||null,s.state&&s.state.key||"default")}function n(i,s){let a=i.document.querySelector("base"),o="";if(a&&a.getAttribute("href")){let l=i.location.href,u=l.indexOf("#");o=u===-1?l:l.slice(0,u)}return o+"#"+(typeof s=="string"?s:NE(s))}function r(i,s){oP(i.pathname.charAt(0)==="/","relative pathnames are not supported in hash history.push("+JSON.stringify(s)+")")}return Sae(e,n,r,t)}function ki(t,e){if(t===!1||t===null||typeof t>"u")throw new Error(e)}function oP(t,e){if(!t){typeof console<"u"&&console.warn(e);try{throw new Error(e)}catch{}}}function _ae(){return Math.random().toString(36).substr(2,8)}function M4(t,e){return{usr:t.state,key:t.key,idx:e}}function MR(t,e,n,r){return n===void 0&&(n=null),Yb({pathname:typeof t=="string"?t:t.pathname,search:"",hash:""},typeof e=="string"?gf(e):e,{state:n,key:e&&e.key||r||_ae()})}function NE(t){let{pathname:e="/",search:n="",hash:r=""}=t;return n&&n!=="?"&&(e+=n.charAt(0)==="?"?n:"?"+n),r&&r!=="#"&&(e+=r.charAt(0)==="#"?r:"#"+r),e}function gf(t){let e={};if(t){let n=t.indexOf("#");n>=0&&(e.hash=t.substr(n),t=t.substr(0,n));let r=t.indexOf("?");r>=0&&(e.search=t.substr(r),t=t.substr(0,r)),t&&(e.pathname=t)}return e}function Sae(t,e,n,r){r===void 0&&(r={});let{window:i=document.defaultView,v5Compat:s=!1}=r,a=i.history,o=ad.Pop,l=null,u=c();u==null&&(u=0,a.replaceState(Yb({},a.state,{idx:u}),""));function c(){return(a.state||{idx:null}).idx}function d(){o=ad.Pop;let y=c(),m=y==null?null:y-u;u=y,l&&l({action:o,location:g.location,delta:m})}function h(y,m){o=ad.Push;let b=MR(g.location,y,m);n&&n(b,y),u=c()+1;let w=M4(b,u),_=g.createHref(b);try{a.pushState(w,"",_)}catch(S){if(S instanceof DOMException&&S.name==="DataCloneError")throw S;i.location.assign(_)}s&&l&&l({action:o,location:g.location,delta:1})}function p(y,m){o=ad.Replace;let b=MR(g.location,y,m);n&&n(b,y),u=c();let w=M4(b,u),_=g.createHref(b);a.replaceState(w,"",_),s&&l&&l({action:o,location:g.location,delta:0})}function f(y){let m=i.location.origin!=="null"?i.location.origin:i.location.href,b=typeof y=="string"?y:NE(y);return b=b.replace(/ $/,"%20"),ki(m,"No window.location.(origin|href) available to create URL for href: "+b),new URL(b,m)}let g={get action(){return o},get location(){return t(i,a)},listen(y){if(l)throw new Error("A history only accepts one active listener");return i.addEventListener(C4,d),l=y,()=>{i.removeEventListener(C4,d),l=null}},createHref(y){return e(i,y)},createURL:f,encodeLocation(y){let m=f(y);return{pathname:m.pathname,search:m.search,hash:m.hash}},push:h,replace:p,go(y){return a.go(y)}};return g}var k4;(function(t){t.data="data",t.deferred="deferred",t.redirect="redirect",t.error="error"})(k4||(k4={}));function Aae(t,e,n){return n===void 0&&(n="/"),Eae(t,e,n,!1)}function Eae(t,e,n,r){let i=typeof e=="string"?gf(e):e,s=lP(i.pathname||"/",n);if(s==null)return null;let a=j8(t);Iae(a);let o=null;for(let l=0;o==null&&l<a.length;++l){let u=Oae(s);o=Pae(a[l],u,r)}return o}function j8(t,e,n,r){e===void 0&&(e=[]),n===void 0&&(n=[]),r===void 0&&(r="");let i=(s,a,o)=>{let l={relativePath:o===void 0?s.path||"":o,caseSensitive:s.caseSensitive===!0,childrenIndex:a,route:s};l.relativePath.startsWith("/")&&(ki(l.relativePath.startsWith(r),'Absolute route path "'+l.relativePath+'" nested under path '+('"'+r+'" is not valid. An absolute child route path ')+"must start with the combined path of all its parent routes."),l.relativePath=l.relativePath.slice(r.length));let u=wd([r,l.relativePath]),c=n.concat(l);s.children&&s.children.length>0&&(ki(s.index!==!0,"Index routes must not have child routes. Please remove "+('all child routes from route path "'+u+'".')),j8(s.children,e,c,u)),!(s.path==null&&!s.index)&&e.push({path:u,score:Fae(u,s.index),routesMeta:c})};return t.forEach((s,a)=>{var o;if(s.path===""||!((o=s.path)!=null&&o.includes("?")))i(s,a);else for(let l of X8(s.path))i(s,a,l)}),e}function X8(t){let e=t.split("/");if(e.length===0)return[];let[n,...r]=e,i=n.endsWith("?"),s=n.replace(/\?$/,"");if(r.length===0)return i?[s,""]:[s];let a=X8(r.join("/")),o=[];return o.push(...a.map(l=>l===""?s:[s,l].join("/"))),i&&o.push(...a),o.map(l=>t.startsWith("/")&&l===""?"/":l)}function Iae(t){t.sort((e,n)=>e.score!==n.score?n.score-e.score:Dae(e.routesMeta.map(r=>r.childrenIndex),n.routesMeta.map(r=>r.childrenIndex)))}const Tae=/^:[\w-]+$/,Cae=3,Mae=2,kae=1,Nae=10,Rae=-2,N4=t=>t==="*";function Fae(t,e){let n=t.split("/"),r=n.length;return n.some(N4)&&(r+=Rae),e&&(r+=Mae),n.filter(i=>!N4(i)).reduce((i,s)=>i+(Tae.test(s)?Cae:s===""?kae:Nae),r)}function Dae(t,e){return t.length===e.length&&t.slice(0,-1).every((r,i)=>r===e[i])?t[t.length-1]-e[e.length-1]:0}function Pae(t,e,n){let{routesMeta:r}=t,i={},s="/",a=[];for(let o=0;o<r.length;++o){let l=r[o],u=o===r.length-1,c=s==="/"?e:e.slice(s.length)||"/",d=R4({path:l.relativePath,caseSensitive:l.caseSensitive,end:u},c),h=l.route;if(!d&&u&&n&&!r[r.length-1].route.index&&(d=R4({path:l.relativePath,caseSensitive:l.caseSensitive,end:!1},c)),!d)return null;Object.assign(i,d.params),a.push({params:i,pathname:wd([s,d.pathname]),pathnameBase:zae(wd([s,d.pathnameBase])),route:h}),d.pathnameBase!=="/"&&(s=wd([s,d.pathnameBase]))}return a}function R4(t,e){typeof t=="string"&&(t={path:t,caseSensitive:!1,end:!0});let[n,r]=Lae(t.path,t.caseSensitive,t.end),i=e.match(n);if(!i)return null;let s=i[0],a=s.replace(/(.)\/+$/,"$1"),o=i.slice(1);return{params:r.reduce((u,c,d)=>{let{paramName:h,isOptional:p}=c;if(h==="*"){let g=o[d]||"";a=s.slice(0,s.length-g.length).replace(/(.)\/+$/,"$1")}const f=o[d];return p&&!f?u[h]=void 0:u[h]=(f||"").replace(/%2F/g,"/"),u},{}),pathname:s,pathnameBase:a,pattern:t}}function Lae(t,e,n){e===void 0&&(e=!1),n===void 0&&(n=!0),oP(t==="*"||!t.endsWith("*")||t.endsWith("/*"),'Route path "'+t+'" will be treated as if it were '+('"'+t.replace(/\*$/,"/*")+'" because the `*` character must ')+"always follow a `/` in the pattern. To get rid of this warning, "+('please change the route path to "'+t.replace(/\*$/,"/*")+'".'));let r=[],i="^"+t.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(a,o,l)=>(r.push({paramName:o,isOptional:l!=null}),l?"/?([^\\/]+)?":"/([^\\/]+)"));return t.endsWith("*")?(r.push({paramName:"*"}),i+=t==="*"||t==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?i+="\\/*$":t!==""&&t!=="/"&&(i+="(?:(?=\\/|$))"),[new RegExp(i,e?void 0:"i"),r]}function Oae(t){try{return t.split("/").map(e=>decodeURIComponent(e).replace(/\//g,"%2F")).join("/")}catch(e){return oP(!1,'The URL path "'+t+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent '+("encoding ("+e+").")),t}}function lP(t,e){if(e==="/")return t;if(!t.toLowerCase().startsWith(e.toLowerCase()))return null;let n=e.endsWith("/")?e.length-1:e.length,r=t.charAt(n);return r&&r!=="/"?null:t.slice(n)||"/"}function Bae(t,e){e===void 0&&(e="/");let{pathname:n,search:r="",hash:i=""}=typeof t=="string"?gf(t):t;return{pathname:n?n.startsWith("/")?n:Uae(n,e):e,search:Gae(r),hash:Hae(i)}}function Uae(t,e){let n=e.replace(/\/+$/,"").split("/");return t.split("/").forEach(i=>{i===".."?n.length>1&&n.pop():i!=="."&&n.push(i)}),n.length>1?n.join("/"):"/"}function Q2(t,e,n,r){return"Cannot include a '"+t+"' character in a manually specified "+("`to."+e+"` field ["+JSON.stringify(r)+"].  Please separate it out to the ")+("`to."+n+"` field. Alternatively you may provide the full path as ")+'a string in <Link to="..."> and the router will parse it for you.'}function $ae(t){return t.filter((e,n)=>n===0||e.route.path&&e.route.path.length>0)}function K8(t,e){let n=$ae(t);return e?n.map((r,i)=>i===n.length-1?r.pathname:r.pathnameBase):n.map(r=>r.pathnameBase)}function q8(t,e,n,r){r===void 0&&(r=!1);let i;typeof t=="string"?i=gf(t):(i=Yb({},t),ki(!i.pathname||!i.pathname.includes("?"),Q2("?","pathname","search",i)),ki(!i.pathname||!i.pathname.includes("#"),Q2("#","pathname","hash",i)),ki(!i.search||!i.search.includes("#"),Q2("#","search","hash",i)));let s=t===""||i.pathname==="",a=s?"/":i.pathname,o;if(a==null)o=n;else{let d=e.length-1;if(!r&&a.startsWith("..")){let h=a.split("/");for(;h[0]==="..";)h.shift(),d-=1;i.pathname=h.join("/")}o=d>=0?e[d]:"/"}let l=Bae(i,o),u=a&&a!=="/"&&a.endsWith("/"),c=(s||a===".")&&n.endsWith("/");return!l.pathname.endsWith("/")&&(u||c)&&(l.pathname+="/"),l}const wd=t=>t.join("/").replace(/\/\/+/g,"/"),zae=t=>t.replace(/\/+$/,"").replace(/^\/*/,"/"),Gae=t=>!t||t==="?"?"":t.startsWith("?")?t:"?"+t,Hae=t=>!t||t==="#"?"":t.startsWith("#")?t:"#"+t;function Wae(t){return t!=null&&typeof t.status=="number"&&typeof t.statusText=="string"&&typeof t.internal=="boolean"&&"data"in t}const J8=["post","put","patch","delete"];new Set(J8);const Vae=["get",...J8];new Set(Vae);/**
 * React Router v6.28.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Zb(){return Zb=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},Zb.apply(this,arguments)}const uP=ne.createContext(null),jae=ne.createContext(null),yf=ne.createContext(null),xT=ne.createContext(null),qd=ne.createContext({outlet:null,matches:[],isDataRoute:!1}),Y8=ne.createContext(null);function Xae(t,e){let{relative:n}=e===void 0?{}:e;L1()||ki(!1);let{basename:r,navigator:i}=ne.useContext(yf),{hash:s,pathname:a,search:o}=Q8(t,{relative:n}),l=a;return r!=="/"&&(l=a==="/"?r:wd([r,a])),i.createHref({pathname:l,search:o,hash:s})}function L1(){return ne.useContext(xT)!=null}function O1(){return L1()||ki(!1),ne.useContext(xT).location}function Z8(t){ne.useContext(yf).static||ne.useLayoutEffect(t)}function h0(){let{isDataRoute:t}=ne.useContext(qd);return t?loe():Kae()}function Kae(){L1()||ki(!1);let t=ne.useContext(uP),{basename:e,future:n,navigator:r}=ne.useContext(yf),{matches:i}=ne.useContext(qd),{pathname:s}=O1(),a=JSON.stringify(K8(i,n.v7_relativeSplatPath)),o=ne.useRef(!1);return Z8(()=>{o.current=!0}),ne.useCallback(function(u,c){if(c===void 0&&(c={}),!o.current)return;if(typeof u=="number"){r.go(u);return}let d=q8(u,JSON.parse(a),s,c.relative==="path");t==null&&e!=="/"&&(d.pathname=d.pathname==="/"?e:wd([e,d.pathname])),(c.replace?r.replace:r.push)(d,c.state,c)},[e,r,a,s,t])}const qae=ne.createContext(null);function Jae(t){let e=ne.useContext(qd).outlet;return e&&ne.createElement(qae.Provider,{value:t},e)}function Q8(t,e){let{relative:n}=e===void 0?{}:e,{future:r}=ne.useContext(yf),{matches:i}=ne.useContext(qd),{pathname:s}=O1(),a=JSON.stringify(K8(i,r.v7_relativeSplatPath));return ne.useMemo(()=>q8(t,JSON.parse(a),s,n==="path"),[t,a,s,n])}function Yae(t,e){return Zae(t,e)}function Zae(t,e,n,r){L1()||ki(!1);let{navigator:i}=ne.useContext(yf),{matches:s}=ne.useContext(qd),a=s[s.length-1],o=a?a.params:{};a&&a.pathname;let l=a?a.pathnameBase:"/";a&&a.route;let u=O1(),c;if(e){var d;let y=typeof e=="string"?gf(e):e;l==="/"||(d=y.pathname)!=null&&d.startsWith(l)||ki(!1),c=y}else c=u;let h=c.pathname||"/",p=h;if(l!=="/"){let y=l.replace(/^\//,"").split("/");p="/"+h.replace(/^\//,"").split("/").slice(y.length).join("/")}let f=Aae(t,{pathname:p}),g=roe(f&&f.map(y=>Object.assign({},y,{params:Object.assign({},o,y.params),pathname:wd([l,i.encodeLocation?i.encodeLocation(y.pathname).pathname:y.pathname]),pathnameBase:y.pathnameBase==="/"?l:wd([l,i.encodeLocation?i.encodeLocation(y.pathnameBase).pathname:y.pathnameBase])})),s,n,r);return e&&g?ne.createElement(xT.Provider,{value:{location:Zb({pathname:"/",search:"",hash:"",state:null,key:"default"},c),navigationType:ad.Pop}},g):g}function Qae(){let t=ooe(),e=Wae(t)?t.status+" "+t.statusText:t instanceof Error?t.message:JSON.stringify(t),n=t instanceof Error?t.stack:null,i={padding:"0.5rem",backgroundColor:"rgba(200,200,200, 0.5)"};return ne.createElement(ne.Fragment,null,ne.createElement("h2",null,"Unexpected Application Error!"),ne.createElement("h3",{style:{fontStyle:"italic"}},e),n?ne.createElement("pre",{style:i},n):null,null)}const eoe=ne.createElement(Qae,null);class toe extends ne.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,n){return n.location!==e.location||n.revalidation!=="idle"&&e.revalidation==="idle"?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:e.error!==void 0?e.error:n.error,location:n.location,revalidation:e.revalidation||n.revalidation}}componentDidCatch(e,n){console.error("React Router caught the following error during render",e,n)}render(){return this.state.error!==void 0?ne.createElement(qd.Provider,{value:this.props.routeContext},ne.createElement(Y8.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function noe(t){let{routeContext:e,match:n,children:r}=t,i=ne.useContext(uP);return i&&i.static&&i.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(i.staticContext._deepestRenderedBoundaryId=n.route.id),ne.createElement(qd.Provider,{value:e},r)}function roe(t,e,n,r){var i;if(e===void 0&&(e=[]),n===void 0&&(n=null),r===void 0&&(r=null),t==null){var s;if(!n)return null;if(n.errors)t=n.matches;else if((s=r)!=null&&s.v7_partialHydration&&e.length===0&&!n.initialized&&n.matches.length>0)t=n.matches;else return null}let a=t,o=(i=n)==null?void 0:i.errors;if(o!=null){let c=a.findIndex(d=>d.route.id&&(o==null?void 0:o[d.route.id])!==void 0);c>=0||ki(!1),a=a.slice(0,Math.min(a.length,c+1))}let l=!1,u=-1;if(n&&r&&r.v7_partialHydration)for(let c=0;c<a.length;c++){let d=a[c];if((d.route.HydrateFallback||d.route.hydrateFallbackElement)&&(u=c),d.route.id){let{loaderData:h,errors:p}=n,f=d.route.loader&&h[d.route.id]===void 0&&(!p||p[d.route.id]===void 0);if(d.route.lazy||f){l=!0,u>=0?a=a.slice(0,u+1):a=[a[0]];break}}}return a.reduceRight((c,d,h)=>{let p,f=!1,g=null,y=null;n&&(p=o&&d.route.id?o[d.route.id]:void 0,g=d.route.errorElement||eoe,l&&(u<0&&h===0?(f=!0,y=null):u===h&&(f=!0,y=d.route.hydrateFallbackElement||null)));let m=e.concat(a.slice(0,h+1)),b=()=>{let w;return p?w=g:f?w=y:d.route.Component?w=ne.createElement(d.route.Component,null):d.route.element?w=d.route.element:w=c,ne.createElement(noe,{match:d,routeContext:{outlet:c,matches:m,isDataRoute:n!=null},children:w})};return n&&(d.route.ErrorBoundary||d.route.errorElement||h===0)?ne.createElement(toe,{location:n.location,revalidation:n.revalidation,component:g,error:p,children:b(),routeContext:{outlet:null,matches:m,isDataRoute:!0}}):b()},null)}var ej=function(t){return t.UseBlocker="useBlocker",t.UseRevalidator="useRevalidator",t.UseNavigateStable="useNavigate",t}(ej||{}),RE=function(t){return t.UseBlocker="useBlocker",t.UseLoaderData="useLoaderData",t.UseActionData="useActionData",t.UseRouteError="useRouteError",t.UseNavigation="useNavigation",t.UseRouteLoaderData="useRouteLoaderData",t.UseMatches="useMatches",t.UseRevalidator="useRevalidator",t.UseNavigateStable="useNavigate",t.UseRouteId="useRouteId",t}(RE||{});function ioe(t){let e=ne.useContext(uP);return e||ki(!1),e}function soe(t){let e=ne.useContext(jae);return e||ki(!1),e}function aoe(t){let e=ne.useContext(qd);return e||ki(!1),e}function tj(t){let e=aoe(),n=e.matches[e.matches.length-1];return n.route.id||ki(!1),n.route.id}function ooe(){var t;let e=ne.useContext(Y8),n=soe(RE.UseRouteError),r=tj(RE.UseRouteError);return e!==void 0?e:(t=n.errors)==null?void 0:t[r]}function loe(){let{router:t}=ioe(ej.UseNavigateStable),e=tj(RE.UseNavigateStable),n=ne.useRef(!1);return Z8(()=>{n.current=!0}),ne.useCallback(function(i,s){s===void 0&&(s={}),n.current&&(typeof i=="number"?t.navigate(i):t.navigate(i,Zb({fromRouteId:e},s)))},[t,e])}const F4={};function uoe(t,e){F4[e]||(F4[e]=!0,console.warn(e))}const D4=(t,e,n)=>uoe(t," React Router Future Flag Warning: "+e+". "+("You can use the `"+t+"` future flag to opt-in early. ")+("For more information, see "+n+"."));function coe(t,e){(t==null?void 0:t.v7_startTransition)===void 0&&D4("v7_startTransition","React Router will begin wrapping state updates in `React.startTransition` in v7","https://reactrouter.com/v6/upgrading/future#v7_starttransition"),(t==null?void 0:t.v7_relativeSplatPath)===void 0&&!e&&D4("v7_relativeSplatPath","Relative route resolution within Splat routes is changing in v7","https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath")}function doe(t){return Jae(t.context)}function Mo(t){ki(!1)}function hoe(t){let{basename:e="/",children:n=null,location:r,navigationType:i=ad.Pop,navigator:s,static:a=!1,future:o}=t;L1()&&ki(!1);let l=e.replace(/^\/*/,"/"),u=ne.useMemo(()=>({basename:l,navigator:s,static:a,future:Zb({v7_relativeSplatPath:!1},o)}),[l,o,s,a]);typeof r=="string"&&(r=gf(r));let{pathname:c="/",search:d="",hash:h="",state:p=null,key:f="default"}=r,g=ne.useMemo(()=>{let y=lP(c,l);return y==null?null:{location:{pathname:y,search:d,hash:h,state:p,key:f},navigationType:i}},[l,c,d,h,p,f,i]);return g==null?null:ne.createElement(yf.Provider,{value:u},ne.createElement(xT.Provider,{children:n,value:g}))}function poe(t){let{children:e,location:n}=t;return Yae(kR(e),n)}new Promise(()=>{});function kR(t,e){e===void 0&&(e=[]);let n=[];return ne.Children.forEach(t,(r,i)=>{if(!ne.isValidElement(r))return;let s=[...e,i];if(r.type===ne.Fragment){n.push.apply(n,kR(r.props.children,s));return}r.type!==Mo&&ki(!1),!r.props.index||!r.props.children||ki(!1);let a={id:r.props.id||s.join("-"),caseSensitive:r.props.caseSensitive,element:r.props.element,Component:r.props.Component,index:r.props.index,path:r.props.path,loader:r.props.loader,action:r.props.action,errorElement:r.props.errorElement,ErrorBoundary:r.props.ErrorBoundary,hasErrorBoundary:r.props.ErrorBoundary!=null||r.props.errorElement!=null,shouldRevalidate:r.props.shouldRevalidate,handle:r.props.handle,lazy:r.props.lazy};r.props.children&&(a.children=kR(r.props.children,s)),n.push(a)}),n}/**
 * React Router DOM v6.28.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function NR(){return NR=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},NR.apply(this,arguments)}function foe(t,e){if(t==null)return{};var n={},r=Object.keys(t),i,s;for(s=0;s<r.length;s++)i=r[s],!(e.indexOf(i)>=0)&&(n[i]=t[i]);return n}function moe(t){return!!(t.metaKey||t.altKey||t.ctrlKey||t.shiftKey)}function goe(t,e){return t.button===0&&(!e||e==="_self")&&!moe(t)}const yoe=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","viewTransition"],voe="6";try{window.__reactRouterVersion=voe}catch{}const xoe="startTransition",P4=uie[xoe];function boe(t){let{basename:e,children:n,future:r,window:i}=t,s=ne.useRef();s.current==null&&(s.current=wae({window:i,v5Compat:!0}));let a=s.current,[o,l]=ne.useState({action:a.action,location:a.location}),{v7_startTransition:u}=r||{},c=ne.useCallback(d=>{u&&P4?P4(()=>l(d)):l(d)},[l,u]);return ne.useLayoutEffect(()=>a.listen(c),[a,c]),ne.useEffect(()=>coe(r),[r]),ne.createElement(hoe,{basename:e,children:n,location:o.location,navigationType:o.action,navigator:a,future:r})}const woe=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u",_oe=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Kx=ne.forwardRef(function(e,n){let{onClick:r,relative:i,reloadDocument:s,replace:a,state:o,target:l,to:u,preventScrollReset:c,viewTransition:d}=e,h=foe(e,yoe),{basename:p}=ne.useContext(yf),f,g=!1;if(typeof u=="string"&&_oe.test(u)&&(f=u,woe))try{let w=new URL(window.location.href),_=u.startsWith("//")?new URL(w.protocol+u):new URL(u),S=lP(_.pathname,p);_.origin===w.origin&&S!=null?u=S+_.search+_.hash:g=!0}catch{}let y=Xae(u,{relative:i}),m=Soe(u,{replace:a,state:o,target:l,preventScrollReset:c,relative:i,viewTransition:d});function b(w){r&&r(w),w.defaultPrevented||m(w)}return ne.createElement("a",NR({},h,{href:f||y,onClick:g||s?r:b,ref:n,target:l}))});var L4;(function(t){t.UseScrollRestoration="useScrollRestoration",t.UseSubmit="useSubmit",t.UseSubmitFetcher="useSubmitFetcher",t.UseFetcher="useFetcher",t.useViewTransitionState="useViewTransitionState"})(L4||(L4={}));var O4;(function(t){t.UseFetcher="useFetcher",t.UseFetchers="useFetchers",t.UseScrollRestoration="useScrollRestoration"})(O4||(O4={}));function Soe(t,e){let{target:n,replace:r,state:i,preventScrollReset:s,relative:a,viewTransition:o}=e===void 0?{}:e,l=h0(),u=O1(),c=Q8(t,{relative:a});return ne.useCallback(d=>{if(goe(d,n)){d.preventDefault();let h=r!==void 0?r:NE(u)===NE(c);l(t,{replace:h,state:i,preventScrollReset:s,relative:a,viewTransition:o})}},[u,l,c,r,i,n,t,s,a,o])}var RR=function(t,e){return RR=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(n[i]=r[i])},RR(t,e)};function Aoe(t,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");RR(t,e);function n(){this.constructor=t}t.prototype=e===null?Object.create(e):(n.prototype=e.prototype,new n)}var ss=function(){return ss=Object.assign||function(e){for(var n,r=1,i=arguments.length;r<i;r++){n=arguments[r];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(e[s]=n[s])}return e},ss.apply(this,arguments)};function Eoe(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(t!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,r=Object.getOwnPropertySymbols(t);i<r.length;i++)e.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(t,r[i])&&(n[r[i]]=t[r[i]]);return n}function gg(t,e,n,r){function i(s){return s instanceof n?s:new n(function(a){a(s)})}return new(n||(n=Promise))(function(s,a){function o(c){try{u(r.next(c))}catch(d){a(d)}}function l(c){try{u(r.throw(c))}catch(d){a(d)}}function u(c){c.done?s(c.value):i(c.value).then(o,l)}u((r=r.apply(t,[])).next())})}function yg(t,e){var n={label:0,sent:function(){if(s[0]&1)throw s[1];return s[1]},trys:[],ops:[]},r,i,s,a=Object.create((typeof Iterator=="function"?Iterator:Object).prototype);return a.next=o(0),a.throw=o(1),a.return=o(2),typeof Symbol=="function"&&(a[Symbol.iterator]=function(){return this}),a;function o(u){return function(c){return l([u,c])}}function l(u){if(r)throw new TypeError("Generator is already executing.");for(;a&&(a=0,u[0]&&(n=0)),n;)try{if(r=1,i&&(s=u[0]&2?i.return:u[0]?i.throw||((s=i.return)&&s.call(i),0):i.next)&&!(s=s.call(i,u[1])).done)return s;switch(i=0,s&&(u=[u[0]&2,s.value]),u[0]){case 0:case 1:s=u;break;case 4:return n.label++,{value:u[1],done:!1};case 5:n.label++,i=u[1],u=[0];continue;case 7:u=n.ops.pop(),n.trys.pop();continue;default:if(s=n.trys,!(s=s.length>0&&s[s.length-1])&&(u[0]===6||u[0]===2)){n=0;continue}if(u[0]===3&&(!s||u[1]>s[0]&&u[1]<s[3])){n.label=u[1];break}if(u[0]===6&&n.label<s[1]){n.label=s[1],s=u;break}if(s&&n.label<s[2]){n.label=s[2],n.ops.push(u);break}s[2]&&n.ops.pop(),n.trys.pop();continue}u=e.call(t,n)}catch(c){u=[6,c],i=0}finally{r=s=0}if(u[0]&5)throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}}function Vl(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(t!=null&&typeof Object.getOwnPropertySymbols=="function"){var i=0;for(r=Object.getOwnPropertySymbols(t);i<r.length;i++)e.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(t,r[i])&&(n[r[i]]=t[r[i]])}return n}var tp=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function cP(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function dP(t,e){return t(e={exports:{}},e.exports),e.exports}var Xh=dP(function(t,e){Object.defineProperty(e,"__esModule",{value:!0});var n=function(){function r(){var i=this;this.locked=new Map,this.addToLocked=function(s,a){var o=i.locked.get(s);o===void 0?a===void 0?i.locked.set(s,[]):i.locked.set(s,[a]):a!==void 0&&(o.unshift(a),i.locked.set(s,o))},this.isLocked=function(s){return i.locked.has(s)},this.lock=function(s){return new Promise(function(a,o){i.isLocked(s)?i.addToLocked(s,a):(i.addToLocked(s),a())})},this.unlock=function(s){var a=i.locked.get(s);if(a!==void 0&&a.length!==0){var o=a.pop();i.locked.set(s,a),o!==void 0&&setTimeout(o,0)}else i.locked.delete(s)}}return r.getInstance=function(){return r.instance===void 0&&(r.instance=new r),r.instance},r}();e.default=function(){return n.getInstance()}});cP(Xh);var Ioe=cP(dP(function(t,e){var n=tp&&tp.__awaiter||function(c,d,h,p){return new(h||(h=Promise))(function(f,g){function y(w){try{b(p.next(w))}catch(_){g(_)}}function m(w){try{b(p.throw(w))}catch(_){g(_)}}function b(w){w.done?f(w.value):new h(function(_){_(w.value)}).then(y,m)}b((p=p.apply(c,d||[])).next())})},r=tp&&tp.__generator||function(c,d){var h,p,f,g,y={label:0,sent:function(){if(1&f[0])throw f[1];return f[1]},trys:[],ops:[]};return g={next:m(0),throw:m(1),return:m(2)},typeof Symbol=="function"&&(g[Symbol.iterator]=function(){return this}),g;function m(b){return function(w){return function(_){if(h)throw new TypeError("Generator is already executing.");for(;y;)try{if(h=1,p&&(f=2&_[0]?p.return:_[0]?p.throw||((f=p.return)&&f.call(p),0):p.next)&&!(f=f.call(p,_[1])).done)return f;switch(p=0,f&&(_=[2&_[0],f.value]),_[0]){case 0:case 1:f=_;break;case 4:return y.label++,{value:_[1],done:!1};case 5:y.label++,p=_[1],_=[0];continue;case 7:_=y.ops.pop(),y.trys.pop();continue;default:if(f=y.trys,!((f=f.length>0&&f[f.length-1])||_[0]!==6&&_[0]!==2)){y=0;continue}if(_[0]===3&&(!f||_[1]>f[0]&&_[1]<f[3])){y.label=_[1];break}if(_[0]===6&&y.label<f[1]){y.label=f[1],f=_;break}if(f&&y.label<f[2]){y.label=f[2],y.ops.push(_);break}f[2]&&y.ops.pop(),y.trys.pop();continue}_=d.call(c,y)}catch(S){_=[6,S],p=0}finally{h=f=0}if(5&_[0])throw _[1];return{value:_[0]?_[1]:void 0,done:!0}}([b,w])}}},i=tp;Object.defineProperty(e,"__esModule",{value:!0});var s="browser-tabs-lock-key",a={key:function(c){return n(i,void 0,void 0,function(){return r(this,function(d){throw new Error("Unsupported")})})},getItem:function(c){return n(i,void 0,void 0,function(){return r(this,function(d){throw new Error("Unsupported")})})},clear:function(){return n(i,void 0,void 0,function(){return r(this,function(c){return[2,window.localStorage.clear()]})})},removeItem:function(c){return n(i,void 0,void 0,function(){return r(this,function(d){throw new Error("Unsupported")})})},setItem:function(c,d){return n(i,void 0,void 0,function(){return r(this,function(h){throw new Error("Unsupported")})})},keySync:function(c){return window.localStorage.key(c)},getItemSync:function(c){return window.localStorage.getItem(c)},clearSync:function(){return window.localStorage.clear()},removeItemSync:function(c){return window.localStorage.removeItem(c)},setItemSync:function(c,d){return window.localStorage.setItem(c,d)}};function o(c){return new Promise(function(d){return setTimeout(d,c)})}function l(c){for(var d="0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz",h="",p=0;p<c;p++)h+=d[Math.floor(Math.random()*d.length)];return h}var u=function(){function c(d){this.acquiredIatSet=new Set,this.storageHandler=void 0,this.id=Date.now().toString()+l(15),this.acquireLock=this.acquireLock.bind(this),this.releaseLock=this.releaseLock.bind(this),this.releaseLock__private__=this.releaseLock__private__.bind(this),this.waitForSomethingToChange=this.waitForSomethingToChange.bind(this),this.refreshLockWhileAcquired=this.refreshLockWhileAcquired.bind(this),this.storageHandler=d,c.waiters===void 0&&(c.waiters=[])}return c.prototype.acquireLock=function(d,h){return h===void 0&&(h=5e3),n(this,void 0,void 0,function(){var p,f,g,y,m,b,w;return r(this,function(_){switch(_.label){case 0:p=Date.now()+l(4),f=Date.now()+h,g=s+"-"+d,y=this.storageHandler===void 0?a:this.storageHandler,_.label=1;case 1:return Date.now()<f?[4,o(30)]:[3,8];case 2:return _.sent(),y.getItemSync(g)!==null?[3,5]:(m=this.id+"-"+d+"-"+p,[4,o(Math.floor(25*Math.random()))]);case 3:return _.sent(),y.setItemSync(g,JSON.stringify({id:this.id,iat:p,timeoutKey:m,timeAcquired:Date.now(),timeRefreshed:Date.now()})),[4,o(30)];case 4:return _.sent(),(b=y.getItemSync(g))!==null&&(w=JSON.parse(b)).id===this.id&&w.iat===p?(this.acquiredIatSet.add(p),this.refreshLockWhileAcquired(g,p),[2,!0]):[3,7];case 5:return c.lockCorrector(this.storageHandler===void 0?a:this.storageHandler),[4,this.waitForSomethingToChange(f)];case 6:_.sent(),_.label=7;case 7:return p=Date.now()+l(4),[3,1];case 8:return[2,!1]}})})},c.prototype.refreshLockWhileAcquired=function(d,h){return n(this,void 0,void 0,function(){var p=this;return r(this,function(f){return setTimeout(function(){return n(p,void 0,void 0,function(){var g,y,m;return r(this,function(b){switch(b.label){case 0:return[4,Xh.default().lock(h)];case 1:return b.sent(),this.acquiredIatSet.has(h)?(g=this.storageHandler===void 0?a:this.storageHandler,(y=g.getItemSync(d))===null?(Xh.default().unlock(h),[2]):((m=JSON.parse(y)).timeRefreshed=Date.now(),g.setItemSync(d,JSON.stringify(m)),Xh.default().unlock(h),this.refreshLockWhileAcquired(d,h),[2])):(Xh.default().unlock(h),[2])}})})},1e3),[2]})})},c.prototype.waitForSomethingToChange=function(d){return n(this,void 0,void 0,function(){return r(this,function(h){switch(h.label){case 0:return[4,new Promise(function(p){var f=!1,g=Date.now(),y=!1;function m(){if(y||(window.removeEventListener("storage",m),c.removeFromWaiting(m),clearTimeout(b),y=!0),!f){f=!0;var w=50-(Date.now()-g);w>0?setTimeout(p,w):p(null)}}window.addEventListener("storage",m),c.addToWaiting(m);var b=setTimeout(m,Math.max(0,d-Date.now()))})];case 1:return h.sent(),[2]}})})},c.addToWaiting=function(d){this.removeFromWaiting(d),c.waiters!==void 0&&c.waiters.push(d)},c.removeFromWaiting=function(d){c.waiters!==void 0&&(c.waiters=c.waiters.filter(function(h){return h!==d}))},c.notifyWaiters=function(){c.waiters!==void 0&&c.waiters.slice().forEach(function(d){return d()})},c.prototype.releaseLock=function(d){return n(this,void 0,void 0,function(){return r(this,function(h){switch(h.label){case 0:return[4,this.releaseLock__private__(d)];case 1:return[2,h.sent()]}})})},c.prototype.releaseLock__private__=function(d){return n(this,void 0,void 0,function(){var h,p,f,g;return r(this,function(y){switch(y.label){case 0:return h=this.storageHandler===void 0?a:this.storageHandler,p=s+"-"+d,(f=h.getItemSync(p))===null?[2]:(g=JSON.parse(f)).id!==this.id?[3,2]:[4,Xh.default().lock(g.iat)];case 1:y.sent(),this.acquiredIatSet.delete(g.iat),h.removeItemSync(p),Xh.default().unlock(g.iat),c.notifyWaiters(),y.label=2;case 2:return[2]}})})},c.lockCorrector=function(d){for(var h=Date.now()-5e3,p=d,f=[],g=0;;){var y=p.keySync(g);if(y===null)break;f.push(y),g++}for(var m=!1,b=0;b<f.length;b++){var w=f[b];if(w.includes(s)){var _=p.getItemSync(w);if(_!==null){var S=JSON.parse(_);(S.timeRefreshed===void 0&&S.timeAcquired<h||S.timeRefreshed!==void 0&&S.timeRefreshed<h)&&(p.removeItemSync(w),m=!0)}}}m&&c.notifyWaiters()},c.waiters=void 0,c}();e.default=u}));const Toe={timeoutInSeconds:60},nj={name:"auth0-spa-js",version:"2.1.3"},rj=()=>Date.now();class Ds extends Error{constructor(e,n){super(n),this.error=e,this.error_description=n,Object.setPrototypeOf(this,Ds.prototype)}static fromPayload({error:e,error_description:n}){return new Ds(e,n)}}class hP extends Ds{constructor(e,n,r,i=null){super(e,n),this.state=r,this.appState=i,Object.setPrototypeOf(this,hP.prototype)}}class Qb extends Ds{constructor(){super("timeout","Timeout"),Object.setPrototypeOf(this,Qb.prototype)}}class pP extends Qb{constructor(e){super(),this.popup=e,Object.setPrototypeOf(this,pP.prototype)}}let Coe=class ij extends Ds{constructor(e){super("cancelled","Popup closed"),this.popup=e,Object.setPrototypeOf(this,ij.prototype)}};class fP extends Ds{constructor(e,n,r){super(e,n),this.mfa_token=r,Object.setPrototypeOf(this,fP.prototype)}}class bT extends Ds{constructor(e,n){super("missing_refresh_token",`Missing Refresh Token (audience: '${B4(e,["default"])}', scope: '${B4(n)}')`),this.audience=e,this.scope=n,Object.setPrototypeOf(this,bT.prototype)}}function B4(t,e=[]){return t&&!e.includes(t)?t:""}const VA=()=>window.crypto,ek=()=>{const t="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.";let e="";return Array.from(VA().getRandomValues(new Uint8Array(43))).forEach(n=>e+=t[n%t.length]),e},U4=t=>btoa(t),FR=t=>{var{clientId:e}=t,n=Vl(t,["clientId"]);return new URLSearchParams((r=>Object.keys(r).filter(i=>r[i]!==void 0).reduce((i,s)=>Object.assign(Object.assign({},i),{[s]:r[s]}),{}))(Object.assign({client_id:e},n))).toString()},$4=t=>(e=>decodeURIComponent(atob(e).split("").map(n=>"%"+("00"+n.charCodeAt(0).toString(16)).slice(-2)).join("")))(t.replace(/_/g,"/").replace(/-/g,"+")),Moe=async(t,e)=>{const n=await fetch(t,e);return{ok:n.ok,json:await n.json()}},koe=async(t,e,n)=>{const r=new AbortController;let i;return e.signal=r.signal,Promise.race([Moe(t,e),new Promise((s,a)=>{i=setTimeout(()=>{r.abort(),a(new Error("Timeout when executing 'fetch'"))},n)})]).finally(()=>{clearTimeout(i)})},Noe=async(t,e,n,r,i,s,a)=>{return o={auth:{audience:e,scope:n},timeout:i,fetchUrl:t,fetchOptions:r,useFormData:a},l=s,new Promise(function(u,c){const d=new MessageChannel;d.port1.onmessage=function(h){h.data.error?c(new Error(h.data.error)):u(h.data),d.port1.close()},l.postMessage(o,[d.port2])});var o,l},Roe=async(t,e,n,r,i,s,a=1e4)=>i?Noe(t,e,n,r,a,i,s):koe(t,r,a);async function Foe(t,e){var{baseUrl:n,timeout:r,audience:i,scope:s,auth0Client:a,useFormData:o}=t,l=Vl(t,["baseUrl","timeout","audience","scope","auth0Client","useFormData"]);const u=o?FR(l):JSON.stringify(l);return await async function(c,d,h,p,f,g,y){let m,b=null;for(let T=0;T<3;T++)try{m=await Roe(c,h,p,f,g,y,d),b=null;break}catch(M){b=M}if(b)throw b;const w=m.json,{error:_,error_description:S}=w,E=Vl(w,["error","error_description"]),{ok:C}=m;if(!C){const T=S||`HTTP error. Unable to fetch ${c}`;throw _==="mfa_required"?new fP(_,T,E.mfa_token):_==="missing_refresh_token"?new bT(h,p):new Ds(_||"request_error",T)}return E}(`${n}/oauth/token`,r,i||"default",s,{method:"POST",body:u,headers:{"Content-Type":o?"application/x-www-form-urlencoded":"application/json","Auth0-Client":btoa(JSON.stringify(a||nj))}},e,o)}const mS=(...t)=>{return(e=t.filter(Boolean).join(" ").trim().split(/\s+/),Array.from(new Set(e))).join(" ");var e};class Yl{constructor(e,n="@@auth0spajs@@",r){this.prefix=n,this.suffix=r,this.clientId=e.clientId,this.scope=e.scope,this.audience=e.audience}toKey(){return[this.prefix,this.clientId,this.audience,this.scope,this.suffix].filter(Boolean).join("::")}static fromKey(e){const[n,r,i,s]=e.split("::");return new Yl({clientId:r,scope:s,audience:i},n)}static fromCacheEntry(e){const{scope:n,audience:r,client_id:i}=e;return new Yl({scope:n,audience:r,clientId:i})}}let Doe=class{set(e,n){localStorage.setItem(e,JSON.stringify(n))}get(e){const n=window.localStorage.getItem(e);if(n)try{return JSON.parse(n)}catch{return}}remove(e){localStorage.removeItem(e)}allKeys(){return Object.keys(window.localStorage).filter(e=>e.startsWith("@@auth0spajs@@"))}},sj=class{constructor(){this.enclosedCache=function(){let e={};return{set(n,r){e[n]=r},get(n){const r=e[n];if(r)return r},remove(n){delete e[n]},allKeys:()=>Object.keys(e)}}()}},Poe=class{constructor(e,n,r){this.cache=e,this.keyManifest=n,this.nowProvider=r||rj}async setIdToken(e,n,r){var i;const s=this.getIdTokenCacheKey(e);await this.cache.set(s,{id_token:n,decodedToken:r}),await((i=this.keyManifest)===null||i===void 0?void 0:i.add(s))}async getIdToken(e){const n=await this.cache.get(this.getIdTokenCacheKey(e.clientId));if(!n&&e.scope&&e.audience){const r=await this.get(e);return!r||!r.id_token||!r.decodedToken?void 0:{id_token:r.id_token,decodedToken:r.decodedToken}}if(n)return{id_token:n.id_token,decodedToken:n.decodedToken}}async get(e,n=0){var r;let i=await this.cache.get(e.toKey());if(!i){const o=await this.getCacheKeys();if(!o)return;const l=this.matchExistingCacheKey(e,o);l&&(i=await this.cache.get(l))}if(!i)return;const s=await this.nowProvider(),a=Math.floor(s/1e3);return i.expiresAt-n<a?i.body.refresh_token?(i.body={refresh_token:i.body.refresh_token},await this.cache.set(e.toKey(),i),i.body):(await this.cache.remove(e.toKey()),void await((r=this.keyManifest)===null||r===void 0?void 0:r.remove(e.toKey()))):i.body}async set(e){var n;const r=new Yl({clientId:e.client_id,scope:e.scope,audience:e.audience}),i=await this.wrapCacheEntry(e);await this.cache.set(r.toKey(),i),await((n=this.keyManifest)===null||n===void 0?void 0:n.add(r.toKey()))}async clear(e){var n;const r=await this.getCacheKeys();r&&(await r.filter(i=>!e||i.includes(e)).reduce(async(i,s)=>{await i,await this.cache.remove(s)},Promise.resolve()),await((n=this.keyManifest)===null||n===void 0?void 0:n.clear()))}async wrapCacheEntry(e){const n=await this.nowProvider();return{body:e,expiresAt:Math.floor(n/1e3)+e.expires_in}}async getCacheKeys(){var e;return this.keyManifest?(e=await this.keyManifest.get())===null||e===void 0?void 0:e.keys:this.cache.allKeys?this.cache.allKeys():void 0}getIdTokenCacheKey(e){return new Yl({clientId:e},"@@auth0spajs@@","@@user@@").toKey()}matchExistingCacheKey(e,n){return n.filter(r=>{var i;const s=Yl.fromKey(r),a=new Set(s.scope&&s.scope.split(" ")),o=((i=e.scope)===null||i===void 0?void 0:i.split(" "))||[],l=s.scope&&o.reduce((u,c)=>u&&a.has(c),!0);return s.prefix==="@@auth0spajs@@"&&s.clientId===e.clientId&&s.audience===e.audience&&l})[0]}};class Loe{constructor(e,n,r){this.storage=e,this.clientId=n,this.cookieDomain=r,this.storageKey=`a0.spajs.txs.${this.clientId}`}create(e){this.storage.save(this.storageKey,e,{daysUntilExpire:1,cookieDomain:this.cookieDomain})}get(){return this.storage.get(this.storageKey)}remove(){this.storage.remove(this.storageKey,{cookieDomain:this.cookieDomain})}}const mx=t=>typeof t=="number",Ooe=["iss","aud","exp","nbf","iat","jti","azp","nonce","auth_time","at_hash","c_hash","acr","amr","sub_jwk","cnf","sip_from_tag","sip_date","sip_callid","sip_cseq_num","sip_via_branch","orig","dest","mky","events","toe","txn","rph","sid","vot","vtm"],Boe=t=>{if(!t.id_token)throw new Error("ID token is required but missing");const e=(s=>{const a=s.split("."),[o,l,u]=a;if(a.length!==3||!o||!l||!u)throw new Error("ID token could not be decoded");const c=JSON.parse($4(l)),d={__raw:s},h={};return Object.keys(c).forEach(p=>{d[p]=c[p],Ooe.includes(p)||(h[p]=c[p])}),{encoded:{header:o,payload:l,signature:u},header:JSON.parse($4(o)),claims:d,user:h}})(t.id_token);if(!e.claims.iss)throw new Error("Issuer (iss) claim must be a string present in the ID token");if(e.claims.iss!==t.iss)throw new Error(`Issuer (iss) claim mismatch in the ID token; expected "${t.iss}", found "${e.claims.iss}"`);if(!e.user.sub)throw new Error("Subject (sub) claim must be a string present in the ID token");if(e.header.alg!=="RS256")throw new Error(`Signature algorithm of "${e.header.alg}" is not supported. Expected the ID token to be signed with "RS256".`);if(!e.claims.aud||typeof e.claims.aud!="string"&&!Array.isArray(e.claims.aud))throw new Error("Audience (aud) claim must be a string or array of strings present in the ID token");if(Array.isArray(e.claims.aud)){if(!e.claims.aud.includes(t.aud))throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${t.aud}" but was not one of "${e.claims.aud.join(", ")}"`);if(e.claims.aud.length>1){if(!e.claims.azp)throw new Error("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values");if(e.claims.azp!==t.aud)throw new Error(`Authorized Party (azp) claim mismatch in the ID token; expected "${t.aud}", found "${e.claims.azp}"`)}}else if(e.claims.aud!==t.aud)throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${t.aud}" but found "${e.claims.aud}"`);if(t.nonce){if(!e.claims.nonce)throw new Error("Nonce (nonce) claim must be a string present in the ID token");if(e.claims.nonce!==t.nonce)throw new Error(`Nonce (nonce) claim mismatch in the ID token; expected "${t.nonce}", found "${e.claims.nonce}"`)}if(t.max_age&&!mx(e.claims.auth_time))throw new Error("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified");if(e.claims.exp==null||!mx(e.claims.exp))throw new Error("Expiration Time (exp) claim must be a number present in the ID token");if(!mx(e.claims.iat))throw new Error("Issued At (iat) claim must be a number present in the ID token");const n=t.leeway||60,r=new Date(t.now||Date.now()),i=new Date(0);if(i.setUTCSeconds(e.claims.exp+n),r>i)throw new Error(`Expiration Time (exp) claim error in the ID token; current time (${r}) is after expiration time (${i})`);if(e.claims.nbf!=null&&mx(e.claims.nbf)){const s=new Date(0);if(s.setUTCSeconds(e.claims.nbf-n),r<s)throw new Error(`Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (${r}) is before ${s}`)}if(e.claims.auth_time!=null&&mx(e.claims.auth_time)){const s=new Date(0);if(s.setUTCSeconds(parseInt(e.claims.auth_time)+t.max_age+n),r>s)throw new Error(`Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (${r}) is after last auth at ${s}`)}if(t.organization){const s=t.organization.trim();if(s.startsWith("org_")){const a=s;if(!e.claims.org_id)throw new Error("Organization ID (org_id) claim must be a string present in the ID token");if(a!==e.claims.org_id)throw new Error(`Organization ID (org_id) claim mismatch in the ID token; expected "${a}", found "${e.claims.org_id}"`)}else{const a=s.toLowerCase();if(!e.claims.org_name)throw new Error("Organization Name (org_name) claim must be a string present in the ID token");if(a!==e.claims.org_name)throw new Error(`Organization Name (org_name) claim mismatch in the ID token; expected "${a}", found "${e.claims.org_name}"`)}}return e};var hp=dP(function(t,e){var n=tp&&tp.__assign||function(){return n=Object.assign||function(l){for(var u,c=1,d=arguments.length;c<d;c++)for(var h in u=arguments[c])Object.prototype.hasOwnProperty.call(u,h)&&(l[h]=u[h]);return l},n.apply(this,arguments)};function r(l,u){if(!u)return"";var c="; "+l;return u===!0?c:c+"="+u}function i(l,u,c){return encodeURIComponent(l).replace(/%(23|24|26|2B|5E|60|7C)/g,decodeURIComponent).replace(/\(/g,"%28").replace(/\)/g,"%29")+"="+encodeURIComponent(u).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g,decodeURIComponent)+function(d){if(typeof d.expires=="number"){var h=new Date;h.setMilliseconds(h.getMilliseconds()+864e5*d.expires),d.expires=h}return r("Expires",d.expires?d.expires.toUTCString():"")+r("Domain",d.domain)+r("Path",d.path)+r("Secure",d.secure)+r("SameSite",d.sameSite)}(c)}function s(l){for(var u={},c=l?l.split("; "):[],d=/(%[\dA-F]{2})+/gi,h=0;h<c.length;h++){var p=c[h].split("="),f=p.slice(1).join("=");f.charAt(0)==='"'&&(f=f.slice(1,-1));try{u[p[0].replace(d,decodeURIComponent)]=f.replace(d,decodeURIComponent)}catch{}}return u}function a(){return s(document.cookie)}function o(l,u,c){document.cookie=i(l,u,n({path:"/"},c))}e.__esModule=!0,e.encode=i,e.parse=s,e.getAll=a,e.get=function(l){return a()[l]},e.set=o,e.remove=function(l,u){o(l,"",n(n({},u),{expires:-1}))}});cP(hp),hp.encode,hp.parse,hp.getAll;var Uoe=hp.get,aj=hp.set,oj=hp.remove;const Gg={get(t){const e=Uoe(t);if(e!==void 0)return JSON.parse(e)},save(t,e,n){let r={};window.location.protocol==="https:"&&(r={secure:!0,sameSite:"none"}),n!=null&&n.daysUntilExpire&&(r.expires=n.daysUntilExpire),n!=null&&n.cookieDomain&&(r.domain=n.cookieDomain),aj(t,JSON.stringify(e),r)},remove(t,e){let n={};e!=null&&e.cookieDomain&&(n.domain=e.cookieDomain),oj(t,n)}},$oe={get(t){return Gg.get(t)||Gg.get(`_legacy_${t}`)},save(t,e,n){let r={};window.location.protocol==="https:"&&(r={secure:!0}),n!=null&&n.daysUntilExpire&&(r.expires=n.daysUntilExpire),n!=null&&n.cookieDomain&&(r.domain=n.cookieDomain),aj(`_legacy_${t}`,JSON.stringify(e),r),Gg.save(t,e,n)},remove(t,e){let n={};e!=null&&e.cookieDomain&&(n.domain=e.cookieDomain),oj(t,n),Gg.remove(t,e),Gg.remove(`_legacy_${t}`,e)}},zoe={get(t){if(typeof sessionStorage>"u")return;const e=sessionStorage.getItem(t);return e!=null?JSON.parse(e):void 0},save(t,e){sessionStorage.setItem(t,JSON.stringify(e))},remove(t){sessionStorage.removeItem(t)}};function Goe(t,e,n){var r=e===void 0?null:e,i=function(l,u){var c=atob(l);if(u){for(var d=new Uint8Array(c.length),h=0,p=c.length;h<p;++h)d[h]=c.charCodeAt(h);return String.fromCharCode.apply(null,new Uint16Array(d.buffer))}return c}(t,n!==void 0&&n),s=i.indexOf(`
`,10)+1,a=i.substring(s)+(r?"//# sourceMappingURL="+r:""),o=new Blob([a],{type:"application/javascript"});return URL.createObjectURL(o)}var z4,G4,H4,tk,Hoe=(z4="Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHtlcnJvcjp0LGVycm9yX2Rlc2NyaXB0aW9uOnJ9KXtyZXR1cm4gbmV3IGUodCxyKX19Y2xhc3MgdCBleHRlbmRzIGV7Y29uc3RydWN0b3IoZSxzKXtzdXBlcigibWlzc2luZ19yZWZyZXNoX3Rva2VuIixgTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyR7cihlLFsiZGVmYXVsdCJdKX0nLCBzY29wZTogJyR7cihzKX0nKWApLHRoaXMuYXVkaWVuY2U9ZSx0aGlzLnNjb3BlPXMsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdC5wcm90b3R5cGUpfX1mdW5jdGlvbiByKGUsdD1bXSl7cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9ImZ1bmN0aW9uIj09dHlwZW9mIFN1cHByZXNzZWRFcnJvciYmU3VwcHJlc3NlZEVycm9yO2NvbnN0IHM9ZT0+e3ZhcntjbGllbnRJZDp0fT1lLHI9ZnVuY3Rpb24oZSx0KXt2YXIgcj17fTtmb3IodmFyIHMgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxzKSYmdC5pbmRleE9mKHMpPDAmJihyW3NdPWVbc10pO2lmKG51bGwhPWUmJiJmdW5jdGlvbiI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbz0wO2ZvcihzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7bzxzLmxlbmd0aDtvKyspdC5pbmRleE9mKHNbb10pPDAmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLHNbb10pJiYocltzW29dXT1lW3Nbb11dKX1yZXR1cm4gcn0oZSxbImNsaWVudElkIl0pO3JldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKChlPT5PYmplY3Qua2V5cyhlKS5maWx0ZXIoKHQ9PnZvaWQgMCE9PWVbdF0pKS5yZWR1Y2UoKCh0LHIpPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse1tyXTplW3JdfSkpLHt9KSkoT2JqZWN0LmFzc2lnbih7Y2xpZW50X2lkOnR9LHIpKSkudG9TdHJpbmcoKX07bGV0IG89e307Y29uc3Qgbj0oZSx0KT0+YCR7ZX18JHt0fWA7YWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsKGFzeW5jKHtkYXRhOnt0aW1lb3V0OmUsYXV0aDpyLGZldGNoVXJsOmksZmV0Y2hPcHRpb25zOmMsdXNlRm9ybURhdGE6YX0scG9ydHM6W3BdfSk9PntsZXQgZjtjb25zdHthdWRpZW5jZTp1LHNjb3BlOmx9PXJ8fHt9O3RyeXtjb25zdCByPWE/KGU9Pntjb25zdCB0PW5ldyBVUkxTZWFyY2hQYXJhbXMoZSkscj17fTtyZXR1cm4gdC5mb3JFYWNoKCgoZSx0KT0+e3JbdF09ZX0pKSxyfSkoYy5ib2R5KTpKU09OLnBhcnNlKGMuYm9keSk7aWYoIXIucmVmcmVzaF90b2tlbiYmInJlZnJlc2hfdG9rZW4iPT09ci5ncmFudF90eXBlKXtjb25zdCBlPSgoZSx0KT0+b1tuKGUsdCldKSh1LGwpO2lmKCFlKXRocm93IG5ldyB0KHUsbCk7Yy5ib2R5PWE/cyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKTpKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKX1sZXQgaCxnOyJmdW5jdGlvbiI9PXR5cGVvZiBBYm9ydENvbnRyb2xsZXImJihoPW5ldyBBYm9ydENvbnRyb2xsZXIsYy5zaWduYWw9aC5zaWduYWwpO3RyeXtnPWF3YWl0IFByb21pc2UucmFjZShbKGQ9ZSxuZXcgUHJvbWlzZSgoZT0+c2V0VGltZW91dChlLGQpKSkpLGZldGNoKGksT2JqZWN0LmFzc2lnbih7fSxjKSldKX1jYXRjaChlKXtyZXR1cm4gdm9pZCBwLnBvc3RNZXNzYWdlKHtlcnJvcjplLm1lc3NhZ2V9KX1pZighZylyZXR1cm4gaCYmaC5hYm9ydCgpLHZvaWQgcC5wb3N0TWVzc2FnZSh7ZXJyb3I6IlRpbWVvdXQgd2hlbiBleGVjdXRpbmcgJ2ZldGNoJyJ9KTtmPWF3YWl0IGcuanNvbigpLGYucmVmcmVzaF90b2tlbj8oKChlLHQscik9PntvW24odCxyKV09ZX0pKGYucmVmcmVzaF90b2tlbix1LGwpLGRlbGV0ZSBmLnJlZnJlc2hfdG9rZW4pOigoZSx0KT0+e2RlbGV0ZSBvW24oZSx0KV19KSh1LGwpLHAucG9zdE1lc3NhZ2Uoe29rOmcub2ssanNvbjpmfSl9Y2F0Y2goZSl7cC5wb3N0TWVzc2FnZSh7b2s6ITEsanNvbjp7ZXJyb3I6ZS5lcnJvcixlcnJvcl9kZXNjcmlwdGlvbjplLm1lc3NhZ2V9fSl9dmFyIGR9KSl9KCk7Cgo=",G4=null,H4=!1,function(t){return tk=tk||Goe(z4,G4,H4),new Worker(tk,t)});const nk={};class Woe{constructor(e,n){this.cache=e,this.clientId=n,this.manifestKey=this.createManifestKeyFrom(this.clientId)}async add(e){var n;const r=new Set(((n=await this.cache.get(this.manifestKey))===null||n===void 0?void 0:n.keys)||[]);r.add(e),await this.cache.set(this.manifestKey,{keys:[...r]})}async remove(e){const n=await this.cache.get(this.manifestKey);if(n){const r=new Set(n.keys);return r.delete(e),r.size>0?await this.cache.set(this.manifestKey,{keys:[...r]}):await this.cache.remove(this.manifestKey)}}get(){return this.cache.get(this.manifestKey)}clear(){return this.cache.remove(this.manifestKey)}createManifestKeyFrom(e){return`@@auth0spajs@@::${e}`}}const Voe={memory:()=>new sj().enclosedCache,localstorage:()=>new Doe},W4=t=>Voe[t],V4=t=>{const{openUrl:e,onRedirect:n}=t,r=Vl(t,["openUrl","onRedirect"]);return Object.assign(Object.assign({},r),{openUrl:e===!1||e?e:n})},rk=new Ioe;class joe{constructor(e){let n,r;if(this.userCache=new sj().enclosedCache,this.defaultOptions={authorizationParams:{scope:"openid profile email"},useRefreshTokensFallback:!1,useFormData:!0},this._releaseLockOnPageHide=async()=>{await rk.releaseLock("auth0.lock.getTokenSilently"),window.removeEventListener("pagehide",this._releaseLockOnPageHide)},this.options=Object.assign(Object.assign(Object.assign({},this.defaultOptions),e),{authorizationParams:Object.assign(Object.assign({},this.defaultOptions.authorizationParams),e.authorizationParams)}),typeof window<"u"&&(()=>{if(!VA())throw new Error("For security reasons, `window.crypto` is required to run `auth0-spa-js`.");if(VA().subtle===void 0)throw new Error(`
      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/main/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.
    `)})(),e.cache&&e.cacheLocation&&console.warn("Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`."),e.cache)r=e.cache;else{if(n=e.cacheLocation||"memory",!W4(n))throw new Error(`Invalid cache location "${n}"`);r=W4(n)()}this.httpTimeoutMs=e.httpTimeoutInSeconds?1e3*e.httpTimeoutInSeconds:1e4,this.cookieStorage=e.legacySameSiteCookie===!1?Gg:$oe,this.orgHintCookieName=`auth0.${this.options.clientId}.organization_hint`,this.isAuthenticatedCookieName=(a=>`auth0.${a}.is.authenticated`)(this.options.clientId),this.sessionCheckExpiryDays=e.sessionCheckExpiryDays||1;const i=e.useCookiesForTransactions?this.cookieStorage:zoe;var s;this.scope=mS("openid",this.options.authorizationParams.scope,this.options.useRefreshTokens?"offline_access":""),this.transactionManager=new Loe(i,this.options.clientId,this.options.cookieDomain),this.nowProvider=this.options.nowProvider||rj,this.cacheManager=new Poe(r,r.allKeys?void 0:new Woe(r,this.options.clientId),this.nowProvider),this.domainUrl=(s=this.options.domain,/^https?:\/\//.test(s)?s:`https://${s}`),this.tokenIssuer=((a,o)=>a?a.startsWith("https://")?a:`https://${a}/`:`${o}/`)(this.options.issuer,this.domainUrl),typeof window<"u"&&window.Worker&&this.options.useRefreshTokens&&n==="memory"&&(this.options.workerUrl?this.worker=new Worker(this.options.workerUrl):this.worker=new Hoe)}_url(e){const n=encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client||nj)));return`${this.domainUrl}${e}&auth0Client=${n}`}_authorizeUrl(e){return this._url(`/authorize?${FR(e)}`)}async _verifyIdToken(e,n,r){const i=await this.nowProvider();return Boe({iss:this.tokenIssuer,aud:this.options.clientId,id_token:e,nonce:n,organization:r,leeway:this.options.leeway,max_age:(s=this.options.authorizationParams.max_age,typeof s!="string"?s:parseInt(s,10)||void 0),now:i});var s}_processOrgHint(e){e?this.cookieStorage.save(this.orgHintCookieName,e,{daysUntilExpire:this.sessionCheckExpiryDays,cookieDomain:this.options.cookieDomain}):this.cookieStorage.remove(this.orgHintCookieName,{cookieDomain:this.options.cookieDomain})}async _prepareAuthorizeUrl(e,n,r){const i=U4(ek()),s=U4(ek()),a=ek(),o=(c=>{const d=new Uint8Array(c);return(h=>{const p={"+":"-","/":"_","=":""};return h.replace(/[+/=]/g,f=>p[f])})(window.btoa(String.fromCharCode(...Array.from(d))))})(await(async c=>await VA().subtle.digest({name:"SHA-256"},new TextEncoder().encode(c)))(a)),l=((c,d,h,p,f,g,y,m)=>Object.assign(Object.assign(Object.assign({client_id:c.clientId},c.authorizationParams),h),{scope:mS(d,h.scope),response_type:"code",response_mode:m||"query",state:p,nonce:f,redirect_uri:y||c.authorizationParams.redirect_uri,code_challenge:g,code_challenge_method:"S256"}))(this.options,this.scope,e,i,s,o,e.redirect_uri||this.options.authorizationParams.redirect_uri||r,n==null?void 0:n.response_mode),u=this._authorizeUrl(l);return{nonce:s,code_verifier:a,scope:l.scope,audience:l.audience||"default",redirect_uri:l.redirect_uri,state:i,url:u}}async loginWithPopup(e,n){var r;if(e=e||{},!(n=n||{}).popup&&(n.popup=(o=>{const l=window.screenX+(window.innerWidth-400)/2,u=window.screenY+(window.innerHeight-600)/2;return window.open(o,"auth0:authorize:popup",`left=${l},top=${u},width=400,height=600,resizable,scrollbars=yes,status=1`)})(""),!n.popup))throw new Error("Unable to open a popup for loginWithPopup - window.open returned `null`");const i=await this._prepareAuthorizeUrl(e.authorizationParams||{},{response_mode:"web_message"},window.location.origin);n.popup.location.href=i.url;const s=await(o=>new Promise((l,u)=>{let c;const d=setInterval(()=>{o.popup&&o.popup.closed&&(clearInterval(d),clearTimeout(h),window.removeEventListener("message",c,!1),u(new Coe(o.popup)))},1e3),h=setTimeout(()=>{clearInterval(d),u(new pP(o.popup)),window.removeEventListener("message",c,!1)},1e3*(o.timeoutInSeconds||60));c=function(p){if(p.data&&p.data.type==="authorization_response"){if(clearTimeout(h),clearInterval(d),window.removeEventListener("message",c,!1),o.popup.close(),p.data.response.error)return u(Ds.fromPayload(p.data.response));l(p.data.response)}},window.addEventListener("message",c)}))(Object.assign(Object.assign({},n),{timeoutInSeconds:n.timeoutInSeconds||this.options.authorizeTimeoutInSeconds||60}));if(i.state!==s.state)throw new Ds("state_mismatch","Invalid state");const a=((r=e.authorizationParams)===null||r===void 0?void 0:r.organization)||this.options.authorizationParams.organization;await this._requestToken({audience:i.audience,scope:i.scope,code_verifier:i.code_verifier,grant_type:"authorization_code",code:s.code,redirect_uri:i.redirect_uri},{nonceIn:i.nonce,organization:a})}async getUser(){var e;const n=await this._getIdTokenFromCache();return(e=n==null?void 0:n.decodedToken)===null||e===void 0?void 0:e.user}async getIdTokenClaims(){var e;const n=await this._getIdTokenFromCache();return(e=n==null?void 0:n.decodedToken)===null||e===void 0?void 0:e.claims}async loginWithRedirect(e={}){var n;const r=V4(e),{openUrl:i,fragment:s,appState:a}=r,o=Vl(r,["openUrl","fragment","appState"]),l=((n=o.authorizationParams)===null||n===void 0?void 0:n.organization)||this.options.authorizationParams.organization,u=await this._prepareAuthorizeUrl(o.authorizationParams||{}),{url:c}=u,d=Vl(u,["url"]);this.transactionManager.create(Object.assign(Object.assign(Object.assign({},d),{appState:a}),l&&{organization:l}));const h=s?`${c}#${s}`:c;i?await i(h):window.location.assign(h)}async handleRedirectCallback(e=window.location.href){const n=e.split("?").slice(1);if(n.length===0)throw new Error("There are no query params available for parsing.");const{state:r,code:i,error:s,error_description:a}=(d=>{d.indexOf("#")>-1&&(d=d.substring(0,d.indexOf("#")));const h=new URLSearchParams(d);return{state:h.get("state"),code:h.get("code")||void 0,error:h.get("error")||void 0,error_description:h.get("error_description")||void 0}})(n.join("")),o=this.transactionManager.get();if(!o)throw new Ds("missing_transaction","Invalid state");if(this.transactionManager.remove(),s)throw new hP(s,a||s,r,o.appState);if(!o.code_verifier||o.state&&o.state!==r)throw new Ds("state_mismatch","Invalid state");const l=o.organization,u=o.nonce,c=o.redirect_uri;return await this._requestToken(Object.assign({audience:o.audience,scope:o.scope,code_verifier:o.code_verifier,grant_type:"authorization_code",code:i},c?{redirect_uri:c}:{}),{nonceIn:u,organization:l}),{appState:o.appState}}async checkSession(e){if(!this.cookieStorage.get(this.isAuthenticatedCookieName)){if(!this.cookieStorage.get("auth0.is.authenticated"))return;this.cookieStorage.save(this.isAuthenticatedCookieName,!0,{daysUntilExpire:this.sessionCheckExpiryDays,cookieDomain:this.options.cookieDomain}),this.cookieStorage.remove("auth0.is.authenticated")}try{await this.getTokenSilently(e)}catch{}}async getTokenSilently(e={}){var n;const r=Object.assign(Object.assign({cacheMode:"on"},e),{authorizationParams:Object.assign(Object.assign(Object.assign({},this.options.authorizationParams),e.authorizationParams),{scope:mS(this.scope,(n=e.authorizationParams)===null||n===void 0?void 0:n.scope)})}),i=await((s,a)=>{let o=nk[a];return o||(o=s().finally(()=>{delete nk[a],o=null}),nk[a]=o),o})(()=>this._getTokenSilently(r),`${this.options.clientId}::${r.authorizationParams.audience}::${r.authorizationParams.scope}`);return e.detailedResponse?i:i==null?void 0:i.access_token}async _getTokenSilently(e){const{cacheMode:n}=e,r=Vl(e,["cacheMode"]);if(n!=="off"){const i=await this._getEntryFromCache({scope:r.authorizationParams.scope,audience:r.authorizationParams.audience||"default",clientId:this.options.clientId});if(i)return i}if(n!=="cache-only"){if(!await(async(i,s=3)=>{for(let a=0;a<s;a++)if(await i())return!0;return!1})(()=>rk.acquireLock("auth0.lock.getTokenSilently",5e3),10))throw new Qb;try{if(window.addEventListener("pagehide",this._releaseLockOnPageHide),n!=="off"){const u=await this._getEntryFromCache({scope:r.authorizationParams.scope,audience:r.authorizationParams.audience||"default",clientId:this.options.clientId});if(u)return u}const i=this.options.useRefreshTokens?await this._getTokenUsingRefreshToken(r):await this._getTokenFromIFrame(r),{id_token:s,access_token:a,oauthTokenScope:o,expires_in:l}=i;return Object.assign(Object.assign({id_token:s,access_token:a},o?{scope:o}:null),{expires_in:l})}finally{await rk.releaseLock("auth0.lock.getTokenSilently"),window.removeEventListener("pagehide",this._releaseLockOnPageHide)}}}async getTokenWithPopup(e={},n={}){var r;const i=Object.assign(Object.assign({},e),{authorizationParams:Object.assign(Object.assign(Object.assign({},this.options.authorizationParams),e.authorizationParams),{scope:mS(this.scope,(r=e.authorizationParams)===null||r===void 0?void 0:r.scope)})});return n=Object.assign(Object.assign({},Toe),n),await this.loginWithPopup(i,n),(await this.cacheManager.get(new Yl({scope:i.authorizationParams.scope,audience:i.authorizationParams.audience||"default",clientId:this.options.clientId}))).access_token}async isAuthenticated(){return!!await this.getUser()}_buildLogoutUrl(e){e.clientId!==null?e.clientId=e.clientId||this.options.clientId:delete e.clientId;const n=e.logoutParams||{},{federated:r}=n,i=Vl(n,["federated"]),s=r?"&federated":"";return this._url(`/v2/logout?${FR(Object.assign({clientId:e.clientId},i))}`)+s}async logout(e={}){const n=V4(e),{openUrl:r}=n,i=Vl(n,["openUrl"]);e.clientId===null?await this.cacheManager.clear():await this.cacheManager.clear(e.clientId||this.options.clientId),this.cookieStorage.remove(this.orgHintCookieName,{cookieDomain:this.options.cookieDomain}),this.cookieStorage.remove(this.isAuthenticatedCookieName,{cookieDomain:this.options.cookieDomain}),this.userCache.remove("@@user@@");const s=this._buildLogoutUrl(i);r?await r(s):r!==!1&&window.location.assign(s)}async _getTokenFromIFrame(e){const n=Object.assign(Object.assign({},e.authorizationParams),{prompt:"none"}),r=this.cookieStorage.get(this.orgHintCookieName);r&&!n.organization&&(n.organization=r);const{url:i,state:s,nonce:a,code_verifier:o,redirect_uri:l,scope:u,audience:c}=await this._prepareAuthorizeUrl(n,{response_mode:"web_message"},window.location.origin);try{if(window.crossOriginIsolated)throw new Ds("login_required","The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.");const d=e.timeoutInSeconds||this.options.authorizeTimeoutInSeconds,h=await((f,g,y=60)=>new Promise((m,b)=>{const w=window.document.createElement("iframe");w.setAttribute("width","0"),w.setAttribute("height","0"),w.style.display="none";const _=()=>{window.document.body.contains(w)&&(window.document.body.removeChild(w),window.removeEventListener("message",S,!1))};let S;const E=setTimeout(()=>{b(new Qb),_()},1e3*y);S=function(C){if(C.origin!=g||!C.data||C.data.type!=="authorization_response")return;const T=C.source;T&&T.close(),C.data.response.error?b(Ds.fromPayload(C.data.response)):m(C.data.response),clearTimeout(E),window.removeEventListener("message",S,!1),setTimeout(_,2e3)},window.addEventListener("message",S,!1),window.document.body.appendChild(w),w.setAttribute("src",f)}))(i,this.domainUrl,d);if(s!==h.state)throw new Ds("state_mismatch","Invalid state");const p=await this._requestToken(Object.assign(Object.assign({},e.authorizationParams),{code_verifier:o,code:h.code,grant_type:"authorization_code",redirect_uri:l,timeout:e.authorizationParams.timeout||this.httpTimeoutMs}),{nonceIn:a,organization:n.organization});return Object.assign(Object.assign({},p),{scope:u,oauthTokenScope:p.scope,audience:c})}catch(d){throw d.error==="login_required"&&this.logout({openUrl:!1}),d}}async _getTokenUsingRefreshToken(e){const n=await this.cacheManager.get(new Yl({scope:e.authorizationParams.scope,audience:e.authorizationParams.audience||"default",clientId:this.options.clientId}));if(!(n&&n.refresh_token||this.worker)){if(this.options.useRefreshTokensFallback)return await this._getTokenFromIFrame(e);throw new bT(e.authorizationParams.audience||"default",e.authorizationParams.scope)}const r=e.authorizationParams.redirect_uri||this.options.authorizationParams.redirect_uri||window.location.origin,i=typeof e.timeoutInSeconds=="number"?1e3*e.timeoutInSeconds:null;try{const s=await this._requestToken(Object.assign(Object.assign(Object.assign({},e.authorizationParams),{grant_type:"refresh_token",refresh_token:n&&n.refresh_token,redirect_uri:r}),i&&{timeout:i}));return Object.assign(Object.assign({},s),{scope:e.authorizationParams.scope,oauthTokenScope:s.scope,audience:e.authorizationParams.audience||"default"})}catch(s){if((s.message.indexOf("Missing Refresh Token")>-1||s.message&&s.message.indexOf("invalid refresh token")>-1)&&this.options.useRefreshTokensFallback)return await this._getTokenFromIFrame(e);throw s}}async _saveEntryInCache(e){const{id_token:n,decodedToken:r}=e,i=Vl(e,["id_token","decodedToken"]);this.userCache.set("@@user@@",{id_token:n,decodedToken:r}),await this.cacheManager.setIdToken(this.options.clientId,e.id_token,e.decodedToken),await this.cacheManager.set(i)}async _getIdTokenFromCache(){const e=this.options.authorizationParams.audience||"default",n=await this.cacheManager.getIdToken(new Yl({clientId:this.options.clientId,audience:e,scope:this.scope})),r=this.userCache.get("@@user@@");return n&&n.id_token===(r==null?void 0:r.id_token)?r:(this.userCache.set("@@user@@",n),n)}async _getEntryFromCache({scope:e,audience:n,clientId:r}){const i=await this.cacheManager.get(new Yl({scope:e,audience:n,clientId:r}),60);if(i&&i.access_token){const{access_token:s,oauthTokenScope:a,expires_in:o}=i,l=await this._getIdTokenFromCache();return l&&Object.assign(Object.assign({id_token:l.id_token,access_token:s},a?{scope:a}:null),{expires_in:o})}}async _requestToken(e,n){const{nonceIn:r,organization:i}=n||{},s=await Foe(Object.assign({baseUrl:this.domainUrl,client_id:this.options.clientId,auth0Client:this.options.auth0Client,useFormData:this.options.useFormData,timeout:this.httpTimeoutMs},e),this.worker),a=await this._verifyIdToken(s.id_token,r,i);return await this._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({},s),{decodedToken:a,scope:e.scope,audience:e.audience||"default"}),s.scope?{oauthTokenScope:s.scope}:null),{client_id:this.options.clientId})),this.cookieStorage.save(this.isAuthenticatedCookieName,!0,{daysUntilExpire:this.sessionCheckExpiryDays,cookieDomain:this.options.cookieDomain}),this._processOrgHint(i||a.claims.org_id),Object.assign(Object.assign({},s),{decodedToken:a})}}var lj={isAuthenticated:!1,isLoading:!0},Tu=function(){throw new Error("You forgot to wrap your component in <Auth0Provider>.")},Xoe=ss(ss({},lj),{buildAuthorizeUrl:Tu,buildLogoutUrl:Tu,getAccessTokenSilently:Tu,getAccessTokenWithPopup:Tu,getIdTokenClaims:Tu,loginWithRedirect:Tu,loginWithPopup:Tu,logout:Tu,handleRedirectCallback:Tu}),uj=ne.createContext(Xoe),j4=function(t){Aoe(e,t);function e(n,r){var i=t.call(this,r||n)||this;return i.error=n,i.error_description=r,Object.setPrototypeOf(i,e.prototype),i}return e}(Error),Koe=/[?&]code=[^&]+/,qoe=/[?&]state=[^&]+/,Joe=/[?&]error=[^&]+/,Yoe=function(t){return t===void 0&&(t=window.location.search),(Koe.test(t)||Joe.test(t))&&qoe.test(t)},cj=function(t){return function(e){return e instanceof Error?e:e!==null&&typeof e=="object"&&"error"in e&&typeof e.error=="string"?"error_description"in e&&typeof e.error_description=="string"?new j4(e.error,e.error_description):new j4(e.error):new Error(t)}},X4=cj("Login failed"),ik=cj("Get access token failed"),dj=function(t){var e;t!=null&&t.redirectUri&&(console.warn("Using `redirectUri` has been deprecated, please use `authorizationParams.redirect_uri` instead as `redirectUri` will be no longer supported in a future version"),t.authorizationParams=t.authorizationParams||{},t.authorizationParams.redirect_uri=t.redirectUri,delete t.redirectUri),!((e=t==null?void 0:t.authorizationParams)===null||e===void 0)&&e.redirectUri&&(console.warn("Using `authorizationParams.redirectUri` has been deprecated, please use `authorizationParams.redirect_uri` instead as `authorizationParams.redirectUri` will be removed in a future version"),t.authorizationParams.redirect_uri=t.authorizationParams.redirectUri,delete t.authorizationParams.redirectUri)},Zoe=function(t,e){switch(e.type){case"LOGIN_POPUP_STARTED":return ss(ss({},t),{isLoading:!0});case"LOGIN_POPUP_COMPLETE":case"INITIALISED":return ss(ss({},t),{isAuthenticated:!!e.user,user:e.user,isLoading:!1,error:void 0});case"HANDLE_REDIRECT_COMPLETE":case"GET_ACCESS_TOKEN_COMPLETE":return t.user===e.user?t:ss(ss({},t),{isAuthenticated:!!e.user,user:e.user});case"LOGOUT":return ss(ss({},t),{isAuthenticated:!1,user:void 0});case"ERROR":return ss(ss({},t),{isLoading:!1,error:e.error})}},Qoe=function(t){return dj(t),ss(ss({},t),{auth0Client:{name:"auth0-react",version:"2.3.0"}})},ele=function(t){window.history.replaceState({},document.title,(t==null?void 0:t.returnTo)||window.location.pathname)},tle=function(t){var e=t.children,n=t.skipRedirectCallback,r=t.onRedirectCallback,i=r===void 0?ele:r,s=t.context,a=s===void 0?uj:s,o=Eoe(t,["children","skipRedirectCallback","onRedirectCallback","context"]),l=ne.useState(function(){return new joe(Qoe(o))})[0],u=ne.useReducer(Zoe,lj),c=u[0],d=u[1],h=ne.useRef(!1),p=ne.useCallback(function(E){return d({type:"ERROR",error:E}),E},[]);ne.useEffect(function(){h.current||(h.current=!0,function(){return gg(void 0,void 0,void 0,function(){var E,C,T;return yg(this,function(M){switch(M.label){case 0:return M.trys.push([0,7,,8]),E=void 0,Yoe()&&!n?[4,l.handleRedirectCallback()]:[3,3];case 1:return C=M.sent().appState,[4,l.getUser()];case 2:return E=M.sent(),i(C,E),[3,6];case 3:return[4,l.checkSession()];case 4:return M.sent(),[4,l.getUser()];case 5:E=M.sent(),M.label=6;case 6:return d({type:"INITIALISED",user:E}),[3,8];case 7:return T=M.sent(),p(X4(T)),[3,8];case 8:return[2]}})})}())},[l,i,n,p]);var f=ne.useCallback(function(E){return dj(E),l.loginWithRedirect(E)},[l]),g=ne.useCallback(function(E,C){return gg(void 0,void 0,void 0,function(){var T,M;return yg(this,function(k){switch(k.label){case 0:d({type:"LOGIN_POPUP_STARTED"}),k.label=1;case 1:return k.trys.push([1,3,,4]),[4,l.loginWithPopup(E,C)];case 2:return k.sent(),[3,4];case 3:return T=k.sent(),p(X4(T)),[2];case 4:return[4,l.getUser()];case 5:return M=k.sent(),d({type:"LOGIN_POPUP_COMPLETE",user:M}),[2]}})})},[l]),y=ne.useCallback(function(E){return E===void 0&&(E={}),gg(void 0,void 0,void 0,function(){return yg(this,function(C){switch(C.label){case 0:return[4,l.logout(E)];case 1:return C.sent(),(E.openUrl||E.openUrl===!1)&&d({type:"LOGOUT"}),[2]}})})},[l]),m=ne.useCallback(function(E){return gg(void 0,void 0,void 0,function(){var C,T,M,k;return yg(this,function(R){switch(R.label){case 0:return R.trys.push([0,2,3,5]),[4,l.getTokenSilently(E)];case 1:return C=R.sent(),[3,5];case 2:throw T=R.sent(),ik(T);case 3:return M=d,k={type:"GET_ACCESS_TOKEN_COMPLETE"},[4,l.getUser()];case 4:return M.apply(void 0,[(k.user=R.sent(),k)]),[7];case 5:return[2,C]}})})},[l]),b=ne.useCallback(function(E,C){return gg(void 0,void 0,void 0,function(){var T,M,k,R;return yg(this,function(N){switch(N.label){case 0:return N.trys.push([0,2,3,5]),[4,l.getTokenWithPopup(E,C)];case 1:return T=N.sent(),[3,5];case 2:throw M=N.sent(),ik(M);case 3:return k=d,R={type:"GET_ACCESS_TOKEN_COMPLETE"},[4,l.getUser()];case 4:return k.apply(void 0,[(R.user=N.sent(),R)]),[7];case 5:return[2,T]}})})},[l]),w=ne.useCallback(function(){return l.getIdTokenClaims()},[l]),_=ne.useCallback(function(E){return gg(void 0,void 0,void 0,function(){var C,T,M;return yg(this,function(k){switch(k.label){case 0:return k.trys.push([0,2,3,5]),[4,l.handleRedirectCallback(E)];case 1:return[2,k.sent()];case 2:throw C=k.sent(),ik(C);case 3:return T=d,M={type:"HANDLE_REDIRECT_COMPLETE"},[4,l.getUser()];case 4:return T.apply(void 0,[(M.user=k.sent(),M)]),[7];case 5:return[2]}})})},[l]),S=ne.useMemo(function(){return ss(ss({},c),{getAccessTokenSilently:m,getAccessTokenWithPopup:b,getIdTokenClaims:w,loginWithRedirect:f,loginWithPopup:g,logout:y,handleRedirectCallback:_})},[c,m,b,w,f,g,y,_]);return G5.createElement(a.Provider,{value:S},e)},hj=function(t){return t===void 0&&(t=uj),ne.useContext(t)};/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var nle={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const rle=t=>t.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase().trim(),rr=(t,e)=>{const n=ne.forwardRef(({color:r="currentColor",size:i=24,strokeWidth:s=2,absoluteStrokeWidth:a,className:o="",children:l,...u},c)=>ne.createElement("svg",{ref:c,...nle,width:i,height:i,stroke:r,strokeWidth:a?Number(s)*24/Number(i):s,className:["lucide",`lucide-${rle(t)}`,o].join(" "),...u},[...e.map(([d,h])=>ne.createElement(d,h)),...Array.isArray(l)?l:[l]]));return n.displayName=`${t}`,n};/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ile=rr("AlertCircle",[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["line",{x1:"12",x2:"12",y1:"8",y2:"12",key:"1pkeuh"}],["line",{x1:"12",x2:"12.01",y1:"16",y2:"16",key:"4dfq90"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const sle=rr("Award",[["circle",{cx:"12",cy:"8",r:"6",key:"1vp47v"}],["path",{d:"M15.477 12.89 17 22l-5-3-5 3 1.523-9.11",key:"em7aur"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ale=rr("BedDouble",[["path",{d:"M2 20v-8a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v8",key:"1k78r4"}],["path",{d:"M4 10V6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v4",key:"fb3tl2"}],["path",{d:"M12 4v6",key:"1dcgq2"}],["path",{d:"M2 18h20",key:"ajqnye"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ole=rr("Briefcase",[["rect",{width:"20",height:"14",x:"2",y:"7",rx:"2",ry:"2",key:"eto64e"}],["path",{d:"M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16",key:"zwj3tp"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const lle=rr("Building2",[["path",{d:"M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z",key:"1b4qmf"}],["path",{d:"M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2",key:"i71pzd"}],["path",{d:"M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2",key:"10jefs"}],["path",{d:"M10 6h4",key:"1itunk"}],["path",{d:"M10 10h4",key:"tcdvrf"}],["path",{d:"M10 14h4",key:"kelpxr"}],["path",{d:"M10 18h4",key:"1ulq68"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const pj=rr("Camera",[["path",{d:"M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z",key:"1tc9qg"}],["circle",{cx:"12",cy:"13",r:"3",key:"1vg3eu"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ule=rr("ChevronRight",[["path",{d:"m9 18 6-6-6-6",key:"mthhwq"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const cle=rr("CreditCard",[["rect",{width:"20",height:"14",x:"2",y:"5",rx:"2",key:"ynyp8z"}],["line",{x1:"2",x2:"22",y1:"10",y2:"10",key:"1b3vmo"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const dle=rr("Filter",[["polygon",{points:"22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3",key:"1yg77f"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const FE=rr("Heart",[["path",{d:"M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z",key:"c3ymky"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const hle=rr("Home",[["path",{d:"m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",key:"y5dka4"}],["polyline",{points:"9 22 9 12 15 12 15 22",key:"e2us08"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const K4=rr("Loader2",[["path",{d:"M21 12a9 9 0 1 1-6.219-8.56",key:"13zald"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ple=rr("LogOut",[["path",{d:"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",key:"1uf3rs"}],["polyline",{points:"16 17 21 12 16 7",key:"1gabdz"}],["line",{x1:"21",x2:"9",y1:"12",y2:"12",key:"1uyos4"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const jA=rr("MapPin",[["path",{d:"M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z",key:"2oe9fu"}],["circle",{cx:"12",cy:"10",r:"3",key:"ilqhr7"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const q4=rr("MessageCircle",[["path",{d:"M7.9 20A9 9 0 1 0 4 16.1L2 22Z",key:"vv11sd"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const fle=rr("Minus",[["path",{d:"M5 12h14",key:"1ays0h"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const DR=rr("Package",[["path",{d:"m7.5 4.27 9 5.15",key:"1c824w"}],["path",{d:"M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z",key:"hh9hay"}],["path",{d:"m3.3 7 8.7 5 8.7-5",key:"g66t2b"}],["path",{d:"M12 22V12",key:"d0xqtd"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const mle=rr("Palette",[["circle",{cx:"13.5",cy:"6.5",r:".5",fill:"currentColor",key:"1okk4w"}],["circle",{cx:"17.5",cy:"10.5",r:".5",fill:"currentColor",key:"f64h9f"}],["circle",{cx:"8.5",cy:"7.5",r:".5",fill:"currentColor",key:"fotxhn"}],["circle",{cx:"6.5",cy:"12.5",r:".5",fill:"currentColor",key:"qy21gx"}],["path",{d:"M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z",key:"12rzf8"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const fj=rr("Plus",[["path",{d:"M5 12h14",key:"1ays0h"}],["path",{d:"M12 5v14",key:"s699le"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const gle=rr("Ruler",[["path",{d:"M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.41 2.41 0 0 1 0-3.4l2.6-2.6a2.41 2.41 0 0 1 3.4 0Z",key:"icamh8"}],["path",{d:"m14.5 12.5 2-2",key:"inckbg"}],["path",{d:"m11.5 9.5 2-2",key:"fmmyf7"}],["path",{d:"m8.5 6.5 2-2",key:"vc6u1g"}],["path",{d:"m17.5 15.5 2-2",key:"wo5hmg"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const PR=rr("Scissors",[["circle",{cx:"6",cy:"6",r:"3",key:"1lh9wr"}],["path",{d:"M8.12 8.12 12 12",key:"1alkpv"}],["path",{d:"M20 4 8.12 15.88",key:"xgtan2"}],["circle",{cx:"6",cy:"18",r:"3",key:"fqmcym"}],["path",{d:"M14.8 14.8 20 20",key:"ptml3r"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const yle=rr("Search",[["circle",{cx:"11",cy:"11",r:"8",key:"4ej97u"}],["path",{d:"m21 21-4.3-4.3",key:"1qie3q"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const vle=rr("Send",[["path",{d:"m22 2-7 20-4-9-9-4Z",key:"1q3vgg"}],["path",{d:"M22 2 11 13",key:"nzbqef"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const xle=rr("Settings",[["path",{d:"M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",key:"1qme2f"}],["circle",{cx:"12",cy:"12",r:"3",key:"1v7zrd"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const mP=rr("ShoppingBag",[["path",{d:"M6 2 3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4Z",key:"hou9p0"}],["path",{d:"M3 6h18",key:"d0wm0j"}],["path",{d:"M16 10a4 4 0 0 1-8 0",key:"1ltviw"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const mj=rr("ShoppingCart",[["circle",{cx:"8",cy:"21",r:"1",key:"jimo8o"}],["circle",{cx:"19",cy:"21",r:"1",key:"13723u"}],["path",{d:"M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12",key:"9zh506"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const gj=rr("Sparkles",[["path",{d:"m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z",key:"17u4zn"}],["path",{d:"M5 3v4",key:"bklmnn"}],["path",{d:"M19 17v4",key:"iiml17"}],["path",{d:"M3 5h4",key:"nem4j1"}],["path",{d:"M17 19h4",key:"lbex7p"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ble=rr("SquarePen",[["path",{d:"M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7",key:"1m0v6g"}],["path",{d:"M18.375 2.625a2.121 2.121 0 1 1 3 3L12 15l-4 1 1-4Z",key:"1lpok0"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const sk=rr("Trash2",[["path",{d:"M3 6h18",key:"d0wm0j"}],["path",{d:"M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6",key:"4alrt4"}],["path",{d:"M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2",key:"v07s0e"}],["line",{x1:"10",x2:"10",y1:"11",y2:"17",key:"1uufr5"}],["line",{x1:"14",x2:"14",y1:"11",y2:"17",key:"xtxkd"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const wle=rr("Trash",[["path",{d:"M3 6h18",key:"d0wm0j"}],["path",{d:"M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6",key:"4alrt4"}],["path",{d:"M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2",key:"v07s0e"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const _le=rr("Upload",[["path",{d:"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",key:"ih7n3h"}],["polyline",{points:"17 8 12 3 7 8",key:"t8dd8p"}],["line",{x1:"12",x2:"12",y1:"3",y2:"15",key:"widbto"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const yj=rr("User",[["path",{d:"M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2",key:"975kel"}],["circle",{cx:"12",cy:"7",r:"4",key:"17ys0d"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Sle=rr("Users",[["path",{d:"M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",key:"1yyitq"}],["circle",{cx:"9",cy:"7",r:"4",key:"nufk8"}],["path",{d:"M22 21v-2a4 4 0 0 0-3-3.87",key:"kshegd"}],["path",{d:"M16 3.13a4 4 0 0 1 0 7.75",key:"1da9ce"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Fy=rr("X",[["path",{d:"M18 6 6 18",key:"1bl5f8"}],["path",{d:"m6 6 12 12",key:"d8bk6v"}]]),vj=ne.createContext(void 0);function Ale({children:t}){const[e,n]=ne.useState([]),[r,i]=ne.useState(!1),s=l=>{n(u=>u.find(d=>d.id===l.id)?u.map(d=>d.id===l.id?{...d,quantity:d.quantity+1}:d):[...u,{...l,quantity:1}]),i(!0)},a=l=>{n(u=>u.filter(c=>c.id!==l))},o=(l,u)=>{if(u<1){a(l);return}n(c=>c.map(d=>d.id===l?{...d,quantity:u}:d))};return D.jsx(vj.Provider,{value:{items:e,addItem:s,removeItem:a,updateQuantity:o,isCartOpen:r,setIsCartOpen:i},children:t})}function B1(){const t=ne.useContext(vj);if(t===void 0)throw new Error("useCart must be used within a CartProvider");return t}const xj=ne.createContext(void 0),Ele=({children:t})=>{h0();const{isAuthenticated:e,loginWithRedirect:n,logout:r,user:i,isLoading:s}=hj();ne.useEffect(()=>{},[e,i]);const a={isAuthenticated:e,user:i,loading:s,logout:()=>r({logoutParams:{returnTo:window.location.origin}}),loginWithRedirect:n};return D.jsx(xj.Provider,{value:a,children:t})},bj=()=>{const t=ne.useContext(xj);if(t===void 0)throw new Error("useAuth must be used within an AuthProvider");return t},Ile=({isOpen:t,onClose:e})=>{const{user:n,logout:r}=bj(),{setIsCartOpen:i}=B1(),a=[{icon:mj,label:"Shopping Cart",action:()=>{e(),i(!0)}},{icon:DR,label:"My Orders",link:"/orders"},{icon:mP,label:"My Designs",link:"/profile/my-designs"},{icon:FE,label:"Wishlist",link:"/profile/wishlist"},{icon:cle,label:"Payment Methods",link:"/profile/payments"},{icon:jA,label:"Saved Addresses",link:"/profile/addresses"},{icon:xle,label:"Account Settings",link:"/profile/settings"}];return t?D.jsxs("div",{className:"fixed inset-0 z-50 flex justify-end",children:[D.jsx("div",{className:"fixed inset-0 bg-black bg-opacity-50",onClick:e}),D.jsxs("div",{className:"relative w-full max-w-md bg-white h-full shadow-xl flex flex-col",children:["        ",D.jsxs("div",{className:"p-4 border-b flex justify-between items-center",children:[D.jsxs("div",{className:"flex items-center space-x-2",children:[D.jsx(yj,{className:"h-5 w-5 text-rose-600"}),D.jsx("h2",{className:"text-lg font-semibold",children:"My Profile"})]}),D.jsx("button",{onClick:e,className:"text-gray-500 hover:text-gray-700",children:D.jsx(Fy,{className:"h-5 w-5"})})]}),D.jsxs("div",{className:"flex-1 flex flex-col overflow-hidden",children:[D.jsx("div",{className:"p-4 border-b bg-gray-50",children:D.jsxs("div",{className:"flex items-center",children:[(n==null?void 0:n.picture)&&D.jsx("img",{src:n.picture,alt:n.name||"Profile",className:"w-12 h-12 rounded-full border-2 border-rose-200"}),D.jsxs("div",{className:"ml-4",children:[D.jsx("h3",{className:"font-medium text-gray-900",children:n==null?void 0:n.name}),D.jsx("p",{className:"text-sm text-gray-600",children:n==null?void 0:n.email})]})]})}),"          ",D.jsx("nav",{className:"flex-1 overflow-y-auto",children:D.jsx("ul",{className:"divide-y divide-gray-200",children:a.map((o,l)=>D.jsx("li",{children:o.action?D.jsxs("button",{onClick:o.action,className:"flex items-center space-x-3 w-full px-4 py-3 text-gray-700 hover:bg-gray-50",children:[D.jsx(o.icon,{className:"h-5 w-5"}),D.jsx("span",{children:o.label})]}):D.jsxs(Kx,{to:o.link,className:"flex items-center space-x-3 px-4 py-3 text-gray-700 hover:bg-gray-50",onClick:e,children:[D.jsx(o.icon,{className:"h-5 w-5"}),D.jsx("span",{children:o.label})]})},l))})}),D.jsx("div",{className:"border-t p-4",children:D.jsxs("button",{onClick:()=>r(),className:"flex items-center justify-center space-x-2 w-full px-4 py-2 text-white bg-rose-600 hover:bg-rose-700 rounded-md transition-colors",children:[D.jsx(ple,{className:"h-5 w-5"}),D.jsx("span",{children:"Logout"})]})})]})]})]}):null};function Tle(){const{setIsCartOpen:t,items:e}=B1(),{isAuthenticated:n,user:r,loginWithRedirect:i,logout:s}=bj(),[a,o]=ne.useState(!1);return D.jsx("nav",{className:"bg-white border-b border-gray-100 px-4 py-3",children:D.jsxs("div",{className:"max-w-7xl mx-auto flex items-center justify-between",children:[D.jsxs("div",{className:"flex items-center space-x-8",children:[D.jsxs(Kx,{to:"/",className:"flex items-center space-x-2",children:[D.jsx(PR,{className:"h-6 w-6 text-rose-600"}),D.jsx("span",{className:"text-xl font-semibold",children:"FabricCraft"})]}),D.jsxs("div",{className:"hidden md:flex space-x-6",children:[D.jsx(Kx,{to:"/",className:"text-gray-600 hover:text-gray-900",children:"Home"}),D.jsx(Kx,{to:"/about",className:"text-gray-600 hover:text-gray-900",children:"About"}),D.jsx(Kx,{to:"/design",className:"text-gray-600 hover:text-gray-900",children:"Create Own Design"})]})]}),D.jsxs("div",{className:"flex items-center space-x-6",children:[D.jsx("button",{className:"text-gray-600 hover:text-gray-900",children:D.jsx(FE,{className:"h-5 w-5"})}),D.jsxs("button",{onClick:()=>t(!0),className:"text-gray-600 hover:text-gray-900 relative",children:[D.jsx(mj,{className:"h-5 w-5"}),e.length>0&&D.jsx("span",{className:"absolute -top-2 -right-2 bg-rose-600 text-white text-xs w-5 h-5 rounded-full flex items-center justify-center",children:e.length})]}),n?D.jsxs("button",{onClick:()=>o(!0),className:"flex items-center space-x-2 hover:opacity-75 transition-opacity",children:[D.jsx("img",{src:r==null?void 0:r.picture,className:"h-8 w-8 rounded-full border-2 border-rose-200"}),D.jsx("span",{className:"text-sm text-gray-700 hidden md:inline",children:r==null?void 0:r.name})]}):D.jsxs("button",{onClick:()=>i(),className:"text-sm text-gray-600 hover:text-gray-900 flex items-center space-x-1",children:[D.jsx(yj,{className:"h-5 w-5"}),D.jsx("span",{children:"Sign In"})]}),D.jsx(Ile,{isOpen:a,onClose:()=>o(!1)})]})]})})}function Cle(){const[t,e]=ne.useState(!1),[n,r]=ne.useState([{text:"Hi! I'm here to help with your fabric design questions. How can I assist you today?",isBot:!0}]),[i,s]=ne.useState(""),a=o=>{o.preventDefault(),i.trim()&&(r([...n,{text:i,isBot:!1}]),s(""),setTimeout(()=>{r(l=>[...l,{text:"Thanks for your message! A design specialist will respond shortly. In the meantime, feel free to browse our featured collections.",isBot:!0}])},1e3))};return D.jsx("div",{className:"fixed bottom-6 right-6 z-50",children:t?D.jsxs("div",{className:"bg-white rounded-lg shadow-xl w-[360px] h-[480px] flex flex-col",children:[D.jsxs("div",{className:"p-4 bg-rose-600 text-white rounded-t-lg flex justify-between items-center",children:[D.jsxs("div",{className:"flex items-center space-x-2",children:[D.jsx(q4,{className:"h-5 w-5"}),D.jsx("span",{className:"font-semibold",children:"Design Assistant"})]}),D.jsx("button",{onClick:()=>e(!1),className:"text-white hover:text-rose-200 transition",children:D.jsx(Fy,{className:"h-5 w-5"})})]}),D.jsx("div",{className:"flex-1 overflow-y-auto p-4 space-y-4",children:n.map((o,l)=>D.jsx("div",{className:`flex ${o.isBot?"justify-start":"justify-end"}`,children:D.jsx("div",{className:`max-w-[80%] p-3 rounded-lg ${o.isBot?"bg-gray-100 text-gray-800":"bg-rose-600 text-white"}`,children:o.text})},l))}),D.jsx("form",{onSubmit:a,className:"p-4 border-t",children:D.jsxs("div",{className:"flex space-x-2",children:[D.jsx("input",{type:"text",value:i,onChange:o=>s(o.target.value),placeholder:"Type your message...",className:"flex-1 border rounded-full px-4 py-2 focus:outline-none focus:border-rose-600"}),D.jsx("button",{type:"submit",className:"bg-rose-600 text-white p-2 rounded-full hover:bg-rose-700 transition",children:D.jsx(vle,{className:"h-5 w-5"})})]})})]}):D.jsx("button",{onClick:()=>e(!0),className:"bg-rose-600 text-white p-4 rounded-full shadow-lg hover:bg-rose-700 transition",children:D.jsx(q4,{className:"h-6 w-6"})})})}function Mle(){const{items:t,removeItem:e,updateQuantity:n,isCartOpen:r,setIsCartOpen:i}=B1(),s=t.reduce((a,o)=>a+o.price*o.quantity,0);return r?D.jsxs("div",{className:"fixed inset-0 z-50 flex justify-end",children:[D.jsx("div",{className:"fixed inset-0 bg-black bg-opacity-50",onClick:()=>i(!1)}),D.jsxs("div",{className:"relative w-full max-w-md bg-white h-full shadow-xl flex flex-col",children:[D.jsxs("div",{className:"p-4 border-b flex justify-between items-center",children:[D.jsxs("div",{className:"flex items-center space-x-2",children:[D.jsx(mP,{className:"h-5 w-5"}),D.jsx("h2",{className:"text-lg font-semibold",children:"Shopping Cart"})]}),D.jsx("button",{onClick:()=>i(!1),className:"text-gray-500 hover:text-gray-700",children:D.jsx(Fy,{className:"h-5 w-5"})})]}),t.length===0?D.jsx("div",{className:"flex-1 flex items-center justify-center",children:D.jsx("p",{className:"text-gray-500",children:"Your cart is empty"})}):D.jsxs(D.Fragment,{children:[D.jsx("div",{className:"flex-1 overflow-y-auto p-4 space-y-4",children:t.map(a=>D.jsxs("div",{className:"flex items-center space-x-4 border-b pb-4",children:[D.jsx("img",{src:a.image,alt:a.name,className:"w-20 h-20 object-cover rounded"}),D.jsxs("div",{className:"flex-1",children:[D.jsx("h3",{className:"font-medium",children:a.name}),D.jsxs("p",{className:"text-gray-600",children:["$",a.price.toFixed(2)]}),D.jsxs("div",{className:"flex items-center space-x-2 mt-2",children:[D.jsx("button",{onClick:()=>n(a.id,a.quantity-1),className:"p-1 rounded-full hover:bg-gray-100",children:D.jsx(fle,{className:"h-4 w-4"})}),D.jsx("span",{children:a.quantity}),D.jsx("button",{onClick:()=>n(a.id,a.quantity+1),className:"p-1 rounded-full hover:bg-gray-100",children:D.jsx(fj,{className:"h-4 w-4"})})]})]}),D.jsx("button",{onClick:()=>e(a.id),className:"text-gray-400 hover:text-gray-600",children:D.jsx(Fy,{className:"h-5 w-5"})})]},a.id))}),D.jsxs("div",{className:"border-t p-4 space-y-4",children:[D.jsxs("div",{className:"flex justify-between text-lg font-semibold",children:[D.jsx("span",{children:"Total"}),D.jsxs("span",{children:["$",s.toFixed(2)]})]}),D.jsx("button",{className:"w-full bg-rose-600 text-white py-3 rounded-full hover:bg-rose-700 transition",children:"Checkout"})]})]})]})]}):null}function kle(){return D.jsxs("div",{className:"min-h-screen bg-white",children:[D.jsxs("div",{className:"relative h-[400px] bg-cover bg-center",style:{backgroundImage:'url("https://images.unsplash.com/photo-1459156212016-c812468e2115?auto=format&fit=crop&q=80")'},children:[D.jsx("div",{className:"absolute inset-0 bg-black bg-opacity-50"}),D.jsx("div",{className:"absolute inset-0 flex items-center justify-center",children:D.jsxs("div",{className:"text-center text-white max-w-3xl px-4",children:[D.jsx("h1",{className:"text-5xl font-bold mb-4",children:"Crafting Dreams into Fabric"}),D.jsx("p",{className:"text-xl",children:"Since 1970, we've been transforming creative visions into beautiful, custom-made fabrics."})]})})]}),D.jsx("div",{className:"max-w-7xl mx-auto py-16 px-4",children:D.jsxs("div",{className:"text-center max-w-3xl mx-auto",children:[D.jsx("h2",{className:"text-3xl font-bold mb-6",children:"Our Mission"}),D.jsx("p",{className:"text-lg text-gray-600 leading-relaxed",children:"At FabricCraft, we believe that every piece of fabric tells a story. Our mission is to empower creators, designers, and dreamers to bring their unique visions to life through high-quality, custom-printed fabrics."})]})}),D.jsx("div",{className:"bg-gray-50 py-16",children:D.jsx("div",{className:"max-w-7xl mx-auto px-4",children:D.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8",children:[D.jsx(gS,{icon:D.jsx(mle,{className:"h-8 w-8"}),title:"Premium Quality",description:"We use the finest materials and advanced printing technology to ensure vibrant, long-lasting results."}),D.jsx(gS,{icon:D.jsx(Sle,{className:"h-8 w-8"}),title:"Expert Support",description:"Our team of design specialists is here to help you every step of the way."}),D.jsx(gS,{icon:D.jsx(sle,{className:"h-8 w-8"}),title:"Satisfaction Guaranteed",description:"We stand behind our products with a 100% satisfaction guarantee."}),D.jsx(gS,{icon:D.jsx(gj,{className:"h-8 w-8"}),title:"Endless Possibilities",description:"From custom bedding to designer prints, bring any design to life."})]})})}),D.jsx("div",{className:"max-w-7xl mx-auto py-16 px-4",children:D.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-2 gap-12 items-center",children:[D.jsx("div",{children:D.jsx("img",{src:"https://images.unsplash.com/photo-1544367567-0f2fcb009e0b?auto=format&fit=crop&q=80",alt:"Fabric Workshop",className:"rounded-lg shadow-lg"})}),D.jsxs("div",{children:[D.jsx("h2",{className:"text-3xl font-bold mb-6",children:"Our Story"}),D.jsxs("div",{className:"space-y-4 text-gray-600",children:[D.jsx("p",{children:"Founded in 1970, FabricCraft began as a small family-owned textile shop with a big dream: to revolutionize custom fabric printing."}),D.jsx("p",{children:"Today, we've grown into a leading digital fabric printing service, combining traditional craftsmanship with cutting-edge technology to deliver exceptional quality and creativity to designers worldwide."}),D.jsx("p",{children:"Our commitment to innovation, sustainability, and customer satisfaction has made us the trusted choice for both individual creators and industry professionals."})]})]})]})})]})}const gS=({icon:t,title:e,description:n})=>D.jsxs("div",{className:"bg-white p-6 rounded-xl shadow-sm hover:shadow-md transition",children:[D.jsx("div",{className:"text-rose-600 mb-4",children:t}),D.jsx("h3",{className:"text-xl font-semibold mb-2",children:e}),D.jsx("p",{className:"text-gray-600",children:n})]}),ak=({title:t,image:e,icon:n})=>D.jsxs("div",{className:"group relative rounded-xl overflow-hidden shadow-lg hover:shadow-xl transition",children:[D.jsx("div",{className:"absolute inset-0 bg-gradient-to-t from-black/60 to-black/0 z-10"}),D.jsx("img",{src:e,alt:t,className:"w-full h-[300px] object-cover group-hover:scale-105 transition duration-300"}),D.jsx("div",{className:"absolute bottom-0 left-0 right-0 p-6 z-20",children:D.jsxs("div",{className:"flex items-center space-x-2 text-white",children:[D.jsx("div",{className:"bg-rose-600 p-2 rounded-full",children:n}),D.jsx("h3",{className:"text-xl font-semibold",children:t})]})})]}),Nle=()=>{const{addItem:t}=B1(),e=h0();return D.jsxs(D.Fragment,{children:[D.jsxs("div",{className:"relative h-[500px] bg-cover bg-center",style:{backgroundImage:'url("https://images.unsplash.com/photo-1528578950694-9f79b45a3397?auto=format&fit=crop&q=80")'},children:[D.jsx("div",{className:"absolute inset-0 bg-black bg-opacity-40"}),D.jsx("div",{className:"absolute inset-0 flex items-center justify-center",children:D.jsxs("div",{className:"text-center text-white",children:[D.jsx("h1",{className:"text-5xl font-bold mb-4",children:"Design Your Dream Fabric"}),D.jsx("p",{className:"text-xl mb-8",children:"Turn your creativity into beautiful custom fabrics"}),D.jsx("button",{onClick:()=>e("/design"),className:"bg-rose-600 text-white px-8 py-3 rounded-full hover:bg-rose-700 transition",children:"Start Designing"})]})})]}),D.jsx("div",{className:"bg-gray-50 py-16",children:D.jsx("div",{className:"max-w-7xl mx-auto px-4",children:D.jsxs("div",{className:"grid grid-cols-1 lg:grid-cols-2 gap-12 items-center",children:[D.jsxs("div",{className:"space-y-6",children:[D.jsx("div",{className:"inline-block bg-rose-100 text-rose-600 px-4 py-1 rounded-full text-sm font-semibold",children:"NEW"}),D.jsx("h2",{className:"text-4xl font-bold",children:"Extra-Wide Cotton Sateen Fabrics"}),D.jsx("p",{className:"text-lg text-gray-600 leading-relaxed",children:'With 116" (over 9 feet!) of printed width, these two 100% cotton fabrics are perfect for large scale projects like bedding, table linens and quilt backings. Now available by the yard featuring your choice of any Spoonflower print.'}),D.jsxs("div",{className:"flex items-center space-x-4",children:[D.jsxs("div",{className:"flex items-center space-x-2 text-gray-600",children:[D.jsx(gle,{className:"h-5 w-5"}),D.jsx("span",{children:'116" Width'})]}),D.jsxs("div",{className:"flex items-center space-x-2 text-gray-600",children:[D.jsx(PR,{className:"h-5 w-5"}),D.jsx("span",{children:"100% Cotton"})]})]}),D.jsx("button",{onClick:()=>t({id:"cotton-sateen",name:"Extra-Wide Cotton Sateen Fabric",price:24.99,image:"https://images.unsplash.com/photo-1544367567-0f2fcb009e0b?auto=format&fit=crop&q=80"}),className:"bg-rose-600 text-white px-6 py-3 rounded-full hover:bg-rose-700 transition",children:"Shop Now"})]}),D.jsx("div",{className:"relative",children:D.jsx("img",{src:"https://images.unsplash.com/photo-1544367567-0f2fcb009e0b?auto=format&fit=crop&q=80",alt:"Extra-Wide Cotton Sateen Fabric",className:"rounded-lg shadow-xl"})})]})})}),D.jsxs("div",{className:"max-w-7xl mx-auto py-16 px-4",children:[D.jsx("h2",{className:"text-3xl font-bold mb-12 text-center",children:"Featured Collections"}),D.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-3 gap-8",children:[D.jsx(ak,{title:"Custom Bedding",image:"https://images.unsplash.com/photo-1522771739844-6a9f6d5f14af?auto=format&fit=crop&q=80",icon:D.jsx(ale,{className:"h-6 w-6"})}),D.jsx(ak,{title:"Designer Prints",image:"https://images.unsplash.com/photo-1528458909336-e7a0adfed0a5?auto=format&fit=crop&q=80",icon:D.jsx(gj,{className:"h-6 w-6"})}),D.jsx(ak,{title:"Seasonal Fabrics",image:"https://images.unsplash.com/photo-1544365558-35aa4afcf11f?auto=format&fit=crop&q=80",icon:D.jsx(PR,{className:"h-6 w-6"})})]})]}),D.jsx("div",{className:"bg-gray py-12",children:D.jsx("div",{className:"max-w-7xl mx-auto px-4"})})]})};/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const vf="177",Kh={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},qh={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},wj=0,LR=1,_j=2,Rle=3,Sj=0,wT=1,vb=2,ul=3,lu=0,sa=1,ta=2,nu=0,Sp=1,OR=2,BR=3,UR=4,Aj=5,nd=100,Ej=101,Ij=102,Tj=103,Cj=104,Mj=200,kj=201,Nj=202,Rj=203,DE=204,PE=205,Fj=206,Dj=207,Pj=208,Lj=209,Oj=210,Bj=211,Uj=212,$j=213,zj=214,LE=0,OE=1,BE=2,Bp=3,UE=4,$E=5,zE=6,GE=7,U1=0,Gj=1,Hj=2,ru=0,Wj=1,Vj=2,jj=3,gP=4,Xj=5,Kj=6,qj=7,$R="attached",Jj="detached",Cd=300,uu=301,Md=302,Dy=303,e1=304,p0=306,ac=1e3,jr=1001,Up=1002,yi=1003,$1=1004,Fle=1004,od=1005,Dle=1005,er=1006,Ap=1007,Ple=1007,Ma=1008,HE=1008,la=1009,_T=1010,ST=1011,Py=1012,z1=1013,cu=1014,ti=1015,Wi=1016,AT=1017,ET=1018,Ly=1020,yP=35902,vP=1021,xP=1022,ui=1023,Oy=1026,By=1027,G1=1028,H1=1029,bP=1030,IT=1031,Lle=1032,TT=1033,xb=33776,bb=33777,wb=33778,_b=33779,WE=35840,VE=35841,jE=35842,XE=35843,KE=36196,qE=37492,JE=37496,YE=37808,ZE=37809,QE=37810,eI=37811,tI=37812,nI=37813,rI=37814,iI=37815,sI=37816,aI=37817,oI=37818,lI=37819,uI=37820,cI=37821,Sb=36492,dI=36494,hI=36495,wP=36283,pI=36284,fI=36285,mI=36286,Yj=2200,Zj=2201,Qj=2202,$p=2300,zp=2301,XA=2302,pp=2400,fp=2401,t1=2402,CT=2500,_P=2501,e9=0,SP=1,gI=2,t9=3200,n9=3201,Ole=3202,Ble=3203,Jd=0,r9=1,Jl="",Ui="srgb",du="srgb-linear",n1="linear",yr="srgb",Ule=0,Jh=7680,$le=7681,zle=7682,Gle=7683,Hle=34055,Wle=34056,Vle=5386,jle=512,Xle=513,Kle=514,qle=515,Jle=516,Yle=517,Zle=518,zR=519,i9=512,s9=513,a9=514,AP=515,o9=516,l9=517,u9=518,c9=519,r1=35044,Qle=35048,eue=35040,tue=35045,nue=35049,rue=35041,iue=35046,sue=35050,aue=35042,oue="100",GR="300 es",Oo=2e3,i1=2001,lue={COMPUTE:"compute",RENDER:"render"},uue={PERSPECTIVE:"perspective",LINEAR:"linear",FLAT:"flat"},cue={NORMAL:"normal",CENTROID:"centroid",SAMPLE:"sample",FLAT_FIRST:"flat first",FLAT_EITHER:"flat either"};let gu=class{addEventListener(e,n){this._listeners===void 0&&(this._listeners={});const r=this._listeners;r[e]===void 0&&(r[e]=[]),r[e].indexOf(n)===-1&&r[e].push(n)}hasEventListener(e,n){const r=this._listeners;return r===void 0?!1:r[e]!==void 0&&r[e].indexOf(n)!==-1}removeEventListener(e,n){const r=this._listeners;if(r===void 0)return;const i=r[e];if(i!==void 0){const s=i.indexOf(n);s!==-1&&i.splice(s,1)}}dispatchEvent(e){const n=this._listeners;if(n===void 0)return;const r=n[e.type];if(r!==void 0){e.target=this;const i=r.slice(0);for(let s=0,a=i.length;s<a;s++)i[s].call(this,e);e.target=null}}};const Ns=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let J4=1234567;const Ep=Math.PI/180,Uy=180/Math.PI;function ao(){const t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0,r=Math.random()*4294967295|0;return(Ns[t&255]+Ns[t>>8&255]+Ns[t>>16&255]+Ns[t>>24&255]+"-"+Ns[e&255]+Ns[e>>8&255]+"-"+Ns[e>>16&15|64]+Ns[e>>24&255]+"-"+Ns[n&63|128]+Ns[n>>8&255]+"-"+Ns[n>>16&255]+Ns[n>>24&255]+Ns[r&255]+Ns[r>>8&255]+Ns[r>>16&255]+Ns[r>>24&255]).toLowerCase()}function En(t,e,n){return Math.max(e,Math.min(n,t))}function EP(t,e){return(t%e+e)%e}function due(t,e,n,r,i){return r+(t-e)*(i-r)/(n-e)}function hue(t,e,n){return t!==e?(n-t)/(e-t):0}function Ab(t,e,n){return(1-n)*t+n*e}function pue(t,e,n,r){return Ab(t,e,1-Math.exp(-n*r))}function fue(t,e=1){return e-Math.abs(EP(t,e*2)-e)}function mue(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e),t*t*(3-2*t))}function gue(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e),t*t*t*(t*(t*6-15)+10))}function yue(t,e){return t+Math.floor(Math.random()*(e-t+1))}function vue(t,e){return t+Math.random()*(e-t)}function xue(t){return t*(.5-Math.random())}function bue(t){t!==void 0&&(J4=t);let e=J4+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function wue(t){return t*Ep}function _ue(t){return t*Uy}function Sue(t){return(t&t-1)===0&&t!==0}function Aue(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))}function Eue(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}function Iue(t,e,n,r,i){const s=Math.cos,a=Math.sin,o=s(n/2),l=a(n/2),u=s((e+r)/2),c=a((e+r)/2),d=s((e-r)/2),h=a((e-r)/2),p=s((r-e)/2),f=a((r-e)/2);switch(i){case"XYX":t.set(o*c,l*d,l*h,o*u);break;case"YZY":t.set(l*h,o*c,l*d,o*u);break;case"ZXZ":t.set(l*d,l*h,o*c,o*u);break;case"XZX":t.set(o*c,l*f,l*p,o*u);break;case"YXY":t.set(l*p,o*c,l*f,o*u);break;case"ZYZ":t.set(l*f,l*p,o*c,o*u);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function na(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return t/4294967295;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int32Array:return Math.max(t/2147483647,-1);case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}function Fn(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return Math.round(t*4294967295);case Uint16Array:return Math.round(t*65535);case Uint8Array:return Math.round(t*255);case Int32Array:return Math.round(t*2147483647);case Int16Array:return Math.round(t*32767);case Int8Array:return Math.round(t*127);default:throw new Error("Invalid component type.")}}const Ju={DEG2RAD:Ep,RAD2DEG:Uy,generateUUID:ao,clamp:En,euclideanModulo:EP,mapLinear:due,inverseLerp:hue,lerp:Ab,damp:pue,pingpong:fue,smoothstep:mue,smootherstep:gue,randInt:yue,randFloat:vue,randFloatSpread:xue,seededRandom:bue,degToRad:wue,radToDeg:_ue,isPowerOfTwo:Sue,ceilPowerOfTwo:Aue,floorPowerOfTwo:Eue,setQuaternionFromProperEuler:Iue,normalize:Fn,denormalize:na};class Qe{constructor(e=0,n=0){Qe.prototype.isVector2=!0,this.x=e,this.y=n}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,n){return this.x=e,this.y=n,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,n){switch(e){case 0:this.x=n;break;case 1:this.y=n;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,n){return this.x=e.x+n.x,this.y=e.y+n.y,this}addScaledVector(e,n){return this.x+=e.x*n,this.y+=e.y*n,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,n){return this.x=e.x-n.x,this.y=e.y-n.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const n=this.x,r=this.y,i=e.elements;return this.x=i[0]*n+i[3]*r+i[6],this.y=i[1]*n+i[4]*r+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,n){return this.x=En(this.x,e.x,n.x),this.y=En(this.y,e.y,n.y),this}clampScalar(e,n){return this.x=En(this.x,e,n),this.y=En(this.y,e,n),this}clampLength(e,n){const r=this.length();return this.divideScalar(r||1).multiplyScalar(En(r,e,n))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const n=Math.sqrt(this.lengthSq()*e.lengthSq());if(n===0)return Math.PI/2;const r=this.dot(e)/n;return Math.acos(En(r,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const n=this.x-e.x,r=this.y-e.y;return n*n+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,n){return this.x+=(e.x-this.x)*n,this.y+=(e.y-this.y)*n,this}lerpVectors(e,n,r){return this.x=e.x+(n.x-e.x)*r,this.y=e.y+(n.y-e.y)*r,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,n=0){return this.x=e[n],this.y=e[n+1],this}toArray(e=[],n=0){return e[n]=this.x,e[n+1]=this.y,e}fromBufferAttribute(e,n){return this.x=e.getX(n),this.y=e.getY(n),this}rotateAround(e,n){const r=Math.cos(n),i=Math.sin(n),s=this.x-e.x,a=this.y-e.y;return this.x=s*r-a*i+e.x,this.y=s*i+a*r+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Kr{constructor(e=0,n=0,r=0,i=1){this.isQuaternion=!0,this._x=e,this._y=n,this._z=r,this._w=i}static slerpFlat(e,n,r,i,s,a,o){let l=r[i+0],u=r[i+1],c=r[i+2],d=r[i+3];const h=s[a+0],p=s[a+1],f=s[a+2],g=s[a+3];if(o===0){e[n+0]=l,e[n+1]=u,e[n+2]=c,e[n+3]=d;return}if(o===1){e[n+0]=h,e[n+1]=p,e[n+2]=f,e[n+3]=g;return}if(d!==g||l!==h||u!==p||c!==f){let y=1-o;const m=l*h+u*p+c*f+d*g,b=m>=0?1:-1,w=1-m*m;if(w>Number.EPSILON){const S=Math.sqrt(w),E=Math.atan2(S,m*b);y=Math.sin(y*E)/S,o=Math.sin(o*E)/S}const _=o*b;if(l=l*y+h*_,u=u*y+p*_,c=c*y+f*_,d=d*y+g*_,y===1-o){const S=1/Math.sqrt(l*l+u*u+c*c+d*d);l*=S,u*=S,c*=S,d*=S}}e[n]=l,e[n+1]=u,e[n+2]=c,e[n+3]=d}static multiplyQuaternionsFlat(e,n,r,i,s,a){const o=r[i],l=r[i+1],u=r[i+2],c=r[i+3],d=s[a],h=s[a+1],p=s[a+2],f=s[a+3];return e[n]=o*f+c*d+l*p-u*h,e[n+1]=l*f+c*h+u*d-o*p,e[n+2]=u*f+c*p+o*h-l*d,e[n+3]=c*f-o*d-l*h-u*p,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,n,r,i){return this._x=e,this._y=n,this._z=r,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,n=!0){const r=e._x,i=e._y,s=e._z,a=e._order,o=Math.cos,l=Math.sin,u=o(r/2),c=o(i/2),d=o(s/2),h=l(r/2),p=l(i/2),f=l(s/2);switch(a){case"XYZ":this._x=h*c*d+u*p*f,this._y=u*p*d-h*c*f,this._z=u*c*f+h*p*d,this._w=u*c*d-h*p*f;break;case"YXZ":this._x=h*c*d+u*p*f,this._y=u*p*d-h*c*f,this._z=u*c*f-h*p*d,this._w=u*c*d+h*p*f;break;case"ZXY":this._x=h*c*d-u*p*f,this._y=u*p*d+h*c*f,this._z=u*c*f+h*p*d,this._w=u*c*d-h*p*f;break;case"ZYX":this._x=h*c*d-u*p*f,this._y=u*p*d+h*c*f,this._z=u*c*f-h*p*d,this._w=u*c*d+h*p*f;break;case"YZX":this._x=h*c*d+u*p*f,this._y=u*p*d+h*c*f,this._z=u*c*f-h*p*d,this._w=u*c*d-h*p*f;break;case"XZY":this._x=h*c*d-u*p*f,this._y=u*p*d-h*c*f,this._z=u*c*f+h*p*d,this._w=u*c*d+h*p*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return n===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,n){const r=n/2,i=Math.sin(r);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(r),this._onChangeCallback(),this}setFromRotationMatrix(e){const n=e.elements,r=n[0],i=n[4],s=n[8],a=n[1],o=n[5],l=n[9],u=n[2],c=n[6],d=n[10],h=r+o+d;if(h>0){const p=.5/Math.sqrt(h+1);this._w=.25/p,this._x=(c-l)*p,this._y=(s-u)*p,this._z=(a-i)*p}else if(r>o&&r>d){const p=2*Math.sqrt(1+r-o-d);this._w=(c-l)/p,this._x=.25*p,this._y=(i+a)/p,this._z=(s+u)/p}else if(o>d){const p=2*Math.sqrt(1+o-r-d);this._w=(s-u)/p,this._x=(i+a)/p,this._y=.25*p,this._z=(l+c)/p}else{const p=2*Math.sqrt(1+d-r-o);this._w=(a-i)/p,this._x=(s+u)/p,this._y=(l+c)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(e,n){let r=e.dot(n)+1;return r<Number.EPSILON?(r=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=r):(this._x=0,this._y=-e.z,this._z=e.y,this._w=r)):(this._x=e.y*n.z-e.z*n.y,this._y=e.z*n.x-e.x*n.z,this._z=e.x*n.y-e.y*n.x,this._w=r),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(En(this.dot(e),-1,1)))}rotateTowards(e,n){const r=this.angleTo(e);if(r===0)return this;const i=Math.min(1,n/r);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,n){const r=e._x,i=e._y,s=e._z,a=e._w,o=n._x,l=n._y,u=n._z,c=n._w;return this._x=r*c+a*o+i*u-s*l,this._y=i*c+a*l+s*o-r*u,this._z=s*c+a*u+r*l-i*o,this._w=a*c-r*o-i*l-s*u,this._onChangeCallback(),this}slerp(e,n){if(n===0)return this;if(n===1)return this.copy(e);const r=this._x,i=this._y,s=this._z,a=this._w;let o=a*e._w+r*e._x+i*e._y+s*e._z;if(o<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,o=-o):this.copy(e),o>=1)return this._w=a,this._x=r,this._y=i,this._z=s,this;const l=1-o*o;if(l<=Number.EPSILON){const p=1-n;return this._w=p*a+n*this._w,this._x=p*r+n*this._x,this._y=p*i+n*this._y,this._z=p*s+n*this._z,this.normalize(),this}const u=Math.sqrt(l),c=Math.atan2(u,o),d=Math.sin((1-n)*c)/u,h=Math.sin(n*c)/u;return this._w=a*d+this._w*h,this._x=r*d+this._x*h,this._y=i*d+this._y*h,this._z=s*d+this._z*h,this._onChangeCallback(),this}slerpQuaternions(e,n,r){return this.copy(e).slerp(n,r)}random(){const e=2*Math.PI*Math.random(),n=2*Math.PI*Math.random(),r=Math.random(),i=Math.sqrt(1-r),s=Math.sqrt(r);return this.set(i*Math.sin(e),i*Math.cos(e),s*Math.sin(n),s*Math.cos(n))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,n=0){return this._x=e[n],this._y=e[n+1],this._z=e[n+2],this._w=e[n+3],this._onChangeCallback(),this}toArray(e=[],n=0){return e[n]=this._x,e[n+1]=this._y,e[n+2]=this._z,e[n+3]=this._w,e}fromBufferAttribute(e,n){return this._x=e.getX(n),this._y=e.getY(n),this._z=e.getZ(n),this._w=e.getW(n),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Z{constructor(e=0,n=0,r=0){Z.prototype.isVector3=!0,this.x=e,this.y=n,this.z=r}set(e,n,r){return r===void 0&&(r=this.z),this.x=e,this.y=n,this.z=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,n){switch(e){case 0:this.x=n;break;case 1:this.y=n;break;case 2:this.z=n;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,n){return this.x=e.x+n.x,this.y=e.y+n.y,this.z=e.z+n.z,this}addScaledVector(e,n){return this.x+=e.x*n,this.y+=e.y*n,this.z+=e.z*n,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,n){return this.x=e.x-n.x,this.y=e.y-n.y,this.z=e.z-n.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,n){return this.x=e.x*n.x,this.y=e.y*n.y,this.z=e.z*n.z,this}applyEuler(e){return this.applyQuaternion(Y4.setFromEuler(e))}applyAxisAngle(e,n){return this.applyQuaternion(Y4.setFromAxisAngle(e,n))}applyMatrix3(e){const n=this.x,r=this.y,i=this.z,s=e.elements;return this.x=s[0]*n+s[3]*r+s[6]*i,this.y=s[1]*n+s[4]*r+s[7]*i,this.z=s[2]*n+s[5]*r+s[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const n=this.x,r=this.y,i=this.z,s=e.elements,a=1/(s[3]*n+s[7]*r+s[11]*i+s[15]);return this.x=(s[0]*n+s[4]*r+s[8]*i+s[12])*a,this.y=(s[1]*n+s[5]*r+s[9]*i+s[13])*a,this.z=(s[2]*n+s[6]*r+s[10]*i+s[14])*a,this}applyQuaternion(e){const n=this.x,r=this.y,i=this.z,s=e.x,a=e.y,o=e.z,l=e.w,u=2*(a*i-o*r),c=2*(o*n-s*i),d=2*(s*r-a*n);return this.x=n+l*u+a*d-o*c,this.y=r+l*c+o*u-s*d,this.z=i+l*d+s*c-a*u,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const n=this.x,r=this.y,i=this.z,s=e.elements;return this.x=s[0]*n+s[4]*r+s[8]*i,this.y=s[1]*n+s[5]*r+s[9]*i,this.z=s[2]*n+s[6]*r+s[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,n){return this.x=En(this.x,e.x,n.x),this.y=En(this.y,e.y,n.y),this.z=En(this.z,e.z,n.z),this}clampScalar(e,n){return this.x=En(this.x,e,n),this.y=En(this.y,e,n),this.z=En(this.z,e,n),this}clampLength(e,n){const r=this.length();return this.divideScalar(r||1).multiplyScalar(En(r,e,n))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,n){return this.x+=(e.x-this.x)*n,this.y+=(e.y-this.y)*n,this.z+=(e.z-this.z)*n,this}lerpVectors(e,n,r){return this.x=e.x+(n.x-e.x)*r,this.y=e.y+(n.y-e.y)*r,this.z=e.z+(n.z-e.z)*r,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,n){const r=e.x,i=e.y,s=e.z,a=n.x,o=n.y,l=n.z;return this.x=i*l-s*o,this.y=s*a-r*l,this.z=r*o-i*a,this}projectOnVector(e){const n=e.lengthSq();if(n===0)return this.set(0,0,0);const r=e.dot(this)/n;return this.copy(e).multiplyScalar(r)}projectOnPlane(e){return ok.copy(this).projectOnVector(e),this.sub(ok)}reflect(e){return this.sub(ok.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const n=Math.sqrt(this.lengthSq()*e.lengthSq());if(n===0)return Math.PI/2;const r=this.dot(e)/n;return Math.acos(En(r,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const n=this.x-e.x,r=this.y-e.y,i=this.z-e.z;return n*n+r*r+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,n,r){const i=Math.sin(n)*e;return this.x=i*Math.sin(r),this.y=Math.cos(n)*e,this.z=i*Math.cos(r),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,n,r){return this.x=e*Math.sin(n),this.y=r,this.z=e*Math.cos(n),this}setFromMatrixPosition(e){const n=e.elements;return this.x=n[12],this.y=n[13],this.z=n[14],this}setFromMatrixScale(e){const n=this.setFromMatrixColumn(e,0).length(),r=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=n,this.y=r,this.z=i,this}setFromMatrixColumn(e,n){return this.fromArray(e.elements,n*4)}setFromMatrix3Column(e,n){return this.fromArray(e.elements,n*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,n=0){return this.x=e[n],this.y=e[n+1],this.z=e[n+2],this}toArray(e=[],n=0){return e[n]=this.x,e[n+1]=this.y,e[n+2]=this.z,e}fromBufferAttribute(e,n){return this.x=e.getX(n),this.y=e.getY(n),this.z=e.getZ(n),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,n=Math.random()*2-1,r=Math.sqrt(1-n*n);return this.x=r*Math.cos(e),this.y=n,this.z=r*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const ok=new Z,Y4=new Kr;class Mn{constructor(e,n,r,i,s,a,o,l,u){Mn.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,n,r,i,s,a,o,l,u)}set(e,n,r,i,s,a,o,l,u){const c=this.elements;return c[0]=e,c[1]=i,c[2]=o,c[3]=n,c[4]=s,c[5]=l,c[6]=r,c[7]=a,c[8]=u,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const n=this.elements,r=e.elements;return n[0]=r[0],n[1]=r[1],n[2]=r[2],n[3]=r[3],n[4]=r[4],n[5]=r[5],n[6]=r[6],n[7]=r[7],n[8]=r[8],this}extractBasis(e,n,r){return e.setFromMatrix3Column(this,0),n.setFromMatrix3Column(this,1),r.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const n=e.elements;return this.set(n[0],n[4],n[8],n[1],n[5],n[9],n[2],n[6],n[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,n){const r=e.elements,i=n.elements,s=this.elements,a=r[0],o=r[3],l=r[6],u=r[1],c=r[4],d=r[7],h=r[2],p=r[5],f=r[8],g=i[0],y=i[3],m=i[6],b=i[1],w=i[4],_=i[7],S=i[2],E=i[5],C=i[8];return s[0]=a*g+o*b+l*S,s[3]=a*y+o*w+l*E,s[6]=a*m+o*_+l*C,s[1]=u*g+c*b+d*S,s[4]=u*y+c*w+d*E,s[7]=u*m+c*_+d*C,s[2]=h*g+p*b+f*S,s[5]=h*y+p*w+f*E,s[8]=h*m+p*_+f*C,this}multiplyScalar(e){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=e,n[4]*=e,n[7]*=e,n[2]*=e,n[5]*=e,n[8]*=e,this}determinant(){const e=this.elements,n=e[0],r=e[1],i=e[2],s=e[3],a=e[4],o=e[5],l=e[6],u=e[7],c=e[8];return n*a*c-n*o*u-r*s*c+r*o*l+i*s*u-i*a*l}invert(){const e=this.elements,n=e[0],r=e[1],i=e[2],s=e[3],a=e[4],o=e[5],l=e[6],u=e[7],c=e[8],d=c*a-o*u,h=o*l-c*s,p=u*s-a*l,f=n*d+r*h+i*p;if(f===0)return this.set(0,0,0,0,0,0,0,0,0);const g=1/f;return e[0]=d*g,e[1]=(i*u-c*r)*g,e[2]=(o*r-i*a)*g,e[3]=h*g,e[4]=(c*n-i*l)*g,e[5]=(i*s-o*n)*g,e[6]=p*g,e[7]=(r*l-u*n)*g,e[8]=(a*n-r*s)*g,this}transpose(){let e;const n=this.elements;return e=n[1],n[1]=n[3],n[3]=e,e=n[2],n[2]=n[6],n[6]=e,e=n[5],n[5]=n[7],n[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const n=this.elements;return e[0]=n[0],e[1]=n[3],e[2]=n[6],e[3]=n[1],e[4]=n[4],e[5]=n[7],e[6]=n[2],e[7]=n[5],e[8]=n[8],this}setUvTransform(e,n,r,i,s,a,o){const l=Math.cos(s),u=Math.sin(s);return this.set(r*l,r*u,-r*(l*a+u*o)+a+e,-i*u,i*l,-i*(-u*a+l*o)+o+n,0,0,1),this}scale(e,n){return this.premultiply(lk.makeScale(e,n)),this}rotate(e){return this.premultiply(lk.makeRotation(-e)),this}translate(e,n){return this.premultiply(lk.makeTranslation(e,n)),this}makeTranslation(e,n){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,n,0,0,1),this}makeRotation(e){const n=Math.cos(e),r=Math.sin(e);return this.set(n,-r,0,r,n,0,0,0,1),this}makeScale(e,n){return this.set(e,0,0,0,n,0,0,0,1),this}equals(e){const n=this.elements,r=e.elements;for(let i=0;i<9;i++)if(n[i]!==r[i])return!1;return!0}fromArray(e,n=0){for(let r=0;r<9;r++)this.elements[r]=e[r+n];return this}toArray(e=[],n=0){const r=this.elements;return e[n]=r[0],e[n+1]=r[1],e[n+2]=r[2],e[n+3]=r[3],e[n+4]=r[4],e[n+5]=r[5],e[n+6]=r[6],e[n+7]=r[7],e[n+8]=r[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const lk=new Mn;function d9(t){for(let e=t.length-1;e>=0;--e)if(t[e]>=65535)return!0;return!1}const Tue={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function ay(t,e){return new Tue[t](e)}function s1(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}function h9(){const t=s1("canvas");return t.style.display="block",t}const Z4={};function gy(t){t in Z4||(Z4[t]=!0,console.warn(t))}function Cue(t,e,n){return new Promise(function(r,i){function s(){switch(t.clientWaitSync(e,t.SYNC_FLUSH_COMMANDS_BIT,0)){case t.WAIT_FAILED:i();break;case t.TIMEOUT_EXPIRED:setTimeout(s,n);break;default:r()}}setTimeout(s,n)})}function Mue(t){const e=t.elements;e[2]=.5*e[2]+.5*e[3],e[6]=.5*e[6]+.5*e[7],e[10]=.5*e[10]+.5*e[11],e[14]=.5*e[14]+.5*e[15]}function kue(t){const e=t.elements;e[11]===-1?(e[10]=-e[10]-1,e[14]=-e[14]):(e[10]=-e[10],e[14]=-e[14]+1)}const Q4=new Mn().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),eG=new Mn().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function Nue(){const t={enabled:!0,workingColorSpace:du,spaces:{},convert:function(i,s,a){return this.enabled===!1||s===a||!s||!a||(this.spaces[s].transfer===yr&&(i.r=Yu(i.r),i.g=Yu(i.g),i.b=Yu(i.b)),this.spaces[s].primaries!==this.spaces[a].primaries&&(i.applyMatrix3(this.spaces[s].toXYZ),i.applyMatrix3(this.spaces[a].fromXYZ)),this.spaces[a].transfer===yr&&(i.r=yy(i.r),i.g=yy(i.g),i.b=yy(i.b))),i},workingToColorSpace:function(i,s){return this.convert(i,this.workingColorSpace,s)},colorSpaceToWorking:function(i,s){return this.convert(i,s,this.workingColorSpace)},getPrimaries:function(i){return this.spaces[i].primaries},getTransfer:function(i){return i===Jl?n1:this.spaces[i].transfer},getLuminanceCoefficients:function(i,s=this.workingColorSpace){return i.fromArray(this.spaces[s].luminanceCoefficients)},define:function(i){Object.assign(this.spaces,i)},_getMatrix:function(i,s,a){return i.copy(this.spaces[s].toXYZ).multiply(this.spaces[a].fromXYZ)},_getDrawingBufferColorSpace:function(i){return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(i=this.workingColorSpace){return this.spaces[i].workingColorSpaceConfig.unpackColorSpace},fromWorkingColorSpace:function(i,s){return gy("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),t.workingToColorSpace(i,s)},toWorkingColorSpace:function(i,s){return gy("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),t.colorSpaceToWorking(i,s)}},e=[.64,.33,.3,.6,.15,.06],n=[.2126,.7152,.0722],r=[.3127,.329];return t.define({[du]:{primaries:e,whitePoint:r,transfer:n1,toXYZ:Q4,fromXYZ:eG,luminanceCoefficients:n,workingColorSpaceConfig:{unpackColorSpace:Ui},outputColorSpaceConfig:{drawingBufferColorSpace:Ui}},[Ui]:{primaries:e,whitePoint:r,transfer:yr,toXYZ:Q4,fromXYZ:eG,luminanceCoefficients:n,outputColorSpaceConfig:{drawingBufferColorSpace:Ui}}}),t}const Qn=Nue();function Yu(t){return t<.04045?t*.0773993808:Math.pow(t*.9478672986+.0521327014,2.4)}function yy(t){return t<.0031308?t*12.92:1.055*Math.pow(t,.41666)-.055}let vg;class IP{static getDataURL(e,n="image/png"){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let r;if(e instanceof HTMLCanvasElement)r=e;else{vg===void 0&&(vg=s1("canvas")),vg.width=e.width,vg.height=e.height;const i=vg.getContext("2d");e instanceof ImageData?i.putImageData(e,0,0):i.drawImage(e,0,0,e.width,e.height),r=vg}return r.toDataURL(n)}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const n=s1("canvas");n.width=e.width,n.height=e.height;const r=n.getContext("2d");r.drawImage(e,0,0,e.width,e.height);const i=r.getImageData(0,0,e.width,e.height),s=i.data;for(let a=0;a<s.length;a++)s[a]=Yu(s[a]/255)*255;return r.putImageData(i,0,0),n}else if(e.data){const n=e.data.slice(0);for(let r=0;r<n.length;r++)n instanceof Uint8Array||n instanceof Uint8ClampedArray?n[r]=Math.floor(Yu(n[r]/255)*255):n[r]=Yu(n[r]);return{data:n,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let Rue=0;class ju{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:Rue++}),this.uuid=ao(),this.data=e,this.dataReady=!0,this.version=0}getSize(e){const n=this.data;return n instanceof HTMLVideoElement?e.set(n.videoWidth,n.videoHeight):n!==null?e.set(n.width,n.height,n.depth||0):e.set(0,0,0),e}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const n=e===void 0||typeof e=="string";if(!n&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const r={uuid:this.uuid,url:""},i=this.data;if(i!==null){let s;if(Array.isArray(i)){s=[];for(let a=0,o=i.length;a<o;a++)i[a].isDataTexture?s.push(uk(i[a].image)):s.push(uk(i[a]))}else s=uk(i);r.url=s}return n||(e.images[this.uuid]=r),r}}function uk(t){return typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap?IP.getDataURL(t):t.data?{data:Array.from(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Fue=0;const ck=new Z;class hr extends gu{constructor(e=hr.DEFAULT_IMAGE,n=hr.DEFAULT_MAPPING,r=jr,i=jr,s=er,a=Ma,o=ui,l=la,u=hr.DEFAULT_ANISOTROPY,c=Jl){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Fue++}),this.uuid=ao(),this.name="",this.source=new ju(e),this.mipmaps=[],this.mapping=n,this.channel=0,this.wrapS=r,this.wrapT=i,this.magFilter=s,this.minFilter=a,this.anisotropy=u,this.format=o,this.internalFormat=null,this.type=l,this.offset=new Qe(0,0),this.repeat=new Qe(1,1),this.center=new Qe(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Mn,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=c,this.userData={},this.updateRanges=[],this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.isArrayTexture=!!(e&&e.depth&&e.depth>1),this.pmremVersion=0}get width(){return this.source.getSize(ck).x}get height(){return this.source.getSize(ck).y}get depth(){return this.source.getSize(ck).z}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}addUpdateRange(e,n){this.updateRanges.push({start:e,count:n})}clearUpdateRanges(){this.updateRanges.length=0}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.renderTarget=e.renderTarget,this.isRenderTargetTexture=e.isRenderTargetTexture,this.isArrayTexture=e.isArrayTexture,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}setValues(e){for(const n in e){const r=e[n];if(r===void 0){console.warn(`THREE.Texture.setValues(): parameter '${n}' has value of undefined.`);continue}const i=this[n];if(i===void 0){console.warn(`THREE.Texture.setValues(): property '${n}' does not exist.`);continue}i&&r&&i.isVector2&&r.isVector2||i&&r&&i.isVector3&&r.isVector3||i&&r&&i.isMatrix3&&r.isMatrix3?i.copy(r):this[n]=r}}toJSON(e){const n=e===void 0||typeof e=="string";if(!n&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const r={metadata:{version:4.7,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(r.userData=this.userData),n||(e.textures[this.uuid]=r),r}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==Cd)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case ac:e.x=e.x-Math.floor(e.x);break;case jr:e.x=e.x<0?0:1;break;case Up:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case ac:e.y=e.y-Math.floor(e.y);break;case jr:e.y=e.y<0?0:1;break;case Up:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(e){e===!0&&this.pmremVersion++}}hr.DEFAULT_IMAGE=null;hr.DEFAULT_MAPPING=Cd;hr.DEFAULT_ANISOTROPY=1;class Xn{constructor(e=0,n=0,r=0,i=1){Xn.prototype.isVector4=!0,this.x=e,this.y=n,this.z=r,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,n,r,i){return this.x=e,this.y=n,this.z=r,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,n){switch(e){case 0:this.x=n;break;case 1:this.y=n;break;case 2:this.z=n;break;case 3:this.w=n;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,n){return this.x=e.x+n.x,this.y=e.y+n.y,this.z=e.z+n.z,this.w=e.w+n.w,this}addScaledVector(e,n){return this.x+=e.x*n,this.y+=e.y*n,this.z+=e.z*n,this.w+=e.w*n,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,n){return this.x=e.x-n.x,this.y=e.y-n.y,this.z=e.z-n.z,this.w=e.w-n.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const n=this.x,r=this.y,i=this.z,s=this.w,a=e.elements;return this.x=a[0]*n+a[4]*r+a[8]*i+a[12]*s,this.y=a[1]*n+a[5]*r+a[9]*i+a[13]*s,this.z=a[2]*n+a[6]*r+a[10]*i+a[14]*s,this.w=a[3]*n+a[7]*r+a[11]*i+a[15]*s,this}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this.w/=e.w,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const n=Math.sqrt(1-e.w*e.w);return n<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/n,this.y=e.y/n,this.z=e.z/n),this}setAxisAngleFromRotationMatrix(e){let n,r,i,s;const l=e.elements,u=l[0],c=l[4],d=l[8],h=l[1],p=l[5],f=l[9],g=l[2],y=l[6],m=l[10];if(Math.abs(c-h)<.01&&Math.abs(d-g)<.01&&Math.abs(f-y)<.01){if(Math.abs(c+h)<.1&&Math.abs(d+g)<.1&&Math.abs(f+y)<.1&&Math.abs(u+p+m-3)<.1)return this.set(1,0,0,0),this;n=Math.PI;const w=(u+1)/2,_=(p+1)/2,S=(m+1)/2,E=(c+h)/4,C=(d+g)/4,T=(f+y)/4;return w>_&&w>S?w<.01?(r=0,i=.707106781,s=.707106781):(r=Math.sqrt(w),i=E/r,s=C/r):_>S?_<.01?(r=.707106781,i=0,s=.707106781):(i=Math.sqrt(_),r=E/i,s=T/i):S<.01?(r=.707106781,i=.707106781,s=0):(s=Math.sqrt(S),r=C/s,i=T/s),this.set(r,i,s,n),this}let b=Math.sqrt((y-f)*(y-f)+(d-g)*(d-g)+(h-c)*(h-c));return Math.abs(b)<.001&&(b=1),this.x=(y-f)/b,this.y=(d-g)/b,this.z=(h-c)/b,this.w=Math.acos((u+p+m-1)/2),this}setFromMatrixPosition(e){const n=e.elements;return this.x=n[12],this.y=n[13],this.z=n[14],this.w=n[15],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,n){return this.x=En(this.x,e.x,n.x),this.y=En(this.y,e.y,n.y),this.z=En(this.z,e.z,n.z),this.w=En(this.w,e.w,n.w),this}clampScalar(e,n){return this.x=En(this.x,e,n),this.y=En(this.y,e,n),this.z=En(this.z,e,n),this.w=En(this.w,e,n),this}clampLength(e,n){const r=this.length();return this.divideScalar(r||1).multiplyScalar(En(r,e,n))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,n){return this.x+=(e.x-this.x)*n,this.y+=(e.y-this.y)*n,this.z+=(e.z-this.z)*n,this.w+=(e.w-this.w)*n,this}lerpVectors(e,n,r){return this.x=e.x+(n.x-e.x)*r,this.y=e.y+(n.y-e.y)*r,this.z=e.z+(n.z-e.z)*r,this.w=e.w+(n.w-e.w)*r,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,n=0){return this.x=e[n],this.y=e[n+1],this.z=e[n+2],this.w=e[n+3],this}toArray(e=[],n=0){return e[n]=this.x,e[n+1]=this.y,e[n+2]=this.z,e[n+3]=this.w,e}fromBufferAttribute(e,n){return this.x=e.getX(n),this.y=e.getY(n),this.z=e.getZ(n),this.w=e.getW(n),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class TP extends gu{constructor(e=1,n=1,r={}){super(),r=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:er,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1,depth:1,multiview:!1},r),this.isRenderTarget=!0,this.width=e,this.height=n,this.depth=r.depth,this.scissor=new Xn(0,0,e,n),this.scissorTest=!1,this.viewport=new Xn(0,0,e,n);const i={width:e,height:n,depth:r.depth},s=new hr(i);this.textures=[];const a=r.count;for(let o=0;o<a;o++)this.textures[o]=s.clone(),this.textures[o].isRenderTargetTexture=!0,this.textures[o].renderTarget=this;this._setTextureOptions(r),this.depthBuffer=r.depthBuffer,this.stencilBuffer=r.stencilBuffer,this.resolveDepthBuffer=r.resolveDepthBuffer,this.resolveStencilBuffer=r.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=r.depthTexture,this.samples=r.samples,this.multiview=r.multiview}_setTextureOptions(e={}){const n={minFilter:er,generateMipmaps:!1,flipY:!1,internalFormat:null};e.mapping!==void 0&&(n.mapping=e.mapping),e.wrapS!==void 0&&(n.wrapS=e.wrapS),e.wrapT!==void 0&&(n.wrapT=e.wrapT),e.wrapR!==void 0&&(n.wrapR=e.wrapR),e.magFilter!==void 0&&(n.magFilter=e.magFilter),e.minFilter!==void 0&&(n.minFilter=e.minFilter),e.format!==void 0&&(n.format=e.format),e.type!==void 0&&(n.type=e.type),e.anisotropy!==void 0&&(n.anisotropy=e.anisotropy),e.colorSpace!==void 0&&(n.colorSpace=e.colorSpace),e.flipY!==void 0&&(n.flipY=e.flipY),e.generateMipmaps!==void 0&&(n.generateMipmaps=e.generateMipmaps),e.internalFormat!==void 0&&(n.internalFormat=e.internalFormat);for(let r=0;r<this.textures.length;r++)this.textures[r].setValues(n)}get texture(){return this.textures[0]}set texture(e){this.textures[0]=e}set depthTexture(e){this._depthTexture!==null&&(this._depthTexture.renderTarget=null),e!==null&&(e.renderTarget=this),this._depthTexture=e}get depthTexture(){return this._depthTexture}setSize(e,n,r=1){if(this.width!==e||this.height!==n||this.depth!==r){this.width=e,this.height=n,this.depth=r;for(let i=0,s=this.textures.length;i<s;i++)this.textures[i].image.width=e,this.textures[i].image.height=n,this.textures[i].image.depth=r,this.textures[i].isArrayTexture=this.textures[i].image.depth>1;this.dispose()}this.viewport.set(0,0,e,n),this.scissor.set(0,0,e,n)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.textures.length=0;for(let n=0,r=e.textures.length;n<r;n++){this.textures[n]=e.textures[n].clone(),this.textures[n].isRenderTargetTexture=!0,this.textures[n].renderTarget=this;const i=Object.assign({},e.textures[n].image);this.textures[n].source=new ju(i)}return this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.resolveDepthBuffer=e.resolveDepthBuffer,this.resolveStencilBuffer=e.resolveStencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Oa extends TP{constructor(e=1,n=1,r={}){super(e,n,r),this.isWebGLRenderTarget=!0}}class MT extends hr{constructor(e=null,n=1,r=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:n,height:r,depth:i},this.magFilter=yi,this.minFilter=yi,this.wrapR=jr,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class Due extends Oa{constructor(e=1,n=1,r=1,i={}){super(e,n,i),this.isWebGLArrayRenderTarget=!0,this.depth=r,this.texture=new MT(null,e,n,r),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class kT extends hr{constructor(e=null,n=1,r=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:n,height:r,depth:i},this.magFilter=yi,this.minFilter=yi,this.wrapR=jr,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Pue extends Oa{constructor(e=1,n=1,r=1,i={}){super(e,n,i),this.isWebGL3DRenderTarget=!0,this.depth=r,this.texture=new kT(null,e,n,r),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class ds{constructor(e=new Z(1/0,1/0,1/0),n=new Z(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=n}set(e,n){return this.min.copy(e),this.max.copy(n),this}setFromArray(e){this.makeEmpty();for(let n=0,r=e.length;n<r;n+=3)this.expandByPoint(el.fromArray(e,n));return this}setFromBufferAttribute(e){this.makeEmpty();for(let n=0,r=e.count;n<r;n++)this.expandByPoint(el.fromBufferAttribute(e,n));return this}setFromPoints(e){this.makeEmpty();for(let n=0,r=e.length;n<r;n++)this.expandByPoint(e[n]);return this}setFromCenterAndSize(e,n){const r=el.copy(n).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}setFromObject(e,n=!1){return this.makeEmpty(),this.expandByObject(e,n)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,n=!1){e.updateWorldMatrix(!1,!1);const r=e.geometry;if(r!==void 0){const s=r.getAttribute("position");if(n===!0&&s!==void 0&&e.isInstancedMesh!==!0)for(let a=0,o=s.count;a<o;a++)e.isMesh===!0?e.getVertexPosition(a,el):el.fromBufferAttribute(s,a),el.applyMatrix4(e.matrixWorld),this.expandByPoint(el);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),yS.copy(e.boundingBox)):(r.boundingBox===null&&r.computeBoundingBox(),yS.copy(r.boundingBox)),yS.applyMatrix4(e.matrixWorld),this.union(yS)}const i=e.children;for(let s=0,a=i.length;s<a;s++)this.expandByObject(i[s],n);return this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y&&e.z>=this.min.z&&e.z<=this.max.z}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,n){return n.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y&&e.max.z>=this.min.z&&e.min.z<=this.max.z}intersectsSphere(e){return this.clampPoint(e.center,el),el.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let n,r;return e.normal.x>0?(n=e.normal.x*this.min.x,r=e.normal.x*this.max.x):(n=e.normal.x*this.max.x,r=e.normal.x*this.min.x),e.normal.y>0?(n+=e.normal.y*this.min.y,r+=e.normal.y*this.max.y):(n+=e.normal.y*this.max.y,r+=e.normal.y*this.min.y),e.normal.z>0?(n+=e.normal.z*this.min.z,r+=e.normal.z*this.max.z):(n+=e.normal.z*this.max.z,r+=e.normal.z*this.min.z),n<=-e.constant&&r>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(gx),vS.subVectors(this.max,gx),xg.subVectors(e.a,gx),bg.subVectors(e.b,gx),wg.subVectors(e.c,gx),Fc.subVectors(bg,xg),Dc.subVectors(wg,bg),Th.subVectors(xg,wg);let n=[0,-Fc.z,Fc.y,0,-Dc.z,Dc.y,0,-Th.z,Th.y,Fc.z,0,-Fc.x,Dc.z,0,-Dc.x,Th.z,0,-Th.x,-Fc.y,Fc.x,0,-Dc.y,Dc.x,0,-Th.y,Th.x,0];return!dk(n,xg,bg,wg,vS)||(n=[1,0,0,0,1,0,0,0,1],!dk(n,xg,bg,wg,vS))?!1:(xS.crossVectors(Fc,Dc),n=[xS.x,xS.y,xS.z],dk(n,xg,bg,wg,vS))}clampPoint(e,n){return n.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,el).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(el).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Cu[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Cu[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Cu[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Cu[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Cu[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Cu[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Cu[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Cu[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Cu),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}toJSON(){return{min:this.min.toArray(),max:this.max.toArray()}}fromJSON(e){return this.min.fromArray(e.min),this.max.fromArray(e.max),this}}const Cu=[new Z,new Z,new Z,new Z,new Z,new Z,new Z,new Z],el=new Z,yS=new ds,xg=new Z,bg=new Z,wg=new Z,Fc=new Z,Dc=new Z,Th=new Z,gx=new Z,vS=new Z,xS=new Z,Ch=new Z;function dk(t,e,n,r,i){for(let s=0,a=t.length-3;s<=a;s+=3){Ch.fromArray(t,s);const o=i.x*Math.abs(Ch.x)+i.y*Math.abs(Ch.y)+i.z*Math.abs(Ch.z),l=e.dot(Ch),u=n.dot(Ch),c=r.dot(Ch);if(Math.max(-Math.max(l,u,c),Math.min(l,u,c))>o)return!1}return!0}const Lue=new ds,yx=new Z,hk=new Z;class Xi{constructor(e=new Z,n=-1){this.isSphere=!0,this.center=e,this.radius=n}set(e,n){return this.center.copy(e),this.radius=n,this}setFromPoints(e,n){const r=this.center;n!==void 0?r.copy(n):Lue.setFromPoints(e).getCenter(r);let i=0;for(let s=0,a=e.length;s<a;s++)i=Math.max(i,r.distanceToSquared(e[s]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const n=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=n*n}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,n){const r=this.center.distanceToSquared(e);return n.copy(e),r>this.radius*this.radius&&(n.sub(this.center).normalize(),n.multiplyScalar(this.radius).add(this.center)),n}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;yx.subVectors(e,this.center);const n=yx.lengthSq();if(n>this.radius*this.radius){const r=Math.sqrt(n),i=(r-this.radius)*.5;this.center.addScaledVector(yx,i/r),this.radius+=i}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(hk.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(yx.copy(e.center).add(hk)),this.expandByPoint(yx.copy(e.center).sub(hk))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}toJSON(){return{radius:this.radius,center:this.center.toArray()}}fromJSON(e){return this.radius=e.radius,this.center.fromArray(e.center),this}}const Mu=new Z,pk=new Z,bS=new Z,Pc=new Z,fk=new Z,wS=new Z,mk=new Z;class xf{constructor(e=new Z,n=new Z(0,0,-1)){this.origin=e,this.direction=n}set(e,n){return this.origin.copy(e),this.direction.copy(n),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,n){return n.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Mu)),this}closestPointToPoint(e,n){n.subVectors(e,this.origin);const r=n.dot(this.direction);return r<0?n.copy(this.origin):n.copy(this.origin).addScaledVector(this.direction,r)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const n=Mu.subVectors(e,this.origin).dot(this.direction);return n<0?this.origin.distanceToSquared(e):(Mu.copy(this.origin).addScaledVector(this.direction,n),Mu.distanceToSquared(e))}distanceSqToSegment(e,n,r,i){pk.copy(e).add(n).multiplyScalar(.5),bS.copy(n).sub(e).normalize(),Pc.copy(this.origin).sub(pk);const s=e.distanceTo(n)*.5,a=-this.direction.dot(bS),o=Pc.dot(this.direction),l=-Pc.dot(bS),u=Pc.lengthSq(),c=Math.abs(1-a*a);let d,h,p,f;if(c>0)if(d=a*l-o,h=a*o-l,f=s*c,d>=0)if(h>=-f)if(h<=f){const g=1/c;d*=g,h*=g,p=d*(d+a*h+2*o)+h*(a*d+h+2*l)+u}else h=s,d=Math.max(0,-(a*h+o)),p=-d*d+h*(h+2*l)+u;else h=-s,d=Math.max(0,-(a*h+o)),p=-d*d+h*(h+2*l)+u;else h<=-f?(d=Math.max(0,-(-a*s+o)),h=d>0?-s:Math.min(Math.max(-s,-l),s),p=-d*d+h*(h+2*l)+u):h<=f?(d=0,h=Math.min(Math.max(-s,-l),s),p=h*(h+2*l)+u):(d=Math.max(0,-(a*s+o)),h=d>0?s:Math.min(Math.max(-s,-l),s),p=-d*d+h*(h+2*l)+u);else h=a>0?-s:s,d=Math.max(0,-(a*h+o)),p=-d*d+h*(h+2*l)+u;return r&&r.copy(this.origin).addScaledVector(this.direction,d),i&&i.copy(pk).addScaledVector(bS,h),p}intersectSphere(e,n){Mu.subVectors(e.center,this.origin);const r=Mu.dot(this.direction),i=Mu.dot(Mu)-r*r,s=e.radius*e.radius;if(i>s)return null;const a=Math.sqrt(s-i),o=r-a,l=r+a;return l<0?null:o<0?this.at(l,n):this.at(o,n)}intersectsSphere(e){return e.radius<0?!1:this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const n=e.normal.dot(this.direction);if(n===0)return e.distanceToPoint(this.origin)===0?0:null;const r=-(this.origin.dot(e.normal)+e.constant)/n;return r>=0?r:null}intersectPlane(e,n){const r=this.distanceToPlane(e);return r===null?null:this.at(r,n)}intersectsPlane(e){const n=e.distanceToPoint(this.origin);return n===0||e.normal.dot(this.direction)*n<0}intersectBox(e,n){let r,i,s,a,o,l;const u=1/this.direction.x,c=1/this.direction.y,d=1/this.direction.z,h=this.origin;return u>=0?(r=(e.min.x-h.x)*u,i=(e.max.x-h.x)*u):(r=(e.max.x-h.x)*u,i=(e.min.x-h.x)*u),c>=0?(s=(e.min.y-h.y)*c,a=(e.max.y-h.y)*c):(s=(e.max.y-h.y)*c,a=(e.min.y-h.y)*c),r>a||s>i||((s>r||isNaN(r))&&(r=s),(a<i||isNaN(i))&&(i=a),d>=0?(o=(e.min.z-h.z)*d,l=(e.max.z-h.z)*d):(o=(e.max.z-h.z)*d,l=(e.min.z-h.z)*d),r>l||o>i)||((o>r||r!==r)&&(r=o),(l<i||i!==i)&&(i=l),i<0)?null:this.at(r>=0?r:i,n)}intersectsBox(e){return this.intersectBox(e,Mu)!==null}intersectTriangle(e,n,r,i,s){fk.subVectors(n,e),wS.subVectors(r,e),mk.crossVectors(fk,wS);let a=this.direction.dot(mk),o;if(a>0){if(i)return null;o=1}else if(a<0)o=-1,a=-a;else return null;Pc.subVectors(this.origin,e);const l=o*this.direction.dot(wS.crossVectors(Pc,wS));if(l<0)return null;const u=o*this.direction.dot(fk.cross(Pc));if(u<0||l+u>a)return null;const c=-o*Pc.dot(mk);return c<0?null:this.at(c/a,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class ln{constructor(e,n,r,i,s,a,o,l,u,c,d,h,p,f,g,y){ln.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,n,r,i,s,a,o,l,u,c,d,h,p,f,g,y)}set(e,n,r,i,s,a,o,l,u,c,d,h,p,f,g,y){const m=this.elements;return m[0]=e,m[4]=n,m[8]=r,m[12]=i,m[1]=s,m[5]=a,m[9]=o,m[13]=l,m[2]=u,m[6]=c,m[10]=d,m[14]=h,m[3]=p,m[7]=f,m[11]=g,m[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new ln().fromArray(this.elements)}copy(e){const n=this.elements,r=e.elements;return n[0]=r[0],n[1]=r[1],n[2]=r[2],n[3]=r[3],n[4]=r[4],n[5]=r[5],n[6]=r[6],n[7]=r[7],n[8]=r[8],n[9]=r[9],n[10]=r[10],n[11]=r[11],n[12]=r[12],n[13]=r[13],n[14]=r[14],n[15]=r[15],this}copyPosition(e){const n=this.elements,r=e.elements;return n[12]=r[12],n[13]=r[13],n[14]=r[14],this}setFromMatrix3(e){const n=e.elements;return this.set(n[0],n[3],n[6],0,n[1],n[4],n[7],0,n[2],n[5],n[8],0,0,0,0,1),this}extractBasis(e,n,r){return e.setFromMatrixColumn(this,0),n.setFromMatrixColumn(this,1),r.setFromMatrixColumn(this,2),this}makeBasis(e,n,r){return this.set(e.x,n.x,r.x,0,e.y,n.y,r.y,0,e.z,n.z,r.z,0,0,0,0,1),this}extractRotation(e){const n=this.elements,r=e.elements,i=1/_g.setFromMatrixColumn(e,0).length(),s=1/_g.setFromMatrixColumn(e,1).length(),a=1/_g.setFromMatrixColumn(e,2).length();return n[0]=r[0]*i,n[1]=r[1]*i,n[2]=r[2]*i,n[3]=0,n[4]=r[4]*s,n[5]=r[5]*s,n[6]=r[6]*s,n[7]=0,n[8]=r[8]*a,n[9]=r[9]*a,n[10]=r[10]*a,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}makeRotationFromEuler(e){const n=this.elements,r=e.x,i=e.y,s=e.z,a=Math.cos(r),o=Math.sin(r),l=Math.cos(i),u=Math.sin(i),c=Math.cos(s),d=Math.sin(s);if(e.order==="XYZ"){const h=a*c,p=a*d,f=o*c,g=o*d;n[0]=l*c,n[4]=-l*d,n[8]=u,n[1]=p+f*u,n[5]=h-g*u,n[9]=-o*l,n[2]=g-h*u,n[6]=f+p*u,n[10]=a*l}else if(e.order==="YXZ"){const h=l*c,p=l*d,f=u*c,g=u*d;n[0]=h+g*o,n[4]=f*o-p,n[8]=a*u,n[1]=a*d,n[5]=a*c,n[9]=-o,n[2]=p*o-f,n[6]=g+h*o,n[10]=a*l}else if(e.order==="ZXY"){const h=l*c,p=l*d,f=u*c,g=u*d;n[0]=h-g*o,n[4]=-a*d,n[8]=f+p*o,n[1]=p+f*o,n[5]=a*c,n[9]=g-h*o,n[2]=-a*u,n[6]=o,n[10]=a*l}else if(e.order==="ZYX"){const h=a*c,p=a*d,f=o*c,g=o*d;n[0]=l*c,n[4]=f*u-p,n[8]=h*u+g,n[1]=l*d,n[5]=g*u+h,n[9]=p*u-f,n[2]=-u,n[6]=o*l,n[10]=a*l}else if(e.order==="YZX"){const h=a*l,p=a*u,f=o*l,g=o*u;n[0]=l*c,n[4]=g-h*d,n[8]=f*d+p,n[1]=d,n[5]=a*c,n[9]=-o*c,n[2]=-u*c,n[6]=p*d+f,n[10]=h-g*d}else if(e.order==="XZY"){const h=a*l,p=a*u,f=o*l,g=o*u;n[0]=l*c,n[4]=-d,n[8]=u*c,n[1]=h*d+g,n[5]=a*c,n[9]=p*d-f,n[2]=f*d-p,n[6]=o*c,n[10]=g*d+h}return n[3]=0,n[7]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Oue,e,Bue)}lookAt(e,n,r){const i=this.elements;return Ja.subVectors(e,n),Ja.lengthSq()===0&&(Ja.z=1),Ja.normalize(),Lc.crossVectors(r,Ja),Lc.lengthSq()===0&&(Math.abs(r.z)===1?Ja.x+=1e-4:Ja.z+=1e-4,Ja.normalize(),Lc.crossVectors(r,Ja)),Lc.normalize(),_S.crossVectors(Ja,Lc),i[0]=Lc.x,i[4]=_S.x,i[8]=Ja.x,i[1]=Lc.y,i[5]=_S.y,i[9]=Ja.y,i[2]=Lc.z,i[6]=_S.z,i[10]=Ja.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,n){const r=e.elements,i=n.elements,s=this.elements,a=r[0],o=r[4],l=r[8],u=r[12],c=r[1],d=r[5],h=r[9],p=r[13],f=r[2],g=r[6],y=r[10],m=r[14],b=r[3],w=r[7],_=r[11],S=r[15],E=i[0],C=i[4],T=i[8],M=i[12],k=i[1],R=i[5],N=i[9],B=i[13],z=i[2],V=i[6],K=i[10],Q=i[14],O=i[3],j=i[7],X=i[11],te=i[15];return s[0]=a*E+o*k+l*z+u*O,s[4]=a*C+o*R+l*V+u*j,s[8]=a*T+o*N+l*K+u*X,s[12]=a*M+o*B+l*Q+u*te,s[1]=c*E+d*k+h*z+p*O,s[5]=c*C+d*R+h*V+p*j,s[9]=c*T+d*N+h*K+p*X,s[13]=c*M+d*B+h*Q+p*te,s[2]=f*E+g*k+y*z+m*O,s[6]=f*C+g*R+y*V+m*j,s[10]=f*T+g*N+y*K+m*X,s[14]=f*M+g*B+y*Q+m*te,s[3]=b*E+w*k+_*z+S*O,s[7]=b*C+w*R+_*V+S*j,s[11]=b*T+w*N+_*K+S*X,s[15]=b*M+w*B+_*Q+S*te,this}multiplyScalar(e){const n=this.elements;return n[0]*=e,n[4]*=e,n[8]*=e,n[12]*=e,n[1]*=e,n[5]*=e,n[9]*=e,n[13]*=e,n[2]*=e,n[6]*=e,n[10]*=e,n[14]*=e,n[3]*=e,n[7]*=e,n[11]*=e,n[15]*=e,this}determinant(){const e=this.elements,n=e[0],r=e[4],i=e[8],s=e[12],a=e[1],o=e[5],l=e[9],u=e[13],c=e[2],d=e[6],h=e[10],p=e[14],f=e[3],g=e[7],y=e[11],m=e[15];return f*(+s*l*d-i*u*d-s*o*h+r*u*h+i*o*p-r*l*p)+g*(+n*l*p-n*u*h+s*a*h-i*a*p+i*u*c-s*l*c)+y*(+n*u*d-n*o*p-s*a*d+r*a*p+s*o*c-r*u*c)+m*(-i*o*c-n*l*d+n*o*h+i*a*d-r*a*h+r*l*c)}transpose(){const e=this.elements;let n;return n=e[1],e[1]=e[4],e[4]=n,n=e[2],e[2]=e[8],e[8]=n,n=e[6],e[6]=e[9],e[9]=n,n=e[3],e[3]=e[12],e[12]=n,n=e[7],e[7]=e[13],e[13]=n,n=e[11],e[11]=e[14],e[14]=n,this}setPosition(e,n,r){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=n,i[14]=r),this}invert(){const e=this.elements,n=e[0],r=e[1],i=e[2],s=e[3],a=e[4],o=e[5],l=e[6],u=e[7],c=e[8],d=e[9],h=e[10],p=e[11],f=e[12],g=e[13],y=e[14],m=e[15],b=d*y*u-g*h*u+g*l*p-o*y*p-d*l*m+o*h*m,w=f*h*u-c*y*u-f*l*p+a*y*p+c*l*m-a*h*m,_=c*g*u-f*d*u+f*o*p-a*g*p-c*o*m+a*d*m,S=f*d*l-c*g*l-f*o*h+a*g*h+c*o*y-a*d*y,E=n*b+r*w+i*_+s*S;if(E===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const C=1/E;return e[0]=b*C,e[1]=(g*h*s-d*y*s-g*i*p+r*y*p+d*i*m-r*h*m)*C,e[2]=(o*y*s-g*l*s+g*i*u-r*y*u-o*i*m+r*l*m)*C,e[3]=(d*l*s-o*h*s-d*i*u+r*h*u+o*i*p-r*l*p)*C,e[4]=w*C,e[5]=(c*y*s-f*h*s+f*i*p-n*y*p-c*i*m+n*h*m)*C,e[6]=(f*l*s-a*y*s-f*i*u+n*y*u+a*i*m-n*l*m)*C,e[7]=(a*h*s-c*l*s+c*i*u-n*h*u-a*i*p+n*l*p)*C,e[8]=_*C,e[9]=(f*d*s-c*g*s-f*r*p+n*g*p+c*r*m-n*d*m)*C,e[10]=(a*g*s-f*o*s+f*r*u-n*g*u-a*r*m+n*o*m)*C,e[11]=(c*o*s-a*d*s-c*r*u+n*d*u+a*r*p-n*o*p)*C,e[12]=S*C,e[13]=(c*g*i-f*d*i+f*r*h-n*g*h-c*r*y+n*d*y)*C,e[14]=(f*o*i-a*g*i-f*r*l+n*g*l+a*r*y-n*o*y)*C,e[15]=(a*d*i-c*o*i+c*r*l-n*d*l-a*r*h+n*o*h)*C,this}scale(e){const n=this.elements,r=e.x,i=e.y,s=e.z;return n[0]*=r,n[4]*=i,n[8]*=s,n[1]*=r,n[5]*=i,n[9]*=s,n[2]*=r,n[6]*=i,n[10]*=s,n[3]*=r,n[7]*=i,n[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,n=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(n,r,i))}makeTranslation(e,n,r){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,n,0,0,1,r,0,0,0,1),this}makeRotationX(e){const n=Math.cos(e),r=Math.sin(e);return this.set(1,0,0,0,0,n,-r,0,0,r,n,0,0,0,0,1),this}makeRotationY(e){const n=Math.cos(e),r=Math.sin(e);return this.set(n,0,r,0,0,1,0,0,-r,0,n,0,0,0,0,1),this}makeRotationZ(e){const n=Math.cos(e),r=Math.sin(e);return this.set(n,-r,0,0,r,n,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,n){const r=Math.cos(n),i=Math.sin(n),s=1-r,a=e.x,o=e.y,l=e.z,u=s*a,c=s*o;return this.set(u*a+r,u*o-i*l,u*l+i*o,0,u*o+i*l,c*o+r,c*l-i*a,0,u*l-i*o,c*l+i*a,s*l*l+r,0,0,0,0,1),this}makeScale(e,n,r){return this.set(e,0,0,0,0,n,0,0,0,0,r,0,0,0,0,1),this}makeShear(e,n,r,i,s,a){return this.set(1,r,s,0,e,1,a,0,n,i,1,0,0,0,0,1),this}compose(e,n,r){const i=this.elements,s=n._x,a=n._y,o=n._z,l=n._w,u=s+s,c=a+a,d=o+o,h=s*u,p=s*c,f=s*d,g=a*c,y=a*d,m=o*d,b=l*u,w=l*c,_=l*d,S=r.x,E=r.y,C=r.z;return i[0]=(1-(g+m))*S,i[1]=(p+_)*S,i[2]=(f-w)*S,i[3]=0,i[4]=(p-_)*E,i[5]=(1-(h+m))*E,i[6]=(y+b)*E,i[7]=0,i[8]=(f+w)*C,i[9]=(y-b)*C,i[10]=(1-(h+g))*C,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,n,r){const i=this.elements;let s=_g.set(i[0],i[1],i[2]).length();const a=_g.set(i[4],i[5],i[6]).length(),o=_g.set(i[8],i[9],i[10]).length();this.determinant()<0&&(s=-s),e.x=i[12],e.y=i[13],e.z=i[14],tl.copy(this);const u=1/s,c=1/a,d=1/o;return tl.elements[0]*=u,tl.elements[1]*=u,tl.elements[2]*=u,tl.elements[4]*=c,tl.elements[5]*=c,tl.elements[6]*=c,tl.elements[8]*=d,tl.elements[9]*=d,tl.elements[10]*=d,n.setFromRotationMatrix(tl),r.x=s,r.y=a,r.z=o,this}makePerspective(e,n,r,i,s,a,o=Oo){const l=this.elements,u=2*s/(n-e),c=2*s/(r-i),d=(n+e)/(n-e),h=(r+i)/(r-i);let p,f;if(o===Oo)p=-(a+s)/(a-s),f=-2*a*s/(a-s);else if(o===i1)p=-a/(a-s),f=-a*s/(a-s);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+o);return l[0]=u,l[4]=0,l[8]=d,l[12]=0,l[1]=0,l[5]=c,l[9]=h,l[13]=0,l[2]=0,l[6]=0,l[10]=p,l[14]=f,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(e,n,r,i,s,a,o=Oo){const l=this.elements,u=1/(n-e),c=1/(r-i),d=1/(a-s),h=(n+e)*u,p=(r+i)*c;let f,g;if(o===Oo)f=(a+s)*d,g=-2*d;else if(o===i1)f=s*d,g=-1*d;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+o);return l[0]=2*u,l[4]=0,l[8]=0,l[12]=-h,l[1]=0,l[5]=2*c,l[9]=0,l[13]=-p,l[2]=0,l[6]=0,l[10]=g,l[14]=-f,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(e){const n=this.elements,r=e.elements;for(let i=0;i<16;i++)if(n[i]!==r[i])return!1;return!0}fromArray(e,n=0){for(let r=0;r<16;r++)this.elements[r]=e[r+n];return this}toArray(e=[],n=0){const r=this.elements;return e[n]=r[0],e[n+1]=r[1],e[n+2]=r[2],e[n+3]=r[3],e[n+4]=r[4],e[n+5]=r[5],e[n+6]=r[6],e[n+7]=r[7],e[n+8]=r[8],e[n+9]=r[9],e[n+10]=r[10],e[n+11]=r[11],e[n+12]=r[12],e[n+13]=r[13],e[n+14]=r[14],e[n+15]=r[15],e}}const _g=new Z,tl=new ln,Oue=new Z(0,0,0),Bue=new Z(1,1,1),Lc=new Z,_S=new Z,Ja=new Z,tG=new ln,nG=new Kr;class Ba{constructor(e=0,n=0,r=0,i=Ba.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=n,this._z=r,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,n,r,i=this._order){return this._x=e,this._y=n,this._z=r,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,n=this._order,r=!0){const i=e.elements,s=i[0],a=i[4],o=i[8],l=i[1],u=i[5],c=i[9],d=i[2],h=i[6],p=i[10];switch(n){case"XYZ":this._y=Math.asin(En(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,p),this._z=Math.atan2(-a,s)):(this._x=Math.atan2(h,u),this._z=0);break;case"YXZ":this._x=Math.asin(-En(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(o,p),this._z=Math.atan2(l,u)):(this._y=Math.atan2(-d,s),this._z=0);break;case"ZXY":this._x=Math.asin(En(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(-d,p),this._z=Math.atan2(-a,u)):(this._y=0,this._z=Math.atan2(l,s));break;case"ZYX":this._y=Math.asin(-En(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(h,p),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-a,u));break;case"YZX":this._z=Math.asin(En(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-c,u),this._y=Math.atan2(-d,s)):(this._x=0,this._y=Math.atan2(o,p));break;case"XZY":this._z=Math.asin(-En(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(h,u),this._y=Math.atan2(o,s)):(this._x=Math.atan2(-c,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+n)}return this._order=n,r===!0&&this._onChangeCallback(),this}setFromQuaternion(e,n,r){return tG.makeRotationFromQuaternion(e),this.setFromRotationMatrix(tG,n,r)}setFromVector3(e,n=this._order){return this.set(e.x,e.y,e.z,n)}reorder(e){return nG.setFromEuler(this),this.setFromQuaternion(nG,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],n=0){return e[n]=this._x,e[n+1]=this._y,e[n+2]=this._z,e[n+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Ba.DEFAULT_ORDER="XYZ";class Ip{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let Uue=0;const rG=new Z,Sg=new Kr,ku=new ln,SS=new Z,vx=new Z,$ue=new Z,zue=new Kr,iG=new Z(1,0,0),sG=new Z(0,1,0),aG=new Z(0,0,1),oG={type:"added"},Gue={type:"removed"},Ag={type:"childadded",child:null},gk={type:"childremoved",child:null};class Yn extends gu{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Uue++}),this.uuid=ao(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Yn.DEFAULT_UP.clone();const e=new Z,n=new Ba,r=new Kr,i=new Z(1,1,1);function s(){r.setFromEuler(n,!1)}function a(){n.setFromQuaternion(r,void 0,!1)}n._onChange(s),r._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:n},quaternion:{configurable:!0,enumerable:!0,value:r},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new ln},normalMatrix:{value:new Mn}}),this.matrix=new ln,this.matrixWorld=new ln,this.matrixAutoUpdate=Yn.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Yn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Ip,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,n){this.quaternion.setFromAxisAngle(e,n)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,n){return Sg.setFromAxisAngle(e,n),this.quaternion.multiply(Sg),this}rotateOnWorldAxis(e,n){return Sg.setFromAxisAngle(e,n),this.quaternion.premultiply(Sg),this}rotateX(e){return this.rotateOnAxis(iG,e)}rotateY(e){return this.rotateOnAxis(sG,e)}rotateZ(e){return this.rotateOnAxis(aG,e)}translateOnAxis(e,n){return rG.copy(e).applyQuaternion(this.quaternion),this.position.add(rG.multiplyScalar(n)),this}translateX(e){return this.translateOnAxis(iG,e)}translateY(e){return this.translateOnAxis(sG,e)}translateZ(e){return this.translateOnAxis(aG,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(ku.copy(this.matrixWorld).invert())}lookAt(e,n,r){e.isVector3?SS.copy(e):SS.set(e,n,r);const i=this.parent;this.updateWorldMatrix(!0,!1),vx.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ku.lookAt(vx,SS,this.up):ku.lookAt(SS,vx,this.up),this.quaternion.setFromRotationMatrix(ku),i&&(ku.extractRotation(i.matrixWorld),Sg.setFromRotationMatrix(ku),this.quaternion.premultiply(Sg.invert()))}add(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.add(arguments[n]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.removeFromParent(),e.parent=this,this.children.push(e),e.dispatchEvent(oG),Ag.child=e,this.dispatchEvent(Ag),Ag.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let r=0;r<arguments.length;r++)this.remove(arguments[r]);return this}const n=this.children.indexOf(e);return n!==-1&&(e.parent=null,this.children.splice(n,1),e.dispatchEvent(Gue),gk.child=e,this.dispatchEvent(gk),gk.child=null),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),ku.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),ku.multiply(e.parent.matrixWorld)),e.applyMatrix4(ku),e.removeFromParent(),e.parent=this,this.children.push(e),e.updateWorldMatrix(!1,!0),e.dispatchEvent(oG),Ag.child=e,this.dispatchEvent(Ag),Ag.child=null,this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,n){if(this[e]===n)return this;for(let r=0,i=this.children.length;r<i;r++){const a=this.children[r].getObjectByProperty(e,n);if(a!==void 0)return a}}getObjectsByProperty(e,n,r=[]){this[e]===n&&r.push(this);const i=this.children;for(let s=0,a=i.length;s<a;s++)i[s].getObjectsByProperty(e,n,r);return r}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(vx,e,$ue),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(vx,zue,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const n=this.matrixWorld.elements;return e.set(n[8],n[9],n[10]).normalize()}raycast(){}traverse(e){e(this);const n=this.children;for(let r=0,i=n.length;r<i;r++)n[r].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const n=this.children;for(let r=0,i=n.length;r<i;r++)n[r].traverseVisible(e)}traverseAncestors(e){const n=this.parent;n!==null&&(e(n),n.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,e=!0);const n=this.children;for(let r=0,i=n.length;r<i;r++)n[r].updateMatrixWorld(e)}updateWorldMatrix(e,n){const r=this.parent;if(e===!0&&r!==null&&r.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),n===!0){const i=this.children;for(let s=0,a=i.length;s<a;s++)i[s].updateWorldMatrix(!1,!0)}}toJSON(e){const n=e===void 0||typeof e=="string",r={};n&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},r.metadata={version:4.7,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.geometryInfo=this._geometryInfo.map(o=>({...o,boundingBox:o.boundingBox?o.boundingBox.toJSON():void 0,boundingSphere:o.boundingSphere?o.boundingSphere.toJSON():void 0})),i.instanceInfo=this._instanceInfo.map(o=>({...o})),i.availableInstanceIds=this._availableInstanceIds.slice(),i.availableGeometryIds=this._availableGeometryIds.slice(),i.nextIndexStart=this._nextIndexStart,i.nextVertexStart=this._nextVertexStart,i.geometryCount=this._geometryCount,i.maxInstanceCount=this._maxInstanceCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.matricesTexture=this._matricesTexture.toJSON(e),i.indirectTexture=this._indirectTexture.toJSON(e),this._colorsTexture!==null&&(i.colorsTexture=this._colorsTexture.toJSON(e)),this.boundingSphere!==null&&(i.boundingSphere=this.boundingSphere.toJSON()),this.boundingBox!==null&&(i.boundingBox=this.boundingBox.toJSON()));function s(o,l){return o[l.uuid]===void 0&&(o[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=s(e.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const l=o.shapes;if(Array.isArray(l))for(let u=0,c=l.length;u<c;u++){const d=l[u];s(e.shapes,d)}else s(e.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let l=0,u=this.material.length;l<u;l++)o.push(s(e.materials,this.material[l]));i.material=o}else i.material=s(e.materials,this.material);if(this.children.length>0){i.children=[];for(let o=0;o<this.children.length;o++)i.children.push(this.children[o].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let o=0;o<this.animations.length;o++){const l=this.animations[o];i.animations.push(s(e.animations,l))}}if(n){const o=a(e.geometries),l=a(e.materials),u=a(e.textures),c=a(e.images),d=a(e.shapes),h=a(e.skeletons),p=a(e.animations),f=a(e.nodes);o.length>0&&(r.geometries=o),l.length>0&&(r.materials=l),u.length>0&&(r.textures=u),c.length>0&&(r.images=c),d.length>0&&(r.shapes=d),h.length>0&&(r.skeletons=h),p.length>0&&(r.animations=p),f.length>0&&(r.nodes=f)}return r.object=i,r;function a(o){const l=[];for(const u in o){const c=o[u];delete c.metadata,l.push(c)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,n=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),n===!0)for(let r=0;r<e.children.length;r++){const i=e.children[r];this.add(i.clone())}return this}}Yn.DEFAULT_UP=new Z(0,1,0);Yn.DEFAULT_MATRIX_AUTO_UPDATE=!0;Yn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const nl=new Z,Nu=new Z,yk=new Z,Ru=new Z,Eg=new Z,Ig=new Z,lG=new Z,vk=new Z,xk=new Z,bk=new Z,wk=new Xn,_k=new Xn,Sk=new Xn;class Ia{constructor(e=new Z,n=new Z,r=new Z){this.a=e,this.b=n,this.c=r}static getNormal(e,n,r,i){i.subVectors(r,n),nl.subVectors(e,n),i.cross(nl);const s=i.lengthSq();return s>0?i.multiplyScalar(1/Math.sqrt(s)):i.set(0,0,0)}static getBarycoord(e,n,r,i,s){nl.subVectors(i,n),Nu.subVectors(r,n),yk.subVectors(e,n);const a=nl.dot(nl),o=nl.dot(Nu),l=nl.dot(yk),u=Nu.dot(Nu),c=Nu.dot(yk),d=a*u-o*o;if(d===0)return s.set(0,0,0),null;const h=1/d,p=(u*l-o*c)*h,f=(a*c-o*l)*h;return s.set(1-p-f,f,p)}static containsPoint(e,n,r,i){return this.getBarycoord(e,n,r,i,Ru)===null?!1:Ru.x>=0&&Ru.y>=0&&Ru.x+Ru.y<=1}static getInterpolation(e,n,r,i,s,a,o,l){return this.getBarycoord(e,n,r,i,Ru)===null?(l.x=0,l.y=0,"z"in l&&(l.z=0),"w"in l&&(l.w=0),null):(l.setScalar(0),l.addScaledVector(s,Ru.x),l.addScaledVector(a,Ru.y),l.addScaledVector(o,Ru.z),l)}static getInterpolatedAttribute(e,n,r,i,s,a){return wk.setScalar(0),_k.setScalar(0),Sk.setScalar(0),wk.fromBufferAttribute(e,n),_k.fromBufferAttribute(e,r),Sk.fromBufferAttribute(e,i),a.setScalar(0),a.addScaledVector(wk,s.x),a.addScaledVector(_k,s.y),a.addScaledVector(Sk,s.z),a}static isFrontFacing(e,n,r,i){return nl.subVectors(r,n),Nu.subVectors(e,n),nl.cross(Nu).dot(i)<0}set(e,n,r){return this.a.copy(e),this.b.copy(n),this.c.copy(r),this}setFromPointsAndIndices(e,n,r,i){return this.a.copy(e[n]),this.b.copy(e[r]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,n,r,i){return this.a.fromBufferAttribute(e,n),this.b.fromBufferAttribute(e,r),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return nl.subVectors(this.c,this.b),Nu.subVectors(this.a,this.b),nl.cross(Nu).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Ia.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,n){return Ia.getBarycoord(e,this.a,this.b,this.c,n)}getInterpolation(e,n,r,i,s){return Ia.getInterpolation(e,this.a,this.b,this.c,n,r,i,s)}containsPoint(e){return Ia.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Ia.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,n){const r=this.a,i=this.b,s=this.c;let a,o;Eg.subVectors(i,r),Ig.subVectors(s,r),vk.subVectors(e,r);const l=Eg.dot(vk),u=Ig.dot(vk);if(l<=0&&u<=0)return n.copy(r);xk.subVectors(e,i);const c=Eg.dot(xk),d=Ig.dot(xk);if(c>=0&&d<=c)return n.copy(i);const h=l*d-c*u;if(h<=0&&l>=0&&c<=0)return a=l/(l-c),n.copy(r).addScaledVector(Eg,a);bk.subVectors(e,s);const p=Eg.dot(bk),f=Ig.dot(bk);if(f>=0&&p<=f)return n.copy(s);const g=p*u-l*f;if(g<=0&&u>=0&&f<=0)return o=u/(u-f),n.copy(r).addScaledVector(Ig,o);const y=c*f-p*d;if(y<=0&&d-c>=0&&p-f>=0)return lG.subVectors(s,i),o=(d-c)/(d-c+(p-f)),n.copy(i).addScaledVector(lG,o);const m=1/(y+g+h);return a=g*m,o=h*m,n.copy(r).addScaledVector(Eg,a).addScaledVector(Ig,o)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const p9={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Oc={h:0,s:0,l:0},AS={h:0,s:0,l:0};function Ak(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+(e-t)*6*n:n<1/2?e:n<2/3?t+(e-t)*6*(2/3-n):t}class Ct{constructor(e,n,r){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,n,r)}set(e,n,r){if(n===void 0&&r===void 0){const i=e;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(e,n,r);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,n=Ui){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Qn.colorSpaceToWorking(this,n),this}setRGB(e,n,r,i=Qn.workingColorSpace){return this.r=e,this.g=n,this.b=r,Qn.colorSpaceToWorking(this,i),this}setHSL(e,n,r,i=Qn.workingColorSpace){if(e=EP(e,1),n=En(n,0,1),r=En(r,0,1),n===0)this.r=this.g=this.b=r;else{const s=r<=.5?r*(1+n):r+n-r*n,a=2*r-s;this.r=Ak(a,s,e+1/3),this.g=Ak(a,s,e),this.b=Ak(a,s,e-1/3)}return Qn.colorSpaceToWorking(this,i),this}setStyle(e,n=Ui){function r(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(e)){let s;const a=i[1],o=i[2];switch(a){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return r(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,n);if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return r(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,n);break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return r(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,n);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=i[1],a=s.length;if(a===3)return this.setRGB(parseInt(s.charAt(0),16)/15,parseInt(s.charAt(1),16)/15,parseInt(s.charAt(2),16)/15,n);if(a===6)return this.setHex(parseInt(s,16),n);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,n);return this}setColorName(e,n=Ui){const r=p9[e.toLowerCase()];return r!==void 0?this.setHex(r,n):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=Yu(e.r),this.g=Yu(e.g),this.b=Yu(e.b),this}copyLinearToSRGB(e){return this.r=yy(e.r),this.g=yy(e.g),this.b=yy(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=Ui){return Qn.workingToColorSpace(Rs.copy(this),e),Math.round(En(Rs.r*255,0,255))*65536+Math.round(En(Rs.g*255,0,255))*256+Math.round(En(Rs.b*255,0,255))}getHexString(e=Ui){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,n=Qn.workingColorSpace){Qn.workingToColorSpace(Rs.copy(this),n);const r=Rs.r,i=Rs.g,s=Rs.b,a=Math.max(r,i,s),o=Math.min(r,i,s);let l,u;const c=(o+a)/2;if(o===a)l=0,u=0;else{const d=a-o;switch(u=c<=.5?d/(a+o):d/(2-a-o),a){case r:l=(i-s)/d+(i<s?6:0);break;case i:l=(s-r)/d+2;break;case s:l=(r-i)/d+4;break}l/=6}return e.h=l,e.s=u,e.l=c,e}getRGB(e,n=Qn.workingColorSpace){return Qn.workingToColorSpace(Rs.copy(this),n),e.r=Rs.r,e.g=Rs.g,e.b=Rs.b,e}getStyle(e=Ui){Qn.workingToColorSpace(Rs.copy(this),e);const n=Rs.r,r=Rs.g,i=Rs.b;return e!==Ui?`color(${e} ${n.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(n*255)},${Math.round(r*255)},${Math.round(i*255)})`}offsetHSL(e,n,r){return this.getHSL(Oc),this.setHSL(Oc.h+e,Oc.s+n,Oc.l+r)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,n){return this.r=e.r+n.r,this.g=e.g+n.g,this.b=e.b+n.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,n){return this.r+=(e.r-this.r)*n,this.g+=(e.g-this.g)*n,this.b+=(e.b-this.b)*n,this}lerpColors(e,n,r){return this.r=e.r+(n.r-e.r)*r,this.g=e.g+(n.g-e.g)*r,this.b=e.b+(n.b-e.b)*r,this}lerpHSL(e,n){this.getHSL(Oc),e.getHSL(AS);const r=Ab(Oc.h,AS.h,n),i=Ab(Oc.s,AS.s,n),s=Ab(Oc.l,AS.l,n);return this.setHSL(r,i,s),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const n=this.r,r=this.g,i=this.b,s=e.elements;return this.r=s[0]*n+s[3]*r+s[6]*i,this.g=s[1]*n+s[4]*r+s[7]*i,this.b=s[2]*n+s[5]*r+s[8]*i,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,n=0){return this.r=e[n],this.g=e[n+1],this.b=e[n+2],this}toArray(e=[],n=0){return e[n]=this.r,e[n+1]=this.g,e[n+2]=this.b,e}fromBufferAttribute(e,n){return this.r=e.getX(n),this.g=e.getY(n),this.b=e.getZ(n),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Rs=new Ct;Ct.NAMES=p9;let Hue=0;class Ki extends gu{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Hue++}),this.uuid=ao(),this.name="",this.type="Material",this.blending=Sp,this.side=lu,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=DE,this.blendDst=PE,this.blendEquation=nd,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Ct(0,0,0),this.blendAlpha=0,this.depthFunc=Bp,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=zR,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Jh,this.stencilZFail=Jh,this.stencilZPass=Jh,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const n in e){const r=e[n];if(r===void 0){console.warn(`THREE.Material: parameter '${n}' has value of undefined.`);continue}const i=this[n];if(i===void 0){console.warn(`THREE.Material: '${n}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(r):i&&i.isVector3&&r&&r.isVector3?i.copy(r):this[n]=r}}toJSON(e){const n=e===void 0||typeof e=="string";n&&(e={textures:{},images:{}});const r={metadata:{version:4.7,type:"Material",generator:"Material.toJSON"}};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.color&&this.color.isColor&&(r.color=this.color.getHex()),this.roughness!==void 0&&(r.roughness=this.roughness),this.metalness!==void 0&&(r.metalness=this.metalness),this.sheen!==void 0&&(r.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(r.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(r.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(r.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(r.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(r.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(r.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(r.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(r.shininess=this.shininess),this.clearcoat!==void 0&&(r.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(r.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(r.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(r.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(r.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,r.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(r.dispersion=this.dispersion),this.iridescence!==void 0&&(r.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(r.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(r.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(r.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(r.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(r.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(r.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(r.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(r.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(r.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(r.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(r.lightMap=this.lightMap.toJSON(e).uuid,r.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(r.aoMap=this.aoMap.toJSON(e).uuid,r.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(r.bumpMap=this.bumpMap.toJSON(e).uuid,r.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(r.normalMap=this.normalMap.toJSON(e).uuid,r.normalMapType=this.normalMapType,r.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(r.displacementMap=this.displacementMap.toJSON(e).uuid,r.displacementScale=this.displacementScale,r.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(r.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(r.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(r.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(r.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(r.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(r.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(r.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(r.combine=this.combine)),this.envMapRotation!==void 0&&(r.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(r.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(r.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(r.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(r.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(r.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(r.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(r.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(r.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(r.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(r.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(r.size=this.size),this.shadowSide!==null&&(r.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(r.sizeAttenuation=this.sizeAttenuation),this.blending!==Sp&&(r.blending=this.blending),this.side!==lu&&(r.side=this.side),this.vertexColors===!0&&(r.vertexColors=!0),this.opacity<1&&(r.opacity=this.opacity),this.transparent===!0&&(r.transparent=!0),this.blendSrc!==DE&&(r.blendSrc=this.blendSrc),this.blendDst!==PE&&(r.blendDst=this.blendDst),this.blendEquation!==nd&&(r.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(r.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(r.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(r.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(r.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(r.blendAlpha=this.blendAlpha),this.depthFunc!==Bp&&(r.depthFunc=this.depthFunc),this.depthTest===!1&&(r.depthTest=this.depthTest),this.depthWrite===!1&&(r.depthWrite=this.depthWrite),this.colorWrite===!1&&(r.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(r.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==zR&&(r.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(r.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(r.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Jh&&(r.stencilFail=this.stencilFail),this.stencilZFail!==Jh&&(r.stencilZFail=this.stencilZFail),this.stencilZPass!==Jh&&(r.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(r.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(r.rotation=this.rotation),this.polygonOffset===!0&&(r.polygonOffset=!0),this.polygonOffsetFactor!==0&&(r.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(r.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(r.linewidth=this.linewidth),this.dashSize!==void 0&&(r.dashSize=this.dashSize),this.gapSize!==void 0&&(r.gapSize=this.gapSize),this.scale!==void 0&&(r.scale=this.scale),this.dithering===!0&&(r.dithering=!0),this.alphaTest>0&&(r.alphaTest=this.alphaTest),this.alphaHash===!0&&(r.alphaHash=!0),this.alphaToCoverage===!0&&(r.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(r.premultipliedAlpha=!0),this.forceSinglePass===!0&&(r.forceSinglePass=!0),this.wireframe===!0&&(r.wireframe=!0),this.wireframeLinewidth>1&&(r.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(r.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(r.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(r.flatShading=!0),this.visible===!1&&(r.visible=!1),this.toneMapped===!1&&(r.toneMapped=!1),this.fog===!1&&(r.fog=!1),Object.keys(this.userData).length>0&&(r.userData=this.userData);function i(s){const a=[];for(const o in s){const l=s[o];delete l.metadata,a.push(l)}return a}if(n){const s=i(e.textures),a=i(e.images);s.length>0&&(r.textures=s),a.length>0&&(r.images=a)}return r}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const n=e.clippingPlanes;let r=null;if(n!==null){const i=n.length;r=new Array(i);for(let s=0;s!==i;++s)r[s]=n[s].clone()}return this.clippingPlanes=r,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}class ka extends Ki{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Ct(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ba,this.combine=U1,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const Gu=Wue();function Wue(){const t=new ArrayBuffer(4),e=new Float32Array(t),n=new Uint32Array(t),r=new Uint32Array(512),i=new Uint32Array(512);for(let l=0;l<256;++l){const u=l-127;u<-27?(r[l]=0,r[l|256]=32768,i[l]=24,i[l|256]=24):u<-14?(r[l]=1024>>-u-14,r[l|256]=1024>>-u-14|32768,i[l]=-u-1,i[l|256]=-u-1):u<=15?(r[l]=u+15<<10,r[l|256]=u+15<<10|32768,i[l]=13,i[l|256]=13):u<128?(r[l]=31744,r[l|256]=64512,i[l]=24,i[l|256]=24):(r[l]=31744,r[l|256]=64512,i[l]=13,i[l|256]=13)}const s=new Uint32Array(2048),a=new Uint32Array(64),o=new Uint32Array(64);for(let l=1;l<1024;++l){let u=l<<13,c=0;for(;!(u&8388608);)u<<=1,c-=8388608;u&=-8388609,c+=947912704,s[l]=u|c}for(let l=1024;l<2048;++l)s[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)a[l]=l<<23;a[31]=1199570944,a[32]=2147483648;for(let l=33;l<63;++l)a[l]=2147483648+(l-32<<23);a[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(o[l]=1024);return{floatView:e,uint32View:n,baseTable:r,shiftTable:i,mantissaTable:s,exponentTable:a,offsetTable:o}}function wa(t){Math.abs(t)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),t=En(t,-65504,65504),Gu.floatView[0]=t;const e=Gu.uint32View[0],n=e>>23&511;return Gu.baseTable[n]+((e&8388607)>>Gu.shiftTable[n])}function qx(t){const e=t>>10;return Gu.uint32View[0]=Gu.mantissaTable[Gu.offsetTable[e]+(t&1023)]+Gu.exponentTable[e],Gu.floatView[0]}class mp{static toHalfFloat(e){return wa(e)}static fromHalfFloat(e){return qx(e)}}const Ii=new Z,ES=new Qe;let Vue=0;class Ln{constructor(e,n,r=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:Vue++}),this.name="",this.array=e,this.itemSize=n,this.count=e!==void 0?e.length/n:0,this.normalized=r,this.usage=r1,this.updateRanges=[],this.gpuType=ti,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,n){this.updateRanges.push({start:e,count:n})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,n,r){e*=this.itemSize,r*=n.itemSize;for(let i=0,s=this.itemSize;i<s;i++)this.array[e+i]=n.array[r+i];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let n=0,r=this.count;n<r;n++)ES.fromBufferAttribute(this,n),ES.applyMatrix3(e),this.setXY(n,ES.x,ES.y);else if(this.itemSize===3)for(let n=0,r=this.count;n<r;n++)Ii.fromBufferAttribute(this,n),Ii.applyMatrix3(e),this.setXYZ(n,Ii.x,Ii.y,Ii.z);return this}applyMatrix4(e){for(let n=0,r=this.count;n<r;n++)Ii.fromBufferAttribute(this,n),Ii.applyMatrix4(e),this.setXYZ(n,Ii.x,Ii.y,Ii.z);return this}applyNormalMatrix(e){for(let n=0,r=this.count;n<r;n++)Ii.fromBufferAttribute(this,n),Ii.applyNormalMatrix(e),this.setXYZ(n,Ii.x,Ii.y,Ii.z);return this}transformDirection(e){for(let n=0,r=this.count;n<r;n++)Ii.fromBufferAttribute(this,n),Ii.transformDirection(e),this.setXYZ(n,Ii.x,Ii.y,Ii.z);return this}set(e,n=0){return this.array.set(e,n),this}getComponent(e,n){let r=this.array[e*this.itemSize+n];return this.normalized&&(r=na(r,this.array)),r}setComponent(e,n,r){return this.normalized&&(r=Fn(r,this.array)),this.array[e*this.itemSize+n]=r,this}getX(e){let n=this.array[e*this.itemSize];return this.normalized&&(n=na(n,this.array)),n}setX(e,n){return this.normalized&&(n=Fn(n,this.array)),this.array[e*this.itemSize]=n,this}getY(e){let n=this.array[e*this.itemSize+1];return this.normalized&&(n=na(n,this.array)),n}setY(e,n){return this.normalized&&(n=Fn(n,this.array)),this.array[e*this.itemSize+1]=n,this}getZ(e){let n=this.array[e*this.itemSize+2];return this.normalized&&(n=na(n,this.array)),n}setZ(e,n){return this.normalized&&(n=Fn(n,this.array)),this.array[e*this.itemSize+2]=n,this}getW(e){let n=this.array[e*this.itemSize+3];return this.normalized&&(n=na(n,this.array)),n}setW(e,n){return this.normalized&&(n=Fn(n,this.array)),this.array[e*this.itemSize+3]=n,this}setXY(e,n,r){return e*=this.itemSize,this.normalized&&(n=Fn(n,this.array),r=Fn(r,this.array)),this.array[e+0]=n,this.array[e+1]=r,this}setXYZ(e,n,r,i){return e*=this.itemSize,this.normalized&&(n=Fn(n,this.array),r=Fn(r,this.array),i=Fn(i,this.array)),this.array[e+0]=n,this.array[e+1]=r,this.array[e+2]=i,this}setXYZW(e,n,r,i,s){return e*=this.itemSize,this.normalized&&(n=Fn(n,this.array),r=Fn(r,this.array),i=Fn(i,this.array),s=Fn(s,this.array)),this.array[e+0]=n,this.array[e+1]=r,this.array[e+2]=i,this.array[e+3]=s,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==r1&&(e.usage=this.usage),e}}class jue extends Ln{constructor(e,n,r){super(new Int8Array(e),n,r)}}class Xue extends Ln{constructor(e,n,r){super(new Uint8Array(e),n,r)}}class Kue extends Ln{constructor(e,n,r){super(new Uint8ClampedArray(e),n,r)}}class que extends Ln{constructor(e,n,r){super(new Int16Array(e),n,r)}}class CP extends Ln{constructor(e,n,r){super(new Uint16Array(e),n,r)}}class Jue extends Ln{constructor(e,n,r){super(new Int32Array(e),n,r)}}class MP extends Ln{constructor(e,n,r){super(new Uint32Array(e),n,r)}}class Yue extends Ln{constructor(e,n,r){super(new Uint16Array(e),n,r),this.isFloat16BufferAttribute=!0}getX(e){let n=qx(this.array[e*this.itemSize]);return this.normalized&&(n=na(n,this.array)),n}setX(e,n){return this.normalized&&(n=Fn(n,this.array)),this.array[e*this.itemSize]=wa(n),this}getY(e){let n=qx(this.array[e*this.itemSize+1]);return this.normalized&&(n=na(n,this.array)),n}setY(e,n){return this.normalized&&(n=Fn(n,this.array)),this.array[e*this.itemSize+1]=wa(n),this}getZ(e){let n=qx(this.array[e*this.itemSize+2]);return this.normalized&&(n=na(n,this.array)),n}setZ(e,n){return this.normalized&&(n=Fn(n,this.array)),this.array[e*this.itemSize+2]=wa(n),this}getW(e){let n=qx(this.array[e*this.itemSize+3]);return this.normalized&&(n=na(n,this.array)),n}setW(e,n){return this.normalized&&(n=Fn(n,this.array)),this.array[e*this.itemSize+3]=wa(n),this}setXY(e,n,r){return e*=this.itemSize,this.normalized&&(n=Fn(n,this.array),r=Fn(r,this.array)),this.array[e+0]=wa(n),this.array[e+1]=wa(r),this}setXYZ(e,n,r,i){return e*=this.itemSize,this.normalized&&(n=Fn(n,this.array),r=Fn(r,this.array),i=Fn(i,this.array)),this.array[e+0]=wa(n),this.array[e+1]=wa(r),this.array[e+2]=wa(i),this}setXYZW(e,n,r,i,s){return e*=this.itemSize,this.normalized&&(n=Fn(n,this.array),r=Fn(r,this.array),i=Fn(i,this.array),s=Fn(s,this.array)),this.array[e+0]=wa(n),this.array[e+1]=wa(r),this.array[e+2]=wa(i),this.array[e+3]=wa(s),this}}class Jt extends Ln{constructor(e,n,r){super(new Float32Array(e),n,r)}}let Zue=0;const Eo=new ln,Ek=new Yn,Tg=new Z,Ya=new ds,xx=new ds,is=new Z;class An extends gu{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Zue++}),this.uuid=ao(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(d9(e)?MP:CP)(e,1):this.index=e,this}setIndirect(e){return this.indirect=e,this}getIndirect(){return this.indirect}getAttribute(e){return this.attributes[e]}setAttribute(e,n){return this.attributes[e]=n,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,n,r=0){this.groups.push({start:e,count:n,materialIndex:r})}clearGroups(){this.groups=[]}setDrawRange(e,n){this.drawRange.start=e,this.drawRange.count=n}applyMatrix4(e){const n=this.attributes.position;n!==void 0&&(n.applyMatrix4(e),n.needsUpdate=!0);const r=this.attributes.normal;if(r!==void 0){const s=new Mn().getNormalMatrix(e);r.applyNormalMatrix(s),r.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Eo.makeRotationFromQuaternion(e),this.applyMatrix4(Eo),this}rotateX(e){return Eo.makeRotationX(e),this.applyMatrix4(Eo),this}rotateY(e){return Eo.makeRotationY(e),this.applyMatrix4(Eo),this}rotateZ(e){return Eo.makeRotationZ(e),this.applyMatrix4(Eo),this}translate(e,n,r){return Eo.makeTranslation(e,n,r),this.applyMatrix4(Eo),this}scale(e,n,r){return Eo.makeScale(e,n,r),this.applyMatrix4(Eo),this}lookAt(e){return Ek.lookAt(e),Ek.updateMatrix(),this.applyMatrix4(Ek.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Tg).negate(),this.translate(Tg.x,Tg.y,Tg.z),this}setFromPoints(e){const n=this.getAttribute("position");if(n===void 0){const r=[];for(let i=0,s=e.length;i<s;i++){const a=e[i];r.push(a.x,a.y,a.z||0)}this.setAttribute("position",new Jt(r,3))}else{const r=Math.min(e.length,n.count);for(let i=0;i<r;i++){const s=e[i];n.setXYZ(i,s.x,s.y,s.z||0)}e.length>n.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),n.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new ds);const e=this.attributes.position,n=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new Z(-1/0,-1/0,-1/0),new Z(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),n)for(let r=0,i=n.length;r<i;r++){const s=n[r];Ya.setFromBufferAttribute(s),this.morphTargetsRelative?(is.addVectors(this.boundingBox.min,Ya.min),this.boundingBox.expandByPoint(is),is.addVectors(this.boundingBox.max,Ya.max),this.boundingBox.expandByPoint(is)):(this.boundingBox.expandByPoint(Ya.min),this.boundingBox.expandByPoint(Ya.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Xi);const e=this.attributes.position,n=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new Z,1/0);return}if(e){const r=this.boundingSphere.center;if(Ya.setFromBufferAttribute(e),n)for(let s=0,a=n.length;s<a;s++){const o=n[s];xx.setFromBufferAttribute(o),this.morphTargetsRelative?(is.addVectors(Ya.min,xx.min),Ya.expandByPoint(is),is.addVectors(Ya.max,xx.max),Ya.expandByPoint(is)):(Ya.expandByPoint(xx.min),Ya.expandByPoint(xx.max))}Ya.getCenter(r);let i=0;for(let s=0,a=e.count;s<a;s++)is.fromBufferAttribute(e,s),i=Math.max(i,r.distanceToSquared(is));if(n)for(let s=0,a=n.length;s<a;s++){const o=n[s],l=this.morphTargetsRelative;for(let u=0,c=o.count;u<c;u++)is.fromBufferAttribute(o,u),l&&(Tg.fromBufferAttribute(e,u),is.add(Tg)),i=Math.max(i,r.distanceToSquared(is))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,n=this.attributes;if(e===null||n.position===void 0||n.normal===void 0||n.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const r=n.position,i=n.normal,s=n.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Ln(new Float32Array(4*r.count),4));const a=this.getAttribute("tangent"),o=[],l=[];for(let T=0;T<r.count;T++)o[T]=new Z,l[T]=new Z;const u=new Z,c=new Z,d=new Z,h=new Qe,p=new Qe,f=new Qe,g=new Z,y=new Z;function m(T,M,k){u.fromBufferAttribute(r,T),c.fromBufferAttribute(r,M),d.fromBufferAttribute(r,k),h.fromBufferAttribute(s,T),p.fromBufferAttribute(s,M),f.fromBufferAttribute(s,k),c.sub(u),d.sub(u),p.sub(h),f.sub(h);const R=1/(p.x*f.y-f.x*p.y);isFinite(R)&&(g.copy(c).multiplyScalar(f.y).addScaledVector(d,-p.y).multiplyScalar(R),y.copy(d).multiplyScalar(p.x).addScaledVector(c,-f.x).multiplyScalar(R),o[T].add(g),o[M].add(g),o[k].add(g),l[T].add(y),l[M].add(y),l[k].add(y))}let b=this.groups;b.length===0&&(b=[{start:0,count:e.count}]);for(let T=0,M=b.length;T<M;++T){const k=b[T],R=k.start,N=k.count;for(let B=R,z=R+N;B<z;B+=3)m(e.getX(B+0),e.getX(B+1),e.getX(B+2))}const w=new Z,_=new Z,S=new Z,E=new Z;function C(T){S.fromBufferAttribute(i,T),E.copy(S);const M=o[T];w.copy(M),w.sub(S.multiplyScalar(S.dot(M))).normalize(),_.crossVectors(E,M);const R=_.dot(l[T])<0?-1:1;a.setXYZW(T,w.x,w.y,w.z,R)}for(let T=0,M=b.length;T<M;++T){const k=b[T],R=k.start,N=k.count;for(let B=R,z=R+N;B<z;B+=3)C(e.getX(B+0)),C(e.getX(B+1)),C(e.getX(B+2))}}computeVertexNormals(){const e=this.index,n=this.getAttribute("position");if(n!==void 0){let r=this.getAttribute("normal");if(r===void 0)r=new Ln(new Float32Array(n.count*3),3),this.setAttribute("normal",r);else for(let h=0,p=r.count;h<p;h++)r.setXYZ(h,0,0,0);const i=new Z,s=new Z,a=new Z,o=new Z,l=new Z,u=new Z,c=new Z,d=new Z;if(e)for(let h=0,p=e.count;h<p;h+=3){const f=e.getX(h+0),g=e.getX(h+1),y=e.getX(h+2);i.fromBufferAttribute(n,f),s.fromBufferAttribute(n,g),a.fromBufferAttribute(n,y),c.subVectors(a,s),d.subVectors(i,s),c.cross(d),o.fromBufferAttribute(r,f),l.fromBufferAttribute(r,g),u.fromBufferAttribute(r,y),o.add(c),l.add(c),u.add(c),r.setXYZ(f,o.x,o.y,o.z),r.setXYZ(g,l.x,l.y,l.z),r.setXYZ(y,u.x,u.y,u.z)}else for(let h=0,p=n.count;h<p;h+=3)i.fromBufferAttribute(n,h+0),s.fromBufferAttribute(n,h+1),a.fromBufferAttribute(n,h+2),c.subVectors(a,s),d.subVectors(i,s),c.cross(d),r.setXYZ(h+0,c.x,c.y,c.z),r.setXYZ(h+1,c.x,c.y,c.z),r.setXYZ(h+2,c.x,c.y,c.z);this.normalizeNormals(),r.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let n=0,r=e.count;n<r;n++)is.fromBufferAttribute(e,n),is.normalize(),e.setXYZ(n,is.x,is.y,is.z)}toNonIndexed(){function e(o,l){const u=o.array,c=o.itemSize,d=o.normalized,h=new u.constructor(l.length*c);let p=0,f=0;for(let g=0,y=l.length;g<y;g++){o.isInterleavedBufferAttribute?p=l[g]*o.data.stride+o.offset:p=l[g]*c;for(let m=0;m<c;m++)h[f++]=u[p++]}return new Ln(h,c,d)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const n=new An,r=this.index.array,i=this.attributes;for(const o in i){const l=i[o],u=e(l,r);n.setAttribute(o,u)}const s=this.morphAttributes;for(const o in s){const l=[],u=s[o];for(let c=0,d=u.length;c<d;c++){const h=u[c],p=e(h,r);l.push(p)}n.morphAttributes[o]=l}n.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let o=0,l=a.length;o<l;o++){const u=a[o];n.addGroup(u.start,u.count,u.materialIndex)}return n}toJSON(){const e={metadata:{version:4.7,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const u in l)l[u]!==void 0&&(e[u]=l[u]);return e}e.data={attributes:{}};const n=this.index;n!==null&&(e.data.index={type:n.array.constructor.name,array:Array.prototype.slice.call(n.array)});const r=this.attributes;for(const l in r){const u=r[l];e.data.attributes[l]=u.toJSON(e.data)}const i={};let s=!1;for(const l in this.morphAttributes){const u=this.morphAttributes[l],c=[];for(let d=0,h=u.length;d<h;d++){const p=u[d];c.push(p.toJSON(e.data))}c.length>0&&(i[l]=c,s=!0)}s&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(e.data.groups=JSON.parse(JSON.stringify(a)));const o=this.boundingSphere;return o!==null&&(e.data.boundingSphere=o.toJSON()),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const n={};this.name=e.name;const r=e.index;r!==null&&this.setIndex(r.clone());const i=e.attributes;for(const u in i){const c=i[u];this.setAttribute(u,c.clone(n))}const s=e.morphAttributes;for(const u in s){const c=[],d=s[u];for(let h=0,p=d.length;h<p;h++)c.push(d[h].clone(n));this.morphAttributes[u]=c}this.morphTargetsRelative=e.morphTargetsRelative;const a=e.groups;for(let u=0,c=a.length;u<c;u++){const d=a[u];this.addGroup(d.start,d.count,d.materialIndex)}const o=e.boundingBox;o!==null&&(this.boundingBox=o.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const uG=new ln,Mh=new xf,IS=new Xi,cG=new Z,TS=new Z,CS=new Z,MS=new Z,Ik=new Z,kS=new Z,dG=new Z,NS=new Z;class Cr extends Yn{constructor(e=new An,n=new ka){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=n,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(e,n){return super.copy(e,n),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const n=this.geometry.morphAttributes,r=Object.keys(n);if(r.length>0){const i=n[r[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const o=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}getVertexPosition(e,n){const r=this.geometry,i=r.attributes.position,s=r.morphAttributes.position,a=r.morphTargetsRelative;n.fromBufferAttribute(i,e);const o=this.morphTargetInfluences;if(s&&o){kS.set(0,0,0);for(let l=0,u=s.length;l<u;l++){const c=o[l],d=s[l];c!==0&&(Ik.fromBufferAttribute(d,e),a?kS.addScaledVector(Ik,c):kS.addScaledVector(Ik.sub(n),c))}n.add(kS)}return n}raycast(e,n){const r=this.geometry,i=this.material,s=this.matrixWorld;i!==void 0&&(r.boundingSphere===null&&r.computeBoundingSphere(),IS.copy(r.boundingSphere),IS.applyMatrix4(s),Mh.copy(e.ray).recast(e.near),!(IS.containsPoint(Mh.origin)===!1&&(Mh.intersectSphere(IS,cG)===null||Mh.origin.distanceToSquared(cG)>(e.far-e.near)**2))&&(uG.copy(s).invert(),Mh.copy(e.ray).applyMatrix4(uG),!(r.boundingBox!==null&&Mh.intersectsBox(r.boundingBox)===!1)&&this._computeIntersections(e,n,Mh)))}_computeIntersections(e,n,r){let i;const s=this.geometry,a=this.material,o=s.index,l=s.attributes.position,u=s.attributes.uv,c=s.attributes.uv1,d=s.attributes.normal,h=s.groups,p=s.drawRange;if(o!==null)if(Array.isArray(a))for(let f=0,g=h.length;f<g;f++){const y=h[f],m=a[y.materialIndex],b=Math.max(y.start,p.start),w=Math.min(o.count,Math.min(y.start+y.count,p.start+p.count));for(let _=b,S=w;_<S;_+=3){const E=o.getX(_),C=o.getX(_+1),T=o.getX(_+2);i=RS(this,m,e,r,u,c,d,E,C,T),i&&(i.faceIndex=Math.floor(_/3),i.face.materialIndex=y.materialIndex,n.push(i))}}else{const f=Math.max(0,p.start),g=Math.min(o.count,p.start+p.count);for(let y=f,m=g;y<m;y+=3){const b=o.getX(y),w=o.getX(y+1),_=o.getX(y+2);i=RS(this,a,e,r,u,c,d,b,w,_),i&&(i.faceIndex=Math.floor(y/3),n.push(i))}}else if(l!==void 0)if(Array.isArray(a))for(let f=0,g=h.length;f<g;f++){const y=h[f],m=a[y.materialIndex],b=Math.max(y.start,p.start),w=Math.min(l.count,Math.min(y.start+y.count,p.start+p.count));for(let _=b,S=w;_<S;_+=3){const E=_,C=_+1,T=_+2;i=RS(this,m,e,r,u,c,d,E,C,T),i&&(i.faceIndex=Math.floor(_/3),i.face.materialIndex=y.materialIndex,n.push(i))}}else{const f=Math.max(0,p.start),g=Math.min(l.count,p.start+p.count);for(let y=f,m=g;y<m;y+=3){const b=y,w=y+1,_=y+2;i=RS(this,a,e,r,u,c,d,b,w,_),i&&(i.faceIndex=Math.floor(y/3),n.push(i))}}}}function Que(t,e,n,r,i,s,a,o){let l;if(e.side===sa?l=r.intersectTriangle(a,s,i,!0,o):l=r.intersectTriangle(i,s,a,e.side===lu,o),l===null)return null;NS.copy(o),NS.applyMatrix4(t.matrixWorld);const u=n.ray.origin.distanceTo(NS);return u<n.near||u>n.far?null:{distance:u,point:NS.clone(),object:t}}function RS(t,e,n,r,i,s,a,o,l,u){t.getVertexPosition(o,TS),t.getVertexPosition(l,CS),t.getVertexPosition(u,MS);const c=Que(t,e,n,r,TS,CS,MS,dG);if(c){const d=new Z;Ia.getBarycoord(dG,TS,CS,MS,d),i&&(c.uv=Ia.getInterpolatedAttribute(i,o,l,u,d,new Qe)),s&&(c.uv1=Ia.getInterpolatedAttribute(s,o,l,u,d,new Qe)),a&&(c.normal=Ia.getInterpolatedAttribute(a,o,l,u,d,new Z),c.normal.dot(r.direction)>0&&c.normal.multiplyScalar(-1));const h={a:o,b:l,c:u,normal:new Z,materialIndex:0};Ia.getNormal(TS,CS,MS,h.normal),c.face=h,c.barycoord=d}return c}class bf extends An{constructor(e=1,n=1,r=1,i=1,s=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:n,depth:r,widthSegments:i,heightSegments:s,depthSegments:a};const o=this;i=Math.floor(i),s=Math.floor(s),a=Math.floor(a);const l=[],u=[],c=[],d=[];let h=0,p=0;f("z","y","x",-1,-1,r,n,e,a,s,0),f("z","y","x",1,-1,r,n,-e,a,s,1),f("x","z","y",1,1,e,r,n,i,a,2),f("x","z","y",1,-1,e,r,-n,i,a,3),f("x","y","z",1,-1,e,n,r,i,s,4),f("x","y","z",-1,-1,e,n,-r,i,s,5),this.setIndex(l),this.setAttribute("position",new Jt(u,3)),this.setAttribute("normal",new Jt(c,3)),this.setAttribute("uv",new Jt(d,2));function f(g,y,m,b,w,_,S,E,C,T,M){const k=_/C,R=S/T,N=_/2,B=S/2,z=E/2,V=C+1,K=T+1;let Q=0,O=0;const j=new Z;for(let X=0;X<K;X++){const te=X*R-B;for(let le=0;le<V;le++){const ge=le*k-N;j[g]=ge*b,j[y]=te*w,j[m]=z,u.push(j.x,j.y,j.z),j[g]=0,j[y]=0,j[m]=E>0?1:-1,c.push(j.x,j.y,j.z),d.push(le/C),d.push(1-X/T),Q+=1}}for(let X=0;X<T;X++)for(let te=0;te<C;te++){const le=h+te+V*X,ge=h+te+V*(X+1),ie=h+(te+1)+V*(X+1),we=h+(te+1)+V*X;l.push(le,ge,we),l.push(ge,ie,we),O+=6}o.addGroup(p,O,M),p+=O,h+=Q}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new bf(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function $y(t){const e={};for(const n in t){e[n]={};for(const r in t[n]){const i=t[n][r];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[n][r]=null):e[n][r]=i.clone():Array.isArray(i)?e[n][r]=i.slice():e[n][r]=i}}return e}function Zs(t){const e={};for(let n=0;n<t.length;n++){const r=$y(t[n]);for(const i in r)e[i]=r[i]}return e}function ece(t){const e=[];for(let n=0;n<t.length;n++)e.push(t[n].clone());return e}function f9(t){const e=t.getRenderTarget();return e===null?t.outputColorSpace:e.isXRRenderTarget===!0?e.texture.colorSpace:Qn.workingColorSpace}const kP={clone:$y,merge:Zs};var tce=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,nce=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class ua extends Ki{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=tce,this.fragmentShader=nce,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=$y(e.uniforms),this.uniformsGroups=ece(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const n=super.toJSON(e);n.glslVersion=this.glslVersion,n.uniforms={};for(const i in this.uniforms){const a=this.uniforms[i].value;a&&a.isTexture?n.uniforms[i]={type:"t",value:a.toJSON(e).uuid}:a&&a.isColor?n.uniforms[i]={type:"c",value:a.getHex()}:a&&a.isVector2?n.uniforms[i]={type:"v2",value:a.toArray()}:a&&a.isVector3?n.uniforms[i]={type:"v3",value:a.toArray()}:a&&a.isVector4?n.uniforms[i]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?n.uniforms[i]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?n.uniforms[i]={type:"m4",value:a.toArray()}:n.uniforms[i]={value:a}}Object.keys(this.defines).length>0&&(n.defines=this.defines),n.vertexShader=this.vertexShader,n.fragmentShader=this.fragmentShader,n.lights=this.lights,n.clipping=this.clipping;const r={};for(const i in this.extensions)this.extensions[i]===!0&&(r[i]=!0);return Object.keys(r).length>0&&(n.extensions=r),n}}class W1 extends Yn{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new ln,this.projectionMatrix=new ln,this.projectionMatrixInverse=new ln,this.coordinateSystem=Oo}copy(e,n){return super.copy(e,n),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,n){super.updateWorldMatrix(e,n),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const Bc=new Z,hG=new Qe,pG=new Qe;class Qr extends W1{constructor(e=50,n=1,r=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=r,this.far=i,this.focus=10,this.aspect=n,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,n){return super.copy(e,n),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const n=.5*this.getFilmHeight()/e;this.fov=Uy*2*Math.atan(n),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Ep*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return Uy*2*Math.atan(Math.tan(Ep*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,n,r){Bc.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),n.set(Bc.x,Bc.y).multiplyScalar(-e/Bc.z),Bc.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),r.set(Bc.x,Bc.y).multiplyScalar(-e/Bc.z)}getViewSize(e,n){return this.getViewBounds(e,hG,pG),n.subVectors(pG,hG)}setViewOffset(e,n,r,i,s,a){this.aspect=e/n,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=n,this.view.offsetX=r,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let n=e*Math.tan(Ep*.5*this.fov)/this.zoom,r=2*n,i=this.aspect*r,s=-.5*i;const a=this.view;if(this.view!==null&&this.view.enabled){const l=a.fullWidth,u=a.fullHeight;s+=a.offsetX*i/l,n-=a.offsetY*r/u,i*=a.width/l,r*=a.height/u}const o=this.filmOffset;o!==0&&(s+=e*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+i,n,n-r,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const n=super.toJSON(e);return n.object.fov=this.fov,n.object.zoom=this.zoom,n.object.near=this.near,n.object.far=this.far,n.object.focus=this.focus,n.object.aspect=this.aspect,this.view!==null&&(n.object.view=Object.assign({},this.view)),n.object.filmGauge=this.filmGauge,n.object.filmOffset=this.filmOffset,n}}const Cg=-90,Mg=1;class m9 extends Yn{constructor(e,n,r){super(),this.type="CubeCamera",this.renderTarget=r,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new Qr(Cg,Mg,e,n);i.layers=this.layers,this.add(i);const s=new Qr(Cg,Mg,e,n);s.layers=this.layers,this.add(s);const a=new Qr(Cg,Mg,e,n);a.layers=this.layers,this.add(a);const o=new Qr(Cg,Mg,e,n);o.layers=this.layers,this.add(o);const l=new Qr(Cg,Mg,e,n);l.layers=this.layers,this.add(l);const u=new Qr(Cg,Mg,e,n);u.layers=this.layers,this.add(u)}updateCoordinateSystem(){const e=this.coordinateSystem,n=this.children.concat(),[r,i,s,a,o,l]=n;for(const u of n)this.remove(u);if(e===Oo)r.up.set(0,1,0),r.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),a.up.set(0,0,1),a.lookAt(0,-1,0),o.up.set(0,1,0),o.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(e===i1)r.up.set(0,-1,0),r.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),a.up.set(0,0,-1),a.lookAt(0,-1,0),o.up.set(0,-1,0),o.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const u of n)this.add(u),u.updateMatrixWorld()}update(e,n){this.parent===null&&this.updateMatrixWorld();const{renderTarget:r,activeMipmapLevel:i}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[s,a,o,l,u,c]=this.children,d=e.getRenderTarget(),h=e.getActiveCubeFace(),p=e.getActiveMipmapLevel(),f=e.xr.enabled;e.xr.enabled=!1;const g=r.texture.generateMipmaps;r.texture.generateMipmaps=!1,e.setRenderTarget(r,0,i),e.render(n,s),e.setRenderTarget(r,1,i),e.render(n,a),e.setRenderTarget(r,2,i),e.render(n,o),e.setRenderTarget(r,3,i),e.render(n,l),e.setRenderTarget(r,4,i),e.render(n,u),r.texture.generateMipmaps=g,e.setRenderTarget(r,5,i),e.render(n,c),e.setRenderTarget(d,h,p),e.xr.enabled=f,r.texture.needsPMREMUpdate=!0}}class V1 extends hr{constructor(e=[],n=uu,r,i,s,a,o,l,u,c){super(e,n,r,i,s,a,o,l,u,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class NP extends Oa{constructor(e=1,n={}){super(e,e,n),this.isWebGLCubeRenderTarget=!0;const r={width:e,height:e,depth:1},i=[r,r,r,r,r,r];this.texture=new V1(i),this._setTextureOptions(n),this.texture.isRenderTargetTexture=!0}fromEquirectangularTexture(e,n){this.texture.type=n.type,this.texture.colorSpace=n.colorSpace,this.texture.generateMipmaps=n.generateMipmaps,this.texture.minFilter=n.minFilter,this.texture.magFilter=n.magFilter;const r={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new bf(5,5,5),s=new ua({name:"CubemapFromEquirect",uniforms:$y(r.uniforms),vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,side:sa,blending:nu});s.uniforms.tEquirect.value=n;const a=new Cr(i,s),o=n.minFilter;return n.minFilter===Ma&&(n.minFilter=er),new m9(1,10,this).update(e,a),n.minFilter=o,a.geometry.dispose(),a.material.dispose(),this}clear(e,n=!0,r=!0,i=!0){const s=e.getRenderTarget();for(let a=0;a<6;a++)e.setRenderTarget(this,a),e.clear(n,r,i);e.setRenderTarget(s)}}class Xu extends Yn{constructor(){super(),this.isGroup=!0,this.type="Group"}}const rce={type:"move"};class KA{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Xu,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Xu,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Z,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Z),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Xu,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Z,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Z),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const n=this._hand;if(n)for(const r of e.hand.values())this._getHandJoint(n,r)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,n,r){let i=null,s=null,a=null;const o=this._targetRay,l=this._grip,u=this._hand;if(e&&n.session.visibilityState!=="visible-blurred"){if(u&&e.hand){a=!0;for(const g of e.hand.values()){const y=n.getJointPose(g,r),m=this._getHandJoint(u,g);y!==null&&(m.matrix.fromArray(y.transform.matrix),m.matrix.decompose(m.position,m.rotation,m.scale),m.matrixWorldNeedsUpdate=!0,m.jointRadius=y.radius),m.visible=y!==null}const c=u.joints["index-finger-tip"],d=u.joints["thumb-tip"],h=c.position.distanceTo(d.position),p=.02,f=.005;u.inputState.pinching&&h>p+f?(u.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!u.inputState.pinching&&h<=p-f&&(u.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(s=n.getPose(e.gripSpace,r),s!==null&&(l.matrix.fromArray(s.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,s.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(s.linearVelocity)):l.hasLinearVelocity=!1,s.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(s.angularVelocity)):l.hasAngularVelocity=!1));o!==null&&(i=n.getPose(e.targetRaySpace,r),i===null&&s!==null&&(i=s),i!==null&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.matrixWorldNeedsUpdate=!0,i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(rce)))}return o!==null&&(o.visible=i!==null),l!==null&&(l.visible=s!==null),u!==null&&(u.visible=a!==null),this}_getHandJoint(e,n){if(e.joints[n.jointName]===void 0){const r=new Xu;r.matrixAutoUpdate=!1,r.visible=!1,e.joints[n.jointName]=r,e.add(r)}return e.joints[n.jointName]}}class NT{constructor(e,n=25e-5){this.isFogExp2=!0,this.name="",this.color=new Ct(e),this.density=n}clone(){return new NT(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class RT{constructor(e,n=1,r=1e3){this.isFog=!0,this.name="",this.color=new Ct(e),this.near=n,this.far=r}clone(){return new RT(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class oc extends Yn{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Ba,this.environmentIntensity=1,this.environmentRotation=new Ba,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,n){return super.copy(e,n),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundRotation.copy(e.backgroundRotation),this.environmentIntensity=e.environmentIntensity,this.environmentRotation.copy(e.environmentRotation),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const n=super.toJSON(e);return this.fog!==null&&(n.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(n.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(n.object.backgroundIntensity=this.backgroundIntensity),n.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(n.object.environmentIntensity=this.environmentIntensity),n.object.environmentRotation=this.environmentRotation.toArray(),n}}class j1{constructor(e,n){this.isInterleavedBuffer=!0,this.array=e,this.stride=n,this.count=e!==void 0?e.length/n:0,this.usage=r1,this.updateRanges=[],this.version=0,this.uuid=ao()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,n){this.updateRanges.push({start:e,count:n})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,n,r){e*=this.stride,r*=n.stride;for(let i=0,s=this.stride;i<s;i++)this.array[e+i]=n.array[r+i];return this}set(e,n=0){return this.array.set(e,n),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=ao()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const n=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),r=new this.constructor(n,this.stride);return r.setUsage(this.usage),r}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=ao()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Ys=new Z;class kd{constructor(e,n,r,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=n,this.offset=r,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let n=0,r=this.data.count;n<r;n++)Ys.fromBufferAttribute(this,n),Ys.applyMatrix4(e),this.setXYZ(n,Ys.x,Ys.y,Ys.z);return this}applyNormalMatrix(e){for(let n=0,r=this.count;n<r;n++)Ys.fromBufferAttribute(this,n),Ys.applyNormalMatrix(e),this.setXYZ(n,Ys.x,Ys.y,Ys.z);return this}transformDirection(e){for(let n=0,r=this.count;n<r;n++)Ys.fromBufferAttribute(this,n),Ys.transformDirection(e),this.setXYZ(n,Ys.x,Ys.y,Ys.z);return this}getComponent(e,n){let r=this.array[e*this.data.stride+this.offset+n];return this.normalized&&(r=na(r,this.array)),r}setComponent(e,n,r){return this.normalized&&(r=Fn(r,this.array)),this.data.array[e*this.data.stride+this.offset+n]=r,this}setX(e,n){return this.normalized&&(n=Fn(n,this.array)),this.data.array[e*this.data.stride+this.offset]=n,this}setY(e,n){return this.normalized&&(n=Fn(n,this.array)),this.data.array[e*this.data.stride+this.offset+1]=n,this}setZ(e,n){return this.normalized&&(n=Fn(n,this.array)),this.data.array[e*this.data.stride+this.offset+2]=n,this}setW(e,n){return this.normalized&&(n=Fn(n,this.array)),this.data.array[e*this.data.stride+this.offset+3]=n,this}getX(e){let n=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(n=na(n,this.array)),n}getY(e){let n=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(n=na(n,this.array)),n}getZ(e){let n=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(n=na(n,this.array)),n}getW(e){let n=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(n=na(n,this.array)),n}setXY(e,n,r){return e=e*this.data.stride+this.offset,this.normalized&&(n=Fn(n,this.array),r=Fn(r,this.array)),this.data.array[e+0]=n,this.data.array[e+1]=r,this}setXYZ(e,n,r,i){return e=e*this.data.stride+this.offset,this.normalized&&(n=Fn(n,this.array),r=Fn(r,this.array),i=Fn(i,this.array)),this.data.array[e+0]=n,this.data.array[e+1]=r,this.data.array[e+2]=i,this}setXYZW(e,n,r,i,s){return e=e*this.data.stride+this.offset,this.normalized&&(n=Fn(n,this.array),r=Fn(r,this.array),i=Fn(i,this.array),s=Fn(s,this.array)),this.data.array[e+0]=n,this.data.array[e+1]=r,this.data.array[e+2]=i,this.data.array[e+3]=s,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const n=[];for(let r=0;r<this.count;r++){const i=r*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)n.push(this.data.array[i+s])}return new Ln(new this.array.constructor(n),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new kd(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const n=[];for(let r=0;r<this.count;r++){const i=r*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)n.push(this.data.array[i+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:n,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class RP extends Ki{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Ct(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let kg;const bx=new Z,Ng=new Z,Rg=new Z,Fg=new Qe,wx=new Qe,g9=new ln,FS=new Z,_x=new Z,DS=new Z,fG=new Qe,Tk=new Qe,mG=new Qe;class y9 extends Yn{constructor(e=new RP){if(super(),this.isSprite=!0,this.type="Sprite",kg===void 0){kg=new An;const n=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),r=new j1(n,5);kg.setIndex([0,1,2,0,2,3]),kg.setAttribute("position",new kd(r,3,0,!1)),kg.setAttribute("uv",new kd(r,2,3,!1))}this.geometry=kg,this.material=e,this.center=new Qe(.5,.5),this.count=1}raycast(e,n){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Ng.setFromMatrixScale(this.matrixWorld),g9.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Rg.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Ng.multiplyScalar(-Rg.z);const r=this.material.rotation;let i,s;r!==0&&(s=Math.cos(r),i=Math.sin(r));const a=this.center;PS(FS.set(-.5,-.5,0),Rg,a,Ng,i,s),PS(_x.set(.5,-.5,0),Rg,a,Ng,i,s),PS(DS.set(.5,.5,0),Rg,a,Ng,i,s),fG.set(0,0),Tk.set(1,0),mG.set(1,1);let o=e.ray.intersectTriangle(FS,_x,DS,!1,bx);if(o===null&&(PS(_x.set(-.5,.5,0),Rg,a,Ng,i,s),Tk.set(0,1),o=e.ray.intersectTriangle(FS,DS,_x,!1,bx),o===null))return;const l=e.ray.origin.distanceTo(bx);l<e.near||l>e.far||n.push({distance:l,point:bx.clone(),uv:Ia.getInterpolation(bx,FS,_x,DS,fG,Tk,mG,new Qe),face:null,object:this})}copy(e,n){return super.copy(e,n),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function PS(t,e,n,r,i,s){Fg.subVectors(t,n).addScalar(.5).multiply(r),i!==void 0?(wx.x=s*Fg.x-i*Fg.y,wx.y=i*Fg.x+s*Fg.y):wx.copy(Fg),t.copy(e),t.x+=wx.x,t.y+=wx.y,t.applyMatrix4(g9)}const LS=new Z,gG=new Z;class v9 extends Yn{constructor(){super(),this.isLOD=!0,this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const n=e.levels;for(let r=0,i=n.length;r<i;r++){const s=n[r];this.addLevel(s.object.clone(),s.distance,s.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,n=0,r=0){n=Math.abs(n);const i=this.levels;let s;for(s=0;s<i.length&&!(n<i[s].distance);s++);return i.splice(s,0,{distance:n,hysteresis:r,object:e}),this.add(e),this}removeLevel(e){const n=this.levels;for(let r=0;r<n.length;r++)if(n[r].distance===e){const i=n.splice(r,1);return this.remove(i[0].object),!0}return!1}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const n=this.levels;if(n.length>0){let r,i;for(r=1,i=n.length;r<i;r++){let s=n[r].distance;if(n[r].object.visible&&(s-=s*n[r].hysteresis),e<s)break}return n[r-1].object}return null}raycast(e,n){if(this.levels.length>0){LS.setFromMatrixPosition(this.matrixWorld);const i=e.ray.origin.distanceTo(LS);this.getObjectForDistance(i).raycast(e,n)}}update(e){const n=this.levels;if(n.length>1){LS.setFromMatrixPosition(e.matrixWorld),gG.setFromMatrixPosition(this.matrixWorld);const r=LS.distanceTo(gG)/e.zoom;n[0].object.visible=!0;let i,s;for(i=1,s=n.length;i<s;i++){let a=n[i].distance;if(n[i].object.visible&&(a-=a*n[i].hysteresis),r>=a)n[i-1].object.visible=!1,n[i].object.visible=!0;else break}for(this._currentLevel=i-1;i<s;i++)n[i].object.visible=!1}}toJSON(e){const n=super.toJSON(e);this.autoUpdate===!1&&(n.object.autoUpdate=!1),n.object.levels=[];const r=this.levels;for(let i=0,s=r.length;i<s;i++){const a=r[i];n.object.levels.push({object:a.object.uuid,distance:a.distance,hysteresis:a.hysteresis})}return n}}const yG=new Z,vG=new Xn,xG=new Xn,ice=new Z,bG=new ln,OS=new Z,Ck=new Xi,wG=new ln,Mk=new xf;class FP extends Cr{constructor(e,n){super(e,n),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=$R,this.bindMatrix=new ln,this.bindMatrixInverse=new ln,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new ds),this.boundingBox.makeEmpty();const n=e.getAttribute("position");for(let r=0;r<n.count;r++)this.getVertexPosition(r,OS),this.boundingBox.expandByPoint(OS)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Xi),this.boundingSphere.makeEmpty();const n=e.getAttribute("position");for(let r=0;r<n.count;r++)this.getVertexPosition(r,OS),this.boundingSphere.expandByPoint(OS)}copy(e,n){return super.copy(e,n),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,n){const r=this.material,i=this.matrixWorld;r!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Ck.copy(this.boundingSphere),Ck.applyMatrix4(i),e.ray.intersectsSphere(Ck)!==!1&&(wG.copy(i).invert(),Mk.copy(e.ray).applyMatrix4(wG),!(this.boundingBox!==null&&Mk.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,n,Mk)))}getVertexPosition(e,n){return super.getVertexPosition(e,n),this.applyBoneTransform(e,n),n}bind(e,n){this.skeleton=e,n===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),n=this.matrixWorld),this.bindMatrix.copy(n),this.bindMatrixInverse.copy(n).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Xn,n=this.geometry.attributes.skinWeight;for(let r=0,i=n.count;r<i;r++){e.fromBufferAttribute(n,r);const s=1/e.manhattanLength();s!==1/0?e.multiplyScalar(s):e.set(1,0,0,0),n.setXYZW(r,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===$R?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===Jj?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,n){const r=this.skeleton,i=this.geometry;vG.fromBufferAttribute(i.attributes.skinIndex,e),xG.fromBufferAttribute(i.attributes.skinWeight,e),yG.copy(n).applyMatrix4(this.bindMatrix),n.set(0,0,0);for(let s=0;s<4;s++){const a=xG.getComponent(s);if(a!==0){const o=vG.getComponent(s);bG.multiplyMatrices(r.bones[o].matrixWorld,r.boneInverses[o]),n.addScaledVector(ice.copy(yG).applyMatrix4(bG),a)}}return n.applyMatrix4(this.bindMatrixInverse)}}class FT extends Yn{constructor(){super(),this.isBone=!0,this.type="Bone"}}class yl extends hr{constructor(e=null,n=1,r=1,i,s,a,o,l,u=yi,c=yi,d,h){super(null,a,o,l,u,c,i,s,d,h),this.isDataTexture=!0,this.image={data:e,width:n,height:r},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const _G=new ln,sce=new ln;class X1{constructor(e=[],n=[]){this.uuid=ao(),this.bones=e.slice(0),this.boneInverses=n,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const e=this.bones,n=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),n.length===0)this.calculateInverses();else if(e.length!==n.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let r=0,i=this.bones.length;r<i;r++)this.boneInverses.push(new ln)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,n=this.bones.length;e<n;e++){const r=new ln;this.bones[e]&&r.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(r)}}pose(){for(let e=0,n=this.bones.length;e<n;e++){const r=this.bones[e];r&&r.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,n=this.bones.length;e<n;e++){const r=this.bones[e];r&&(r.parent&&r.parent.isBone?(r.matrix.copy(r.parent.matrixWorld).invert(),r.matrix.multiply(r.matrixWorld)):r.matrix.copy(r.matrixWorld),r.matrix.decompose(r.position,r.quaternion,r.scale))}}update(){const e=this.bones,n=this.boneInverses,r=this.boneMatrices,i=this.boneTexture;for(let s=0,a=e.length;s<a;s++){const o=e[s]?e[s].matrixWorld:sce;_G.multiplyMatrices(o,n[s]),_G.toArray(r,s*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new X1(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const n=new Float32Array(e*e*4);n.set(this.boneMatrices);const r=new yl(n,e,e,ui,ti);return r.needsUpdate=!0,this.boneMatrices=n,this.boneTexture=r,this}getBoneByName(e){for(let n=0,r=this.bones.length;n<r;n++){const i=this.bones[n];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,n){this.uuid=e.uuid;for(let r=0,i=e.bones.length;r<i;r++){const s=e.bones[r];let a=n[s];a===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),a=new FT),this.bones.push(a),this.boneInverses.push(new ln().fromArray(e.boneInverses[r]))}return this.init(),this}toJSON(){const e={metadata:{version:4.7,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const n=this.bones,r=this.boneInverses;for(let i=0,s=n.length;i<s;i++){const a=n[i];e.bones.push(a.uuid);const o=r[i];e.boneInverses.push(o.toArray())}return e}}class Gp extends Ln{constructor(e,n,r,i=1){super(e,n,r),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const Dg=new ln,SG=new ln,BS=[],AG=new ds,ace=new ln,Sx=new Cr,Ax=new Xi;class DP extends Cr{constructor(e,n,r){super(e,n),this.isInstancedMesh=!0,this.instanceMatrix=new Gp(new Float32Array(r*16),16),this.instanceColor=null,this.morphTexture=null,this.count=r,this.boundingBox=null,this.boundingSphere=null;for(let i=0;i<r;i++)this.setMatrixAt(i,ace)}computeBoundingBox(){const e=this.geometry,n=this.count;this.boundingBox===null&&(this.boundingBox=new ds),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let r=0;r<n;r++)this.getMatrixAt(r,Dg),AG.copy(e.boundingBox).applyMatrix4(Dg),this.boundingBox.union(AG)}computeBoundingSphere(){const e=this.geometry,n=this.count;this.boundingSphere===null&&(this.boundingSphere=new Xi),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let r=0;r<n;r++)this.getMatrixAt(r,Dg),Ax.copy(e.boundingSphere).applyMatrix4(Dg),this.boundingSphere.union(Ax)}copy(e,n){return super.copy(e,n),this.instanceMatrix.copy(e.instanceMatrix),e.morphTexture!==null&&(this.morphTexture=e.morphTexture.clone()),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,n){n.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,n){n.fromArray(this.instanceMatrix.array,e*16)}getMorphAt(e,n){const r=n.morphTargetInfluences,i=this.morphTexture.source.data.data,s=r.length+1,a=e*s+1;for(let o=0;o<r.length;o++)r[o]=i[a+o]}raycast(e,n){const r=this.matrixWorld,i=this.count;if(Sx.geometry=this.geometry,Sx.material=this.material,Sx.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Ax.copy(this.boundingSphere),Ax.applyMatrix4(r),e.ray.intersectsSphere(Ax)!==!1))for(let s=0;s<i;s++){this.getMatrixAt(s,Dg),SG.multiplyMatrices(r,Dg),Sx.matrixWorld=SG,Sx.raycast(e,BS);for(let a=0,o=BS.length;a<o;a++){const l=BS[a];l.instanceId=s,l.object=this,n.push(l)}BS.length=0}}setColorAt(e,n){this.instanceColor===null&&(this.instanceColor=new Gp(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),n.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,n){n.toArray(this.instanceMatrix.array,e*16)}setMorphAt(e,n){const r=n.morphTargetInfluences,i=r.length+1;this.morphTexture===null&&(this.morphTexture=new yl(new Float32Array(i*this.count),i,this.count,G1,ti));const s=this.morphTexture.source.data.data;let a=0;for(let u=0;u<r.length;u++)a+=r[u];const o=this.geometry.morphTargetsRelative?1:1-a,l=i*e;s[l]=o,s.set(r,l+1)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null)}}const kk=new Z,oce=new Z,lce=new Mn;class Bu{constructor(e=new Z(1,0,0),n=0){this.isPlane=!0,this.normal=e,this.constant=n}set(e,n){return this.normal.copy(e),this.constant=n,this}setComponents(e,n,r,i){return this.normal.set(e,n,r),this.constant=i,this}setFromNormalAndCoplanarPoint(e,n){return this.normal.copy(e),this.constant=-n.dot(this.normal),this}setFromCoplanarPoints(e,n,r){const i=kk.subVectors(r,n).cross(oce.subVectors(e,n)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,n){return n.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,n){const r=e.delta(kk),i=this.normal.dot(r);if(i===0)return this.distanceToPoint(e.start)===0?n.copy(e.start):null;const s=-(e.start.dot(this.normal)+this.constant)/i;return s<0||s>1?null:n.copy(e.start).addScaledVector(r,s)}intersectsLine(e){const n=this.distanceToPoint(e.start),r=this.distanceToPoint(e.end);return n<0&&r>0||r<0&&n>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,n){const r=n||lce.getNormalMatrix(e),i=this.coplanarPoint(kk).applyMatrix4(e),s=this.normal.applyMatrix3(r).normalize();return this.constant=-i.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const kh=new Xi,US=new Z;class f0{constructor(e=new Bu,n=new Bu,r=new Bu,i=new Bu,s=new Bu,a=new Bu){this.planes=[e,n,r,i,s,a]}set(e,n,r,i,s,a){const o=this.planes;return o[0].copy(e),o[1].copy(n),o[2].copy(r),o[3].copy(i),o[4].copy(s),o[5].copy(a),this}copy(e){const n=this.planes;for(let r=0;r<6;r++)n[r].copy(e.planes[r]);return this}setFromProjectionMatrix(e,n=Oo){const r=this.planes,i=e.elements,s=i[0],a=i[1],o=i[2],l=i[3],u=i[4],c=i[5],d=i[6],h=i[7],p=i[8],f=i[9],g=i[10],y=i[11],m=i[12],b=i[13],w=i[14],_=i[15];if(r[0].setComponents(l-s,h-u,y-p,_-m).normalize(),r[1].setComponents(l+s,h+u,y+p,_+m).normalize(),r[2].setComponents(l+a,h+c,y+f,_+b).normalize(),r[3].setComponents(l-a,h-c,y-f,_-b).normalize(),r[4].setComponents(l-o,h-d,y-g,_-w).normalize(),n===Oo)r[5].setComponents(l+o,h+d,y+g,_+w).normalize();else if(n===i1)r[5].setComponents(o,d,g,w).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+n);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),kh.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const n=e.geometry;n.boundingSphere===null&&n.computeBoundingSphere(),kh.copy(n.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(kh)}intersectsSprite(e){return kh.center.set(0,0,0),kh.radius=.7071067811865476,kh.applyMatrix4(e.matrixWorld),this.intersectsSphere(kh)}intersectsSphere(e){const n=this.planes,r=e.center,i=-e.radius;for(let s=0;s<6;s++)if(n[s].distanceToPoint(r)<i)return!1;return!0}intersectsBox(e){const n=this.planes;for(let r=0;r<6;r++){const i=n[r];if(US.x=i.normal.x>0?e.max.x:e.min.x,US.y=i.normal.y>0?e.max.y:e.min.y,US.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(US)<0)return!1}return!0}containsPoint(e){const n=this.planes;for(let r=0;r<6;r++)if(n[r].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}const Bl=new ln,Ul=new f0;class DT{constructor(){this.coordinateSystem=Oo}intersectsObject(e,n){if(!n.isArrayCamera||n.cameras.length===0)return!1;for(let r=0;r<n.cameras.length;r++){const i=n.cameras[r];if(Bl.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Ul.setFromProjectionMatrix(Bl,this.coordinateSystem),Ul.intersectsObject(e))return!0}return!1}intersectsSprite(e,n){if(!n||!n.cameras||n.cameras.length===0)return!1;for(let r=0;r<n.cameras.length;r++){const i=n.cameras[r];if(Bl.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Ul.setFromProjectionMatrix(Bl,this.coordinateSystem),Ul.intersectsSprite(e))return!0}return!1}intersectsSphere(e,n){if(!n||!n.cameras||n.cameras.length===0)return!1;for(let r=0;r<n.cameras.length;r++){const i=n.cameras[r];if(Bl.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Ul.setFromProjectionMatrix(Bl,this.coordinateSystem),Ul.intersectsSphere(e))return!0}return!1}intersectsBox(e,n){if(!n||!n.cameras||n.cameras.length===0)return!1;for(let r=0;r<n.cameras.length;r++){const i=n.cameras[r];if(Bl.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Ul.setFromProjectionMatrix(Bl,this.coordinateSystem),Ul.intersectsBox(e))return!0}return!1}containsPoint(e,n){if(!n||!n.cameras||n.cameras.length===0)return!1;for(let r=0;r<n.cameras.length;r++){const i=n.cameras[r];if(Bl.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Ul.setFromProjectionMatrix(Bl,this.coordinateSystem),Ul.containsPoint(e))return!0}return!1}clone(){return new DT}}function Nk(t,e){return t-e}function uce(t,e){return t.z-e.z}function cce(t,e){return e.z-t.z}class dce{constructor(){this.index=0,this.pool=[],this.list=[]}push(e,n,r,i){const s=this.pool,a=this.list;this.index>=s.length&&s.push({start:-1,count:-1,z:-1,index:-1});const o=s[this.index];a.push(o),this.index++,o.start=e,o.count=n,o.z=r,o.index=i}reset(){this.list.length=0,this.index=0}}const xa=new ln,hce=new Ct(1,1,1),EG=new f0,pce=new DT,$S=new ds,Nh=new Xi,Ex=new Z,IG=new Z,fce=new Z,Rk=new dce,Fs=new Cr,zS=[];function mce(t,e,n=0){const r=e.itemSize;if(t.isInterleavedBufferAttribute||t.array.constructor!==e.array.constructor){const i=t.count;for(let s=0;s<i;s++)for(let a=0;a<r;a++)e.setComponent(s+n,a,t.getComponent(s,a))}else e.array.set(t.array,n*r);e.needsUpdate=!0}function Rh(t,e){if(t.constructor!==e.constructor){const n=Math.min(t.length,e.length);for(let r=0;r<n;r++)e[r]=t[r]}else{const n=Math.min(t.length,e.length);e.set(new t.constructor(t.buffer,0,n))}}class x9 extends Cr{constructor(e,n,r=n*2,i){super(new An,i),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._instanceInfo=[],this._geometryInfo=[],this._availableInstanceIds=[],this._availableGeometryIds=[],this._nextIndexStart=0,this._nextVertexStart=0,this._geometryCount=0,this._visibilityChanged=!0,this._geometryInitialized=!1,this._maxInstanceCount=e,this._maxVertexCount=n,this._maxIndexCount=r,this._multiDrawCounts=new Int32Array(e),this._multiDrawStarts=new Int32Array(e),this._multiDrawCount=0,this._multiDrawInstances=null,this._matricesTexture=null,this._indirectTexture=null,this._colorsTexture=null,this._initMatricesTexture(),this._initIndirectTexture()}get maxInstanceCount(){return this._maxInstanceCount}get instanceCount(){return this._instanceInfo.length-this._availableInstanceIds.length}get unusedVertexCount(){return this._maxVertexCount-this._nextVertexStart}get unusedIndexCount(){return this._maxIndexCount-this._nextIndexStart}_initMatricesTexture(){let e=Math.sqrt(this._maxInstanceCount*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const n=new Float32Array(e*e*4),r=new yl(n,e,e,ui,ti);this._matricesTexture=r}_initIndirectTexture(){let e=Math.sqrt(this._maxInstanceCount);e=Math.ceil(e);const n=new Uint32Array(e*e),r=new yl(n,e,e,H1,cu);this._indirectTexture=r}_initColorsTexture(){let e=Math.sqrt(this._maxInstanceCount);e=Math.ceil(e);const n=new Float32Array(e*e*4).fill(1),r=new yl(n,e,e,ui,ti);r.colorSpace=Qn.workingColorSpace,this._colorsTexture=r}_initializeGeometry(e){const n=this.geometry,r=this._maxVertexCount,i=this._maxIndexCount;if(this._geometryInitialized===!1){for(const s in e.attributes){const a=e.getAttribute(s),{array:o,itemSize:l,normalized:u}=a,c=new o.constructor(r*l),d=new Ln(c,l,u);n.setAttribute(s,d)}if(e.getIndex()!==null){const s=r>65535?new Uint32Array(i):new Uint16Array(i);n.setIndex(new Ln(s,1))}this._geometryInitialized=!0}}_validateGeometry(e){const n=this.geometry;if(!!e.getIndex()!=!!n.getIndex())throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');for(const r in n.attributes){if(!e.hasAttribute(r))throw new Error(`THREE.BatchedMesh: Added geometry missing "${r}". All geometries must have consistent attributes.`);const i=e.getAttribute(r),s=n.getAttribute(r);if(i.itemSize!==s.itemSize||i.normalized!==s.normalized)throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}validateInstanceId(e){const n=this._instanceInfo;if(e<0||e>=n.length||n[e].active===!1)throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`)}validateGeometryId(e){const n=this._geometryInfo;if(e<0||e>=n.length||n[e].active===!1)throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`)}setCustomSort(e){return this.customSort=e,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new ds);const e=this.boundingBox,n=this._instanceInfo;e.makeEmpty();for(let r=0,i=n.length;r<i;r++){if(n[r].active===!1)continue;const s=n[r].geometryIndex;this.getMatrixAt(r,xa),this.getBoundingBoxAt(s,$S).applyMatrix4(xa),e.union($S)}}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Xi);const e=this.boundingSphere,n=this._instanceInfo;e.makeEmpty();for(let r=0,i=n.length;r<i;r++){if(n[r].active===!1)continue;const s=n[r].geometryIndex;this.getMatrixAt(r,xa),this.getBoundingSphereAt(s,Nh).applyMatrix4(xa),e.union(Nh)}}addInstance(e){if(this._instanceInfo.length>=this.maxInstanceCount&&this._availableInstanceIds.length===0)throw new Error("THREE.BatchedMesh: Maximum item count reached.");const r={visible:!0,active:!0,geometryIndex:e};let i=null;this._availableInstanceIds.length>0?(this._availableInstanceIds.sort(Nk),i=this._availableInstanceIds.shift(),this._instanceInfo[i]=r):(i=this._instanceInfo.length,this._instanceInfo.push(r));const s=this._matricesTexture;xa.identity().toArray(s.image.data,i*16),s.needsUpdate=!0;const a=this._colorsTexture;return a&&(hce.toArray(a.image.data,i*4),a.needsUpdate=!0),this._visibilityChanged=!0,i}addGeometry(e,n=-1,r=-1){this._initializeGeometry(e),this._validateGeometry(e);const i={vertexStart:-1,vertexCount:-1,reservedVertexCount:-1,indexStart:-1,indexCount:-1,reservedIndexCount:-1,start:-1,count:-1,boundingBox:null,boundingSphere:null,active:!0},s=this._geometryInfo;i.vertexStart=this._nextVertexStart,i.reservedVertexCount=n===-1?e.getAttribute("position").count:n;const a=e.getIndex();if(a!==null&&(i.indexStart=this._nextIndexStart,i.reservedIndexCount=r===-1?a.count:r),i.indexStart!==-1&&i.indexStart+i.reservedIndexCount>this._maxIndexCount||i.vertexStart+i.reservedVertexCount>this._maxVertexCount)throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");let l;return this._availableGeometryIds.length>0?(this._availableGeometryIds.sort(Nk),l=this._availableGeometryIds.shift(),s[l]=i):(l=this._geometryCount,this._geometryCount++,s.push(i)),this.setGeometryAt(l,e),this._nextIndexStart=i.indexStart+i.reservedIndexCount,this._nextVertexStart=i.vertexStart+i.reservedVertexCount,l}setGeometryAt(e,n){if(e>=this._geometryCount)throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");this._validateGeometry(n);const r=this.geometry,i=r.getIndex()!==null,s=r.getIndex(),a=n.getIndex(),o=this._geometryInfo[e];if(i&&a.count>o.reservedIndexCount||n.attributes.position.count>o.reservedVertexCount)throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");const l=o.vertexStart,u=o.reservedVertexCount;o.vertexCount=n.getAttribute("position").count;for(const c in r.attributes){const d=n.getAttribute(c),h=r.getAttribute(c);mce(d,h,l);const p=d.itemSize;for(let f=d.count,g=u;f<g;f++){const y=l+f;for(let m=0;m<p;m++)h.setComponent(y,m,0)}h.needsUpdate=!0,h.addUpdateRange(l*p,u*p)}if(i){const c=o.indexStart,d=o.reservedIndexCount;o.indexCount=n.getIndex().count;for(let h=0;h<a.count;h++)s.setX(c+h,l+a.getX(h));for(let h=a.count,p=d;h<p;h++)s.setX(c+h,l);s.needsUpdate=!0,s.addUpdateRange(c,o.reservedIndexCount)}return o.start=i?o.indexStart:o.vertexStart,o.count=i?o.indexCount:o.vertexCount,o.boundingBox=null,n.boundingBox!==null&&(o.boundingBox=n.boundingBox.clone()),o.boundingSphere=null,n.boundingSphere!==null&&(o.boundingSphere=n.boundingSphere.clone()),this._visibilityChanged=!0,e}deleteGeometry(e){const n=this._geometryInfo;if(e>=n.length||n[e].active===!1)return this;const r=this._instanceInfo;for(let i=0,s=r.length;i<s;i++)r[i].active&&r[i].geometryIndex===e&&this.deleteInstance(i);return n[e].active=!1,this._availableGeometryIds.push(e),this._visibilityChanged=!0,this}deleteInstance(e){return this.validateInstanceId(e),this._instanceInfo[e].active=!1,this._availableInstanceIds.push(e),this._visibilityChanged=!0,this}optimize(){let e=0,n=0;const r=this._geometryInfo,i=r.map((a,o)=>o).sort((a,o)=>r[a].vertexStart-r[o].vertexStart),s=this.geometry;for(let a=0,o=r.length;a<o;a++){const l=i[a],u=r[l];if(u.active!==!1){if(s.index!==null){if(u.indexStart!==n){const{indexStart:c,vertexStart:d,reservedIndexCount:h}=u,p=s.index,f=p.array,g=e-d;for(let y=c;y<c+h;y++)f[y]=f[y]+g;p.array.copyWithin(n,c,c+h),p.addUpdateRange(n,h),u.indexStart=n}n+=u.reservedIndexCount}if(u.vertexStart!==e){const{vertexStart:c,reservedVertexCount:d}=u,h=s.attributes;for(const p in h){const f=h[p],{array:g,itemSize:y}=f;g.copyWithin(e*y,c*y,(c+d)*y),f.addUpdateRange(e*y,d*y)}u.vertexStart=e}e+=u.reservedVertexCount,u.start=s.index?u.indexStart:u.vertexStart,this._nextIndexStart=s.index?u.indexStart+u.reservedIndexCount:0,this._nextVertexStart=u.vertexStart+u.reservedVertexCount}}return this}getBoundingBoxAt(e,n){if(e>=this._geometryCount)return null;const r=this.geometry,i=this._geometryInfo[e];if(i.boundingBox===null){const s=new ds,a=r.index,o=r.attributes.position;for(let l=i.start,u=i.start+i.count;l<u;l++){let c=l;a&&(c=a.getX(c)),s.expandByPoint(Ex.fromBufferAttribute(o,c))}i.boundingBox=s}return n.copy(i.boundingBox),n}getBoundingSphereAt(e,n){if(e>=this._geometryCount)return null;const r=this.geometry,i=this._geometryInfo[e];if(i.boundingSphere===null){const s=new Xi;this.getBoundingBoxAt(e,$S),$S.getCenter(s.center);const a=r.index,o=r.attributes.position;let l=0;for(let u=i.start,c=i.start+i.count;u<c;u++){let d=u;a&&(d=a.getX(d)),Ex.fromBufferAttribute(o,d),l=Math.max(l,s.center.distanceToSquared(Ex))}s.radius=Math.sqrt(l),i.boundingSphere=s}return n.copy(i.boundingSphere),n}setMatrixAt(e,n){this.validateInstanceId(e);const r=this._matricesTexture,i=this._matricesTexture.image.data;return n.toArray(i,e*16),r.needsUpdate=!0,this}getMatrixAt(e,n){return this.validateInstanceId(e),n.fromArray(this._matricesTexture.image.data,e*16)}setColorAt(e,n){return this.validateInstanceId(e),this._colorsTexture===null&&this._initColorsTexture(),n.toArray(this._colorsTexture.image.data,e*4),this._colorsTexture.needsUpdate=!0,this}getColorAt(e,n){return this.validateInstanceId(e),n.fromArray(this._colorsTexture.image.data,e*4)}setVisibleAt(e,n){return this.validateInstanceId(e),this._instanceInfo[e].visible===n?this:(this._instanceInfo[e].visible=n,this._visibilityChanged=!0,this)}getVisibleAt(e){return this.validateInstanceId(e),this._instanceInfo[e].visible}setGeometryIdAt(e,n){return this.validateInstanceId(e),this.validateGeometryId(n),this._instanceInfo[e].geometryIndex=n,this}getGeometryIdAt(e){return this.validateInstanceId(e),this._instanceInfo[e].geometryIndex}getGeometryRangeAt(e,n={}){this.validateGeometryId(e);const r=this._geometryInfo[e];return n.vertexStart=r.vertexStart,n.vertexCount=r.vertexCount,n.reservedVertexCount=r.reservedVertexCount,n.indexStart=r.indexStart,n.indexCount=r.indexCount,n.reservedIndexCount=r.reservedIndexCount,n.start=r.start,n.count=r.count,n}setInstanceCount(e){const n=this._availableInstanceIds,r=this._instanceInfo;for(n.sort(Nk);n[n.length-1]===r.length;)r.pop(),n.pop();if(e<r.length)throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);const i=new Int32Array(e),s=new Int32Array(e);Rh(this._multiDrawCounts,i),Rh(this._multiDrawStarts,s),this._multiDrawCounts=i,this._multiDrawStarts=s,this._maxInstanceCount=e;const a=this._indirectTexture,o=this._matricesTexture,l=this._colorsTexture;a.dispose(),this._initIndirectTexture(),Rh(a.image.data,this._indirectTexture.image.data),o.dispose(),this._initMatricesTexture(),Rh(o.image.data,this._matricesTexture.image.data),l&&(l.dispose(),this._initColorsTexture(),Rh(l.image.data,this._colorsTexture.image.data))}setGeometrySize(e,n){const r=[...this._geometryInfo].filter(o=>o.active);if(Math.max(...r.map(o=>o.vertexStart+o.reservedVertexCount))>e)throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${n}. Cannot shrink further.`);if(this.geometry.index&&Math.max(...r.map(l=>l.indexStart+l.reservedIndexCount))>n)throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${n}. Cannot shrink further.`);const s=this.geometry;s.dispose(),this._maxVertexCount=e,this._maxIndexCount=n,this._geometryInitialized&&(this._geometryInitialized=!1,this.geometry=new An,this._initializeGeometry(s));const a=this.geometry;s.index&&Rh(s.index.array,a.index.array);for(const o in s.attributes)Rh(s.attributes[o].array,a.attributes[o].array)}raycast(e,n){const r=this._instanceInfo,i=this._geometryInfo,s=this.matrixWorld,a=this.geometry;Fs.material=this.material,Fs.geometry.index=a.index,Fs.geometry.attributes=a.attributes,Fs.geometry.boundingBox===null&&(Fs.geometry.boundingBox=new ds),Fs.geometry.boundingSphere===null&&(Fs.geometry.boundingSphere=new Xi);for(let o=0,l=r.length;o<l;o++){if(!r[o].visible||!r[o].active)continue;const u=r[o].geometryIndex,c=i[u];Fs.geometry.setDrawRange(c.start,c.count),this.getMatrixAt(o,Fs.matrixWorld).premultiply(s),this.getBoundingBoxAt(u,Fs.geometry.boundingBox),this.getBoundingSphereAt(u,Fs.geometry.boundingSphere),Fs.raycast(e,zS);for(let d=0,h=zS.length;d<h;d++){const p=zS[d];p.object=this,p.batchId=o,n.push(p)}zS.length=0}Fs.material=null,Fs.geometry.index=null,Fs.geometry.attributes={},Fs.geometry.setDrawRange(0,1/0)}copy(e){return super.copy(e),this.geometry=e.geometry.clone(),this.perObjectFrustumCulled=e.perObjectFrustumCulled,this.sortObjects=e.sortObjects,this.boundingBox=e.boundingBox!==null?e.boundingBox.clone():null,this.boundingSphere=e.boundingSphere!==null?e.boundingSphere.clone():null,this._geometryInfo=e._geometryInfo.map(n=>({...n,boundingBox:n.boundingBox!==null?n.boundingBox.clone():null,boundingSphere:n.boundingSphere!==null?n.boundingSphere.clone():null})),this._instanceInfo=e._instanceInfo.map(n=>({...n})),this._availableInstanceIds=e._availableInstanceIds.slice(),this._availableGeometryIds=e._availableGeometryIds.slice(),this._nextIndexStart=e._nextIndexStart,this._nextVertexStart=e._nextVertexStart,this._geometryCount=e._geometryCount,this._maxInstanceCount=e._maxInstanceCount,this._maxVertexCount=e._maxVertexCount,this._maxIndexCount=e._maxIndexCount,this._geometryInitialized=e._geometryInitialized,this._multiDrawCounts=e._multiDrawCounts.slice(),this._multiDrawStarts=e._multiDrawStarts.slice(),this._indirectTexture=e._indirectTexture.clone(),this._indirectTexture.image.data=this._indirectTexture.image.data.slice(),this._matricesTexture=e._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.data.slice(),this._colorsTexture!==null&&(this._colorsTexture=e._colorsTexture.clone(),this._colorsTexture.image.data=this._colorsTexture.image.data.slice()),this}dispose(){this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this._indirectTexture.dispose(),this._indirectTexture=null,this._colorsTexture!==null&&(this._colorsTexture.dispose(),this._colorsTexture=null)}onBeforeRender(e,n,r,i,s){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const a=i.getIndex(),o=a===null?1:a.array.BYTES_PER_ELEMENT,l=this._instanceInfo,u=this._multiDrawStarts,c=this._multiDrawCounts,d=this._geometryInfo,h=this.perObjectFrustumCulled,p=this._indirectTexture,f=p.image.data,g=r.isArrayCamera?pce:EG;h&&!r.isArrayCamera&&(xa.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse).multiply(this.matrixWorld),EG.setFromProjectionMatrix(xa,e.coordinateSystem));let y=0;if(this.sortObjects){xa.copy(this.matrixWorld).invert(),Ex.setFromMatrixPosition(r.matrixWorld).applyMatrix4(xa),IG.set(0,0,-1).transformDirection(r.matrixWorld).transformDirection(xa);for(let w=0,_=l.length;w<_;w++)if(l[w].visible&&l[w].active){const S=l[w].geometryIndex;this.getMatrixAt(w,xa),this.getBoundingSphereAt(S,Nh).applyMatrix4(xa);let E=!1;if(h&&(E=!g.intersectsSphere(Nh,r)),!E){const C=d[S],T=fce.subVectors(Nh.center,Ex).dot(IG);Rk.push(C.start,C.count,T,w)}}const m=Rk.list,b=this.customSort;b===null?m.sort(s.transparent?cce:uce):b.call(this,m,r);for(let w=0,_=m.length;w<_;w++){const S=m[w];u[y]=S.start*o,c[y]=S.count,f[y]=S.index,y++}Rk.reset()}else for(let m=0,b=l.length;m<b;m++)if(l[m].visible&&l[m].active){const w=l[m].geometryIndex;let _=!1;if(h&&(this.getMatrixAt(m,xa),this.getBoundingSphereAt(w,Nh).applyMatrix4(xa),_=!g.intersectsSphere(Nh,r)),!_){const S=d[w];u[y]=S.start*o,c[y]=S.count,f[y]=m,y++}}p.needsUpdate=!0,this._multiDrawCount=y,this._visibilityChanged=!1}onBeforeShadow(e,n,r,i,s,a){this.onBeforeRender(e,null,i,s,a)}}class Ws extends Ki{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Ct(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const yI=new Z,vI=new Z,TG=new ln,Ix=new xf,GS=new Xi,Fk=new Z,CG=new Z;class lc extends Yn{constructor(e=new An,n=new Ws){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=n,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(e,n){return super.copy(e,n),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const n=e.attributes.position,r=[0];for(let i=1,s=n.count;i<s;i++)yI.fromBufferAttribute(n,i-1),vI.fromBufferAttribute(n,i),r[i]=r[i-1],r[i]+=yI.distanceTo(vI);e.setAttribute("lineDistance",new Jt(r,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,n){const r=this.geometry,i=this.matrixWorld,s=e.params.Line.threshold,a=r.drawRange;if(r.boundingSphere===null&&r.computeBoundingSphere(),GS.copy(r.boundingSphere),GS.applyMatrix4(i),GS.radius+=s,e.ray.intersectsSphere(GS)===!1)return;TG.copy(i).invert(),Ix.copy(e.ray).applyMatrix4(TG);const o=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,u=this.isLineSegments?2:1,c=r.index,h=r.attributes.position;if(c!==null){const p=Math.max(0,a.start),f=Math.min(c.count,a.start+a.count);for(let g=p,y=f-1;g<y;g+=u){const m=c.getX(g),b=c.getX(g+1),w=HS(this,e,Ix,l,m,b,g);w&&n.push(w)}if(this.isLineLoop){const g=c.getX(f-1),y=c.getX(p),m=HS(this,e,Ix,l,g,y,f-1);m&&n.push(m)}}else{const p=Math.max(0,a.start),f=Math.min(h.count,a.start+a.count);for(let g=p,y=f-1;g<y;g+=u){const m=HS(this,e,Ix,l,g,g+1,g);m&&n.push(m)}if(this.isLineLoop){const g=HS(this,e,Ix,l,f-1,p,f-1);g&&n.push(g)}}}updateMorphTargets(){const n=this.geometry.morphAttributes,r=Object.keys(n);if(r.length>0){const i=n[r[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const o=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}}function HS(t,e,n,r,i,s,a){const o=t.geometry.attributes.position;if(yI.fromBufferAttribute(o,i),vI.fromBufferAttribute(o,s),n.distanceSqToSegment(yI,vI,Fk,CG)>r)return;Fk.applyMatrix4(t.matrixWorld);const u=e.ray.origin.distanceTo(Fk);if(!(u<e.near||u>e.far))return{distance:u,point:CG.clone().applyMatrix4(t.matrixWorld),index:a,face:null,faceIndex:null,barycoord:null,object:t}}const MG=new Z,kG=new Z;class Tl extends lc{constructor(e,n){super(e,n),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const n=e.attributes.position,r=[];for(let i=0,s=n.count;i<s;i+=2)MG.fromBufferAttribute(n,i),kG.fromBufferAttribute(n,i+1),r[i]=i===0?0:r[i-1],r[i+1]=r[i]+MG.distanceTo(kG);e.setAttribute("lineDistance",new Jt(r,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class PP extends lc{constructor(e,n){super(e,n),this.isLineLoop=!0,this.type="LineLoop"}}class PT extends Ki{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Ct(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const NG=new ln,HR=new xf,WS=new Xi,VS=new Z;class LP extends Yn{constructor(e=new An,n=new PT){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=n,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(e,n){return super.copy(e,n),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,n){const r=this.geometry,i=this.matrixWorld,s=e.params.Points.threshold,a=r.drawRange;if(r.boundingSphere===null&&r.computeBoundingSphere(),WS.copy(r.boundingSphere),WS.applyMatrix4(i),WS.radius+=s,e.ray.intersectsSphere(WS)===!1)return;NG.copy(i).invert(),HR.copy(e.ray).applyMatrix4(NG);const o=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,u=r.index,d=r.attributes.position;if(u!==null){const h=Math.max(0,a.start),p=Math.min(u.count,a.start+a.count);for(let f=h,g=p;f<g;f++){const y=u.getX(f);VS.fromBufferAttribute(d,y),RG(VS,y,l,i,e,n,this)}}else{const h=Math.max(0,a.start),p=Math.min(d.count,a.start+a.count);for(let f=h,g=p;f<g;f++)VS.fromBufferAttribute(d,f),RG(VS,f,l,i,e,n,this)}}updateMorphTargets(){const n=this.geometry.morphAttributes,r=Object.keys(n);if(r.length>0){const i=n[r[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const o=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}}function RG(t,e,n,r,i,s,a){const o=HR.distanceSqToPoint(t);if(o<n){const l=new Z;HR.closestPointToPoint(t,l),l.applyMatrix4(r);const u=i.ray.origin.distanceTo(l);if(u<i.near||u>i.far)return;s.push({distance:u,distanceToRay:Math.sqrt(o),point:l,index:e,face:null,faceIndex:null,barycoord:null,object:a})}}class b9 extends hr{constructor(e,n,r,i,s=er,a=er,o,l,u){super(e,n,r,i,s,a,o,l,u),this.isVideoTexture=!0,this.generateMipmaps=!1;const c=this;function d(){c.needsUpdate=!0,e.requestVideoFrameCallback(d)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(d)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class gce extends b9{constructor(e,n,r,i,s,a,o,l){super({},e,n,r,i,s,a,o,l),this.isVideoFrameTexture=!0}update(){}clone(){return new this.constructor().copy(this)}setFrame(e){this.image=e,this.needsUpdate=!0}}class yce extends hr{constructor(e,n){super({width:e,height:n}),this.isFramebufferTexture=!0,this.magFilter=yi,this.minFilter=yi,this.generateMipmaps=!1,this.needsUpdate=!0}}class Tp extends hr{constructor(e,n,r,i,s,a,o,l,u,c,d,h){super(null,a,o,l,u,c,i,s,d,h),this.isCompressedTexture=!0,this.image={width:n,height:r},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class vce extends Tp{constructor(e,n,r,i,s,a){super(e,n,r,s,a),this.isCompressedArrayTexture=!0,this.image.depth=i,this.wrapR=jr,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class xce extends Tp{constructor(e,n,r){super(void 0,e[0].width,e[0].height,n,r,uu),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=e}}class bce extends hr{constructor(e,n,r,i,s,a,o,l,u){super(e,n,r,i,s,a,o,l,u),this.isCanvasTexture=!0,this.needsUpdate=!0}}class OP extends hr{constructor(e,n,r=cu,i,s,a,o=yi,l=yi,u,c=Oy,d=1){if(c!==Oy&&c!==By)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");const h={width:e,height:n,depth:d};super(h,i,s,a,o,l,c,r,u),this.isDepthTexture=!0,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.source=new ju(Object.assign({},e.image)),this.compareFunction=e.compareFunction,this}toJSON(e){const n=super.toJSON(e);return this.compareFunction!==null&&(n.compareFunction=this.compareFunction),n}}class LT extends An{constructor(e=1,n=1,r=4,i=8,s=1){super(),this.type="CapsuleGeometry",this.parameters={radius:e,height:n,capSegments:r,radialSegments:i,heightSegments:s},n=Math.max(0,n),r=Math.max(1,Math.floor(r)),i=Math.max(3,Math.floor(i)),s=Math.max(1,Math.floor(s));const a=[],o=[],l=[],u=[],c=n/2,d=Math.PI/2*e,h=n,p=2*d+h,f=r*2+s,g=i+1,y=new Z,m=new Z;for(let b=0;b<=f;b++){let w=0,_=0,S=0,E=0;if(b<=r){const M=b/r,k=M*Math.PI/2;_=-c-e*Math.cos(k),S=e*Math.sin(k),E=-e*Math.cos(k),w=M*d}else if(b<=r+s){const M=(b-r)/s;_=-c+M*n,S=e,E=0,w=d+M*h}else{const M=(b-r-s)/r,k=M*Math.PI/2;_=c+e*Math.sin(k),S=e*Math.cos(k),E=e*Math.sin(k),w=d+h+M*d}const C=Math.max(0,Math.min(1,w/p));let T=0;b===0?T=.5/i:b===f&&(T=-.5/i);for(let M=0;M<=i;M++){const k=M/i,R=k*Math.PI*2,N=Math.sin(R),B=Math.cos(R);m.x=-S*B,m.y=_,m.z=S*N,o.push(m.x,m.y,m.z),y.set(-S*B,E,S*N),y.normalize(),l.push(y.x,y.y,y.z),u.push(k+T,C)}if(b>0){const M=(b-1)*g;for(let k=0;k<i;k++){const R=M+k,N=M+k+1,B=b*g+k,z=b*g+k+1;a.push(R,N,B),a.push(N,z,B)}}}this.setIndex(a),this.setAttribute("position",new Jt(o,3)),this.setAttribute("normal",new Jt(l,3)),this.setAttribute("uv",new Jt(u,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new LT(e.radius,e.height,e.capSegments,e.radialSegments,e.heightSegments)}}class OT extends An{constructor(e=1,n=32,r=0,i=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:n,thetaStart:r,thetaLength:i},n=Math.max(3,n);const s=[],a=[],o=[],l=[],u=new Z,c=new Qe;a.push(0,0,0),o.push(0,0,1),l.push(.5,.5);for(let d=0,h=3;d<=n;d++,h+=3){const p=r+d/n*i;u.x=e*Math.cos(p),u.y=e*Math.sin(p),a.push(u.x,u.y,u.z),o.push(0,0,1),c.x=(a[h]/e+1)/2,c.y=(a[h+1]/e+1)/2,l.push(c.x,c.y)}for(let d=1;d<=n;d++)s.push(d,d+1,0);this.setIndex(s),this.setAttribute("position",new Jt(a,3)),this.setAttribute("normal",new Jt(o,3)),this.setAttribute("uv",new Jt(l,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new OT(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class K1 extends An{constructor(e=1,n=1,r=1,i=32,s=1,a=!1,o=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:n,height:r,radialSegments:i,heightSegments:s,openEnded:a,thetaStart:o,thetaLength:l};const u=this;i=Math.floor(i),s=Math.floor(s);const c=[],d=[],h=[],p=[];let f=0;const g=[],y=r/2;let m=0;b(),a===!1&&(e>0&&w(!0),n>0&&w(!1)),this.setIndex(c),this.setAttribute("position",new Jt(d,3)),this.setAttribute("normal",new Jt(h,3)),this.setAttribute("uv",new Jt(p,2));function b(){const _=new Z,S=new Z;let E=0;const C=(n-e)/r;for(let T=0;T<=s;T++){const M=[],k=T/s,R=k*(n-e)+e;for(let N=0;N<=i;N++){const B=N/i,z=B*l+o,V=Math.sin(z),K=Math.cos(z);S.x=R*V,S.y=-k*r+y,S.z=R*K,d.push(S.x,S.y,S.z),_.set(V,C,K).normalize(),h.push(_.x,_.y,_.z),p.push(B,1-k),M.push(f++)}g.push(M)}for(let T=0;T<i;T++)for(let M=0;M<s;M++){const k=g[M][T],R=g[M+1][T],N=g[M+1][T+1],B=g[M][T+1];(e>0||M!==0)&&(c.push(k,R,B),E+=3),(n>0||M!==s-1)&&(c.push(R,N,B),E+=3)}u.addGroup(m,E,0),m+=E}function w(_){const S=f,E=new Qe,C=new Z;let T=0;const M=_===!0?e:n,k=_===!0?1:-1;for(let N=1;N<=i;N++)d.push(0,y*k,0),h.push(0,k,0),p.push(.5,.5),f++;const R=f;for(let N=0;N<=i;N++){const z=N/i*l+o,V=Math.cos(z),K=Math.sin(z);C.x=M*K,C.y=y*k,C.z=M*V,d.push(C.x,C.y,C.z),h.push(0,k,0),E.x=V*.5+.5,E.y=K*.5*k+.5,p.push(E.x,E.y),f++}for(let N=0;N<i;N++){const B=S+N,z=R+N;_===!0?c.push(z,z+1,B):c.push(z+1,z,B),T+=3}u.addGroup(m,T,_===!0?1:2),m+=T}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new K1(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class q1 extends K1{constructor(e=1,n=1,r=32,i=1,s=!1,a=0,o=Math.PI*2){super(0,e,n,r,i,s,a,o),this.type="ConeGeometry",this.parameters={radius:e,height:n,radialSegments:r,heightSegments:i,openEnded:s,thetaStart:a,thetaLength:o}}static fromJSON(e){return new q1(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class Yd extends An{constructor(e=[],n=[],r=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:n,radius:r,detail:i};const s=[],a=[];o(i),u(r),c(),this.setAttribute("position",new Jt(s,3)),this.setAttribute("normal",new Jt(s.slice(),3)),this.setAttribute("uv",new Jt(a,2)),i===0?this.computeVertexNormals():this.normalizeNormals();function o(b){const w=new Z,_=new Z,S=new Z;for(let E=0;E<n.length;E+=3)p(n[E+0],w),p(n[E+1],_),p(n[E+2],S),l(w,_,S,b)}function l(b,w,_,S){const E=S+1,C=[];for(let T=0;T<=E;T++){C[T]=[];const M=b.clone().lerp(_,T/E),k=w.clone().lerp(_,T/E),R=E-T;for(let N=0;N<=R;N++)N===0&&T===E?C[T][N]=M:C[T][N]=M.clone().lerp(k,N/R)}for(let T=0;T<E;T++)for(let M=0;M<2*(E-T)-1;M++){const k=Math.floor(M/2);M%2===0?(h(C[T][k+1]),h(C[T+1][k]),h(C[T][k])):(h(C[T][k+1]),h(C[T+1][k+1]),h(C[T+1][k]))}}function u(b){const w=new Z;for(let _=0;_<s.length;_+=3)w.x=s[_+0],w.y=s[_+1],w.z=s[_+2],w.normalize().multiplyScalar(b),s[_+0]=w.x,s[_+1]=w.y,s[_+2]=w.z}function c(){const b=new Z;for(let w=0;w<s.length;w+=3){b.x=s[w+0],b.y=s[w+1],b.z=s[w+2];const _=y(b)/2/Math.PI+.5,S=m(b)/Math.PI+.5;a.push(_,1-S)}f(),d()}function d(){for(let b=0;b<a.length;b+=6){const w=a[b+0],_=a[b+2],S=a[b+4],E=Math.max(w,_,S),C=Math.min(w,_,S);E>.9&&C<.1&&(w<.2&&(a[b+0]+=1),_<.2&&(a[b+2]+=1),S<.2&&(a[b+4]+=1))}}function h(b){s.push(b.x,b.y,b.z)}function p(b,w){const _=b*3;w.x=e[_+0],w.y=e[_+1],w.z=e[_+2]}function f(){const b=new Z,w=new Z,_=new Z,S=new Z,E=new Qe,C=new Qe,T=new Qe;for(let M=0,k=0;M<s.length;M+=9,k+=6){b.set(s[M+0],s[M+1],s[M+2]),w.set(s[M+3],s[M+4],s[M+5]),_.set(s[M+6],s[M+7],s[M+8]),E.set(a[k+0],a[k+1]),C.set(a[k+2],a[k+3]),T.set(a[k+4],a[k+5]),S.copy(b).add(w).add(_).divideScalar(3);const R=y(S);g(E,k+0,b,R),g(C,k+2,w,R),g(T,k+4,_,R)}}function g(b,w,_,S){S<0&&b.x===1&&(a[w]=b.x-1),_.x===0&&_.z===0&&(a[w]=S/2/Math.PI+.5)}function y(b){return Math.atan2(b.z,-b.x)}function m(b){return Math.atan2(-b.y,Math.sqrt(b.x*b.x+b.z*b.z))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Yd(e.vertices,e.indices,e.radius,e.details)}}class BT extends Yd{constructor(e=1,n=0){const r=(1+Math.sqrt(5))/2,i=1/r,s=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-r,0,-i,r,0,i,-r,0,i,r,-i,-r,0,-i,r,0,i,-r,0,i,r,0,-r,0,-i,r,0,-i,-r,0,i,r,0,i],a=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(s,a,e,n),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:n}}static fromJSON(e){return new BT(e.radius,e.detail)}}const jS=new Z,XS=new Z,Dk=new Z,KS=new Ia;class w9 extends An{constructor(e=null,n=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:n},e!==null){const i=Math.pow(10,4),s=Math.cos(Ep*n),a=e.getIndex(),o=e.getAttribute("position"),l=a?a.count:o.count,u=[0,0,0],c=["a","b","c"],d=new Array(3),h={},p=[];for(let f=0;f<l;f+=3){a?(u[0]=a.getX(f),u[1]=a.getX(f+1),u[2]=a.getX(f+2)):(u[0]=f,u[1]=f+1,u[2]=f+2);const{a:g,b:y,c:m}=KS;if(g.fromBufferAttribute(o,u[0]),y.fromBufferAttribute(o,u[1]),m.fromBufferAttribute(o,u[2]),KS.getNormal(Dk),d[0]=`${Math.round(g.x*i)},${Math.round(g.y*i)},${Math.round(g.z*i)}`,d[1]=`${Math.round(y.x*i)},${Math.round(y.y*i)},${Math.round(y.z*i)}`,d[2]=`${Math.round(m.x*i)},${Math.round(m.y*i)},${Math.round(m.z*i)}`,!(d[0]===d[1]||d[1]===d[2]||d[2]===d[0]))for(let b=0;b<3;b++){const w=(b+1)%3,_=d[b],S=d[w],E=KS[c[b]],C=KS[c[w]],T=`${_}_${S}`,M=`${S}_${_}`;M in h&&h[M]?(Dk.dot(h[M].normal)<=s&&(p.push(E.x,E.y,E.z),p.push(C.x,C.y,C.z)),h[M]=null):T in h||(h[T]={index0:u[b],index1:u[w],normal:Dk.clone()})}}for(const f in h)if(h[f]){const{index0:g,index1:y}=h[f];jS.fromBufferAttribute(o,g),XS.fromBufferAttribute(o,y),p.push(jS.x,jS.y,jS.z),p.push(XS.x,XS.y,XS.z)}this.setAttribute("position",new Jt(p,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}class Cl{constructor(){this.type="Curve",this.arcLengthDivisions=200,this.needsUpdate=!1,this.cacheArcLengths=null}getPoint(){console.warn("THREE.Curve: .getPoint() not implemented.")}getPointAt(e,n){const r=this.getUtoTmapping(e);return this.getPoint(r,n)}getPoints(e=5){const n=[];for(let r=0;r<=e;r++)n.push(this.getPoint(r/e));return n}getSpacedPoints(e=5){const n=[];for(let r=0;r<=e;r++)n.push(this.getPointAt(r/e));return n}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const n=[];let r,i=this.getPoint(0),s=0;n.push(0);for(let a=1;a<=e;a++)r=this.getPoint(a/e),s+=r.distanceTo(i),n.push(s),i=r;return this.cacheArcLengths=n,n}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,n=null){const r=this.getLengths();let i=0;const s=r.length;let a;n?a=n:a=e*r[s-1];let o=0,l=s-1,u;for(;o<=l;)if(i=Math.floor(o+(l-o)/2),u=r[i]-a,u<0)o=i+1;else if(u>0)l=i-1;else{l=i;break}if(i=l,r[i]===a)return i/(s-1);const c=r[i],h=r[i+1]-c,p=(a-c)/h;return(i+p)/(s-1)}getTangent(e,n){let i=e-1e-4,s=e+1e-4;i<0&&(i=0),s>1&&(s=1);const a=this.getPoint(i),o=this.getPoint(s),l=n||(a.isVector2?new Qe:new Z);return l.copy(o).sub(a).normalize(),l}getTangentAt(e,n){const r=this.getUtoTmapping(e);return this.getTangent(r,n)}computeFrenetFrames(e,n=!1){const r=new Z,i=[],s=[],a=[],o=new Z,l=new ln;for(let p=0;p<=e;p++){const f=p/e;i[p]=this.getTangentAt(f,new Z)}s[0]=new Z,a[0]=new Z;let u=Number.MAX_VALUE;const c=Math.abs(i[0].x),d=Math.abs(i[0].y),h=Math.abs(i[0].z);c<=u&&(u=c,r.set(1,0,0)),d<=u&&(u=d,r.set(0,1,0)),h<=u&&r.set(0,0,1),o.crossVectors(i[0],r).normalize(),s[0].crossVectors(i[0],o),a[0].crossVectors(i[0],s[0]);for(let p=1;p<=e;p++){if(s[p]=s[p-1].clone(),a[p]=a[p-1].clone(),o.crossVectors(i[p-1],i[p]),o.length()>Number.EPSILON){o.normalize();const f=Math.acos(En(i[p-1].dot(i[p]),-1,1));s[p].applyMatrix4(l.makeRotationAxis(o,f))}a[p].crossVectors(i[p],s[p])}if(n===!0){let p=Math.acos(En(s[0].dot(s[e]),-1,1));p/=e,i[0].dot(o.crossVectors(s[0],s[e]))>0&&(p=-p);for(let f=1;f<=e;f++)s[f].applyMatrix4(l.makeRotationAxis(i[f],p*f)),a[f].crossVectors(i[f],s[f])}return{tangents:i,normals:s,binormals:a}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.7,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class UT extends Cl{constructor(e=0,n=0,r=1,i=1,s=0,a=Math.PI*2,o=!1,l=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=n,this.xRadius=r,this.yRadius=i,this.aStartAngle=s,this.aEndAngle=a,this.aClockwise=o,this.aRotation=l}getPoint(e,n=new Qe){const r=n,i=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const a=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=i;for(;s>i;)s-=i;s<Number.EPSILON&&(a?s=0:s=i),this.aClockwise===!0&&!a&&(s===i?s=-i:s=s-i);const o=this.aStartAngle+e*s;let l=this.aX+this.xRadius*Math.cos(o),u=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const c=Math.cos(this.aRotation),d=Math.sin(this.aRotation),h=l-this.aX,p=u-this.aY;l=h*c-p*d+this.aX,u=h*d+p*c+this.aY}return r.set(l,u)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class _9 extends UT{constructor(e,n,r,i,s,a){super(e,n,r,r,i,s,a),this.isArcCurve=!0,this.type="ArcCurve"}}function BP(){let t=0,e=0,n=0,r=0;function i(s,a,o,l){t=s,e=o,n=-3*s+3*a-2*o-l,r=2*s-2*a+o+l}return{initCatmullRom:function(s,a,o,l,u){i(a,o,u*(o-s),u*(l-a))},initNonuniformCatmullRom:function(s,a,o,l,u,c,d){let h=(a-s)/u-(o-s)/(u+c)+(o-a)/c,p=(o-a)/c-(l-a)/(c+d)+(l-o)/d;h*=c,p*=c,i(a,o,h,p)},calc:function(s){const a=s*s,o=a*s;return t+e*s+n*a+r*o}}}const qS=new Z,Pk=new BP,Lk=new BP,Ok=new BP;class S9 extends Cl{constructor(e=[],n=!1,r="centripetal",i=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=n,this.curveType=r,this.tension=i}getPoint(e,n=new Z){const r=n,i=this.points,s=i.length,a=(s-(this.closed?0:1))*e;let o=Math.floor(a),l=a-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/s)+1)*s:l===0&&o===s-1&&(o=s-2,l=1);let u,c;this.closed||o>0?u=i[(o-1)%s]:(qS.subVectors(i[0],i[1]).add(i[0]),u=qS);const d=i[o%s],h=i[(o+1)%s];if(this.closed||o+2<s?c=i[(o+2)%s]:(qS.subVectors(i[s-1],i[s-2]).add(i[s-1]),c=qS),this.curveType==="centripetal"||this.curveType==="chordal"){const p=this.curveType==="chordal"?.5:.25;let f=Math.pow(u.distanceToSquared(d),p),g=Math.pow(d.distanceToSquared(h),p),y=Math.pow(h.distanceToSquared(c),p);g<1e-4&&(g=1),f<1e-4&&(f=g),y<1e-4&&(y=g),Pk.initNonuniformCatmullRom(u.x,d.x,h.x,c.x,f,g,y),Lk.initNonuniformCatmullRom(u.y,d.y,h.y,c.y,f,g,y),Ok.initNonuniformCatmullRom(u.z,d.z,h.z,c.z,f,g,y)}else this.curveType==="catmullrom"&&(Pk.initCatmullRom(u.x,d.x,h.x,c.x,this.tension),Lk.initCatmullRom(u.y,d.y,h.y,c.y,this.tension),Ok.initCatmullRom(u.z,d.z,h.z,c.z,this.tension));return r.set(Pk.calc(l),Lk.calc(l),Ok.calc(l)),r}copy(e){super.copy(e),this.points=[];for(let n=0,r=e.points.length;n<r;n++){const i=e.points[n];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let n=0,r=this.points.length;n<r;n++){const i=this.points[n];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let n=0,r=e.points.length;n<r;n++){const i=e.points[n];this.points.push(new Z().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function FG(t,e,n,r,i){const s=(r-e)*.5,a=(i-n)*.5,o=t*t,l=t*o;return(2*n-2*r+s+a)*l+(-3*n+3*r-2*s-a)*o+s*t+n}function wce(t,e){const n=1-t;return n*n*e}function _ce(t,e){return 2*(1-t)*t*e}function Sce(t,e){return t*t*e}function Eb(t,e,n,r){return wce(t,e)+_ce(t,n)+Sce(t,r)}function Ace(t,e){const n=1-t;return n*n*n*e}function Ece(t,e){const n=1-t;return 3*n*n*t*e}function Ice(t,e){return 3*(1-t)*t*t*e}function Tce(t,e){return t*t*t*e}function Ib(t,e,n,r,i){return Ace(t,e)+Ece(t,n)+Ice(t,r)+Tce(t,i)}class UP extends Cl{constructor(e=new Qe,n=new Qe,r=new Qe,i=new Qe){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=n,this.v2=r,this.v3=i}getPoint(e,n=new Qe){const r=n,i=this.v0,s=this.v1,a=this.v2,o=this.v3;return r.set(Ib(e,i.x,s.x,a.x,o.x),Ib(e,i.y,s.y,a.y,o.y)),r}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class A9 extends Cl{constructor(e=new Z,n=new Z,r=new Z,i=new Z){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=n,this.v2=r,this.v3=i}getPoint(e,n=new Z){const r=n,i=this.v0,s=this.v1,a=this.v2,o=this.v3;return r.set(Ib(e,i.x,s.x,a.x,o.x),Ib(e,i.y,s.y,a.y,o.y),Ib(e,i.z,s.z,a.z,o.z)),r}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class $P extends Cl{constructor(e=new Qe,n=new Qe){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=n}getPoint(e,n=new Qe){const r=n;return e===1?r.copy(this.v2):(r.copy(this.v2).sub(this.v1),r.multiplyScalar(e).add(this.v1)),r}getPointAt(e,n){return this.getPoint(e,n)}getTangent(e,n=new Qe){return n.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,n){return this.getTangent(e,n)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class E9 extends Cl{constructor(e=new Z,n=new Z){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=n}getPoint(e,n=new Z){const r=n;return e===1?r.copy(this.v2):(r.copy(this.v2).sub(this.v1),r.multiplyScalar(e).add(this.v1)),r}getPointAt(e,n){return this.getPoint(e,n)}getTangent(e,n=new Z){return n.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,n){return this.getTangent(e,n)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class zP extends Cl{constructor(e=new Qe,n=new Qe,r=new Qe){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=n,this.v2=r}getPoint(e,n=new Qe){const r=n,i=this.v0,s=this.v1,a=this.v2;return r.set(Eb(e,i.x,s.x,a.x),Eb(e,i.y,s.y,a.y)),r}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class GP extends Cl{constructor(e=new Z,n=new Z,r=new Z){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=n,this.v2=r}getPoint(e,n=new Z){const r=n,i=this.v0,s=this.v1,a=this.v2;return r.set(Eb(e,i.x,s.x,a.x),Eb(e,i.y,s.y,a.y),Eb(e,i.z,s.z,a.z)),r}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class HP extends Cl{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,n=new Qe){const r=n,i=this.points,s=(i.length-1)*e,a=Math.floor(s),o=s-a,l=i[a===0?a:a-1],u=i[a],c=i[a>i.length-2?i.length-1:a+1],d=i[a>i.length-3?i.length-1:a+2];return r.set(FG(o,l.x,u.x,c.x,d.x),FG(o,l.y,u.y,c.y,d.y)),r}copy(e){super.copy(e),this.points=[];for(let n=0,r=e.points.length;n<r;n++){const i=e.points[n];this.points.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let n=0,r=this.points.length;n<r;n++){const i=this.points[n];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let n=0,r=e.points.length;n<r;n++){const i=e.points[n];this.points.push(new Qe().fromArray(i))}return this}}var xI=Object.freeze({__proto__:null,ArcCurve:_9,CatmullRomCurve3:S9,CubicBezierCurve:UP,CubicBezierCurve3:A9,EllipseCurve:UT,LineCurve:$P,LineCurve3:E9,QuadraticBezierCurve:zP,QuadraticBezierCurve3:GP,SplineCurve:HP});class I9 extends Cl{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),n=this.curves[this.curves.length-1].getPoint(1);if(!e.equals(n)){const r=e.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new xI[r](n,e))}return this}getPoint(e,n){const r=e*this.getLength(),i=this.getCurveLengths();let s=0;for(;s<i.length;){if(i[s]>=r){const a=i[s]-r,o=this.curves[s],l=o.getLength(),u=l===0?0:1-a/l;return o.getPointAt(u,n)}s++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let n=0;for(let r=0,i=this.curves.length;r<i;r++)n+=this.curves[r].getLength(),e.push(n);return this.cacheLengths=e,e}getSpacedPoints(e=40){const n=[];for(let r=0;r<=e;r++)n.push(this.getPoint(r/e));return this.autoClose&&n.push(n[0]),n}getPoints(e=12){const n=[];let r;for(let i=0,s=this.curves;i<s.length;i++){const a=s[i],o=a.isEllipseCurve?e*2:a.isLineCurve||a.isLineCurve3?1:a.isSplineCurve?e*a.points.length:e,l=a.getPoints(o);for(let u=0;u<l.length;u++){const c=l[u];r&&r.equals(c)||(n.push(c),r=c)}}return this.autoClose&&n.length>1&&!n[n.length-1].equals(n[0])&&n.push(n[0]),n}copy(e){super.copy(e),this.curves=[];for(let n=0,r=e.curves.length;n<r;n++){const i=e.curves[n];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let n=0,r=this.curves.length;n<r;n++){const i=this.curves[n];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let n=0,r=e.curves.length;n<r;n++){const i=e.curves[n];this.curves.push(new xI[i.type]().fromJSON(i))}return this}}class bI extends I9{constructor(e){super(),this.type="Path",this.currentPoint=new Qe,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let n=1,r=e.length;n<r;n++)this.lineTo(e[n].x,e[n].y);return this}moveTo(e,n){return this.currentPoint.set(e,n),this}lineTo(e,n){const r=new $P(this.currentPoint.clone(),new Qe(e,n));return this.curves.push(r),this.currentPoint.set(e,n),this}quadraticCurveTo(e,n,r,i){const s=new zP(this.currentPoint.clone(),new Qe(e,n),new Qe(r,i));return this.curves.push(s),this.currentPoint.set(r,i),this}bezierCurveTo(e,n,r,i,s,a){const o=new UP(this.currentPoint.clone(),new Qe(e,n),new Qe(r,i),new Qe(s,a));return this.curves.push(o),this.currentPoint.set(s,a),this}splineThru(e){const n=[this.currentPoint.clone()].concat(e),r=new HP(n);return this.curves.push(r),this.currentPoint.copy(e[e.length-1]),this}arc(e,n,r,i,s,a){const o=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+o,n+l,r,i,s,a),this}absarc(e,n,r,i,s,a){return this.absellipse(e,n,r,r,i,s,a),this}ellipse(e,n,r,i,s,a,o,l){const u=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(e+u,n+c,r,i,s,a,o,l),this}absellipse(e,n,r,i,s,a,o,l){const u=new UT(e,n,r,i,s,a,o,l);if(this.curves.length>0){const d=u.getPoint(0);d.equals(this.currentPoint)||this.lineTo(d.x,d.y)}this.curves.push(u);const c=u.getPoint(1);return this.currentPoint.copy(c),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class Cp extends bI{constructor(e){super(e),this.uuid=ao(),this.type="Shape",this.holes=[]}getPointsHoles(e){const n=[];for(let r=0,i=this.holes.length;r<i;r++)n[r]=this.holes[r].getPoints(e);return n}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let n=0,r=e.holes.length;n<r;n++){const i=e.holes[n];this.holes.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let n=0,r=this.holes.length;n<r;n++){const i=this.holes[n];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let n=0,r=e.holes.length;n<r;n++){const i=e.holes[n];this.holes.push(new bI().fromJSON(i))}return this}}function Cce(t,e,n=2){const r=e&&e.length,i=r?e[0]*n:t.length;let s=T9(t,0,i,n,!0);const a=[];if(!s||s.next===s.prev)return a;let o,l,u;if(r&&(s=Fce(t,e,s,n)),t.length>80*n){o=1/0,l=1/0;let c=-1/0,d=-1/0;for(let h=n;h<i;h+=n){const p=t[h],f=t[h+1];p<o&&(o=p),f<l&&(l=f),p>c&&(c=p),f>d&&(d=f)}u=Math.max(c-o,d-l),u=u!==0?32767/u:0}return a1(s,a,n,o,l,u,0),a}function T9(t,e,n,r,i){let s;if(i===Wce(t,e,n,r)>0)for(let a=e;a<n;a+=r)s=DG(a/r|0,t[a],t[a+1],s);else for(let a=n-r;a>=e;a-=r)s=DG(a/r|0,t[a],t[a+1],s);return s&&zy(s,s.next)&&(l1(s),s=s.next),s}function Hp(t,e){if(!t)return t;e||(e=t);let n=t,r;do if(r=!1,!n.steiner&&(zy(n,n.next)||ei(n.prev,n,n.next)===0)){if(l1(n),n=e=n.prev,n===n.next)break;r=!0}else n=n.next;while(r||n!==e);return e}function a1(t,e,n,r,i,s,a){if(!t)return;!a&&s&&Bce(t,r,i,s);let o=t;for(;t.prev!==t.next;){const l=t.prev,u=t.next;if(s?kce(t,r,i,s):Mce(t)){e.push(l.i,t.i,u.i),l1(t),t=u.next,o=u.next;continue}if(t=u,t===o){a?a===1?(t=Nce(Hp(t),e),a1(t,e,n,r,i,s,2)):a===2&&Rce(t,e,n,r,i,s):a1(Hp(t),e,n,r,i,s,1);break}}}function Mce(t){const e=t.prev,n=t,r=t.next;if(ei(e,n,r)>=0)return!1;const i=e.x,s=n.x,a=r.x,o=e.y,l=n.y,u=r.y,c=Math.min(i,s,a),d=Math.min(o,l,u),h=Math.max(i,s,a),p=Math.max(o,l,u);let f=r.next;for(;f!==e;){if(f.x>=c&&f.x<=h&&f.y>=d&&f.y<=p&&Jx(i,o,s,l,a,u,f.x,f.y)&&ei(f.prev,f,f.next)>=0)return!1;f=f.next}return!0}function kce(t,e,n,r){const i=t.prev,s=t,a=t.next;if(ei(i,s,a)>=0)return!1;const o=i.x,l=s.x,u=a.x,c=i.y,d=s.y,h=a.y,p=Math.min(o,l,u),f=Math.min(c,d,h),g=Math.max(o,l,u),y=Math.max(c,d,h),m=WR(p,f,e,n,r),b=WR(g,y,e,n,r);let w=t.prevZ,_=t.nextZ;for(;w&&w.z>=m&&_&&_.z<=b;){if(w.x>=p&&w.x<=g&&w.y>=f&&w.y<=y&&w!==i&&w!==a&&Jx(o,c,l,d,u,h,w.x,w.y)&&ei(w.prev,w,w.next)>=0||(w=w.prevZ,_.x>=p&&_.x<=g&&_.y>=f&&_.y<=y&&_!==i&&_!==a&&Jx(o,c,l,d,u,h,_.x,_.y)&&ei(_.prev,_,_.next)>=0))return!1;_=_.nextZ}for(;w&&w.z>=m;){if(w.x>=p&&w.x<=g&&w.y>=f&&w.y<=y&&w!==i&&w!==a&&Jx(o,c,l,d,u,h,w.x,w.y)&&ei(w.prev,w,w.next)>=0)return!1;w=w.prevZ}for(;_&&_.z<=b;){if(_.x>=p&&_.x<=g&&_.y>=f&&_.y<=y&&_!==i&&_!==a&&Jx(o,c,l,d,u,h,_.x,_.y)&&ei(_.prev,_,_.next)>=0)return!1;_=_.nextZ}return!0}function Nce(t,e){let n=t;do{const r=n.prev,i=n.next.next;!zy(r,i)&&M9(r,n,n.next,i)&&o1(r,i)&&o1(i,r)&&(e.push(r.i,n.i,i.i),l1(n),l1(n.next),n=t=i),n=n.next}while(n!==t);return Hp(n)}function Rce(t,e,n,r,i,s){let a=t;do{let o=a.next.next;for(;o!==a.prev;){if(a.i!==o.i&&zce(a,o)){let l=k9(a,o);a=Hp(a,a.next),l=Hp(l,l.next),a1(a,e,n,r,i,s,0),a1(l,e,n,r,i,s,0);return}o=o.next}a=a.next}while(a!==t)}function Fce(t,e,n,r){const i=[];for(let s=0,a=e.length;s<a;s++){const o=e[s]*r,l=s<a-1?e[s+1]*r:t.length,u=T9(t,o,l,r,!1);u===u.next&&(u.steiner=!0),i.push($ce(u))}i.sort(Dce);for(let s=0;s<i.length;s++)n=Pce(i[s],n);return n}function Dce(t,e){let n=t.x-e.x;if(n===0&&(n=t.y-e.y,n===0)){const r=(t.next.y-t.y)/(t.next.x-t.x),i=(e.next.y-e.y)/(e.next.x-e.x);n=r-i}return n}function Pce(t,e){const n=Lce(t,e);if(!n)return e;const r=k9(n,t);return Hp(r,r.next),Hp(n,n.next)}function Lce(t,e){let n=e;const r=t.x,i=t.y;let s=-1/0,a;if(zy(t,n))return n;do{if(zy(t,n.next))return n.next;if(i<=n.y&&i>=n.next.y&&n.next.y!==n.y){const d=n.x+(i-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(d<=r&&d>s&&(s=d,a=n.x<n.next.x?n:n.next,d===r))return a}n=n.next}while(n!==e);if(!a)return null;const o=a,l=a.x,u=a.y;let c=1/0;n=a;do{if(r>=n.x&&n.x>=l&&r!==n.x&&C9(i<u?r:s,i,l,u,i<u?s:r,i,n.x,n.y)){const d=Math.abs(i-n.y)/(r-n.x);o1(n,t)&&(d<c||d===c&&(n.x>a.x||n.x===a.x&&Oce(a,n)))&&(a=n,c=d)}n=n.next}while(n!==o);return a}function Oce(t,e){return ei(t.prev,t,e.prev)<0&&ei(e.next,t,t.next)<0}function Bce(t,e,n,r){let i=t;do i.z===0&&(i.z=WR(i.x,i.y,e,n,r)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,Uce(i)}function Uce(t){let e,n=1;do{let r=t,i;t=null;let s=null;for(e=0;r;){e++;let a=r,o=0;for(let u=0;u<n&&(o++,a=a.nextZ,!!a);u++);let l=n;for(;o>0||l>0&&a;)o!==0&&(l===0||!a||r.z<=a.z)?(i=r,r=r.nextZ,o--):(i=a,a=a.nextZ,l--),s?s.nextZ=i:t=i,i.prevZ=s,s=i;r=a}s.nextZ=null,n*=2}while(e>1);return t}function WR(t,e,n,r,i){return t=(t-n)*i|0,e=(e-r)*i|0,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,t|e<<1}function $ce(t){let e=t,n=t;do(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next;while(e!==t);return n}function C9(t,e,n,r,i,s,a,o){return(i-a)*(e-o)>=(t-a)*(s-o)&&(t-a)*(r-o)>=(n-a)*(e-o)&&(n-a)*(s-o)>=(i-a)*(r-o)}function Jx(t,e,n,r,i,s,a,o){return!(t===a&&e===o)&&C9(t,e,n,r,i,s,a,o)}function zce(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!Gce(t,e)&&(o1(t,e)&&o1(e,t)&&Hce(t,e)&&(ei(t.prev,t,e.prev)||ei(t,e.prev,e))||zy(t,e)&&ei(t.prev,t,t.next)>0&&ei(e.prev,e,e.next)>0)}function ei(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function zy(t,e){return t.x===e.x&&t.y===e.y}function M9(t,e,n,r){const i=YS(ei(t,e,n)),s=YS(ei(t,e,r)),a=YS(ei(n,r,t)),o=YS(ei(n,r,e));return!!(i!==s&&a!==o||i===0&&JS(t,n,e)||s===0&&JS(t,r,e)||a===0&&JS(n,t,r)||o===0&&JS(n,e,r))}function JS(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function YS(t){return t>0?1:t<0?-1:0}function Gce(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&M9(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}function o1(t,e){return ei(t.prev,t,t.next)<0?ei(t,e,t.next)>=0&&ei(t,t.prev,e)>=0:ei(t,e,t.prev)<0||ei(t,t.next,e)<0}function Hce(t,e){let n=t,r=!1;const i=(t.x+e.x)/2,s=(t.y+e.y)/2;do n.y>s!=n.next.y>s&&n.next.y!==n.y&&i<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next;while(n!==t);return r}function k9(t,e){const n=VR(t.i,t.x,t.y),r=VR(e.i,e.x,e.y),i=t.next,s=e.prev;return t.next=e,e.prev=t,n.next=i,i.prev=n,r.next=n,n.prev=r,s.next=r,r.prev=s,r}function DG(t,e,n,r){const i=VR(t,e,n);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function l1(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function VR(t,e,n){return{i:t,x:e,y:n,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}function Wce(t,e,n,r){let i=0;for(let s=e,a=n-r;s<n;s+=r)i+=(t[a]-t[s])*(t[s+1]+t[a+1]),a=s;return i}class Vce{static triangulate(e,n,r=2){return Cce(e,n,r)}}class fl{static area(e){const n=e.length;let r=0;for(let i=n-1,s=0;s<n;i=s++)r+=e[i].x*e[s].y-e[s].x*e[i].y;return r*.5}static isClockWise(e){return fl.area(e)<0}static triangulateShape(e,n){const r=[],i=[],s=[];PG(e),LG(r,e);let a=e.length;n.forEach(PG);for(let l=0;l<n.length;l++)i.push(a),a+=n[l].length,LG(r,n[l]);const o=Vce.triangulate(r,i);for(let l=0;l<o.length;l+=3)s.push(o.slice(l,l+3));return s}}function PG(t){const e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function LG(t,e){for(let n=0;n<e.length;n++)t.push(e[n].x),t.push(e[n].y)}class $T extends An{constructor(e=new Cp([new Qe(.5,.5),new Qe(-.5,.5),new Qe(-.5,-.5),new Qe(.5,-.5)]),n={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:n},e=Array.isArray(e)?e:[e];const r=this,i=[],s=[];for(let o=0,l=e.length;o<l;o++){const u=e[o];a(u)}this.setAttribute("position",new Jt(i,3)),this.setAttribute("uv",new Jt(s,2)),this.computeVertexNormals();function a(o){const l=[],u=n.curveSegments!==void 0?n.curveSegments:12,c=n.steps!==void 0?n.steps:1,d=n.depth!==void 0?n.depth:1;let h=n.bevelEnabled!==void 0?n.bevelEnabled:!0,p=n.bevelThickness!==void 0?n.bevelThickness:.2,f=n.bevelSize!==void 0?n.bevelSize:p-.1,g=n.bevelOffset!==void 0?n.bevelOffset:0,y=n.bevelSegments!==void 0?n.bevelSegments:3;const m=n.extrudePath,b=n.UVGenerator!==void 0?n.UVGenerator:jce;let w,_=!1,S,E,C,T;m&&(w=m.getSpacedPoints(c),_=!0,h=!1,S=m.computeFrenetFrames(c,!1),E=new Z,C=new Z,T=new Z),h||(y=0,p=0,f=0,g=0);const M=o.extractPoints(u);let k=M.shape;const R=M.holes;if(!fl.isClockWise(k)){k=k.reverse();for(let J=0,Ye=R.length;J<Ye;J++){const Be=R[J];fl.isClockWise(Be)&&(R[J]=Be.reverse())}}function B(J){const Be=10000000000000001e-36;let tt=J[0];for(let Ue=1;Ue<=J.length;Ue++){const St=Ue%J.length,Je=J[St],At=Je.x-tt.x,Vt=Je.y-tt.y,re=At*At+Vt*Vt,H=Math.max(Math.abs(Je.x),Math.abs(Je.y),Math.abs(tt.x),Math.abs(tt.y)),Ee=Be*H*H;if(re<=Ee){J.splice(St,1),Ue--;continue}tt=Je}}B(k),R.forEach(B);const z=R.length,V=k;for(let J=0;J<z;J++){const Ye=R[J];k=k.concat(Ye)}function K(J,Ye,Be){return Ye||console.error("THREE.ExtrudeGeometry: vec does not exist"),J.clone().addScaledVector(Ye,Be)}const Q=k.length;function O(J,Ye,Be){let tt,Ue,St;const Je=J.x-Ye.x,At=J.y-Ye.y,Vt=Be.x-J.x,re=Be.y-J.y,H=Je*Je+At*At,Ee=Je*re-At*Vt;if(Math.abs(Ee)>Number.EPSILON){const Oe=Math.sqrt(H),Xe=Math.sqrt(Vt*Vt+re*re),$e=Ye.x-At/Oe,Lt=Ye.y+Je/Oe,wt=Be.x-re/Xe,Pt=Be.y+Vt/Xe,Ht=((wt-$e)*re-(Pt-Lt)*Vt)/(Je*re-At*Vt);tt=$e+Je*Ht-J.x,Ue=Lt+At*Ht-J.y;const et=tt*tt+Ue*Ue;if(et<=2)return new Qe(tt,Ue);St=Math.sqrt(et/2)}else{let Oe=!1;Je>Number.EPSILON?Vt>Number.EPSILON&&(Oe=!0):Je<-Number.EPSILON?Vt<-Number.EPSILON&&(Oe=!0):Math.sign(At)===Math.sign(re)&&(Oe=!0),Oe?(tt=-At,Ue=Je,St=Math.sqrt(H)):(tt=Je,Ue=At,St=Math.sqrt(H/2))}return new Qe(tt/St,Ue/St)}const j=[];for(let J=0,Ye=V.length,Be=Ye-1,tt=J+1;J<Ye;J++,Be++,tt++)Be===Ye&&(Be=0),tt===Ye&&(tt=0),j[J]=O(V[J],V[Be],V[tt]);const X=[];let te,le=j.concat();for(let J=0,Ye=z;J<Ye;J++){const Be=R[J];te=[];for(let tt=0,Ue=Be.length,St=Ue-1,Je=tt+1;tt<Ue;tt++,St++,Je++)St===Ue&&(St=0),Je===Ue&&(Je=0),te[tt]=O(Be[tt],Be[St],Be[Je]);X.push(te),le=le.concat(te)}let ge;if(y===0)ge=fl.triangulateShape(V,R);else{const J=[],Ye=[];for(let Be=0;Be<y;Be++){const tt=Be/y,Ue=p*Math.cos(tt*Math.PI/2),St=f*Math.sin(tt*Math.PI/2)+g;for(let Je=0,At=V.length;Je<At;Je++){const Vt=K(V[Je],j[Je],St);lt(Vt.x,Vt.y,-Ue),tt===0&&J.push(Vt)}for(let Je=0,At=z;Je<At;Je++){const Vt=R[Je];te=X[Je];const re=[];for(let H=0,Ee=Vt.length;H<Ee;H++){const Oe=K(Vt[H],te[H],St);lt(Oe.x,Oe.y,-Ue),tt===0&&re.push(Oe)}tt===0&&Ye.push(re)}}ge=fl.triangulateShape(J,Ye)}const ie=ge.length,we=f+g;for(let J=0;J<Q;J++){const Ye=h?K(k[J],le[J],we):k[J];_?(C.copy(S.normals[0]).multiplyScalar(Ye.x),E.copy(S.binormals[0]).multiplyScalar(Ye.y),T.copy(w[0]).add(C).add(E),lt(T.x,T.y,T.z)):lt(Ye.x,Ye.y,0)}for(let J=1;J<=c;J++)for(let Ye=0;Ye<Q;Ye++){const Be=h?K(k[Ye],le[Ye],we):k[Ye];_?(C.copy(S.normals[J]).multiplyScalar(Be.x),E.copy(S.binormals[J]).multiplyScalar(Be.y),T.copy(w[J]).add(C).add(E),lt(T.x,T.y,T.z)):lt(Be.x,Be.y,d/c*J)}for(let J=y-1;J>=0;J--){const Ye=J/y,Be=p*Math.cos(Ye*Math.PI/2),tt=f*Math.sin(Ye*Math.PI/2)+g;for(let Ue=0,St=V.length;Ue<St;Ue++){const Je=K(V[Ue],j[Ue],tt);lt(Je.x,Je.y,d+Be)}for(let Ue=0,St=R.length;Ue<St;Ue++){const Je=R[Ue];te=X[Ue];for(let At=0,Vt=Je.length;At<Vt;At++){const re=K(Je[At],te[At],tt);_?lt(re.x,re.y+w[c-1].y,w[c-1].x+Be):lt(re.x,re.y,d+Be)}}}Ce(),Re();function Ce(){const J=i.length/3;if(h){let Ye=0,Be=Q*Ye;for(let tt=0;tt<ie;tt++){const Ue=ge[tt];st(Ue[2]+Be,Ue[1]+Be,Ue[0]+Be)}Ye=c+y*2,Be=Q*Ye;for(let tt=0;tt<ie;tt++){const Ue=ge[tt];st(Ue[0]+Be,Ue[1]+Be,Ue[2]+Be)}}else{for(let Ye=0;Ye<ie;Ye++){const Be=ge[Ye];st(Be[2],Be[1],Be[0])}for(let Ye=0;Ye<ie;Ye++){const Be=ge[Ye];st(Be[0]+Q*c,Be[1]+Q*c,Be[2]+Q*c)}}r.addGroup(J,i.length/3-J,0)}function Re(){const J=i.length/3;let Ye=0;Le(V,Ye),Ye+=V.length;for(let Be=0,tt=R.length;Be<tt;Be++){const Ue=R[Be];Le(Ue,Ye),Ye+=Ue.length}r.addGroup(J,i.length/3-J,1)}function Le(J,Ye){let Be=J.length;for(;--Be>=0;){const tt=Be;let Ue=Be-1;Ue<0&&(Ue=J.length-1);for(let St=0,Je=c+y*2;St<Je;St++){const At=Q*St,Vt=Q*(St+1),re=Ye+tt+At,H=Ye+Ue+At,Ee=Ye+Ue+Vt,Oe=Ye+tt+Vt;Et(re,H,Ee,Oe)}}}function lt(J,Ye,Be){l.push(J),l.push(Ye),l.push(Be)}function st(J,Ye,Be){Tt(J),Tt(Ye),Tt(Be);const tt=i.length/3,Ue=b.generateTopUV(r,i,tt-3,tt-2,tt-1);xt(Ue[0]),xt(Ue[1]),xt(Ue[2])}function Et(J,Ye,Be,tt){Tt(J),Tt(Ye),Tt(tt),Tt(Ye),Tt(Be),Tt(tt);const Ue=i.length/3,St=b.generateSideWallUV(r,i,Ue-6,Ue-3,Ue-2,Ue-1);xt(St[0]),xt(St[1]),xt(St[3]),xt(St[1]),xt(St[2]),xt(St[3])}function Tt(J){i.push(l[J*3+0]),i.push(l[J*3+1]),i.push(l[J*3+2])}function xt(J){s.push(J.x),s.push(J.y)}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),n=this.parameters.shapes,r=this.parameters.options;return Xce(n,r,e)}static fromJSON(e,n){const r=[];for(let s=0,a=e.shapes.length;s<a;s++){const o=n[e.shapes[s]];r.push(o)}const i=e.options.extrudePath;return i!==void 0&&(e.options.extrudePath=new xI[i.type]().fromJSON(i)),new $T(r,e.options)}}const jce={generateTopUV:function(t,e,n,r,i){const s=e[n*3],a=e[n*3+1],o=e[r*3],l=e[r*3+1],u=e[i*3],c=e[i*3+1];return[new Qe(s,a),new Qe(o,l),new Qe(u,c)]},generateSideWallUV:function(t,e,n,r,i,s){const a=e[n*3],o=e[n*3+1],l=e[n*3+2],u=e[r*3],c=e[r*3+1],d=e[r*3+2],h=e[i*3],p=e[i*3+1],f=e[i*3+2],g=e[s*3],y=e[s*3+1],m=e[s*3+2];return Math.abs(o-c)<Math.abs(a-u)?[new Qe(a,1-l),new Qe(u,1-d),new Qe(h,1-f),new Qe(g,1-m)]:[new Qe(o,1-l),new Qe(c,1-d),new Qe(p,1-f),new Qe(y,1-m)]}};function Xce(t,e,n){if(n.shapes=[],Array.isArray(t))for(let r=0,i=t.length;r<i;r++){const s=t[r];n.shapes.push(s.uuid)}else n.shapes.push(t.uuid);return n.options=Object.assign({},e),e.extrudePath!==void 0&&(n.options.extrudePath=e.extrudePath.toJSON()),n}class J1 extends Yd{constructor(e=1,n=0){const r=(1+Math.sqrt(5))/2,i=[-1,r,0,1,r,0,-1,-r,0,1,-r,0,0,-1,r,0,1,r,0,-1,-r,0,1,-r,r,0,-1,r,0,1,-r,0,-1,-r,0,1],s=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(i,s,e,n),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:n}}static fromJSON(e){return new J1(e.radius,e.detail)}}class zT extends An{constructor(e=[new Qe(0,-.5),new Qe(.5,0),new Qe(0,.5)],n=12,r=0,i=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:n,phiStart:r,phiLength:i},n=Math.floor(n),i=En(i,0,Math.PI*2);const s=[],a=[],o=[],l=[],u=[],c=1/n,d=new Z,h=new Qe,p=new Z,f=new Z,g=new Z;let y=0,m=0;for(let b=0;b<=e.length-1;b++)switch(b){case 0:y=e[b+1].x-e[b].x,m=e[b+1].y-e[b].y,p.x=m*1,p.y=-y,p.z=m*0,g.copy(p),p.normalize(),l.push(p.x,p.y,p.z);break;case e.length-1:l.push(g.x,g.y,g.z);break;default:y=e[b+1].x-e[b].x,m=e[b+1].y-e[b].y,p.x=m*1,p.y=-y,p.z=m*0,f.copy(p),p.x+=g.x,p.y+=g.y,p.z+=g.z,p.normalize(),l.push(p.x,p.y,p.z),g.copy(f)}for(let b=0;b<=n;b++){const w=r+b*c*i,_=Math.sin(w),S=Math.cos(w);for(let E=0;E<=e.length-1;E++){d.x=e[E].x*_,d.y=e[E].y,d.z=e[E].x*S,a.push(d.x,d.y,d.z),h.x=b/n,h.y=E/(e.length-1),o.push(h.x,h.y);const C=l[3*E+0]*_,T=l[3*E+1],M=l[3*E+0]*S;u.push(C,T,M)}}for(let b=0;b<n;b++)for(let w=0;w<e.length-1;w++){const _=w+b*e.length,S=_,E=_+e.length,C=_+e.length+1,T=_+1;s.push(S,E,T),s.push(C,T,E)}this.setIndex(s),this.setAttribute("position",new Jt(a,3)),this.setAttribute("uv",new Jt(o,2)),this.setAttribute("normal",new Jt(u,3))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new zT(e.points,e.segments,e.phiStart,e.phiLength)}}class Y1 extends Yd{constructor(e=1,n=0){const r=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(r,i,e,n),this.type="OctahedronGeometry",this.parameters={radius:e,detail:n}}static fromJSON(e){return new Y1(e.radius,e.detail)}}class yu extends An{constructor(e=1,n=1,r=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:n,widthSegments:r,heightSegments:i};const s=e/2,a=n/2,o=Math.floor(r),l=Math.floor(i),u=o+1,c=l+1,d=e/o,h=n/l,p=[],f=[],g=[],y=[];for(let m=0;m<c;m++){const b=m*h-a;for(let w=0;w<u;w++){const _=w*d-s;f.push(_,-b,0),g.push(0,0,1),y.push(w/o),y.push(1-m/l)}}for(let m=0;m<l;m++)for(let b=0;b<o;b++){const w=b+u*m,_=b+u*(m+1),S=b+1+u*(m+1),E=b+1+u*m;p.push(w,_,E),p.push(_,S,E)}this.setIndex(p),this.setAttribute("position",new Jt(f,3)),this.setAttribute("normal",new Jt(g,3)),this.setAttribute("uv",new Jt(y,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new yu(e.width,e.height,e.widthSegments,e.heightSegments)}}class GT extends An{constructor(e=.5,n=1,r=32,i=1,s=0,a=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:n,thetaSegments:r,phiSegments:i,thetaStart:s,thetaLength:a},r=Math.max(3,r),i=Math.max(1,i);const o=[],l=[],u=[],c=[];let d=e;const h=(n-e)/i,p=new Z,f=new Qe;for(let g=0;g<=i;g++){for(let y=0;y<=r;y++){const m=s+y/r*a;p.x=d*Math.cos(m),p.y=d*Math.sin(m),l.push(p.x,p.y,p.z),u.push(0,0,1),f.x=(p.x/n+1)/2,f.y=(p.y/n+1)/2,c.push(f.x,f.y)}d+=h}for(let g=0;g<i;g++){const y=g*(r+1);for(let m=0;m<r;m++){const b=m+y,w=b,_=b+r+1,S=b+r+2,E=b+1;o.push(w,_,E),o.push(_,S,E)}}this.setIndex(o),this.setAttribute("position",new Jt(l,3)),this.setAttribute("normal",new Jt(u,3)),this.setAttribute("uv",new Jt(c,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new GT(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class HT extends An{constructor(e=new Cp([new Qe(0,.5),new Qe(-.5,-.5),new Qe(.5,-.5)]),n=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:n};const r=[],i=[],s=[],a=[];let o=0,l=0;if(Array.isArray(e)===!1)u(e);else for(let c=0;c<e.length;c++)u(e[c]),this.addGroup(o,l,c),o+=l,l=0;this.setIndex(r),this.setAttribute("position",new Jt(i,3)),this.setAttribute("normal",new Jt(s,3)),this.setAttribute("uv",new Jt(a,2));function u(c){const d=i.length/3,h=c.extractPoints(n);let p=h.shape;const f=h.holes;fl.isClockWise(p)===!1&&(p=p.reverse());for(let y=0,m=f.length;y<m;y++){const b=f[y];fl.isClockWise(b)===!0&&(f[y]=b.reverse())}const g=fl.triangulateShape(p,f);for(let y=0,m=f.length;y<m;y++){const b=f[y];p=p.concat(b)}for(let y=0,m=p.length;y<m;y++){const b=p[y];i.push(b.x,b.y,0),s.push(0,0,1),a.push(b.x,b.y)}for(let y=0,m=g.length;y<m;y++){const b=g[y],w=b[0]+d,_=b[1]+d,S=b[2]+d;r.push(w,_,S),l+=3}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),n=this.parameters.shapes;return Kce(n,e)}static fromJSON(e,n){const r=[];for(let i=0,s=e.shapes.length;i<s;i++){const a=n[e.shapes[i]];r.push(a)}return new HT(r,e.curveSegments)}}function Kce(t,e){if(e.shapes=[],Array.isArray(t))for(let n=0,r=t.length;n<r;n++){const i=t[n];e.shapes.push(i.uuid)}else e.shapes.push(t.uuid);return e}class Z1 extends An{constructor(e=1,n=32,r=16,i=0,s=Math.PI*2,a=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:n,heightSegments:r,phiStart:i,phiLength:s,thetaStart:a,thetaLength:o},n=Math.max(3,Math.floor(n)),r=Math.max(2,Math.floor(r));const l=Math.min(a+o,Math.PI);let u=0;const c=[],d=new Z,h=new Z,p=[],f=[],g=[],y=[];for(let m=0;m<=r;m++){const b=[],w=m/r;let _=0;m===0&&a===0?_=.5/n:m===r&&l===Math.PI&&(_=-.5/n);for(let S=0;S<=n;S++){const E=S/n;d.x=-e*Math.cos(i+E*s)*Math.sin(a+w*o),d.y=e*Math.cos(a+w*o),d.z=e*Math.sin(i+E*s)*Math.sin(a+w*o),f.push(d.x,d.y,d.z),h.copy(d).normalize(),g.push(h.x,h.y,h.z),y.push(E+_,1-w),b.push(u++)}c.push(b)}for(let m=0;m<r;m++)for(let b=0;b<n;b++){const w=c[m][b+1],_=c[m][b],S=c[m+1][b],E=c[m+1][b+1];(m!==0||a>0)&&p.push(w,_,E),(m!==r-1||l<Math.PI)&&p.push(_,S,E)}this.setIndex(p),this.setAttribute("position",new Jt(f,3)),this.setAttribute("normal",new Jt(g,3)),this.setAttribute("uv",new Jt(y,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Z1(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class WT extends Yd{constructor(e=1,n=0){const r=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];super(r,i,e,n),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:n}}static fromJSON(e){return new WT(e.radius,e.detail)}}class VT extends An{constructor(e=1,n=.4,r=12,i=48,s=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:n,radialSegments:r,tubularSegments:i,arc:s},r=Math.floor(r),i=Math.floor(i);const a=[],o=[],l=[],u=[],c=new Z,d=new Z,h=new Z;for(let p=0;p<=r;p++)for(let f=0;f<=i;f++){const g=f/i*s,y=p/r*Math.PI*2;d.x=(e+n*Math.cos(y))*Math.cos(g),d.y=(e+n*Math.cos(y))*Math.sin(g),d.z=n*Math.sin(y),o.push(d.x,d.y,d.z),c.x=e*Math.cos(g),c.y=e*Math.sin(g),h.subVectors(d,c).normalize(),l.push(h.x,h.y,h.z),u.push(f/i),u.push(p/r)}for(let p=1;p<=r;p++)for(let f=1;f<=i;f++){const g=(i+1)*p+f-1,y=(i+1)*(p-1)+f-1,m=(i+1)*(p-1)+f,b=(i+1)*p+f;a.push(g,y,b),a.push(y,m,b)}this.setIndex(a),this.setAttribute("position",new Jt(o,3)),this.setAttribute("normal",new Jt(l,3)),this.setAttribute("uv",new Jt(u,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new VT(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class jT extends An{constructor(e=1,n=.4,r=64,i=8,s=2,a=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:n,tubularSegments:r,radialSegments:i,p:s,q:a},r=Math.floor(r),i=Math.floor(i);const o=[],l=[],u=[],c=[],d=new Z,h=new Z,p=new Z,f=new Z,g=new Z,y=new Z,m=new Z;for(let w=0;w<=r;++w){const _=w/r*s*Math.PI*2;b(_,s,a,e,p),b(_+.01,s,a,e,f),y.subVectors(f,p),m.addVectors(f,p),g.crossVectors(y,m),m.crossVectors(g,y),g.normalize(),m.normalize();for(let S=0;S<=i;++S){const E=S/i*Math.PI*2,C=-n*Math.cos(E),T=n*Math.sin(E);d.x=p.x+(C*m.x+T*g.x),d.y=p.y+(C*m.y+T*g.y),d.z=p.z+(C*m.z+T*g.z),l.push(d.x,d.y,d.z),h.subVectors(d,p).normalize(),u.push(h.x,h.y,h.z),c.push(w/r),c.push(S/i)}}for(let w=1;w<=r;w++)for(let _=1;_<=i;_++){const S=(i+1)*(w-1)+(_-1),E=(i+1)*w+(_-1),C=(i+1)*w+_,T=(i+1)*(w-1)+_;o.push(S,E,T),o.push(E,C,T)}this.setIndex(o),this.setAttribute("position",new Jt(l,3)),this.setAttribute("normal",new Jt(u,3)),this.setAttribute("uv",new Jt(c,2));function b(w,_,S,E,C){const T=Math.cos(w),M=Math.sin(w),k=S/_*w,R=Math.cos(k);C.x=E*(2+R)*.5*T,C.y=E*(2+R)*M*.5,C.z=E*Math.sin(k)*.5}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new jT(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class XT extends An{constructor(e=new GP(new Z(-1,-1,0),new Z(-1,1,0),new Z(1,1,0)),n=64,r=1,i=8,s=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:n,radius:r,radialSegments:i,closed:s};const a=e.computeFrenetFrames(n,s);this.tangents=a.tangents,this.normals=a.normals,this.binormals=a.binormals;const o=new Z,l=new Z,u=new Qe;let c=new Z;const d=[],h=[],p=[],f=[];g(),this.setIndex(f),this.setAttribute("position",new Jt(d,3)),this.setAttribute("normal",new Jt(h,3)),this.setAttribute("uv",new Jt(p,2));function g(){for(let w=0;w<n;w++)y(w);y(s===!1?n:0),b(),m()}function y(w){c=e.getPointAt(w/n,c);const _=a.normals[w],S=a.binormals[w];for(let E=0;E<=i;E++){const C=E/i*Math.PI*2,T=Math.sin(C),M=-Math.cos(C);l.x=M*_.x+T*S.x,l.y=M*_.y+T*S.y,l.z=M*_.z+T*S.z,l.normalize(),h.push(l.x,l.y,l.z),o.x=c.x+r*l.x,o.y=c.y+r*l.y,o.z=c.z+r*l.z,d.push(o.x,o.y,o.z)}}function m(){for(let w=1;w<=n;w++)for(let _=1;_<=i;_++){const S=(i+1)*(w-1)+(_-1),E=(i+1)*w+(_-1),C=(i+1)*w+_,T=(i+1)*(w-1)+_;f.push(S,E,T),f.push(E,C,T)}}function b(){for(let w=0;w<=n;w++)for(let _=0;_<=i;_++)u.x=w/n,u.y=_/i,p.push(u.x,u.y)}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new XT(new xI[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class N9 extends An{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const n=[],r=new Set,i=new Z,s=new Z;if(e.index!==null){const a=e.attributes.position,o=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:o.count,materialIndex:0}]);for(let u=0,c=l.length;u<c;++u){const d=l[u],h=d.start,p=d.count;for(let f=h,g=h+p;f<g;f+=3)for(let y=0;y<3;y++){const m=o.getX(f+y),b=o.getX(f+(y+1)%3);i.fromBufferAttribute(a,m),s.fromBufferAttribute(a,b),OG(i,s,r)===!0&&(n.push(i.x,i.y,i.z),n.push(s.x,s.y,s.z))}}}else{const a=e.attributes.position;for(let o=0,l=a.count/3;o<l;o++)for(let u=0;u<3;u++){const c=3*o+u,d=3*o+(u+1)%3;i.fromBufferAttribute(a,c),s.fromBufferAttribute(a,d),OG(i,s,r)===!0&&(n.push(i.x,i.y,i.z),n.push(s.x,s.y,s.z))}}this.setAttribute("position",new Jt(n,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}function OG(t,e,n){const r=`${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,i=`${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;return n.has(r)===!0||n.has(i)===!0?!1:(n.add(r),n.add(i),!0)}var BG=Object.freeze({__proto__:null,BoxGeometry:bf,CapsuleGeometry:LT,CircleGeometry:OT,ConeGeometry:q1,CylinderGeometry:K1,DodecahedronGeometry:BT,EdgesGeometry:w9,ExtrudeGeometry:$T,IcosahedronGeometry:J1,LatheGeometry:zT,OctahedronGeometry:Y1,PlaneGeometry:yu,PolyhedronGeometry:Yd,RingGeometry:GT,ShapeGeometry:HT,SphereGeometry:Z1,TetrahedronGeometry:WT,TorusGeometry:VT,TorusKnotGeometry:jT,TubeGeometry:XT,WireframeGeometry:N9});class R9 extends Ki{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new Ct(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class F9 extends ua{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class Zd extends Ki{constructor(e){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new Ct(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ct(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Jd,this.normalScale=new Qe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ba,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Ho extends Zd{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Qe(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return En(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(n){this.ior=(1+.4*n)/(1-.4*n)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Ct(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Ct(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Ct(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get dispersion(){return this._dispersion}set dispersion(e){this._dispersion>0!=e>0&&this.version++,this._dispersion=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.dispersion=e.dispersion,this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class D9 extends Ki{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Ct(16777215),this.specular=new Ct(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ct(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Jd,this.normalScale=new Qe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ba,this.combine=U1,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class P9 extends Ki{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Ct(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ct(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Jd,this.normalScale=new Qe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class L9 extends Ki{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Jd,this.normalScale=new Qe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class WP extends Ki{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Ct(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ct(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Jd,this.normalScale=new Qe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ba,this.combine=U1,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class VP extends Ki{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=t9,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class jP extends Ki{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}class O9 extends Ki{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Ct(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Jd,this.normalScale=new Qe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class B9 extends Ws{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function gp(t,e){return!t||t.constructor===e?t:typeof e.BYTES_PER_ELEMENT=="number"?new e(t):Array.prototype.slice.call(t)}function U9(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)}function $9(t){function e(i,s){return t[i]-t[s]}const n=t.length,r=new Array(n);for(let i=0;i!==n;++i)r[i]=i;return r.sort(e),r}function jR(t,e,n){const r=t.length,i=new t.constructor(r);for(let s=0,a=0;a!==r;++s){const o=n[s]*e;for(let l=0;l!==e;++l)i[a++]=t[o+l]}return i}function XP(t,e,n,r){let i=1,s=t[0];for(;s!==void 0&&s[r]===void 0;)s=t[i++];if(s===void 0)return;let a=s[r];if(a!==void 0)if(Array.isArray(a))do a=s[r],a!==void 0&&(e.push(s.time),n.push(...a)),s=t[i++];while(s!==void 0);else if(a.toArray!==void 0)do a=s[r],a!==void 0&&(e.push(s.time),a.toArray(n,n.length)),s=t[i++];while(s!==void 0);else do a=s[r],a!==void 0&&(e.push(s.time),n.push(a)),s=t[i++];while(s!==void 0)}function qce(t,e,n,r,i=30){const s=t.clone();s.name=e;const a=[];for(let l=0;l<s.tracks.length;++l){const u=s.tracks[l],c=u.getValueSize(),d=[],h=[];for(let p=0;p<u.times.length;++p){const f=u.times[p]*i;if(!(f<n||f>=r)){d.push(u.times[p]);for(let g=0;g<c;++g)h.push(u.values[p*c+g])}}d.length!==0&&(u.times=gp(d,u.times.constructor),u.values=gp(h,u.values.constructor),a.push(u))}s.tracks=a;let o=1/0;for(let l=0;l<s.tracks.length;++l)o>s.tracks[l].times[0]&&(o=s.tracks[l].times[0]);for(let l=0;l<s.tracks.length;++l)s.tracks[l].shift(-1*o);return s.resetDuration(),s}function Jce(t,e=0,n=t,r=30){r<=0&&(r=30);const i=n.tracks.length,s=e/r;for(let a=0;a<i;++a){const o=n.tracks[a],l=o.ValueTypeName;if(l==="bool"||l==="string")continue;const u=t.tracks.find(function(m){return m.name===o.name&&m.ValueTypeName===l});if(u===void 0)continue;let c=0;const d=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=d/3);let h=0;const p=u.getValueSize();u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(h=p/3);const f=o.times.length-1;let g;if(s<=o.times[0]){const m=c,b=d-c;g=o.values.slice(m,b)}else if(s>=o.times[f]){const m=f*d+c,b=m+d-c;g=o.values.slice(m,b)}else{const m=o.createInterpolant(),b=c,w=d-c;m.evaluate(s),g=m.resultBuffer.slice(b,w)}l==="quaternion"&&new Kr().fromArray(g).normalize().conjugate().toArray(g);const y=u.times.length;for(let m=0;m<y;++m){const b=m*p+h;if(l==="quaternion")Kr.multiplyQuaternionsFlat(u.values,b,g,0,u.values,b);else{const w=p-h*2;for(let _=0;_<w;++_)u.values[b+_]-=g[_]}}}return t.blendMode=_P,t}class Yce{static convertArray(e,n){return gp(e,n)}static isTypedArray(e){return U9(e)}static getKeyframeOrder(e){return $9(e)}static sortedArray(e,n,r){return jR(e,n,r)}static flattenJSON(e,n,r,i){XP(e,n,r,i)}static subclip(e,n,r,i,s=30){return qce(e,n,r,i,s)}static makeClipAdditive(e,n=0,r=e,i=30){return Jce(e,n,r,i)}}class m0{constructor(e,n,r,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new n.constructor(r),this.sampleValues=n,this.valueSize=r,this.settings=null,this.DefaultSettings_={}}evaluate(e){const n=this.parameterPositions;let r=this._cachedIndex,i=n[r],s=n[r-1];e:{t:{let a;n:{r:if(!(e<i)){for(let o=r+2;;){if(i===void 0){if(e<s)break r;return r=n.length,this._cachedIndex=r,this.copySampleValue_(r-1)}if(r===o)break;if(s=i,i=n[++r],e<i)break t}a=n.length;break n}if(!(e>=s)){const o=n[1];e<o&&(r=2,s=o);for(let l=r-2;;){if(s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(r===l)break;if(i=s,s=n[--r-1],e>=s)break t}a=r,r=0;break n}break e}for(;r<a;){const o=r+a>>>1;e<n[o]?a=o:r=o+1}if(i=n[r],s=n[r-1],s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===void 0)return r=n.length,this._cachedIndex=r,this.copySampleValue_(r-1)}this._cachedIndex=r,this.intervalChanged_(r,s,i)}return this.interpolate_(r,s,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const n=this.resultBuffer,r=this.sampleValues,i=this.valueSize,s=e*i;for(let a=0;a!==i;++a)n[a]=r[s+a];return n}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class z9 extends m0{constructor(e,n,r,i){super(e,n,r,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:pp,endingEnd:pp}}intervalChanged_(e,n,r){const i=this.parameterPositions;let s=e-2,a=e+1,o=i[s],l=i[a];if(o===void 0)switch(this.getSettings_().endingStart){case fp:s=e,o=2*n-r;break;case t1:s=i.length-2,o=n+i[s]-i[s+1];break;default:s=e,o=r}if(l===void 0)switch(this.getSettings_().endingEnd){case fp:a=e,l=2*r-n;break;case t1:a=1,l=r+i[1]-i[0];break;default:a=e-1,l=n}const u=(r-n)*.5,c=this.valueSize;this._weightPrev=u/(n-o),this._weightNext=u/(l-r),this._offsetPrev=s*c,this._offsetNext=a*c}interpolate_(e,n,r,i){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=e*o,u=l-o,c=this._offsetPrev,d=this._offsetNext,h=this._weightPrev,p=this._weightNext,f=(r-n)/(i-n),g=f*f,y=g*f,m=-h*y+2*h*g-h*f,b=(1+h)*y+(-1.5-2*h)*g+(-.5+h)*f+1,w=(-1-p)*y+(1.5+p)*g+.5*f,_=p*y-p*g;for(let S=0;S!==o;++S)s[S]=m*a[c+S]+b*a[u+S]+w*a[l+S]+_*a[d+S];return s}}class KP extends m0{constructor(e,n,r,i){super(e,n,r,i)}interpolate_(e,n,r,i){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=e*o,u=l-o,c=(r-n)/(i-n),d=1-c;for(let h=0;h!==o;++h)s[h]=a[u+h]*d+a[l+h]*c;return s}}class G9 extends m0{constructor(e,n,r,i){super(e,n,r,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class Wo{constructor(e,n,r,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(n===void 0||n.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=gp(n,this.TimeBufferType),this.values=gp(r,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const n=e.constructor;let r;if(n.toJSON!==this.toJSON)r=n.toJSON(e);else{r={name:e.name,times:gp(e.times,Array),values:gp(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(r.interpolation=i)}return r.type=e.ValueTypeName,r}InterpolantFactoryMethodDiscrete(e){return new G9(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new KP(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new z9(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let n;switch(e){case $p:n=this.InterpolantFactoryMethodDiscrete;break;case zp:n=this.InterpolantFactoryMethodLinear;break;case XA:n=this.InterpolantFactoryMethodSmooth;break}if(n===void 0){const r="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(r);return console.warn("THREE.KeyframeTrack:",r),this}return this.createInterpolant=n,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return $p;case this.InterpolantFactoryMethodLinear:return zp;case this.InterpolantFactoryMethodSmooth:return XA}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const n=this.times;for(let r=0,i=n.length;r!==i;++r)n[r]+=e}return this}scale(e){if(e!==1){const n=this.times;for(let r=0,i=n.length;r!==i;++r)n[r]*=e}return this}trim(e,n){const r=this.times,i=r.length;let s=0,a=i-1;for(;s!==i&&r[s]<e;)++s;for(;a!==-1&&r[a]>n;)--a;if(++a,s!==0||a!==i){s>=a&&(a=Math.max(a,1),s=a-1);const o=this.getValueSize();this.times=r.slice(s,a),this.values=this.values.slice(s*o,a*o)}return this}validate(){let e=!0;const n=this.getValueSize();n-Math.floor(n)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const r=this.times,i=this.values,s=r.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let a=null;for(let o=0;o!==s;o++){const l=r[o];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,l),e=!1;break}if(a!==null&&a>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,l,a),e=!1;break}a=l}if(i!==void 0&&U9(i))for(let o=0,l=i.length;o!==l;++o){const u=i[o];if(isNaN(u)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,u),e=!1;break}}return e}optimize(){const e=this.times.slice(),n=this.values.slice(),r=this.getValueSize(),i=this.getInterpolation()===XA,s=e.length-1;let a=1;for(let o=1;o<s;++o){let l=!1;const u=e[o],c=e[o+1];if(u!==c&&(o!==1||u!==e[0]))if(i)l=!0;else{const d=o*r,h=d-r,p=d+r;for(let f=0;f!==r;++f){const g=n[d+f];if(g!==n[h+f]||g!==n[p+f]){l=!0;break}}}if(l){if(o!==a){e[a]=e[o];const d=o*r,h=a*r;for(let p=0;p!==r;++p)n[h+p]=n[d+p]}++a}}if(s>0){e[a]=e[s];for(let o=s*r,l=a*r,u=0;u!==r;++u)n[l+u]=n[o+u];++a}return a!==e.length?(this.times=e.slice(0,a),this.values=n.slice(0,a*r)):(this.times=e,this.values=n),this}clone(){const e=this.times.slice(),n=this.values.slice(),r=this.constructor,i=new r(this.name,e,n);return i.createInterpolant=this.createInterpolant,i}}Wo.prototype.ValueTypeName="";Wo.prototype.TimeBufferType=Float32Array;Wo.prototype.ValueBufferType=Float32Array;Wo.prototype.DefaultInterpolation=zp;class wf extends Wo{constructor(e,n,r){super(e,n,r)}}wf.prototype.ValueTypeName="bool";wf.prototype.ValueBufferType=Array;wf.prototype.DefaultInterpolation=$p;wf.prototype.InterpolantFactoryMethodLinear=void 0;wf.prototype.InterpolantFactoryMethodSmooth=void 0;class qP extends Wo{constructor(e,n,r,i){super(e,n,r,i)}}qP.prototype.ValueTypeName="color";class Wp extends Wo{constructor(e,n,r,i){super(e,n,r,i)}}Wp.prototype.ValueTypeName="number";class H9 extends m0{constructor(e,n,r,i){super(e,n,r,i)}interpolate_(e,n,r,i){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=(r-n)/(i-n);let u=e*o;for(let c=u+o;u!==c;u+=4)Kr.slerpFlat(s,0,a,u-o,a,u,l);return s}}class Vp extends Wo{constructor(e,n,r,i){super(e,n,r,i)}InterpolantFactoryMethodLinear(e){return new H9(this.times,this.values,this.getValueSize(),e)}}Vp.prototype.ValueTypeName="quaternion";Vp.prototype.InterpolantFactoryMethodSmooth=void 0;class _f extends Wo{constructor(e,n,r){super(e,n,r)}}_f.prototype.ValueTypeName="string";_f.prototype.ValueBufferType=Array;_f.prototype.DefaultInterpolation=$p;_f.prototype.InterpolantFactoryMethodLinear=void 0;_f.prototype.InterpolantFactoryMethodSmooth=void 0;class jp extends Wo{constructor(e,n,r,i){super(e,n,r,i)}}jp.prototype.ValueTypeName="vector";class Gy{constructor(e="",n=-1,r=[],i=CT){this.name=e,this.tracks=r,this.duration=n,this.blendMode=i,this.uuid=ao(),this.duration<0&&this.resetDuration()}static parse(e){const n=[],r=e.tracks,i=1/(e.fps||1);for(let a=0,o=r.length;a!==o;++a)n.push(Qce(r[a]).scale(i));const s=new this(e.name,e.duration,n,e.blendMode);return s.uuid=e.uuid,s}static toJSON(e){const n=[],r=e.tracks,i={name:e.name,duration:e.duration,tracks:n,uuid:e.uuid,blendMode:e.blendMode};for(let s=0,a=r.length;s!==a;++s)n.push(Wo.toJSON(r[s]));return i}static CreateFromMorphTargetSequence(e,n,r,i){const s=n.length,a=[];for(let o=0;o<s;o++){let l=[],u=[];l.push((o+s-1)%s,o,(o+1)%s),u.push(0,1,0);const c=$9(l);l=jR(l,1,c),u=jR(u,1,c),!i&&l[0]===0&&(l.push(s),u.push(u[0])),a.push(new Wp(".morphTargetInfluences["+n[o].name+"]",l,u).scale(1/r))}return new this(e,-1,a)}static findByName(e,n){let r=e;if(!Array.isArray(e)){const i=e;r=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<r.length;i++)if(r[i].name===n)return r[i];return null}static CreateClipsFromMorphTargetSequences(e,n,r){const i={},s=/^([\w-]*?)([\d]+)$/;for(let o=0,l=e.length;o<l;o++){const u=e[o],c=u.name.match(s);if(c&&c.length>1){const d=c[1];let h=i[d];h||(i[d]=h=[]),h.push(u)}}const a=[];for(const o in i)a.push(this.CreateFromMorphTargetSequence(o,i[o],n,r));return a}static parseAnimation(e,n){if(console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"),!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const r=function(d,h,p,f,g){if(p.length!==0){const y=[],m=[];XP(p,y,m,f),y.length!==0&&g.push(new d(h,y,m))}},i=[],s=e.name||"default",a=e.fps||30,o=e.blendMode;let l=e.length||-1;const u=e.hierarchy||[];for(let d=0;d<u.length;d++){const h=u[d].keys;if(!(!h||h.length===0))if(h[0].morphTargets){const p={};let f;for(f=0;f<h.length;f++)if(h[f].morphTargets)for(let g=0;g<h[f].morphTargets.length;g++)p[h[f].morphTargets[g]]=-1;for(const g in p){const y=[],m=[];for(let b=0;b!==h[f].morphTargets.length;++b){const w=h[f];y.push(w.time),m.push(w.morphTarget===g?1:0)}i.push(new Wp(".morphTargetInfluence["+g+"]",y,m))}l=p.length*a}else{const p=".bones["+n[d].name+"]";r(jp,p+".position",h,"pos",i),r(Vp,p+".quaternion",h,"rot",i),r(jp,p+".scale",h,"scl",i)}}return i.length===0?null:new this(s,l,i,o)}resetDuration(){const e=this.tracks;let n=0;for(let r=0,i=e.length;r!==i;++r){const s=this.tracks[r];n=Math.max(n,s.times[s.times.length-1])}return this.duration=n,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let n=0;n<this.tracks.length;n++)e=e&&this.tracks[n].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let n=0;n<this.tracks.length;n++)e.push(this.tracks[n].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Zce(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Wp;case"vector":case"vector2":case"vector3":case"vector4":return jp;case"color":return qP;case"quaternion":return Vp;case"bool":case"boolean":return wf;case"string":return _f}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}function Qce(t){if(t.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=Zce(t.type);if(t.times===void 0){const n=[],r=[];XP(t.keys,n,r,"value"),t.times=n,t.values=r}return e.parse!==void 0?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}const Ku={enabled:!1,files:{},add:function(t,e){this.enabled!==!1&&(this.files[t]=e)},get:function(t){if(this.enabled!==!1)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};class KT{constructor(e,n,r){const i=this;let s=!1,a=0,o=0,l;const u=[];this.onStart=void 0,this.onLoad=e,this.onProgress=n,this.onError=r,this.itemStart=function(c){o++,s===!1&&i.onStart!==void 0&&i.onStart(c,a,o),s=!0},this.itemEnd=function(c){a++,i.onProgress!==void 0&&i.onProgress(c,a,o),a===o&&(s=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(c){i.onError!==void 0&&i.onError(c)},this.resolveURL=function(c){return l?l(c):c},this.setURLModifier=function(c){return l=c,this},this.addHandler=function(c,d){return u.push(c,d),this},this.removeHandler=function(c){const d=u.indexOf(c);return d!==-1&&u.splice(d,2),this},this.getHandler=function(c){for(let d=0,h=u.length;d<h;d+=2){const p=u[d],f=u[d+1];if(p.global&&(p.lastIndex=0),p.test(c))return f}return null}}}const W9=new KT;class _s{constructor(e){this.manager=e!==void 0?e:W9,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,n){const r=this;return new Promise(function(i,s){r.load(e,i,n,s)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}_s.DEFAULT_MATERIAL_NAME="__DEFAULT";const Fu={};class ede extends Error{constructor(e,n){super(e),this.response=n}}class vs extends _s{constructor(e){super(e),this.mimeType="",this.responseType=""}load(e,n,r,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=Ku.get(e);if(s!==void 0)return this.manager.itemStart(e),setTimeout(()=>{n&&n(s),this.manager.itemEnd(e)},0),s;if(Fu[e]!==void 0){Fu[e].push({onLoad:n,onProgress:r,onError:i});return}Fu[e]=[],Fu[e].push({onLoad:n,onProgress:r,onError:i});const a=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),o=this.mimeType,l=this.responseType;fetch(a).then(u=>{if(u.status===200||u.status===0){if(u.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||u.body===void 0||u.body.getReader===void 0)return u;const c=Fu[e],d=u.body.getReader(),h=u.headers.get("X-File-Size")||u.headers.get("Content-Length"),p=h?parseInt(h):0,f=p!==0;let g=0;const y=new ReadableStream({start(m){b();function b(){d.read().then(({done:w,value:_})=>{if(w)m.close();else{g+=_.byteLength;const S=new ProgressEvent("progress",{lengthComputable:f,loaded:g,total:p});for(let E=0,C=c.length;E<C;E++){const T=c[E];T.onProgress&&T.onProgress(S)}m.enqueue(_),b()}},w=>{m.error(w)})}}});return new Response(y)}else throw new ede(`fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`,u)}).then(u=>{switch(l){case"arraybuffer":return u.arrayBuffer();case"blob":return u.blob();case"document":return u.text().then(c=>new DOMParser().parseFromString(c,o));case"json":return u.json();default:if(o==="")return u.text();{const d=/charset="?([^;"\s]*)"?/i.exec(o),h=d&&d[1]?d[1].toLowerCase():void 0,p=new TextDecoder(h);return u.arrayBuffer().then(f=>p.decode(f))}}}).then(u=>{Ku.add(e,u);const c=Fu[e];delete Fu[e];for(let d=0,h=c.length;d<h;d++){const p=c[d];p.onLoad&&p.onLoad(u)}}).catch(u=>{const c=Fu[e];if(c===void 0)throw this.manager.itemError(e),u;delete Fu[e];for(let d=0,h=c.length;d<h;d++){const p=c[d];p.onError&&p.onError(u)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class tde extends _s{constructor(e){super(e)}load(e,n,r,i){const s=this,a=new vs(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(o){try{n(s.parse(JSON.parse(o)))}catch(l){i?i(l):console.error(l),s.manager.itemError(e)}},r,i)}parse(e){const n=[];for(let r=0;r<e.length;r++){const i=Gy.parse(e[r]);n.push(i)}return n}}class nde extends _s{constructor(e){super(e)}load(e,n,r,i){const s=this,a=[],o=new Tp,l=new vs(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(s.withCredentials);let u=0;function c(d){l.load(e[d],function(h){const p=s.parse(h,!0);a[d]={width:p.width,height:p.height,format:p.format,mipmaps:p.mipmaps},u+=1,u===6&&(p.mipmapCount===1&&(o.minFilter=er),o.image=a,o.format=p.format,o.needsUpdate=!0,n&&n(o))},r,i)}if(Array.isArray(e))for(let d=0,h=e.length;d<h;++d)c(d);else l.load(e,function(d){const h=s.parse(d,!0);if(h.isCubemap){const p=h.mipmaps.length/h.mipmapCount;for(let f=0;f<p;f++){a[f]={mipmaps:[]};for(let g=0;g<h.mipmapCount;g++)a[f].mipmaps.push(h.mipmaps[f*h.mipmapCount+g]),a[f].format=h.format,a[f].width=h.width,a[f].height=h.height}o.image=a}else o.image.width=h.width,o.image.height=h.height,o.mipmaps=h.mipmaps;h.mipmapCount===1&&(o.minFilter=er),o.format=h.format,o.needsUpdate=!0,n&&n(o)},r,i);return o}}class u1 extends _s{constructor(e){super(e)}load(e,n,r,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,a=Ku.get(e);if(a!==void 0)return s.manager.itemStart(e),setTimeout(function(){n&&n(a),s.manager.itemEnd(e)},0),a;const o=s1("img");function l(){c(),Ku.add(e,this),n&&n(this),s.manager.itemEnd(e)}function u(d){c(),i&&i(d),s.manager.itemError(e),s.manager.itemEnd(e)}function c(){o.removeEventListener("load",l,!1),o.removeEventListener("error",u,!1)}return o.addEventListener("load",l,!1),o.addEventListener("error",u,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),s.manager.itemStart(e),o.src=e,o}}class V9 extends _s{constructor(e){super(e)}load(e,n,r,i){const s=new V1;s.colorSpace=Ui;const a=new u1(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let o=0;function l(u){a.load(e[u],function(c){s.images[u]=c,o++,o===6&&(s.needsUpdate=!0,n&&n(s))},void 0,i)}for(let u=0;u<e.length;++u)l(u);return s}}class JP extends _s{constructor(e){super(e)}load(e,n,r,i){const s=this,a=new yl,o=new vs(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(s.withCredentials),o.load(e,function(l){let u;try{u=s.parse(l)}catch(c){if(i!==void 0)i(c);else{console.error(c);return}}u.image!==void 0?a.image=u.image:u.data!==void 0&&(a.image.width=u.width,a.image.height=u.height,a.image.data=u.data),a.wrapS=u.wrapS!==void 0?u.wrapS:jr,a.wrapT=u.wrapT!==void 0?u.wrapT:jr,a.magFilter=u.magFilter!==void 0?u.magFilter:er,a.minFilter=u.minFilter!==void 0?u.minFilter:er,a.anisotropy=u.anisotropy!==void 0?u.anisotropy:1,u.colorSpace!==void 0&&(a.colorSpace=u.colorSpace),u.flipY!==void 0&&(a.flipY=u.flipY),u.format!==void 0&&(a.format=u.format),u.type!==void 0&&(a.type=u.type),u.mipmaps!==void 0&&(a.mipmaps=u.mipmaps,a.minFilter=Ma),u.mipmapCount===1&&(a.minFilter=er),u.generateMipmaps!==void 0&&(a.generateMipmaps=u.generateMipmaps),a.needsUpdate=!0,n&&n(a,u)},r,i),a}}class qT extends _s{constructor(e){super(e)}load(e,n,r,i){const s=new hr,a=new u1(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(e,function(o){s.image=o,s.needsUpdate=!0,n!==void 0&&n(s)},r,i),s}}class Qd extends Yn{constructor(e,n=1){super(),this.isLight=!0,this.type="Light",this.color=new Ct(e),this.intensity=n}dispose(){}copy(e,n){return super.copy(e,n),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const n=super.toJSON(e);return n.object.color=this.color.getHex(),n.object.intensity=this.intensity,this.groundColor!==void 0&&(n.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(n.object.distance=this.distance),this.angle!==void 0&&(n.object.angle=this.angle),this.decay!==void 0&&(n.object.decay=this.decay),this.penumbra!==void 0&&(n.object.penumbra=this.penumbra),this.shadow!==void 0&&(n.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(n.object.target=this.target.uuid),n}}class j9 extends Qd{constructor(e,n,r){super(e,r),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Yn.DEFAULT_UP),this.updateMatrix(),this.groundColor=new Ct(n)}copy(e,n){return super.copy(e,n),this.groundColor.copy(e.groundColor),this}}const Bk=new ln,UG=new Z,$G=new Z;class YP{constructor(e){this.camera=e,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Qe(512,512),this.mapType=la,this.map=null,this.mapPass=null,this.matrix=new ln,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new f0,this._frameExtents=new Qe(1,1),this._viewportCount=1,this._viewports=[new Xn(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const n=this.camera,r=this.matrix;UG.setFromMatrixPosition(e.matrixWorld),n.position.copy(UG),$G.setFromMatrixPosition(e.target.matrixWorld),n.lookAt($G),n.updateMatrixWorld(),Bk.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Bk),r.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),r.multiply(Bk)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.intensity=e.intensity,this.bias=e.bias,this.radius=e.radius,this.autoUpdate=e.autoUpdate,this.needsUpdate=e.needsUpdate,this.normalBias=e.normalBias,this.blurSamples=e.blurSamples,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.intensity!==1&&(e.intensity=this.intensity),this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class rde extends YP{constructor(){super(new Qr(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1,this.aspect=1}updateMatrices(e){const n=this.camera,r=Uy*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height*this.aspect,s=e.distance||n.far;(r!==n.fov||i!==n.aspect||s!==n.far)&&(n.fov=r,n.aspect=i,n.far=s,n.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class ZP extends Qd{constructor(e,n,r=0,i=Math.PI/3,s=0,a=2){super(e,n),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Yn.DEFAULT_UP),this.updateMatrix(),this.target=new Yn,this.distance=r,this.angle=i,this.penumbra=s,this.decay=a,this.map=null,this.shadow=new rde}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,n){return super.copy(e,n),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const zG=new ln,Tx=new Z,Uk=new Z;class ide extends YP{constructor(){super(new Qr(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Qe(4,2),this._viewportCount=6,this._viewports=[new Xn(2,1,1,1),new Xn(0,1,1,1),new Xn(3,1,1,1),new Xn(1,1,1,1),new Xn(3,0,1,1),new Xn(1,0,1,1)],this._cubeDirections=[new Z(1,0,0),new Z(-1,0,0),new Z(0,0,1),new Z(0,0,-1),new Z(0,1,0),new Z(0,-1,0)],this._cubeUps=[new Z(0,1,0),new Z(0,1,0),new Z(0,1,0),new Z(0,1,0),new Z(0,0,1),new Z(0,0,-1)]}updateMatrices(e,n=0){const r=this.camera,i=this.matrix,s=e.distance||r.far;s!==r.far&&(r.far=s,r.updateProjectionMatrix()),Tx.setFromMatrixPosition(e.matrixWorld),r.position.copy(Tx),Uk.copy(r.position),Uk.add(this._cubeDirections[n]),r.up.copy(this._cubeUps[n]),r.lookAt(Uk),r.updateMatrixWorld(),i.makeTranslation(-Tx.x,-Tx.y,-Tx.z),zG.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse),this._frustum.setFromProjectionMatrix(zG)}}class QP extends Qd{constructor(e,n,r=0,i=2){super(e,n),this.isPointLight=!0,this.type="PointLight",this.distance=r,this.decay=i,this.shadow=new ide}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,n){return super.copy(e,n),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class iu extends W1{constructor(e=-1,n=1,r=1,i=-1,s=.1,a=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=n,this.top=r,this.bottom=i,this.near=s,this.far=a,this.updateProjectionMatrix()}copy(e,n){return super.copy(e,n),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,n,r,i,s,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=n,this.view.offsetX=r,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),n=(this.top-this.bottom)/(2*this.zoom),r=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let s=r-e,a=r+e,o=i+n,l=i-n;if(this.view!==null&&this.view.enabled){const u=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=u*this.view.offsetX,a=s+u*this.view.width,o-=c*this.view.offsetY,l=o-c*this.view.height}this.projectionMatrix.makeOrthographic(s,a,o,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const n=super.toJSON(e);return n.object.zoom=this.zoom,n.object.left=this.left,n.object.right=this.right,n.object.top=this.top,n.object.bottom=this.bottom,n.object.near=this.near,n.object.far=this.far,this.view!==null&&(n.object.view=Object.assign({},this.view)),n}}class sde extends YP{constructor(){super(new iu(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}let Q1=class extends Qd{constructor(e,n){super(e,n),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Yn.DEFAULT_UP),this.updateMatrix(),this.target=new Yn,this.shadow=new sde}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}};class JT extends Qd{constructor(e,n){super(e,n),this.isAmbientLight=!0,this.type="AmbientLight"}}class X9 extends Qd{constructor(e,n,r=10,i=10){super(e,n),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=r,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const n=super.toJSON(e);return n.object.width=this.width,n.object.height=this.height,n}}class K9{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new Z)}set(e){for(let n=0;n<9;n++)this.coefficients[n].copy(e[n]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,n){const r=e.x,i=e.y,s=e.z,a=this.coefficients;return n.copy(a[0]).multiplyScalar(.282095),n.addScaledVector(a[1],.488603*i),n.addScaledVector(a[2],.488603*s),n.addScaledVector(a[3],.488603*r),n.addScaledVector(a[4],1.092548*(r*i)),n.addScaledVector(a[5],1.092548*(i*s)),n.addScaledVector(a[6],.315392*(3*s*s-1)),n.addScaledVector(a[7],1.092548*(r*s)),n.addScaledVector(a[8],.546274*(r*r-i*i)),n}getIrradianceAt(e,n){const r=e.x,i=e.y,s=e.z,a=this.coefficients;return n.copy(a[0]).multiplyScalar(.886227),n.addScaledVector(a[1],2*.511664*i),n.addScaledVector(a[2],2*.511664*s),n.addScaledVector(a[3],2*.511664*r),n.addScaledVector(a[4],2*.429043*r*i),n.addScaledVector(a[5],2*.429043*i*s),n.addScaledVector(a[6],.743125*s*s-.247708),n.addScaledVector(a[7],2*.429043*r*s),n.addScaledVector(a[8],.429043*(r*r-i*i)),n}add(e){for(let n=0;n<9;n++)this.coefficients[n].add(e.coefficients[n]);return this}addScaledSH(e,n){for(let r=0;r<9;r++)this.coefficients[r].addScaledVector(e.coefficients[r],n);return this}scale(e){for(let n=0;n<9;n++)this.coefficients[n].multiplyScalar(e);return this}lerp(e,n){for(let r=0;r<9;r++)this.coefficients[r].lerp(e.coefficients[r],n);return this}equals(e){for(let n=0;n<9;n++)if(!this.coefficients[n].equals(e.coefficients[n]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,n=0){const r=this.coefficients;for(let i=0;i<9;i++)r[i].fromArray(e,n+i*3);return this}toArray(e=[],n=0){const r=this.coefficients;for(let i=0;i<9;i++)r[i].toArray(e,n+i*3);return e}static getBasisAt(e,n){const r=e.x,i=e.y,s=e.z;n[0]=.282095,n[1]=.488603*i,n[2]=.488603*s,n[3]=.488603*r,n[4]=1.092548*r*i,n[5]=1.092548*i*s,n[6]=.315392*(3*s*s-1),n[7]=1.092548*r*s,n[8]=.546274*(r*r-i*i)}}class q9 extends Qd{constructor(e=new K9,n=1){super(void 0,n),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const n=super.toJSON(e);return n.object.sh=this.sh.toArray(),n}}class YT extends _s{constructor(e){super(e),this.textures={}}load(e,n,r,i){const s=this,a=new vs(s.manager);a.setPath(s.path),a.setRequestHeader(s.requestHeader),a.setWithCredentials(s.withCredentials),a.load(e,function(o){try{n(s.parse(JSON.parse(o)))}catch(l){i?i(l):console.error(l),s.manager.itemError(e)}},r,i)}parse(e){const n=this.textures;function r(s){return n[s]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",s),n[s]}const i=this.createMaterialFromType(e.type);if(e.uuid!==void 0&&(i.uuid=e.uuid),e.name!==void 0&&(i.name=e.name),e.color!==void 0&&i.color!==void 0&&i.color.setHex(e.color),e.roughness!==void 0&&(i.roughness=e.roughness),e.metalness!==void 0&&(i.metalness=e.metalness),e.sheen!==void 0&&(i.sheen=e.sheen),e.sheenColor!==void 0&&(i.sheenColor=new Ct().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(i.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(e.emissive),e.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(e.specular),e.specularIntensity!==void 0&&(i.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&i.specularColor!==void 0&&i.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(i.shininess=e.shininess),e.clearcoat!==void 0&&(i.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=e.clearcoatRoughness),e.dispersion!==void 0&&(i.dispersion=e.dispersion),e.iridescence!==void 0&&(i.iridescence=e.iridescence),e.iridescenceIOR!==void 0&&(i.iridescenceIOR=e.iridescenceIOR),e.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=e.iridescenceThicknessRange),e.transmission!==void 0&&(i.transmission=e.transmission),e.thickness!==void 0&&(i.thickness=e.thickness),e.attenuationDistance!==void 0&&(i.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&i.attenuationColor!==void 0&&i.attenuationColor.setHex(e.attenuationColor),e.anisotropy!==void 0&&(i.anisotropy=e.anisotropy),e.anisotropyRotation!==void 0&&(i.anisotropyRotation=e.anisotropyRotation),e.fog!==void 0&&(i.fog=e.fog),e.flatShading!==void 0&&(i.flatShading=e.flatShading),e.blending!==void 0&&(i.blending=e.blending),e.combine!==void 0&&(i.combine=e.combine),e.side!==void 0&&(i.side=e.side),e.shadowSide!==void 0&&(i.shadowSide=e.shadowSide),e.opacity!==void 0&&(i.opacity=e.opacity),e.transparent!==void 0&&(i.transparent=e.transparent),e.alphaTest!==void 0&&(i.alphaTest=e.alphaTest),e.alphaHash!==void 0&&(i.alphaHash=e.alphaHash),e.depthFunc!==void 0&&(i.depthFunc=e.depthFunc),e.depthTest!==void 0&&(i.depthTest=e.depthTest),e.depthWrite!==void 0&&(i.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(i.colorWrite=e.colorWrite),e.blendSrc!==void 0&&(i.blendSrc=e.blendSrc),e.blendDst!==void 0&&(i.blendDst=e.blendDst),e.blendEquation!==void 0&&(i.blendEquation=e.blendEquation),e.blendSrcAlpha!==void 0&&(i.blendSrcAlpha=e.blendSrcAlpha),e.blendDstAlpha!==void 0&&(i.blendDstAlpha=e.blendDstAlpha),e.blendEquationAlpha!==void 0&&(i.blendEquationAlpha=e.blendEquationAlpha),e.blendColor!==void 0&&i.blendColor!==void 0&&i.blendColor.setHex(e.blendColor),e.blendAlpha!==void 0&&(i.blendAlpha=e.blendAlpha),e.stencilWriteMask!==void 0&&(i.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(i.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(i.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(i.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(i.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(i.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(i.stencilZPass=e.stencilZPass),e.stencilWrite!==void 0&&(i.stencilWrite=e.stencilWrite),e.wireframe!==void 0&&(i.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(i.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(i.rotation=e.rotation),e.linewidth!==void 0&&(i.linewidth=e.linewidth),e.dashSize!==void 0&&(i.dashSize=e.dashSize),e.gapSize!==void 0&&(i.gapSize=e.gapSize),e.scale!==void 0&&(i.scale=e.scale),e.polygonOffset!==void 0&&(i.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(i.dithering=e.dithering),e.alphaToCoverage!==void 0&&(i.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(i.premultipliedAlpha=e.premultipliedAlpha),e.forceSinglePass!==void 0&&(i.forceSinglePass=e.forceSinglePass),e.visible!==void 0&&(i.visible=e.visible),e.toneMapped!==void 0&&(i.toneMapped=e.toneMapped),e.userData!==void 0&&(i.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const s in e.uniforms){const a=e.uniforms[s];switch(i.uniforms[s]={},a.type){case"t":i.uniforms[s].value=r(a.value);break;case"c":i.uniforms[s].value=new Ct().setHex(a.value);break;case"v2":i.uniforms[s].value=new Qe().fromArray(a.value);break;case"v3":i.uniforms[s].value=new Z().fromArray(a.value);break;case"v4":i.uniforms[s].value=new Xn().fromArray(a.value);break;case"m3":i.uniforms[s].value=new Mn().fromArray(a.value);break;case"m4":i.uniforms[s].value=new ln().fromArray(a.value);break;default:i.uniforms[s].value=a.value}}if(e.defines!==void 0&&(i.defines=e.defines),e.vertexShader!==void 0&&(i.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(i.fragmentShader=e.fragmentShader),e.glslVersion!==void 0&&(i.glslVersion=e.glslVersion),e.extensions!==void 0)for(const s in e.extensions)i.extensions[s]=e.extensions[s];if(e.lights!==void 0&&(i.lights=e.lights),e.clipping!==void 0&&(i.clipping=e.clipping),e.size!==void 0&&(i.size=e.size),e.sizeAttenuation!==void 0&&(i.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(i.map=r(e.map)),e.matcap!==void 0&&(i.matcap=r(e.matcap)),e.alphaMap!==void 0&&(i.alphaMap=r(e.alphaMap)),e.bumpMap!==void 0&&(i.bumpMap=r(e.bumpMap)),e.bumpScale!==void 0&&(i.bumpScale=e.bumpScale),e.normalMap!==void 0&&(i.normalMap=r(e.normalMap)),e.normalMapType!==void 0&&(i.normalMapType=e.normalMapType),e.normalScale!==void 0){let s=e.normalScale;Array.isArray(s)===!1&&(s=[s,s]),i.normalScale=new Qe().fromArray(s)}return e.displacementMap!==void 0&&(i.displacementMap=r(e.displacementMap)),e.displacementScale!==void 0&&(i.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(i.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(i.roughnessMap=r(e.roughnessMap)),e.metalnessMap!==void 0&&(i.metalnessMap=r(e.metalnessMap)),e.emissiveMap!==void 0&&(i.emissiveMap=r(e.emissiveMap)),e.emissiveIntensity!==void 0&&(i.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(i.specularMap=r(e.specularMap)),e.specularIntensityMap!==void 0&&(i.specularIntensityMap=r(e.specularIntensityMap)),e.specularColorMap!==void 0&&(i.specularColorMap=r(e.specularColorMap)),e.envMap!==void 0&&(i.envMap=r(e.envMap)),e.envMapRotation!==void 0&&i.envMapRotation.fromArray(e.envMapRotation),e.envMapIntensity!==void 0&&(i.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(i.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(i.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(i.lightMap=r(e.lightMap)),e.lightMapIntensity!==void 0&&(i.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(i.aoMap=r(e.aoMap)),e.aoMapIntensity!==void 0&&(i.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(i.gradientMap=r(e.gradientMap)),e.clearcoatMap!==void 0&&(i.clearcoatMap=r(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=r(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=r(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new Qe().fromArray(e.clearcoatNormalScale)),e.iridescenceMap!==void 0&&(i.iridescenceMap=r(e.iridescenceMap)),e.iridescenceThicknessMap!==void 0&&(i.iridescenceThicknessMap=r(e.iridescenceThicknessMap)),e.transmissionMap!==void 0&&(i.transmissionMap=r(e.transmissionMap)),e.thicknessMap!==void 0&&(i.thicknessMap=r(e.thicknessMap)),e.anisotropyMap!==void 0&&(i.anisotropyMap=r(e.anisotropyMap)),e.sheenColorMap!==void 0&&(i.sheenColorMap=r(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(i.sheenRoughnessMap=r(e.sheenRoughnessMap)),i}setTextures(e){return this.textures=e,this}createMaterialFromType(e){return YT.createMaterialFromType(e)}static createMaterialFromType(e){const n={ShadowMaterial:R9,SpriteMaterial:RP,RawShaderMaterial:F9,ShaderMaterial:ua,PointsMaterial:PT,MeshPhysicalMaterial:Ho,MeshStandardMaterial:Zd,MeshPhongMaterial:D9,MeshToonMaterial:P9,MeshNormalMaterial:L9,MeshLambertMaterial:WP,MeshDepthMaterial:VP,MeshDistanceMaterial:jP,MeshBasicMaterial:ka,MeshMatcapMaterial:O9,LineDashedMaterial:B9,LineBasicMaterial:Ws,Material:Ki};return new n[e]}}class _d{static extractUrlBase(e){const n=e.lastIndexOf("/");return n===-1?"./":e.slice(0,n+1)}static resolveURL(e,n){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(n)&&/^\//.test(e)&&(n=n.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:n+e)}}class J9 extends An{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class Y9 extends _s{constructor(e){super(e)}load(e,n,r,i){const s=this,a=new vs(s.manager);a.setPath(s.path),a.setRequestHeader(s.requestHeader),a.setWithCredentials(s.withCredentials),a.load(e,function(o){try{n(s.parse(JSON.parse(o)))}catch(l){i?i(l):console.error(l),s.manager.itemError(e)}},r,i)}parse(e){const n={},r={};function i(p,f){if(n[f]!==void 0)return n[f];const y=p.interleavedBuffers[f],m=s(p,y.buffer),b=ay(y.type,m),w=new j1(b,y.stride);return w.uuid=y.uuid,n[f]=w,w}function s(p,f){if(r[f]!==void 0)return r[f];const y=p.arrayBuffers[f],m=new Uint32Array(y).buffer;return r[f]=m,m}const a=e.isInstancedBufferGeometry?new J9:new An,o=e.data.index;if(o!==void 0){const p=ay(o.type,o.array);a.setIndex(new Ln(p,1))}const l=e.data.attributes;for(const p in l){const f=l[p];let g;if(f.isInterleavedBufferAttribute){const y=i(e.data,f.data);g=new kd(y,f.itemSize,f.offset,f.normalized)}else{const y=ay(f.type,f.array),m=f.isInstancedBufferAttribute?Gp:Ln;g=new m(y,f.itemSize,f.normalized)}f.name!==void 0&&(g.name=f.name),f.usage!==void 0&&g.setUsage(f.usage),a.setAttribute(p,g)}const u=e.data.morphAttributes;if(u)for(const p in u){const f=u[p],g=[];for(let y=0,m=f.length;y<m;y++){const b=f[y];let w;if(b.isInterleavedBufferAttribute){const _=i(e.data,b.data);w=new kd(_,b.itemSize,b.offset,b.normalized)}else{const _=ay(b.type,b.array);w=new Ln(_,b.itemSize,b.normalized)}b.name!==void 0&&(w.name=b.name),g.push(w)}a.morphAttributes[p]=g}e.data.morphTargetsRelative&&(a.morphTargetsRelative=!0);const d=e.data.groups||e.data.drawcalls||e.data.offsets;if(d!==void 0)for(let p=0,f=d.length;p!==f;++p){const g=d[p];a.addGroup(g.start,g.count,g.materialIndex)}const h=e.data.boundingSphere;return h!==void 0&&(a.boundingSphere=new Xi().fromJSON(h)),e.name&&(a.name=e.name),e.userData&&(a.userData=e.userData),a}}class ade extends _s{constructor(e){super(e)}load(e,n,r,i){const s=this,a=this.path===""?_d.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||a;const o=new vs(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(l){let u=null;try{u=JSON.parse(l)}catch(d){i!==void 0&&i(d),console.error("THREE:ObjectLoader: Can't parse "+e+".",d.message);return}const c=u.metadata;if(c===void 0||c.type===void 0||c.type.toLowerCase()==="geometry"){i!==void 0&&i(new Error("THREE.ObjectLoader: Can't load "+e)),console.error("THREE.ObjectLoader: Can't load "+e);return}s.parse(u,n)},r,i)}async loadAsync(e,n){const r=this,i=this.path===""?_d.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||i;const s=new vs(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials);const a=await s.loadAsync(e,n),o=JSON.parse(a),l=o.metadata;if(l===void 0||l.type===void 0||l.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+e);return await r.parseAsync(o)}parse(e,n){const r=this.parseAnimations(e.animations),i=this.parseShapes(e.shapes),s=this.parseGeometries(e.geometries,i),a=this.parseImages(e.images,function(){n!==void 0&&n(u)}),o=this.parseTextures(e.textures,a),l=this.parseMaterials(e.materials,o),u=this.parseObject(e.object,s,l,o,r),c=this.parseSkeletons(e.skeletons,u);if(this.bindSkeletons(u,c),this.bindLightTargets(u),n!==void 0){let d=!1;for(const h in a)if(a[h].data instanceof HTMLImageElement){d=!0;break}d===!1&&n(u)}return u}async parseAsync(e){const n=this.parseAnimations(e.animations),r=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,r),s=await this.parseImagesAsync(e.images),a=this.parseTextures(e.textures,s),o=this.parseMaterials(e.materials,a),l=this.parseObject(e.object,i,o,a,n),u=this.parseSkeletons(e.skeletons,l);return this.bindSkeletons(l,u),this.bindLightTargets(l),l}parseShapes(e){const n={};if(e!==void 0)for(let r=0,i=e.length;r<i;r++){const s=new Cp().fromJSON(e[r]);n[s.uuid]=s}return n}parseSkeletons(e,n){const r={},i={};if(n.traverse(function(s){s.isBone&&(i[s.uuid]=s)}),e!==void 0)for(let s=0,a=e.length;s<a;s++){const o=new X1().fromJSON(e[s],i);r[o.uuid]=o}return r}parseGeometries(e,n){const r={};if(e!==void 0){const i=new Y9;for(let s=0,a=e.length;s<a;s++){let o;const l=e[s];switch(l.type){case"BufferGeometry":case"InstancedBufferGeometry":o=i.parse(l);break;default:l.type in BG?o=BG[l.type].fromJSON(l,n):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)}o.uuid=l.uuid,l.name!==void 0&&(o.name=l.name),l.userData!==void 0&&(o.userData=l.userData),r[l.uuid]=o}}return r}parseMaterials(e,n){const r={},i={};if(e!==void 0){const s=new YT;s.setTextures(n);for(let a=0,o=e.length;a<o;a++){const l=e[a];r[l.uuid]===void 0&&(r[l.uuid]=s.parse(l)),i[l.uuid]=r[l.uuid]}}return i}parseAnimations(e){const n={};if(e!==void 0)for(let r=0;r<e.length;r++){const i=e[r],s=Gy.parse(i);n[s.uuid]=s}return n}parseImages(e,n){const r=this,i={};let s;function a(l){return r.manager.itemStart(l),s.load(l,function(){r.manager.itemEnd(l)},void 0,function(){r.manager.itemError(l),r.manager.itemEnd(l)})}function o(l){if(typeof l=="string"){const u=l,c=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(u)?u:r.resourcePath+u;return a(c)}else return l.data?{data:ay(l.type,l.data),width:l.width,height:l.height}:null}if(e!==void 0&&e.length>0){const l=new KT(n);s=new u1(l),s.setCrossOrigin(this.crossOrigin);for(let u=0,c=e.length;u<c;u++){const d=e[u],h=d.url;if(Array.isArray(h)){const p=[];for(let f=0,g=h.length;f<g;f++){const y=h[f],m=o(y);m!==null&&(m instanceof HTMLImageElement?p.push(m):p.push(new yl(m.data,m.width,m.height)))}i[d.uuid]=new ju(p)}else{const p=o(d.url);i[d.uuid]=new ju(p)}}}return i}async parseImagesAsync(e){const n=this,r={};let i;async function s(a){if(typeof a=="string"){const o=a,l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(o)?o:n.resourcePath+o;return await i.loadAsync(l)}else return a.data?{data:ay(a.type,a.data),width:a.width,height:a.height}:null}if(e!==void 0&&e.length>0){i=new u1(this.manager),i.setCrossOrigin(this.crossOrigin);for(let a=0,o=e.length;a<o;a++){const l=e[a],u=l.url;if(Array.isArray(u)){const c=[];for(let d=0,h=u.length;d<h;d++){const p=u[d],f=await s(p);f!==null&&(f instanceof HTMLImageElement?c.push(f):c.push(new yl(f.data,f.width,f.height)))}r[l.uuid]=new ju(c)}else{const c=await s(l.url);r[l.uuid]=new ju(c)}}}return r}parseTextures(e,n){function r(s,a){return typeof s=="number"?s:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",s),a[s])}const i={};if(e!==void 0)for(let s=0,a=e.length;s<a;s++){const o=e[s];o.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',o.uuid),n[o.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",o.image);const l=n[o.image],u=l.data;let c;Array.isArray(u)?(c=new V1,u.length===6&&(c.needsUpdate=!0)):(u&&u.data?c=new yl:c=new hr,u&&(c.needsUpdate=!0)),c.source=l,c.uuid=o.uuid,o.name!==void 0&&(c.name=o.name),o.mapping!==void 0&&(c.mapping=r(o.mapping,ode)),o.channel!==void 0&&(c.channel=o.channel),o.offset!==void 0&&c.offset.fromArray(o.offset),o.repeat!==void 0&&c.repeat.fromArray(o.repeat),o.center!==void 0&&c.center.fromArray(o.center),o.rotation!==void 0&&(c.rotation=o.rotation),o.wrap!==void 0&&(c.wrapS=r(o.wrap[0],GG),c.wrapT=r(o.wrap[1],GG)),o.format!==void 0&&(c.format=o.format),o.internalFormat!==void 0&&(c.internalFormat=o.internalFormat),o.type!==void 0&&(c.type=o.type),o.colorSpace!==void 0&&(c.colorSpace=o.colorSpace),o.minFilter!==void 0&&(c.minFilter=r(o.minFilter,HG)),o.magFilter!==void 0&&(c.magFilter=r(o.magFilter,HG)),o.anisotropy!==void 0&&(c.anisotropy=o.anisotropy),o.flipY!==void 0&&(c.flipY=o.flipY),o.generateMipmaps!==void 0&&(c.generateMipmaps=o.generateMipmaps),o.premultiplyAlpha!==void 0&&(c.premultiplyAlpha=o.premultiplyAlpha),o.unpackAlignment!==void 0&&(c.unpackAlignment=o.unpackAlignment),o.compareFunction!==void 0&&(c.compareFunction=o.compareFunction),o.userData!==void 0&&(c.userData=o.userData),i[o.uuid]=c}return i}parseObject(e,n,r,i,s){let a;function o(h){return n[h]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",h),n[h]}function l(h){if(h!==void 0){if(Array.isArray(h)){const p=[];for(let f=0,g=h.length;f<g;f++){const y=h[f];r[y]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",y),p.push(r[y])}return p}return r[h]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",h),r[h]}}function u(h){return i[h]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",h),i[h]}let c,d;switch(e.type){case"Scene":a=new oc,e.background!==void 0&&(Number.isInteger(e.background)?a.background=new Ct(e.background):a.background=u(e.background)),e.environment!==void 0&&(a.environment=u(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?a.fog=new RT(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(a.fog=new NT(e.fog.color,e.fog.density)),e.fog.name!==""&&(a.fog.name=e.fog.name)),e.backgroundBlurriness!==void 0&&(a.backgroundBlurriness=e.backgroundBlurriness),e.backgroundIntensity!==void 0&&(a.backgroundIntensity=e.backgroundIntensity),e.backgroundRotation!==void 0&&a.backgroundRotation.fromArray(e.backgroundRotation),e.environmentIntensity!==void 0&&(a.environmentIntensity=e.environmentIntensity),e.environmentRotation!==void 0&&a.environmentRotation.fromArray(e.environmentRotation);break;case"PerspectiveCamera":a=new Qr(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(a.focus=e.focus),e.zoom!==void 0&&(a.zoom=e.zoom),e.filmGauge!==void 0&&(a.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(a.filmOffset=e.filmOffset),e.view!==void 0&&(a.view=Object.assign({},e.view));break;case"OrthographicCamera":a=new iu(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(a.zoom=e.zoom),e.view!==void 0&&(a.view=Object.assign({},e.view));break;case"AmbientLight":a=new JT(e.color,e.intensity);break;case"DirectionalLight":a=new Q1(e.color,e.intensity),a.target=e.target||"";break;case"PointLight":a=new QP(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":a=new X9(e.color,e.intensity,e.width,e.height);break;case"SpotLight":a=new ZP(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay),a.target=e.target||"";break;case"HemisphereLight":a=new j9(e.color,e.groundColor,e.intensity);break;case"LightProbe":a=new q9().fromJSON(e);break;case"SkinnedMesh":c=o(e.geometry),d=l(e.material),a=new FP(c,d),e.bindMode!==void 0&&(a.bindMode=e.bindMode),e.bindMatrix!==void 0&&a.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(a.skeleton=e.skeleton);break;case"Mesh":c=o(e.geometry),d=l(e.material),a=new Cr(c,d);break;case"InstancedMesh":c=o(e.geometry),d=l(e.material);const h=e.count,p=e.instanceMatrix,f=e.instanceColor;a=new DP(c,d,h),a.instanceMatrix=new Gp(new Float32Array(p.array),16),f!==void 0&&(a.instanceColor=new Gp(new Float32Array(f.array),f.itemSize));break;case"BatchedMesh":c=o(e.geometry),d=l(e.material),a=new x9(e.maxInstanceCount,e.maxVertexCount,e.maxIndexCount,d),a.geometry=c,a.perObjectFrustumCulled=e.perObjectFrustumCulled,a.sortObjects=e.sortObjects,a._drawRanges=e.drawRanges,a._reservedRanges=e.reservedRanges,a._geometryInfo=e.geometryInfo.map(g=>{let y=null,m=null;return g.boundingBox!==void 0&&(y=new ds().fromJSON(g.boundingBox)),g.boundingSphere!==void 0&&(m=new Xi().fromJSON(g.boundingSphere)),{...g,boundingBox:y,boundingSphere:m}}),a._instanceInfo=e.instanceInfo,a._availableInstanceIds=e._availableInstanceIds,a._availableGeometryIds=e._availableGeometryIds,a._nextIndexStart=e.nextIndexStart,a._nextVertexStart=e.nextVertexStart,a._geometryCount=e.geometryCount,a._maxInstanceCount=e.maxInstanceCount,a._maxVertexCount=e.maxVertexCount,a._maxIndexCount=e.maxIndexCount,a._geometryInitialized=e.geometryInitialized,a._matricesTexture=u(e.matricesTexture.uuid),a._indirectTexture=u(e.indirectTexture.uuid),e.colorsTexture!==void 0&&(a._colorsTexture=u(e.colorsTexture.uuid)),e.boundingSphere!==void 0&&(a.boundingSphere=new Xi().fromJSON(e.boundingSphere)),e.boundingBox!==void 0&&(a.boundingBox=new ds().fromJSON(e.boundingBox));break;case"LOD":a=new v9;break;case"Line":a=new lc(o(e.geometry),l(e.material));break;case"LineLoop":a=new PP(o(e.geometry),l(e.material));break;case"LineSegments":a=new Tl(o(e.geometry),l(e.material));break;case"PointCloud":case"Points":a=new LP(o(e.geometry),l(e.material));break;case"Sprite":a=new y9(l(e.material));break;case"Group":a=new Xu;break;case"Bone":a=new FT;break;default:a=new Yn}if(a.uuid=e.uuid,e.name!==void 0&&(a.name=e.name),e.matrix!==void 0?(a.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(a.matrixAutoUpdate=e.matrixAutoUpdate),a.matrixAutoUpdate&&a.matrix.decompose(a.position,a.quaternion,a.scale)):(e.position!==void 0&&a.position.fromArray(e.position),e.rotation!==void 0&&a.rotation.fromArray(e.rotation),e.quaternion!==void 0&&a.quaternion.fromArray(e.quaternion),e.scale!==void 0&&a.scale.fromArray(e.scale)),e.up!==void 0&&a.up.fromArray(e.up),e.castShadow!==void 0&&(a.castShadow=e.castShadow),e.receiveShadow!==void 0&&(a.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.intensity!==void 0&&(a.shadow.intensity=e.shadow.intensity),e.shadow.bias!==void 0&&(a.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(a.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(a.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&a.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(a.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(a.visible=e.visible),e.frustumCulled!==void 0&&(a.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(a.renderOrder=e.renderOrder),e.userData!==void 0&&(a.userData=e.userData),e.layers!==void 0&&(a.layers.mask=e.layers),e.children!==void 0){const h=e.children;for(let p=0;p<h.length;p++)a.add(this.parseObject(h[p],n,r,i,s))}if(e.animations!==void 0){const h=e.animations;for(let p=0;p<h.length;p++){const f=h[p];a.animations.push(s[f])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(a.autoUpdate=e.autoUpdate);const h=e.levels;for(let p=0;p<h.length;p++){const f=h[p],g=a.getObjectByProperty("uuid",f.object);g!==void 0&&a.addLevel(g,f.distance,f.hysteresis)}}return a}bindSkeletons(e,n){Object.keys(n).length!==0&&e.traverse(function(r){if(r.isSkinnedMesh===!0&&r.skeleton!==void 0){const i=n[r.skeleton];i===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",r.skeleton):r.bind(i,r.bindMatrix)}})}bindLightTargets(e){e.traverse(function(n){if(n.isDirectionalLight||n.isSpotLight){const r=n.target,i=e.getObjectByProperty("uuid",r);i!==void 0?n.target=i:n.target=new Yn}})}}const ode={UVMapping:Cd,CubeReflectionMapping:uu,CubeRefractionMapping:Md,EquirectangularReflectionMapping:Dy,EquirectangularRefractionMapping:e1,CubeUVReflectionMapping:p0},GG={RepeatWrapping:ac,ClampToEdgeWrapping:jr,MirroredRepeatWrapping:Up},HG={NearestFilter:yi,NearestMipmapNearestFilter:$1,NearestMipmapLinearFilter:od,LinearFilter:er,LinearMipmapNearestFilter:Ap,LinearMipmapLinearFilter:Ma},$k=new WeakMap;class Z9 extends _s{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,n,r,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,a=Ku.get(e);if(a!==void 0){if(s.manager.itemStart(e),a.then){a.then(u=>{if($k.has(a)===!0)i&&i($k.get(a)),s.manager.itemError(e),s.manager.itemEnd(e);else return n&&n(u),s.manager.itemEnd(e),u});return}return setTimeout(function(){n&&n(a),s.manager.itemEnd(e)},0),a}const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader;const l=fetch(e,o).then(function(u){return u.blob()}).then(function(u){return createImageBitmap(u,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(u){return Ku.add(e,u),n&&n(u),s.manager.itemEnd(e),u}).catch(function(u){i&&i(u),$k.set(l,u),Ku.remove(e),s.manager.itemError(e),s.manager.itemEnd(e)});Ku.add(e,l),s.manager.itemStart(e)}}let ZS;class e3{static getContext(){return ZS===void 0&&(ZS=new(window.AudioContext||window.webkitAudioContext)),ZS}static setContext(e){ZS=e}}class lde extends _s{constructor(e){super(e)}load(e,n,r,i){const s=this,a=new vs(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){try{const u=l.slice(0);e3.getContext().decodeAudioData(u,function(d){n(d)}).catch(o)}catch(u){o(u)}},r,i);function o(l){i?i(l):console.error(l),s.manager.itemError(e)}}}const WG=new ln,VG=new ln,Fh=new ln;class ude{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Qr,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Qr,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const n=this._cache;if(n.focus!==e.focus||n.fov!==e.fov||n.aspect!==e.aspect*this.aspect||n.near!==e.near||n.far!==e.far||n.zoom!==e.zoom||n.eyeSep!==this.eyeSep){n.focus=e.focus,n.fov=e.fov,n.aspect=e.aspect*this.aspect,n.near=e.near,n.far=e.far,n.zoom=e.zoom,n.eyeSep=this.eyeSep,Fh.copy(e.projectionMatrix);const i=n.eyeSep/2,s=i*n.near/n.focus,a=n.near*Math.tan(Ep*n.fov*.5)/n.zoom;let o,l;VG.elements[12]=-i,WG.elements[12]=i,o=-a*n.aspect+s,l=a*n.aspect+s,Fh.elements[0]=2*n.near/(l-o),Fh.elements[8]=(l+o)/(l-o),this.cameraL.projectionMatrix.copy(Fh),o=-a*n.aspect-s,l=a*n.aspect-s,Fh.elements[0]=2*n.near/(l-o),Fh.elements[8]=(l+o)/(l-o),this.cameraR.projectionMatrix.copy(Fh)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(VG),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(WG)}}class Q9 extends Qr{constructor(e=[]){super(),this.isArrayCamera=!0,this.isMultiViewCamera=!1,this.cameras=e}}class t3{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=jG(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const n=jG();e=(n-this.oldTime)/1e3,this.oldTime=n,this.elapsedTime+=e}return e}}function jG(){return performance.now()}const Dh=new Z,zk=new Kr,cde=new Z,Ph=new Z,Lh=new Z;class dde extends Yn{constructor(){super(),this.type="AudioListener",this.context=e3.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new t3}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const n=this.context.listener;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Dh,zk,cde),Ph.set(0,0,-1).applyQuaternion(zk),Lh.set(0,1,0).applyQuaternion(zk),n.positionX){const r=this.context.currentTime+this.timeDelta;n.positionX.linearRampToValueAtTime(Dh.x,r),n.positionY.linearRampToValueAtTime(Dh.y,r),n.positionZ.linearRampToValueAtTime(Dh.z,r),n.forwardX.linearRampToValueAtTime(Ph.x,r),n.forwardY.linearRampToValueAtTime(Ph.y,r),n.forwardZ.linearRampToValueAtTime(Ph.z,r),n.upX.linearRampToValueAtTime(Lh.x,r),n.upY.linearRampToValueAtTime(Lh.y,r),n.upZ.linearRampToValueAtTime(Lh.z,r)}else n.setPosition(Dh.x,Dh.y,Dh.z),n.setOrientation(Ph.x,Ph.y,Ph.z,Lh.x,Lh.y,Lh.z)}}class eX extends Yn{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const n=this.context.createBufferSource();return n.buffer=this.buffer,n.loop=this.loop,n.loopStart=this.loopStart,n.loopEnd=this.loopEnd,n.onended=this.onEnded.bind(this),n.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=n,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(e=0){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(this.context.currentTime+e),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,n=this.filters.length;e<n;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,n=this.filters.length;e<n;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){return this.detune=e,this.isPlaying===!0&&this.source.detune!==void 0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1,this._progress=0}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}copy(e,n){return super.copy(e,n),e.sourceType!=="buffer"?(console.warn("THREE.Audio: Audio source type cannot be copied."),this):(this.autoplay=e.autoplay,this.buffer=e.buffer,this.detune=e.detune,this.loop=e.loop,this.loopStart=e.loopStart,this.loopEnd=e.loopEnd,this.offset=e.offset,this.duration=e.duration,this.playbackRate=e.playbackRate,this.hasPlaybackControl=e.hasPlaybackControl,this.sourceType=e.sourceType,this.filters=e.filters.slice(),this)}clone(e){return new this.constructor(this.listener).copy(this,e)}}const Oh=new Z,XG=new Kr,hde=new Z,Bh=new Z;class pde extends eX{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){return super.connect(),this.panner.connect(this.gain),this}disconnect(){return super.disconnect(),this.panner.disconnect(this.gain),this}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,n,r){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=n,this.panner.coneOuterGain=r,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(Oh,XG,hde),Bh.set(0,0,1).applyQuaternion(XG);const n=this.panner;if(n.positionX){const r=this.context.currentTime+this.listener.timeDelta;n.positionX.linearRampToValueAtTime(Oh.x,r),n.positionY.linearRampToValueAtTime(Oh.y,r),n.positionZ.linearRampToValueAtTime(Oh.z,r),n.orientationX.linearRampToValueAtTime(Bh.x,r),n.orientationY.linearRampToValueAtTime(Bh.y,r),n.orientationZ.linearRampToValueAtTime(Bh.z,r)}else n.setPosition(Oh.x,Oh.y,Oh.z),n.setOrientation(Bh.x,Bh.y,Bh.z)}}class fde{constructor(e,n=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=n,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const n=this.getFrequencyData();for(let r=0;r<n.length;r++)e+=n[r];return e/n.length}}class tX{constructor(e,n,r){this.binding=e,this.valueSize=r;let i,s,a;switch(n){case"quaternion":i=this._slerp,s=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(r*6),this._workIndex=5;break;case"string":case"bool":i=this._select,s=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(r*5);break;default:i=this._lerp,s=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(r*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=s,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,n){const r=this.buffer,i=this.valueSize,s=e*i+i;let a=this.cumulativeWeight;if(a===0){for(let o=0;o!==i;++o)r[s+o]=r[o];a=n}else{a+=n;const o=n/a;this._mixBufferRegion(r,s,0,o,i)}this.cumulativeWeight=a}accumulateAdditive(e){const n=this.buffer,r=this.valueSize,i=r*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(n,i,0,e,r),this.cumulativeWeightAdditive+=e}apply(e){const n=this.valueSize,r=this.buffer,i=e*n+n,s=this.cumulativeWeight,a=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const l=n*this._origIndex;this._mixBufferRegion(r,i,l,1-s,n)}a>0&&this._mixBufferRegionAdditive(r,i,this._addIndex*n,1,n);for(let l=n,u=n+n;l!==u;++l)if(r[l]!==r[l+n]){o.setValue(r,i);break}}saveOriginalState(){const e=this.binding,n=this.buffer,r=this.valueSize,i=r*this._origIndex;e.getValue(n,i);for(let s=r,a=i;s!==a;++s)n[s]=n[i+s%r];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,n=e+this.valueSize;for(let r=e;r<n;r++)this.buffer[r]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,n=this._addIndex*this.valueSize;for(let r=0;r<this.valueSize;r++)this.buffer[n+r]=this.buffer[e+r]}_select(e,n,r,i,s){if(i>=.5)for(let a=0;a!==s;++a)e[n+a]=e[r+a]}_slerp(e,n,r,i){Kr.slerpFlat(e,n,e,n,e,r,i)}_slerpAdditive(e,n,r,i,s){const a=this._workIndex*s;Kr.multiplyQuaternionsFlat(e,a,e,n,e,r),Kr.slerpFlat(e,n,e,n,e,a,i)}_lerp(e,n,r,i,s){const a=1-i;for(let o=0;o!==s;++o){const l=n+o;e[l]=e[l]*a+e[r+o]*i}}_lerpAdditive(e,n,r,i,s){for(let a=0;a!==s;++a){const o=n+a;e[o]=e[o]+e[r+a]*i}}}const n3="\\[\\]\\.:\\/",mde=new RegExp("["+n3+"]","g"),r3="[^"+n3+"]",gde="[^"+n3.replace("\\.","")+"]",yde=/((?:WC+[\/:])*)/.source.replace("WC",r3),vde=/(WCOD+)?/.source.replace("WCOD",gde),xde=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",r3),bde=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",r3),wde=new RegExp("^"+yde+vde+xde+bde+"$"),_de=["material","materials","bones","map"];class Sde{constructor(e,n,r){const i=r||Hn.parseTrackName(n);this._targetGroup=e,this._bindings=e.subscribe_(n,i)}getValue(e,n){this.bind();const r=this._targetGroup.nCachedObjects_,i=this._bindings[r];i!==void 0&&i.getValue(e,n)}setValue(e,n){const r=this._bindings;for(let i=this._targetGroup.nCachedObjects_,s=r.length;i!==s;++i)r[i].setValue(e,n)}bind(){const e=this._bindings;for(let n=this._targetGroup.nCachedObjects_,r=e.length;n!==r;++n)e[n].bind()}unbind(){const e=this._bindings;for(let n=this._targetGroup.nCachedObjects_,r=e.length;n!==r;++n)e[n].unbind()}}class Hn{constructor(e,n,r){this.path=n,this.parsedPath=r||Hn.parseTrackName(n),this.node=Hn.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,n,r){return e&&e.isAnimationObjectGroup?new Hn.Composite(e,n,r):new Hn(e,n,r)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(mde,"")}static parseTrackName(e){const n=wde.exec(e);if(n===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const r={nodeName:n[2],objectName:n[3],objectIndex:n[4],propertyName:n[5],propertyIndex:n[6]},i=r.nodeName&&r.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const s=r.nodeName.substring(i+1);_de.indexOf(s)!==-1&&(r.nodeName=r.nodeName.substring(0,i),r.objectName=s)}if(r.propertyName===null||r.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return r}static findNode(e,n){if(n===void 0||n===""||n==="."||n===-1||n===e.name||n===e.uuid)return e;if(e.skeleton){const r=e.skeleton.getBoneByName(n);if(r!==void 0)return r}if(e.children){const r=function(s){for(let a=0;a<s.length;a++){const o=s[a];if(o.name===n||o.uuid===n)return o;const l=r(o.children);if(l)return l}return null},i=r(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,n){e[n]=this.targetObject[this.propertyName]}_getValue_array(e,n){const r=this.resolvedProperty;for(let i=0,s=r.length;i!==s;++i)e[n++]=r[i]}_getValue_arrayElement(e,n){e[n]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,n){this.resolvedProperty.toArray(e,n)}_setValue_direct(e,n){this.targetObject[this.propertyName]=e[n]}_setValue_direct_setNeedsUpdate(e,n){this.targetObject[this.propertyName]=e[n],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,n){this.targetObject[this.propertyName]=e[n],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,n){const r=this.resolvedProperty;for(let i=0,s=r.length;i!==s;++i)r[i]=e[n++]}_setValue_array_setNeedsUpdate(e,n){const r=this.resolvedProperty;for(let i=0,s=r.length;i!==s;++i)r[i]=e[n++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,n){const r=this.resolvedProperty;for(let i=0,s=r.length;i!==s;++i)r[i]=e[n++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,n){this.resolvedProperty[this.propertyIndex]=e[n]}_setValue_arrayElement_setNeedsUpdate(e,n){this.resolvedProperty[this.propertyIndex]=e[n],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,n){this.resolvedProperty[this.propertyIndex]=e[n],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,n){this.resolvedProperty.fromArray(e,n)}_setValue_fromArray_setNeedsUpdate(e,n){this.resolvedProperty.fromArray(e,n),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,n){this.resolvedProperty.fromArray(e,n),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,n){this.bind(),this.getValue(e,n)}_setValue_unbound(e,n){this.bind(),this.setValue(e,n)}bind(){let e=this.node;const n=this.parsedPath,r=n.objectName,i=n.propertyName;let s=n.propertyIndex;if(e||(e=Hn.findNode(this.rootNode,n.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(r){let u=n.objectIndex;switch(r){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let c=0;c<e.length;c++)if(e[c].name===u){u=c;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[r]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[r]}if(u!==void 0){if(e[u]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[u]}}const a=e[i];if(a===void 0){const u=n.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+u+"."+i+" but it wasn't found.",e);return}let o=this.Versioning.None;this.targetObject=e,e.isMaterial===!0?o=this.Versioning.NeedsUpdate:e.isObject3D===!0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(s!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[s]!==void 0&&(s=e.morphTargetDictionary[s])}l=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=s}else a.fromArray!==void 0&&a.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(l=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Hn.Composite=Sde;Hn.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Hn.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Hn.prototype.GetterByBindingType=[Hn.prototype._getValue_direct,Hn.prototype._getValue_array,Hn.prototype._getValue_arrayElement,Hn.prototype._getValue_toArray];Hn.prototype.SetterByBindingTypeAndVersioning=[[Hn.prototype._setValue_direct,Hn.prototype._setValue_direct_setNeedsUpdate,Hn.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Hn.prototype._setValue_array,Hn.prototype._setValue_array_setNeedsUpdate,Hn.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Hn.prototype._setValue_arrayElement,Hn.prototype._setValue_arrayElement_setNeedsUpdate,Hn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Hn.prototype._setValue_fromArray,Hn.prototype._setValue_fromArray_setNeedsUpdate,Hn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Ade{constructor(){this.isAnimationObjectGroup=!0,this.uuid=ao(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let r=0,i=arguments.length;r!==i;++r)e[arguments[r].uuid]=r;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const n=this;this.stats={objects:{get total(){return n._objects.length},get inUse(){return this.total-n.nCachedObjects_}},get bindingsPerObject(){return n._bindings.length}}}add(){const e=this._objects,n=this._indicesByUUID,r=this._paths,i=this._parsedPaths,s=this._bindings,a=s.length;let o,l=e.length,u=this.nCachedObjects_;for(let c=0,d=arguments.length;c!==d;++c){const h=arguments[c],p=h.uuid;let f=n[p];if(f===void 0){f=l++,n[p]=f,e.push(h);for(let g=0,y=a;g!==y;++g)s[g].push(new Hn(h,r[g],i[g]))}else if(f<u){o=e[f];const g=--u,y=e[g];n[y.uuid]=f,e[f]=y,n[p]=g,e[g]=h;for(let m=0,b=a;m!==b;++m){const w=s[m],_=w[g];let S=w[f];w[f]=_,S===void 0&&(S=new Hn(h,r[m],i[m])),w[g]=S}}else e[f]!==o&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=u}remove(){const e=this._objects,n=this._indicesByUUID,r=this._bindings,i=r.length;let s=this.nCachedObjects_;for(let a=0,o=arguments.length;a!==o;++a){const l=arguments[a],u=l.uuid,c=n[u];if(c!==void 0&&c>=s){const d=s++,h=e[d];n[h.uuid]=c,e[c]=h,n[u]=d,e[d]=l;for(let p=0,f=i;p!==f;++p){const g=r[p],y=g[d],m=g[c];g[c]=y,g[d]=m}}}this.nCachedObjects_=s}uncache(){const e=this._objects,n=this._indicesByUUID,r=this._bindings,i=r.length;let s=this.nCachedObjects_,a=e.length;for(let o=0,l=arguments.length;o!==l;++o){const u=arguments[o],c=u.uuid,d=n[c];if(d!==void 0)if(delete n[c],d<s){const h=--s,p=e[h],f=--a,g=e[f];n[p.uuid]=d,e[d]=p,n[g.uuid]=h,e[h]=g,e.pop();for(let y=0,m=i;y!==m;++y){const b=r[y],w=b[h],_=b[f];b[d]=w,b[h]=_,b.pop()}}else{const h=--a,p=e[h];h>0&&(n[p.uuid]=d),e[d]=p,e.pop();for(let f=0,g=i;f!==g;++f){const y=r[f];y[d]=y[h],y.pop()}}}this.nCachedObjects_=s}subscribe_(e,n){const r=this._bindingsIndicesByPath;let i=r[e];const s=this._bindings;if(i!==void 0)return s[i];const a=this._paths,o=this._parsedPaths,l=this._objects,u=l.length,c=this.nCachedObjects_,d=new Array(u);i=s.length,r[e]=i,a.push(e),o.push(n),s.push(d);for(let h=c,p=l.length;h!==p;++h){const f=l[h];d[h]=new Hn(f,e,n)}return d}unsubscribe_(e){const n=this._bindingsIndicesByPath,r=n[e];if(r!==void 0){const i=this._paths,s=this._parsedPaths,a=this._bindings,o=a.length-1,l=a[o],u=e[o];n[u]=r,a[r]=l,a.pop(),s[r]=s[o],s.pop(),i[r]=i[o],i.pop()}}}class nX{constructor(e,n,r=null,i=n.blendMode){this._mixer=e,this._clip=n,this._localRoot=r,this.blendMode=i;const s=n.tracks,a=s.length,o=new Array(a),l={endingStart:pp,endingEnd:pp};for(let u=0;u!==a;++u){const c=s[u].createInterpolant(null);o[u]=c,c.settings=l}this._interpolantSettings=l,this._interpolants=o,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Zj,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,n){return this.loop=e,this.repetitions=n,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,n,r=!1){if(e.fadeOut(n),this.fadeIn(n),r===!0){const i=this._clip.duration,s=e._clip.duration,a=s/i,o=i/s;e.warp(1,a,n),this.warp(o,1,n)}return this}crossFadeTo(e,n,r=!1){return e.crossFadeFrom(this,n,r)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,n,r){const i=this._mixer,s=i.time,a=this.timeScale;let o=this._timeScaleInterpolant;o===null&&(o=i._lendControlInterpolant(),this._timeScaleInterpolant=o);const l=o.parameterPositions,u=o.sampleValues;return l[0]=s,l[1]=s+r,u[0]=e/a,u[1]=n/a,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,n,r,i){if(!this.enabled){this._updateWeight(e);return}const s=this._startTime;if(s!==null){const l=(e-s)*r;l<0||r===0?n=0:(this._startTime=null,n=r*l)}n*=this._updateTimeScale(e);const a=this._updateTime(n),o=this._updateWeight(e);if(o>0){const l=this._interpolants,u=this._propertyBindings;switch(this.blendMode){case _P:for(let c=0,d=l.length;c!==d;++c)l[c].evaluate(a),u[c].accumulateAdditive(o);break;case CT:default:for(let c=0,d=l.length;c!==d;++c)l[c].evaluate(a),u[c].accumulate(i,o)}}}_updateWeight(e){let n=0;if(this.enabled){n=this.weight;const r=this._weightInterpolant;if(r!==null){const i=r.evaluate(e)[0];n*=i,e>r.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=n,n}_updateTimeScale(e){let n=0;if(!this.paused){n=this.timeScale;const r=this._timeScaleInterpolant;if(r!==null){const i=r.evaluate(e)[0];n*=i,e>r.parameterPositions[1]&&(this.stopWarping(),n===0?this.paused=!0:this.timeScale=n)}}return this._effectiveTimeScale=n,n}_updateTime(e){const n=this._clip.duration,r=this.loop;let i=this.time+e,s=this._loopCount;const a=r===Qj;if(e===0)return s===-1?i:a&&(s&1)===1?n-i:i;if(r===Yj){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=n)i=n;else if(i<0)i=0;else{this.time=i;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(s===-1&&(e>=0?(s=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),i>=n||i<0){const o=Math.floor(i/n);i-=n*o,s+=Math.abs(o);const l=this.repetitions-s;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?n:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const u=e<0;this._setEndings(u,!u,a)}else this._setEndings(!1,!1,a);this._loopCount=s,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}else this.time=i;if(a&&(s&1)===1)return n-i}return i}_setEndings(e,n,r){const i=this._interpolantSettings;r?(i.endingStart=fp,i.endingEnd=fp):(e?i.endingStart=this.zeroSlopeAtStart?fp:pp:i.endingStart=t1,n?i.endingEnd=this.zeroSlopeAtEnd?fp:pp:i.endingEnd=t1)}_scheduleFading(e,n,r){const i=this._mixer,s=i.time;let a=this._weightInterpolant;a===null&&(a=i._lendControlInterpolant(),this._weightInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=s,l[0]=n,o[1]=s+e,l[1]=r,this}}const Ede=new Float32Array(1);class Ide extends gu{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,n){const r=e._localRoot||this._root,i=e._clip.tracks,s=i.length,a=e._propertyBindings,o=e._interpolants,l=r.uuid,u=this._bindingsByRootAndName;let c=u[l];c===void 0&&(c={},u[l]=c);for(let d=0;d!==s;++d){const h=i[d],p=h.name;let f=c[p];if(f!==void 0)++f.referenceCount,a[d]=f;else{if(f=a[d],f!==void 0){f._cacheIndex===null&&(++f.referenceCount,this._addInactiveBinding(f,l,p));continue}const g=n&&n._propertyBindings[d].binding.parsedPath;f=new tX(Hn.create(r,p,g),h.ValueTypeName,h.getValueSize()),++f.referenceCount,this._addInactiveBinding(f,l,p),a[d]=f}o[d].resultBuffer=f.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const r=(e._localRoot||this._root).uuid,i=e._clip.uuid,s=this._actionsByClip[i];this._bindAction(e,s&&s.knownActions[0]),this._addInactiveAction(e,i,r)}const n=e._propertyBindings;for(let r=0,i=n.length;r!==i;++r){const s=n[r];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const n=e._propertyBindings;for(let r=0,i=n.length;r!==i;++r){const s=n[r];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const n=e._cacheIndex;return n!==null&&n<this._nActiveActions}_addInactiveAction(e,n,r){const i=this._actions,s=this._actionsByClip;let a=s[n];if(a===void 0)a={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,s[n]=a;else{const o=a.knownActions;e._byClipCacheIndex=o.length,o.push(e)}e._cacheIndex=i.length,i.push(e),a.actionByRoot[r]=e}_removeInactiveAction(e){const n=this._actions,r=n[n.length-1],i=e._cacheIndex;r._cacheIndex=i,n[i]=r,n.pop(),e._cacheIndex=null;const s=e._clip.uuid,a=this._actionsByClip,o=a[s],l=o.knownActions,u=l[l.length-1],c=e._byClipCacheIndex;u._byClipCacheIndex=c,l[c]=u,l.pop(),e._byClipCacheIndex=null;const d=o.actionByRoot,h=(e._localRoot||this._root).uuid;delete d[h],l.length===0&&delete a[s],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const n=e._propertyBindings;for(let r=0,i=n.length;r!==i;++r){const s=n[r];--s.referenceCount===0&&this._removeInactiveBinding(s)}}_lendAction(e){const n=this._actions,r=e._cacheIndex,i=this._nActiveActions++,s=n[i];e._cacheIndex=i,n[i]=e,s._cacheIndex=r,n[r]=s}_takeBackAction(e){const n=this._actions,r=e._cacheIndex,i=--this._nActiveActions,s=n[i];e._cacheIndex=i,n[i]=e,s._cacheIndex=r,n[r]=s}_addInactiveBinding(e,n,r){const i=this._bindingsByRootAndName,s=this._bindings;let a=i[n];a===void 0&&(a={},i[n]=a),a[r]=e,e._cacheIndex=s.length,s.push(e)}_removeInactiveBinding(e){const n=this._bindings,r=e.binding,i=r.rootNode.uuid,s=r.path,a=this._bindingsByRootAndName,o=a[i],l=n[n.length-1],u=e._cacheIndex;l._cacheIndex=u,n[u]=l,n.pop(),delete o[s],Object.keys(o).length===0&&delete a[i]}_lendBinding(e){const n=this._bindings,r=e._cacheIndex,i=this._nActiveBindings++,s=n[i];e._cacheIndex=i,n[i]=e,s._cacheIndex=r,n[r]=s}_takeBackBinding(e){const n=this._bindings,r=e._cacheIndex,i=--this._nActiveBindings,s=n[i];e._cacheIndex=i,n[i]=e,s._cacheIndex=r,n[r]=s}_lendControlInterpolant(){const e=this._controlInterpolants,n=this._nActiveControlInterpolants++;let r=e[n];return r===void 0&&(r=new KP(new Float32Array(2),new Float32Array(2),1,Ede),r.__cacheIndex=n,e[n]=r),r}_takeBackControlInterpolant(e){const n=this._controlInterpolants,r=e.__cacheIndex,i=--this._nActiveControlInterpolants,s=n[i];e.__cacheIndex=i,n[i]=e,s.__cacheIndex=r,n[r]=s}clipAction(e,n,r){const i=n||this._root,s=i.uuid;let a=typeof e=="string"?Gy.findByName(i,e):e;const o=a!==null?a.uuid:e,l=this._actionsByClip[o];let u=null;if(r===void 0&&(a!==null?r=a.blendMode:r=CT),l!==void 0){const d=l.actionByRoot[s];if(d!==void 0&&d.blendMode===r)return d;u=l.knownActions[0],a===null&&(a=u._clip)}if(a===null)return null;const c=new nX(this,a,n,r);return this._bindAction(c,u),this._addInactiveAction(c,o,s),c}existingAction(e,n){const r=n||this._root,i=r.uuid,s=typeof e=="string"?Gy.findByName(r,e):e,a=s?s.uuid:e,o=this._actionsByClip[a];return o!==void 0&&o.actionByRoot[i]||null}stopAllAction(){const e=this._actions,n=this._nActiveActions;for(let r=n-1;r>=0;--r)e[r].stop();return this}update(e){e*=this.timeScale;const n=this._actions,r=this._nActiveActions,i=this.time+=e,s=Math.sign(e),a=this._accuIndex^=1;for(let u=0;u!==r;++u)n[u]._update(i,e,s,a);const o=this._bindings,l=this._nActiveBindings;for(let u=0;u!==l;++u)o[u].apply(a);return this}setTime(e){this.time=0;for(let n=0;n<this._actions.length;n++)this._actions[n].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const n=this._actions,r=e.uuid,i=this._actionsByClip,s=i[r];if(s!==void 0){const a=s.knownActions;for(let o=0,l=a.length;o!==l;++o){const u=a[o];this._deactivateAction(u);const c=u._cacheIndex,d=n[n.length-1];u._cacheIndex=null,u._byClipCacheIndex=null,d._cacheIndex=c,n[c]=d,n.pop(),this._removeInactiveBindingsForAction(u)}delete i[r]}}uncacheRoot(e){const n=e.uuid,r=this._actionsByClip;for(const a in r){const o=r[a].actionByRoot,l=o[n];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const i=this._bindingsByRootAndName,s=i[n];if(s!==void 0)for(const a in s){const o=s[a];o.restoreOriginalState(),this._removeInactiveBinding(o)}}uncacheAction(e,n){const r=this.existingAction(e,n);r!==null&&(this._deactivateAction(r),this._removeInactiveAction(r))}}class Tde extends TP{constructor(e=1,n=1,r=1,i={}){super(e,n,i),this.isRenderTarget3D=!0,this.depth=r,this.texture=new kT(null,e,n,r),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class i3{constructor(e){this.value=e}clone(){return new i3(this.value.clone===void 0?this.value:this.value.clone())}}let Cde=0;class Mde extends gu{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:Cde++}),this.name="",this.usage=r1,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const n=this.uniforms.indexOf(e);return n!==-1&&this.uniforms.splice(n,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){this.dispatchEvent({type:"dispose"})}copy(e){this.name=e.name,this.usage=e.usage;const n=e.uniforms;this.uniforms.length=0;for(let r=0,i=n.length;r<i;r++){const s=Array.isArray(n[r])?n[r]:[n[r]];for(let a=0;a<s.length;a++)this.uniforms.push(s[a].clone())}return this}clone(){return new this.constructor().copy(this)}}class kde extends j1{constructor(e,n,r=1){super(e,n),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=r}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const n=super.clone(e);return n.meshPerAttribute=this.meshPerAttribute,n}toJSON(e){const n=super.toJSON(e);return n.isInstancedInterleavedBuffer=!0,n.meshPerAttribute=this.meshPerAttribute,n}}class Nde{constructor(e,n,r,i,s){this.isGLBufferAttribute=!0,this.name="",this.buffer=e,this.type=n,this.itemSize=r,this.elementSize=i,this.count=s,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,n){return this.type=e,this.elementSize=n,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}const KG=new ln;class s3{constructor(e,n,r=0,i=1/0){this.ray=new xf(e,n),this.near=r,this.far=i,this.camera=null,this.layers=new Ip,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,n){this.ray.set(e,n)}setFromCamera(e,n){n.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(n.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(n).sub(this.ray.origin).normalize(),this.camera=n):n.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(n.near+n.far)/(n.near-n.far)).unproject(n),this.ray.direction.set(0,0,-1).transformDirection(n.matrixWorld),this.camera=n):console.error("THREE.Raycaster: Unsupported camera type: "+n.type)}setFromXRController(e){return KG.identity().extractRotation(e.matrixWorld),this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(KG),this}intersectObject(e,n=!0,r=[]){return XR(e,this,r,n),r.sort(qG),r}intersectObjects(e,n=!0,r=[]){for(let i=0,s=e.length;i<s;i++)XR(e[i],this,r,n);return r.sort(qG),r}}function qG(t,e){return t.distance-e.distance}function XR(t,e,n,r){let i=!0;if(t.layers.test(e.layers)&&t.raycast(e,n)===!1&&(i=!1),i===!0&&r===!0){const s=t.children;for(let a=0,o=s.length;a<o;a++)XR(s[a],e,n,!0)}}class wI{constructor(e=1,n=0,r=0){this.radius=e,this.phi=n,this.theta=r}set(e,n,r){return this.radius=e,this.phi=n,this.theta=r,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=En(this.phi,1e-6,Math.PI-1e-6),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,n,r){return this.radius=Math.sqrt(e*e+n*n+r*r),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,r),this.phi=Math.acos(En(n/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class Rde{constructor(e=1,n=0,r=0){this.radius=e,this.theta=n,this.y=r}set(e,n,r){return this.radius=e,this.theta=n,this.y=r,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,n,r){return this.radius=Math.sqrt(e*e+r*r),this.theta=Math.atan2(e,r),this.y=n,this}clone(){return new this.constructor().copy(this)}}class a3{constructor(e,n,r,i){a3.prototype.isMatrix2=!0,this.elements=[1,0,0,1],e!==void 0&&this.set(e,n,r,i)}identity(){return this.set(1,0,0,1),this}fromArray(e,n=0){for(let r=0;r<4;r++)this.elements[r]=e[r+n];return this}set(e,n,r,i){const s=this.elements;return s[0]=e,s[2]=n,s[1]=r,s[3]=i,this}}const JG=new Qe;class Fde{constructor(e=new Qe(1/0,1/0),n=new Qe(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=n}set(e,n){return this.min.copy(e),this.max.copy(n),this}setFromPoints(e){this.makeEmpty();for(let n=0,r=e.length;n<r;n++)this.expandByPoint(e[n]);return this}setFromCenterAndSize(e,n){const r=JG.copy(n).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,n){return n.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y}clampPoint(e,n){return n.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,JG).distanceTo(e)}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const YG=new Z,QS=new Z;class Dde{constructor(e=new Z,n=new Z){this.start=e,this.end=n}set(e,n){return this.start.copy(e),this.end.copy(n),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,n){return this.delta(n).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,n){YG.subVectors(e,this.start),QS.subVectors(this.end,this.start);const r=QS.dot(QS);let s=QS.dot(YG)/r;return n&&(s=En(s,0,1)),s}closestPointToPoint(e,n,r){const i=this.closestPointToPointParameter(e,n);return this.delta(r).multiplyScalar(i).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const ZG=new Z;class Pde extends Yn{constructor(e,n){super(),this.light=e,this.matrixAutoUpdate=!1,this.color=n,this.type="SpotLightHelper";const r=new An,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let a=0,o=1,l=32;a<l;a++,o++){const u=a/l*Math.PI*2,c=o/l*Math.PI*2;i.push(Math.cos(u),Math.sin(u),1,Math.cos(c),Math.sin(c),1)}r.setAttribute("position",new Jt(i,3));const s=new Ws({fog:!1,toneMapped:!1});this.cone=new Tl(r,s),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const e=this.light.distance?this.light.distance:1e3,n=e*Math.tan(this.light.angle);this.cone.scale.set(n,n,e),ZG.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(ZG),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Uc=new Z,eA=new ln,Gk=new ln;class Lde extends Tl{constructor(e){const n=rX(e),r=new An,i=[],s=[],a=new Ct(0,0,1),o=new Ct(0,1,0);for(let u=0;u<n.length;u++){const c=n[u];c.parent&&c.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),s.push(a.r,a.g,a.b),s.push(o.r,o.g,o.b))}r.setAttribute("position",new Jt(i,3)),r.setAttribute("color",new Jt(s,3));const l=new Ws({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(r,l),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=n,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const n=this.bones,r=this.geometry,i=r.getAttribute("position");Gk.copy(this.root.matrixWorld).invert();for(let s=0,a=0;s<n.length;s++){const o=n[s];o.parent&&o.parent.isBone&&(eA.multiplyMatrices(Gk,o.matrixWorld),Uc.setFromMatrixPosition(eA),i.setXYZ(a,Uc.x,Uc.y,Uc.z),eA.multiplyMatrices(Gk,o.parent.matrixWorld),Uc.setFromMatrixPosition(eA),i.setXYZ(a+1,Uc.x,Uc.y,Uc.z),a+=2)}r.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose()}}function rX(t){const e=[];t.isBone===!0&&e.push(t);for(let n=0;n<t.children.length;n++)e.push(...rX(t.children[n]));return e}class Ode extends Cr{constructor(e,n,r){const i=new Z1(n,4,2),s=new ka({wireframe:!0,fog:!1,toneMapped:!1});super(i,s),this.light=e,this.color=r,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const Bde=new Z,QG=new Ct,eH=new Ct;class Ude extends Yn{constructor(e,n,r){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=r,this.type="HemisphereLightHelper";const i=new Y1(n);i.rotateY(Math.PI*.5),this.material=new ka({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const s=i.getAttribute("position"),a=new Float32Array(s.count*3);i.setAttribute("color",new Ln(a,3)),this.add(new Cr(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const n=e.geometry.getAttribute("color");QG.copy(this.light.color),eH.copy(this.light.groundColor);for(let r=0,i=n.count;r<i;r++){const s=r<i/2?QG:eH;n.setXYZ(r,s.r,s.g,s.b)}n.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(Bde.setFromMatrixPosition(this.light.matrixWorld).negate())}}class $de extends Tl{constructor(e=10,n=10,r=4473924,i=8947848){r=new Ct(r),i=new Ct(i);const s=n/2,a=e/n,o=e/2,l=[],u=[];for(let h=0,p=0,f=-o;h<=n;h++,f+=a){l.push(-o,0,f,o,0,f),l.push(f,0,-o,f,0,o);const g=h===s?r:i;g.toArray(u,p),p+=3,g.toArray(u,p),p+=3,g.toArray(u,p),p+=3,g.toArray(u,p),p+=3}const c=new An;c.setAttribute("position",new Jt(l,3)),c.setAttribute("color",new Jt(u,3));const d=new Ws({vertexColors:!0,toneMapped:!1});super(c,d),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class zde extends Tl{constructor(e=10,n=16,r=8,i=64,s=4473924,a=8947848){s=new Ct(s),a=new Ct(a);const o=[],l=[];if(n>1)for(let d=0;d<n;d++){const h=d/n*(Math.PI*2),p=Math.sin(h)*e,f=Math.cos(h)*e;o.push(0,0,0),o.push(p,0,f);const g=d&1?s:a;l.push(g.r,g.g,g.b),l.push(g.r,g.g,g.b)}for(let d=0;d<r;d++){const h=d&1?s:a,p=e-e/r*d;for(let f=0;f<i;f++){let g=f/i*(Math.PI*2),y=Math.sin(g)*p,m=Math.cos(g)*p;o.push(y,0,m),l.push(h.r,h.g,h.b),g=(f+1)/i*(Math.PI*2),y=Math.sin(g)*p,m=Math.cos(g)*p,o.push(y,0,m),l.push(h.r,h.g,h.b)}}const u=new An;u.setAttribute("position",new Jt(o,3)),u.setAttribute("color",new Jt(l,3));const c=new Ws({vertexColors:!0,toneMapped:!1});super(u,c),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const tH=new Z,tA=new Z,nH=new Z;class Gde extends Yn{constructor(e,n,r){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=r,this.type="DirectionalLightHelper",n===void 0&&(n=1);let i=new An;i.setAttribute("position",new Jt([-n,n,0,n,n,0,n,-n,0,-n,-n,0,-n,n,0],3));const s=new Ws({fog:!1,toneMapped:!1});this.lightPlane=new lc(i,s),this.add(this.lightPlane),i=new An,i.setAttribute("position",new Jt([0,0,0,0,0,1],3)),this.targetLine=new lc(i,s),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),tH.setFromMatrixPosition(this.light.matrixWorld),tA.setFromMatrixPosition(this.light.target.matrixWorld),nH.subVectors(tA,tH),this.lightPlane.lookAt(tA),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(tA),this.targetLine.scale.z=nH.length()}}const nA=new Z,oi=new W1;class Hde extends Tl{constructor(e){const n=new An,r=new Ws({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],s=[],a={};o("n1","n2"),o("n2","n4"),o("n4","n3"),o("n3","n1"),o("f1","f2"),o("f2","f4"),o("f4","f3"),o("f3","f1"),o("n1","f1"),o("n2","f2"),o("n3","f3"),o("n4","f4"),o("p","n1"),o("p","n2"),o("p","n3"),o("p","n4"),o("u1","u2"),o("u2","u3"),o("u3","u1"),o("c","t"),o("p","c"),o("cn1","cn2"),o("cn3","cn4"),o("cf1","cf2"),o("cf3","cf4");function o(f,g){l(f),l(g)}function l(f){i.push(0,0,0),s.push(0,0,0),a[f]===void 0&&(a[f]=[]),a[f].push(i.length/3-1)}n.setAttribute("position",new Jt(i,3)),n.setAttribute("color",new Jt(s,3)),super(n,r),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=a,this.update();const u=new Ct(16755200),c=new Ct(16711680),d=new Ct(43775),h=new Ct(16777215),p=new Ct(3355443);this.setColors(u,c,d,h,p)}setColors(e,n,r,i,s){const o=this.geometry.getAttribute("color");o.setXYZ(0,e.r,e.g,e.b),o.setXYZ(1,e.r,e.g,e.b),o.setXYZ(2,e.r,e.g,e.b),o.setXYZ(3,e.r,e.g,e.b),o.setXYZ(4,e.r,e.g,e.b),o.setXYZ(5,e.r,e.g,e.b),o.setXYZ(6,e.r,e.g,e.b),o.setXYZ(7,e.r,e.g,e.b),o.setXYZ(8,e.r,e.g,e.b),o.setXYZ(9,e.r,e.g,e.b),o.setXYZ(10,e.r,e.g,e.b),o.setXYZ(11,e.r,e.g,e.b),o.setXYZ(12,e.r,e.g,e.b),o.setXYZ(13,e.r,e.g,e.b),o.setXYZ(14,e.r,e.g,e.b),o.setXYZ(15,e.r,e.g,e.b),o.setXYZ(16,e.r,e.g,e.b),o.setXYZ(17,e.r,e.g,e.b),o.setXYZ(18,e.r,e.g,e.b),o.setXYZ(19,e.r,e.g,e.b),o.setXYZ(20,e.r,e.g,e.b),o.setXYZ(21,e.r,e.g,e.b),o.setXYZ(22,e.r,e.g,e.b),o.setXYZ(23,e.r,e.g,e.b),o.setXYZ(24,n.r,n.g,n.b),o.setXYZ(25,n.r,n.g,n.b),o.setXYZ(26,n.r,n.g,n.b),o.setXYZ(27,n.r,n.g,n.b),o.setXYZ(28,n.r,n.g,n.b),o.setXYZ(29,n.r,n.g,n.b),o.setXYZ(30,n.r,n.g,n.b),o.setXYZ(31,n.r,n.g,n.b),o.setXYZ(32,r.r,r.g,r.b),o.setXYZ(33,r.r,r.g,r.b),o.setXYZ(34,r.r,r.g,r.b),o.setXYZ(35,r.r,r.g,r.b),o.setXYZ(36,r.r,r.g,r.b),o.setXYZ(37,r.r,r.g,r.b),o.setXYZ(38,i.r,i.g,i.b),o.setXYZ(39,i.r,i.g,i.b),o.setXYZ(40,s.r,s.g,s.b),o.setXYZ(41,s.r,s.g,s.b),o.setXYZ(42,s.r,s.g,s.b),o.setXYZ(43,s.r,s.g,s.b),o.setXYZ(44,s.r,s.g,s.b),o.setXYZ(45,s.r,s.g,s.b),o.setXYZ(46,s.r,s.g,s.b),o.setXYZ(47,s.r,s.g,s.b),o.setXYZ(48,s.r,s.g,s.b),o.setXYZ(49,s.r,s.g,s.b),o.needsUpdate=!0}update(){const e=this.geometry,n=this.pointMap,r=1,i=1;oi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);const s=this.camera.coordinateSystem===Oo?-1:0;pi("c",n,e,oi,0,0,s),pi("t",n,e,oi,0,0,1),pi("n1",n,e,oi,-1,-1,s),pi("n2",n,e,oi,r,-1,s),pi("n3",n,e,oi,-1,i,s),pi("n4",n,e,oi,r,i,s),pi("f1",n,e,oi,-1,-1,1),pi("f2",n,e,oi,r,-1,1),pi("f3",n,e,oi,-1,i,1),pi("f4",n,e,oi,r,i,1),pi("u1",n,e,oi,r*.7,i*1.1,s),pi("u2",n,e,oi,-1*.7,i*1.1,s),pi("u3",n,e,oi,0,i*2,s),pi("cf1",n,e,oi,-1,0,1),pi("cf2",n,e,oi,r,0,1),pi("cf3",n,e,oi,0,-1,1),pi("cf4",n,e,oi,0,i,1),pi("cn1",n,e,oi,-1,0,s),pi("cn2",n,e,oi,r,0,s),pi("cn3",n,e,oi,0,-1,s),pi("cn4",n,e,oi,0,i,s),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function pi(t,e,n,r,i,s,a){nA.set(i,s,a).unproject(r);const o=e[t];if(o!==void 0){const l=n.getAttribute("position");for(let u=0,c=o.length;u<c;u++)l.setXYZ(o[u],nA.x,nA.y,nA.z)}}const rA=new ds;class Wde extends Tl{constructor(e,n=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(8*3),s=new An;s.setIndex(new Ln(r,1)),s.setAttribute("position",new Ln(i,3)),super(s,new Ws({color:n,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(){if(this.object!==void 0&&rA.setFromObject(this.object),rA.isEmpty())return;const e=rA.min,n=rA.max,r=this.geometry.attributes.position,i=r.array;i[0]=n.x,i[1]=n.y,i[2]=n.z,i[3]=e.x,i[4]=n.y,i[5]=n.z,i[6]=e.x,i[7]=e.y,i[8]=n.z,i[9]=n.x,i[10]=e.y,i[11]=n.z,i[12]=n.x,i[13]=n.y,i[14]=e.z,i[15]=e.x,i[16]=n.y,i[17]=e.z,i[18]=e.x,i[19]=e.y,i[20]=e.z,i[21]=n.x,i[22]=e.y,i[23]=e.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,n){return super.copy(e,n),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class Vde extends Tl{constructor(e,n=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],s=new An;s.setIndex(new Ln(r,1)),s.setAttribute("position",new Jt(i,3)),super(s,new Ws({color:n,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const n=this.box;n.isEmpty()||(n.getCenter(this.position),n.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}class jde extends lc{constructor(e,n=1,r=16776960){const i=r,s=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],a=new An;a.setAttribute("position",new Jt(s,3)),a.computeBoundingSphere(),super(a,new Ws({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=n;const o=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],l=new An;l.setAttribute("position",new Jt(o,3)),l.computeBoundingSphere(),this.add(new Cr(l,new ka({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const rH=new Z;let iA,Hk;class Xde extends Yn{constructor(e=new Z(0,0,1),n=new Z(0,0,0),r=1,i=16776960,s=r*.2,a=s*.2){super(),this.type="ArrowHelper",iA===void 0&&(iA=new An,iA.setAttribute("position",new Jt([0,0,0,0,1,0],3)),Hk=new q1(.5,1,5,1),Hk.translate(0,-.5,0)),this.position.copy(n),this.line=new lc(iA,new Ws({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Cr(Hk,new ka({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(r,s,a)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{rH.set(e.z,0,-e.x).normalize();const n=Math.acos(e.y);this.quaternion.setFromAxisAngle(rH,n)}}setLength(e,n=e*.2,r=n*.2){this.line.scale.set(1,Math.max(1e-4,e-n),1),this.line.updateMatrix(),this.cone.scale.set(r,n,r),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class Kde extends Tl{constructor(e=1){const n=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],r=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new An;i.setAttribute("position",new Jt(n,3)),i.setAttribute("color",new Jt(r,3));const s=new Ws({vertexColors:!0,toneMapped:!1});super(i,s),this.type="AxesHelper"}setColors(e,n,r){const i=new Ct,s=this.geometry.attributes.color.array;return i.set(e),i.toArray(s,0),i.toArray(s,3),i.set(n),i.toArray(s,6),i.toArray(s,9),i.set(r),i.toArray(s,12),i.toArray(s,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class qde{constructor(){this.type="ShapePath",this.color=new Ct,this.subPaths=[],this.currentPath=null}moveTo(e,n){return this.currentPath=new bI,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,n),this}lineTo(e,n){return this.currentPath.lineTo(e,n),this}quadraticCurveTo(e,n,r,i){return this.currentPath.quadraticCurveTo(e,n,r,i),this}bezierCurveTo(e,n,r,i,s,a){return this.currentPath.bezierCurveTo(e,n,r,i,s,a),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function n(m){const b=[];for(let w=0,_=m.length;w<_;w++){const S=m[w],E=new Cp;E.curves=S.curves,b.push(E)}return b}function r(m,b){const w=b.length;let _=!1;for(let S=w-1,E=0;E<w;S=E++){let C=b[S],T=b[E],M=T.x-C.x,k=T.y-C.y;if(Math.abs(k)>Number.EPSILON){if(k<0&&(C=b[E],M=-M,T=b[S],k=-k),m.y<C.y||m.y>T.y)continue;if(m.y===C.y){if(m.x===C.x)return!0}else{const R=k*(m.x-C.x)-M*(m.y-C.y);if(R===0)return!0;if(R<0)continue;_=!_}}else{if(m.y!==C.y)continue;if(T.x<=m.x&&m.x<=C.x||C.x<=m.x&&m.x<=T.x)return!0}}return _}const i=fl.isClockWise,s=this.subPaths;if(s.length===0)return[];let a,o,l;const u=[];if(s.length===1)return o=s[0],l=new Cp,l.curves=o.curves,u.push(l),u;let c=!i(s[0].getPoints());c=e?!c:c;const d=[],h=[];let p=[],f=0,g;h[f]=void 0,p[f]=[];for(let m=0,b=s.length;m<b;m++)o=s[m],g=o.getPoints(),a=i(g),a=e?!a:a,a?(!c&&h[f]&&f++,h[f]={s:new Cp,p:g},h[f].s.curves=o.curves,c&&f++,p[f]=[]):p[f].push({h:o,p:g[0]});if(!h[0])return n(s);if(h.length>1){let m=!1,b=0;for(let w=0,_=h.length;w<_;w++)d[w]=[];for(let w=0,_=h.length;w<_;w++){const S=p[w];for(let E=0;E<S.length;E++){const C=S[E];let T=!0;for(let M=0;M<h.length;M++)r(C.p,h[M].p)&&(w!==M&&b++,T?(T=!1,d[M].push(C)):m=!0);T&&d[w].push(C)}}b>0&&m===!1&&(p=d)}let y;for(let m=0,b=h.length;m<b;m++){l=h[m].s,u.push(l),y=p[m];for(let w=0,_=y.length;w<_;w++)l.holes.push(y[w].h)}return u}}class Jde extends gu{constructor(e,n=null){super(),this.object=e,this.domElement=n,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(e){if(e===void 0){console.warn("THREE.Controls: connect() now requires an element.");return}this.domElement!==null&&this.disconnect(),this.domElement=e}disconnect(){}dispose(){}update(){}}function Yde(t,e){const n=t.image&&t.image.width?t.image.width/t.image.height:1;return n>e?(t.repeat.x=1,t.repeat.y=n/e,t.offset.x=0,t.offset.y=(1-t.repeat.y)/2):(t.repeat.x=e/n,t.repeat.y=1,t.offset.x=(1-t.repeat.x)/2,t.offset.y=0),t}function Zde(t,e){const n=t.image&&t.image.width?t.image.width/t.image.height:1;return n>e?(t.repeat.x=e/n,t.repeat.y=1,t.offset.x=(1-t.repeat.x)/2,t.offset.y=0):(t.repeat.x=1,t.repeat.y=n/e,t.offset.x=0,t.offset.y=(1-t.repeat.y)/2),t}function Qde(t){return t.repeat.x=1,t.repeat.y=1,t.offset.x=0,t.offset.y=0,t}function KR(t,e,n,r){const i=ehe(r);switch(n){case vP:return t*e;case G1:return t*e/i.components*i.byteLength;case H1:return t*e/i.components*i.byteLength;case bP:return t*e*2/i.components*i.byteLength;case IT:return t*e*2/i.components*i.byteLength;case xP:return t*e*3/i.components*i.byteLength;case ui:return t*e*4/i.components*i.byteLength;case TT:return t*e*4/i.components*i.byteLength;case xb:case bb:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*8;case wb:case _b:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*16;case VE:case XE:return Math.max(t,16)*Math.max(e,8)/4;case WE:case jE:return Math.max(t,8)*Math.max(e,8)/2;case KE:case qE:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*8;case JE:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*16;case YE:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*16;case ZE:return Math.floor((t+4)/5)*Math.floor((e+3)/4)*16;case QE:return Math.floor((t+4)/5)*Math.floor((e+4)/5)*16;case eI:return Math.floor((t+5)/6)*Math.floor((e+4)/5)*16;case tI:return Math.floor((t+5)/6)*Math.floor((e+5)/6)*16;case nI:return Math.floor((t+7)/8)*Math.floor((e+4)/5)*16;case rI:return Math.floor((t+7)/8)*Math.floor((e+5)/6)*16;case iI:return Math.floor((t+7)/8)*Math.floor((e+7)/8)*16;case sI:return Math.floor((t+9)/10)*Math.floor((e+4)/5)*16;case aI:return Math.floor((t+9)/10)*Math.floor((e+5)/6)*16;case oI:return Math.floor((t+9)/10)*Math.floor((e+7)/8)*16;case lI:return Math.floor((t+9)/10)*Math.floor((e+9)/10)*16;case uI:return Math.floor((t+11)/12)*Math.floor((e+9)/10)*16;case cI:return Math.floor((t+11)/12)*Math.floor((e+11)/12)*16;case Sb:case dI:case hI:return Math.ceil(t/4)*Math.ceil(e/4)*16;case wP:case pI:return Math.ceil(t/4)*Math.ceil(e/4)*8;case fI:case mI:return Math.ceil(t/4)*Math.ceil(e/4)*16}throw new Error(`Unable to determine texture byte length for ${n} format.`)}function ehe(t){switch(t){case la:case _T:return{byteLength:1,components:1};case Py:case ST:case Wi:return{byteLength:2,components:1};case AT:case ET:return{byteLength:2,components:4};case cu:case z1:case ti:return{byteLength:4,components:1};case yP:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${t}.`)}class the{static contain(e,n){return Yde(e,n)}static cover(e,n){return Zde(e,n)}static fill(e){return Qde(e)}static getByteLength(e,n,r,i){return KR(e,n,r,i)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:vf}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=vf);/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */function iX(){let t=null,e=!1,n=null,r=null;function i(s,a){n(s,a),r=t.requestAnimationFrame(i)}return{start:function(){e!==!0&&n!==null&&(r=t.requestAnimationFrame(i),e=!0)},stop:function(){t.cancelAnimationFrame(r),e=!1},setAnimationLoop:function(s){n=s},setContext:function(s){t=s}}}function nhe(t){const e=new WeakMap;function n(o,l){const u=o.array,c=o.usage,d=u.byteLength,h=t.createBuffer();t.bindBuffer(l,h),t.bufferData(l,u,c),o.onUploadCallback();let p;if(u instanceof Float32Array)p=t.FLOAT;else if(u instanceof Uint16Array)o.isFloat16BufferAttribute?p=t.HALF_FLOAT:p=t.UNSIGNED_SHORT;else if(u instanceof Int16Array)p=t.SHORT;else if(u instanceof Uint32Array)p=t.UNSIGNED_INT;else if(u instanceof Int32Array)p=t.INT;else if(u instanceof Int8Array)p=t.BYTE;else if(u instanceof Uint8Array)p=t.UNSIGNED_BYTE;else if(u instanceof Uint8ClampedArray)p=t.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+u);return{buffer:h,type:p,bytesPerElement:u.BYTES_PER_ELEMENT,version:o.version,size:d}}function r(o,l,u){const c=l.array,d=l.updateRanges;if(t.bindBuffer(u,o),d.length===0)t.bufferSubData(u,0,c);else{d.sort((p,f)=>p.start-f.start);let h=0;for(let p=1;p<d.length;p++){const f=d[h],g=d[p];g.start<=f.start+f.count+1?f.count=Math.max(f.count,g.start+g.count-f.start):(++h,d[h]=g)}d.length=h+1;for(let p=0,f=d.length;p<f;p++){const g=d[p];t.bufferSubData(u,g.start*c.BYTES_PER_ELEMENT,c,g.start,g.count)}l.clearUpdateRanges()}l.onUploadCallback()}function i(o){return o.isInterleavedBufferAttribute&&(o=o.data),e.get(o)}function s(o){o.isInterleavedBufferAttribute&&(o=o.data);const l=e.get(o);l&&(t.deleteBuffer(l.buffer),e.delete(o))}function a(o,l){if(o.isInterleavedBufferAttribute&&(o=o.data),o.isGLBufferAttribute){const c=e.get(o);(!c||c.version<o.version)&&e.set(o,{buffer:o.buffer,type:o.type,bytesPerElement:o.elementSize,version:o.version});return}const u=e.get(o);if(u===void 0)e.set(o,n(o,l));else if(u.version<o.version){if(u.size!==o.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");r(u.buffer,o,l),u.version=o.version}}return{get:i,remove:s,update:a}}var rhe=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,ihe=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,she=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,ahe=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,ohe=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,lhe=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,uhe=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,che=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,dhe=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,hhe=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,phe=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,fhe=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,mhe=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,ghe=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,yhe=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,vhe=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,xhe=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,bhe=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,whe=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,_he=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,She=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,Ahe=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,Ehe=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,Ihe=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,The=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,Che=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Mhe=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,khe=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,Nhe=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Rhe=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Fhe="gl_FragColor = linearToOutputTexel( gl_FragColor );",Dhe=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,Phe=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Lhe=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Ohe=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,Bhe=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,Uhe=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,$he=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,zhe=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,Ghe=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Hhe=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,Whe=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,Vhe=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,jhe=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,Xhe=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,Khe=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,qhe=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,Jhe=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,Yhe=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,Zhe=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,Qhe=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,epe=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,tpe=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,npe=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,rpe=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,ipe=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,spe=`#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,ape=`#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,ope=`#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,lpe=`#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,upe=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,cpe=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,dpe=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,hpe=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,ppe=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,fpe=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,mpe=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,gpe=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,ype=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,vpe=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,xpe=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,bpe=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,wpe=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,_pe=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Spe=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Ape=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,Epe=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,Ipe=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,Tpe=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,Cpe=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,Mpe=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,kpe=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,Npe=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,Rpe=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Fpe=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Dpe=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,Ppe=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Lpe=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Ope=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,Bpe=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,Upe=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,$pe=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,zpe=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Gpe=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Hpe=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,Wpe=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,Vpe=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,jpe=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,Xpe=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,Kpe=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,qpe=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,Jpe=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,Ype=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,Zpe=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,Qpe=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,efe=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,tfe=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const nfe=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,rfe=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,ife=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,sfe=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,afe=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,ofe=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,lfe=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,ufe=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,cfe=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,dfe=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,hfe=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,pfe=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,ffe=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,mfe=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,gfe=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,yfe=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vfe=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,xfe=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,bfe=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,wfe=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,_fe=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Sfe=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,Afe=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Efe=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Ife=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,Tfe=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Cfe=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Mfe=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,kfe=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Nfe=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Rfe=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Ffe=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,Dfe=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Pfe=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,Dn={alphahash_fragment:rhe,alphahash_pars_fragment:ihe,alphamap_fragment:she,alphamap_pars_fragment:ahe,alphatest_fragment:ohe,alphatest_pars_fragment:lhe,aomap_fragment:uhe,aomap_pars_fragment:che,batching_pars_vertex:dhe,batching_vertex:hhe,begin_vertex:phe,beginnormal_vertex:fhe,bsdfs:mhe,iridescence_fragment:ghe,bumpmap_pars_fragment:yhe,clipping_planes_fragment:vhe,clipping_planes_pars_fragment:xhe,clipping_planes_pars_vertex:bhe,clipping_planes_vertex:whe,color_fragment:_he,color_pars_fragment:She,color_pars_vertex:Ahe,color_vertex:Ehe,common:Ihe,cube_uv_reflection_fragment:The,defaultnormal_vertex:Che,displacementmap_pars_vertex:Mhe,displacementmap_vertex:khe,emissivemap_fragment:Nhe,emissivemap_pars_fragment:Rhe,colorspace_fragment:Fhe,colorspace_pars_fragment:Dhe,envmap_fragment:Phe,envmap_common_pars_fragment:Lhe,envmap_pars_fragment:Ohe,envmap_pars_vertex:Bhe,envmap_physical_pars_fragment:qhe,envmap_vertex:Uhe,fog_vertex:$he,fog_pars_vertex:zhe,fog_fragment:Ghe,fog_pars_fragment:Hhe,gradientmap_pars_fragment:Whe,lightmap_pars_fragment:Vhe,lights_lambert_fragment:jhe,lights_lambert_pars_fragment:Xhe,lights_pars_begin:Khe,lights_toon_fragment:Jhe,lights_toon_pars_fragment:Yhe,lights_phong_fragment:Zhe,lights_phong_pars_fragment:Qhe,lights_physical_fragment:epe,lights_physical_pars_fragment:tpe,lights_fragment_begin:npe,lights_fragment_maps:rpe,lights_fragment_end:ipe,logdepthbuf_fragment:spe,logdepthbuf_pars_fragment:ape,logdepthbuf_pars_vertex:ope,logdepthbuf_vertex:lpe,map_fragment:upe,map_pars_fragment:cpe,map_particle_fragment:dpe,map_particle_pars_fragment:hpe,metalnessmap_fragment:ppe,metalnessmap_pars_fragment:fpe,morphinstance_vertex:mpe,morphcolor_vertex:gpe,morphnormal_vertex:ype,morphtarget_pars_vertex:vpe,morphtarget_vertex:xpe,normal_fragment_begin:bpe,normal_fragment_maps:wpe,normal_pars_fragment:_pe,normal_pars_vertex:Spe,normal_vertex:Ape,normalmap_pars_fragment:Epe,clearcoat_normal_fragment_begin:Ipe,clearcoat_normal_fragment_maps:Tpe,clearcoat_pars_fragment:Cpe,iridescence_pars_fragment:Mpe,opaque_fragment:kpe,packing:Npe,premultiplied_alpha_fragment:Rpe,project_vertex:Fpe,dithering_fragment:Dpe,dithering_pars_fragment:Ppe,roughnessmap_fragment:Lpe,roughnessmap_pars_fragment:Ope,shadowmap_pars_fragment:Bpe,shadowmap_pars_vertex:Upe,shadowmap_vertex:$pe,shadowmask_pars_fragment:zpe,skinbase_vertex:Gpe,skinning_pars_vertex:Hpe,skinning_vertex:Wpe,skinnormal_vertex:Vpe,specularmap_fragment:jpe,specularmap_pars_fragment:Xpe,tonemapping_fragment:Kpe,tonemapping_pars_fragment:qpe,transmission_fragment:Jpe,transmission_pars_fragment:Ype,uv_pars_fragment:Zpe,uv_pars_vertex:Qpe,uv_vertex:efe,worldpos_vertex:tfe,background_vert:nfe,background_frag:rfe,backgroundCube_vert:ife,backgroundCube_frag:sfe,cube_vert:afe,cube_frag:ofe,depth_vert:lfe,depth_frag:ufe,distanceRGBA_vert:cfe,distanceRGBA_frag:dfe,equirect_vert:hfe,equirect_frag:pfe,linedashed_vert:ffe,linedashed_frag:mfe,meshbasic_vert:gfe,meshbasic_frag:yfe,meshlambert_vert:vfe,meshlambert_frag:xfe,meshmatcap_vert:bfe,meshmatcap_frag:wfe,meshnormal_vert:_fe,meshnormal_frag:Sfe,meshphong_vert:Afe,meshphong_frag:Efe,meshphysical_vert:Ife,meshphysical_frag:Tfe,meshtoon_vert:Cfe,meshtoon_frag:Mfe,points_vert:kfe,points_frag:Nfe,shadow_vert:Rfe,shadow_frag:Ffe,sprite_vert:Dfe,sprite_frag:Pfe},Bt={common:{diffuse:{value:new Ct(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Mn},alphaMap:{value:null},alphaMapTransform:{value:new Mn},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Mn}},envmap:{envMap:{value:null},envMapRotation:{value:new Mn},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Mn}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Mn}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Mn},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Mn},normalScale:{value:new Qe(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Mn},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Mn}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Mn}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Mn}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ct(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ct(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Mn},alphaTest:{value:0},uvTransform:{value:new Mn}},sprite:{diffuse:{value:new Ct(16777215)},opacity:{value:1},center:{value:new Qe(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Mn},alphaMap:{value:null},alphaMapTransform:{value:new Mn},alphaTest:{value:0}}},hl={basic:{uniforms:Zs([Bt.common,Bt.specularmap,Bt.envmap,Bt.aomap,Bt.lightmap,Bt.fog]),vertexShader:Dn.meshbasic_vert,fragmentShader:Dn.meshbasic_frag},lambert:{uniforms:Zs([Bt.common,Bt.specularmap,Bt.envmap,Bt.aomap,Bt.lightmap,Bt.emissivemap,Bt.bumpmap,Bt.normalmap,Bt.displacementmap,Bt.fog,Bt.lights,{emissive:{value:new Ct(0)}}]),vertexShader:Dn.meshlambert_vert,fragmentShader:Dn.meshlambert_frag},phong:{uniforms:Zs([Bt.common,Bt.specularmap,Bt.envmap,Bt.aomap,Bt.lightmap,Bt.emissivemap,Bt.bumpmap,Bt.normalmap,Bt.displacementmap,Bt.fog,Bt.lights,{emissive:{value:new Ct(0)},specular:{value:new Ct(1118481)},shininess:{value:30}}]),vertexShader:Dn.meshphong_vert,fragmentShader:Dn.meshphong_frag},standard:{uniforms:Zs([Bt.common,Bt.envmap,Bt.aomap,Bt.lightmap,Bt.emissivemap,Bt.bumpmap,Bt.normalmap,Bt.displacementmap,Bt.roughnessmap,Bt.metalnessmap,Bt.fog,Bt.lights,{emissive:{value:new Ct(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Dn.meshphysical_vert,fragmentShader:Dn.meshphysical_frag},toon:{uniforms:Zs([Bt.common,Bt.aomap,Bt.lightmap,Bt.emissivemap,Bt.bumpmap,Bt.normalmap,Bt.displacementmap,Bt.gradientmap,Bt.fog,Bt.lights,{emissive:{value:new Ct(0)}}]),vertexShader:Dn.meshtoon_vert,fragmentShader:Dn.meshtoon_frag},matcap:{uniforms:Zs([Bt.common,Bt.bumpmap,Bt.normalmap,Bt.displacementmap,Bt.fog,{matcap:{value:null}}]),vertexShader:Dn.meshmatcap_vert,fragmentShader:Dn.meshmatcap_frag},points:{uniforms:Zs([Bt.points,Bt.fog]),vertexShader:Dn.points_vert,fragmentShader:Dn.points_frag},dashed:{uniforms:Zs([Bt.common,Bt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Dn.linedashed_vert,fragmentShader:Dn.linedashed_frag},depth:{uniforms:Zs([Bt.common,Bt.displacementmap]),vertexShader:Dn.depth_vert,fragmentShader:Dn.depth_frag},normal:{uniforms:Zs([Bt.common,Bt.bumpmap,Bt.normalmap,Bt.displacementmap,{opacity:{value:1}}]),vertexShader:Dn.meshnormal_vert,fragmentShader:Dn.meshnormal_frag},sprite:{uniforms:Zs([Bt.sprite,Bt.fog]),vertexShader:Dn.sprite_vert,fragmentShader:Dn.sprite_frag},background:{uniforms:{uvTransform:{value:new Mn},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Dn.background_vert,fragmentShader:Dn.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new Mn}},vertexShader:Dn.backgroundCube_vert,fragmentShader:Dn.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Dn.cube_vert,fragmentShader:Dn.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Dn.equirect_vert,fragmentShader:Dn.equirect_frag},distanceRGBA:{uniforms:Zs([Bt.common,Bt.displacementmap,{referencePosition:{value:new Z},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Dn.distanceRGBA_vert,fragmentShader:Dn.distanceRGBA_frag},shadow:{uniforms:Zs([Bt.lights,Bt.fog,{color:{value:new Ct(0)},opacity:{value:1}}]),vertexShader:Dn.shadow_vert,fragmentShader:Dn.shadow_frag}};hl.physical={uniforms:Zs([hl.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Mn},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Mn},clearcoatNormalScale:{value:new Qe(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Mn},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Mn},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Mn},sheen:{value:0},sheenColor:{value:new Ct(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Mn},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Mn},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Mn},transmissionSamplerSize:{value:new Qe},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Mn},attenuationDistance:{value:0},attenuationColor:{value:new Ct(0)},specularColor:{value:new Ct(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Mn},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Mn},anisotropyVector:{value:new Qe},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Mn}}]),vertexShader:Dn.meshphysical_vert,fragmentShader:Dn.meshphysical_frag};const sA={r:0,b:0,g:0},Uh=new Ba,Lfe=new ln;function Ofe(t,e,n,r,i,s,a){const o=new Ct(0);let l=s===!0?0:1,u,c,d=null,h=0,p=null;function f(w){let _=w.isScene===!0?w.background:null;return _&&_.isTexture&&(_=(w.backgroundBlurriness>0?n:e).get(_)),_}function g(w){let _=!1;const S=f(w);S===null?m(o,l):S&&S.isColor&&(m(S,1),_=!0);const E=t.xr.getEnvironmentBlendMode();E==="additive"?r.buffers.color.setClear(0,0,0,1,a):E==="alpha-blend"&&r.buffers.color.setClear(0,0,0,0,a),(t.autoClear||_)&&(r.buffers.depth.setTest(!0),r.buffers.depth.setMask(!0),r.buffers.color.setMask(!0),t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil))}function y(w,_){const S=f(_);S&&(S.isCubeTexture||S.mapping===p0)?(c===void 0&&(c=new Cr(new bf(1,1,1),new ua({name:"BackgroundCubeMaterial",uniforms:$y(hl.backgroundCube.uniforms),vertexShader:hl.backgroundCube.vertexShader,fragmentShader:hl.backgroundCube.fragmentShader,side:sa,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(E,C,T){this.matrixWorld.copyPosition(T.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(c)),Uh.copy(_.backgroundRotation),Uh.x*=-1,Uh.y*=-1,Uh.z*=-1,S.isCubeTexture&&S.isRenderTargetTexture===!1&&(Uh.y*=-1,Uh.z*=-1),c.material.uniforms.envMap.value=S,c.material.uniforms.flipEnvMap.value=S.isCubeTexture&&S.isRenderTargetTexture===!1?-1:1,c.material.uniforms.backgroundBlurriness.value=_.backgroundBlurriness,c.material.uniforms.backgroundIntensity.value=_.backgroundIntensity,c.material.uniforms.backgroundRotation.value.setFromMatrix4(Lfe.makeRotationFromEuler(Uh)),c.material.toneMapped=Qn.getTransfer(S.colorSpace)!==yr,(d!==S||h!==S.version||p!==t.toneMapping)&&(c.material.needsUpdate=!0,d=S,h=S.version,p=t.toneMapping),c.layers.enableAll(),w.unshift(c,c.geometry,c.material,0,0,null)):S&&S.isTexture&&(u===void 0&&(u=new Cr(new yu(2,2),new ua({name:"BackgroundMaterial",uniforms:$y(hl.background.uniforms),vertexShader:hl.background.vertexShader,fragmentShader:hl.background.fragmentShader,side:lu,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),u.geometry.deleteAttribute("normal"),Object.defineProperty(u.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(u)),u.material.uniforms.t2D.value=S,u.material.uniforms.backgroundIntensity.value=_.backgroundIntensity,u.material.toneMapped=Qn.getTransfer(S.colorSpace)!==yr,S.matrixAutoUpdate===!0&&S.updateMatrix(),u.material.uniforms.uvTransform.value.copy(S.matrix),(d!==S||h!==S.version||p!==t.toneMapping)&&(u.material.needsUpdate=!0,d=S,h=S.version,p=t.toneMapping),u.layers.enableAll(),w.unshift(u,u.geometry,u.material,0,0,null))}function m(w,_){w.getRGB(sA,f9(t)),r.buffers.color.setClear(sA.r,sA.g,sA.b,_,a)}function b(){c!==void 0&&(c.geometry.dispose(),c.material.dispose(),c=void 0),u!==void 0&&(u.geometry.dispose(),u.material.dispose(),u=void 0)}return{getClearColor:function(){return o},setClearColor:function(w,_=1){o.set(w),l=_,m(o,l)},getClearAlpha:function(){return l},setClearAlpha:function(w){l=w,m(o,l)},render:g,addToRenderList:y,dispose:b}}function Bfe(t,e){const n=t.getParameter(t.MAX_VERTEX_ATTRIBS),r={},i=h(null);let s=i,a=!1;function o(k,R,N,B,z){let V=!1;const K=d(B,N,R);s!==K&&(s=K,u(s.object)),V=p(k,B,N,z),V&&f(k,B,N,z),z!==null&&e.update(z,t.ELEMENT_ARRAY_BUFFER),(V||a)&&(a=!1,_(k,R,N,B),z!==null&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e.get(z).buffer))}function l(){return t.createVertexArray()}function u(k){return t.bindVertexArray(k)}function c(k){return t.deleteVertexArray(k)}function d(k,R,N){const B=N.wireframe===!0;let z=r[k.id];z===void 0&&(z={},r[k.id]=z);let V=z[R.id];V===void 0&&(V={},z[R.id]=V);let K=V[B];return K===void 0&&(K=h(l()),V[B]=K),K}function h(k){const R=[],N=[],B=[];for(let z=0;z<n;z++)R[z]=0,N[z]=0,B[z]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:R,enabledAttributes:N,attributeDivisors:B,object:k,attributes:{},index:null}}function p(k,R,N,B){const z=s.attributes,V=R.attributes;let K=0;const Q=N.getAttributes();for(const O in Q)if(Q[O].location>=0){const X=z[O];let te=V[O];if(te===void 0&&(O==="instanceMatrix"&&k.instanceMatrix&&(te=k.instanceMatrix),O==="instanceColor"&&k.instanceColor&&(te=k.instanceColor)),X===void 0||X.attribute!==te||te&&X.data!==te.data)return!0;K++}return s.attributesNum!==K||s.index!==B}function f(k,R,N,B){const z={},V=R.attributes;let K=0;const Q=N.getAttributes();for(const O in Q)if(Q[O].location>=0){let X=V[O];X===void 0&&(O==="instanceMatrix"&&k.instanceMatrix&&(X=k.instanceMatrix),O==="instanceColor"&&k.instanceColor&&(X=k.instanceColor));const te={};te.attribute=X,X&&X.data&&(te.data=X.data),z[O]=te,K++}s.attributes=z,s.attributesNum=K,s.index=B}function g(){const k=s.newAttributes;for(let R=0,N=k.length;R<N;R++)k[R]=0}function y(k){m(k,0)}function m(k,R){const N=s.newAttributes,B=s.enabledAttributes,z=s.attributeDivisors;N[k]=1,B[k]===0&&(t.enableVertexAttribArray(k),B[k]=1),z[k]!==R&&(t.vertexAttribDivisor(k,R),z[k]=R)}function b(){const k=s.newAttributes,R=s.enabledAttributes;for(let N=0,B=R.length;N<B;N++)R[N]!==k[N]&&(t.disableVertexAttribArray(N),R[N]=0)}function w(k,R,N,B,z,V,K){K===!0?t.vertexAttribIPointer(k,R,N,z,V):t.vertexAttribPointer(k,R,N,B,z,V)}function _(k,R,N,B){g();const z=B.attributes,V=N.getAttributes(),K=R.defaultAttributeValues;for(const Q in V){const O=V[Q];if(O.location>=0){let j=z[Q];if(j===void 0&&(Q==="instanceMatrix"&&k.instanceMatrix&&(j=k.instanceMatrix),Q==="instanceColor"&&k.instanceColor&&(j=k.instanceColor)),j!==void 0){const X=j.normalized,te=j.itemSize,le=e.get(j);if(le===void 0)continue;const ge=le.buffer,ie=le.type,we=le.bytesPerElement,Ce=ie===t.INT||ie===t.UNSIGNED_INT||j.gpuType===z1;if(j.isInterleavedBufferAttribute){const Re=j.data,Le=Re.stride,lt=j.offset;if(Re.isInstancedInterleavedBuffer){for(let st=0;st<O.locationSize;st++)m(O.location+st,Re.meshPerAttribute);k.isInstancedMesh!==!0&&B._maxInstanceCount===void 0&&(B._maxInstanceCount=Re.meshPerAttribute*Re.count)}else for(let st=0;st<O.locationSize;st++)y(O.location+st);t.bindBuffer(t.ARRAY_BUFFER,ge);for(let st=0;st<O.locationSize;st++)w(O.location+st,te/O.locationSize,ie,X,Le*we,(lt+te/O.locationSize*st)*we,Ce)}else{if(j.isInstancedBufferAttribute){for(let Re=0;Re<O.locationSize;Re++)m(O.location+Re,j.meshPerAttribute);k.isInstancedMesh!==!0&&B._maxInstanceCount===void 0&&(B._maxInstanceCount=j.meshPerAttribute*j.count)}else for(let Re=0;Re<O.locationSize;Re++)y(O.location+Re);t.bindBuffer(t.ARRAY_BUFFER,ge);for(let Re=0;Re<O.locationSize;Re++)w(O.location+Re,te/O.locationSize,ie,X,te*we,te/O.locationSize*Re*we,Ce)}}else if(K!==void 0){const X=K[Q];if(X!==void 0)switch(X.length){case 2:t.vertexAttrib2fv(O.location,X);break;case 3:t.vertexAttrib3fv(O.location,X);break;case 4:t.vertexAttrib4fv(O.location,X);break;default:t.vertexAttrib1fv(O.location,X)}}}}b()}function S(){T();for(const k in r){const R=r[k];for(const N in R){const B=R[N];for(const z in B)c(B[z].object),delete B[z];delete R[N]}delete r[k]}}function E(k){if(r[k.id]===void 0)return;const R=r[k.id];for(const N in R){const B=R[N];for(const z in B)c(B[z].object),delete B[z];delete R[N]}delete r[k.id]}function C(k){for(const R in r){const N=r[R];if(N[k.id]===void 0)continue;const B=N[k.id];for(const z in B)c(B[z].object),delete B[z];delete N[k.id]}}function T(){M(),a=!0,s!==i&&(s=i,u(s.object))}function M(){i.geometry=null,i.program=null,i.wireframe=!1}return{setup:o,reset:T,resetDefaultState:M,dispose:S,releaseStatesOfGeometry:E,releaseStatesOfProgram:C,initAttributes:g,enableAttribute:y,disableUnusedAttributes:b}}function Ufe(t,e,n){let r;function i(u){r=u}function s(u,c){t.drawArrays(r,u,c),n.update(c,r,1)}function a(u,c,d){d!==0&&(t.drawArraysInstanced(r,u,c,d),n.update(c,r,d))}function o(u,c,d){if(d===0)return;e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r,u,0,c,0,d);let p=0;for(let f=0;f<d;f++)p+=c[f];n.update(p,r,1)}function l(u,c,d,h){if(d===0)return;const p=e.get("WEBGL_multi_draw");if(p===null)for(let f=0;f<u.length;f++)a(u[f],c[f],h[f]);else{p.multiDrawArraysInstancedWEBGL(r,u,0,c,0,h,0,d);let f=0;for(let g=0;g<d;g++)f+=c[g]*h[g];n.update(f,r,1)}}this.setMode=i,this.render=s,this.renderInstances=a,this.renderMultiDraw=o,this.renderMultiDrawInstances=l}function $fe(t,e,n,r){let i;function s(){if(i!==void 0)return i;if(e.has("EXT_texture_filter_anisotropic")===!0){const C=e.get("EXT_texture_filter_anisotropic");i=t.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function a(C){return!(C!==ui&&r.convert(C)!==t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT))}function o(C){const T=C===Wi&&(e.has("EXT_color_buffer_half_float")||e.has("EXT_color_buffer_float"));return!(C!==la&&r.convert(C)!==t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE)&&C!==ti&&!T)}function l(C){if(C==="highp"){if(t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.HIGH_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.HIGH_FLOAT).precision>0)return"highp";C="mediump"}return C==="mediump"&&t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.MEDIUM_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let u=n.precision!==void 0?n.precision:"highp";const c=l(u);c!==u&&(console.warn("THREE.WebGLRenderer:",u,"not supported, using",c,"instead."),u=c);const d=n.logarithmicDepthBuffer===!0,h=n.reverseDepthBuffer===!0&&e.has("EXT_clip_control"),p=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),f=t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),g=t.getParameter(t.MAX_TEXTURE_SIZE),y=t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),m=t.getParameter(t.MAX_VERTEX_ATTRIBS),b=t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),w=t.getParameter(t.MAX_VARYING_VECTORS),_=t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),S=f>0,E=t.getParameter(t.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:s,getMaxPrecision:l,textureFormatReadable:a,textureTypeReadable:o,precision:u,logarithmicDepthBuffer:d,reverseDepthBuffer:h,maxTextures:p,maxVertexTextures:f,maxTextureSize:g,maxCubemapSize:y,maxAttributes:m,maxVertexUniforms:b,maxVaryings:w,maxFragmentUniforms:_,vertexTextures:S,maxSamples:E}}function zfe(t){const e=this;let n=null,r=0,i=!1,s=!1;const a=new Bu,o=new Mn,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(d,h){const p=d.length!==0||h||r!==0||i;return i=h,r=d.length,p},this.beginShadows=function(){s=!0,c(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(d,h){n=c(d,h,0)},this.setState=function(d,h,p){const f=d.clippingPlanes,g=d.clipIntersection,y=d.clipShadows,m=t.get(d);if(!i||f===null||f.length===0||s&&!y)s?c(null):u();else{const b=s?0:r,w=b*4;let _=m.clippingState||null;l.value=_,_=c(f,h,w,p);for(let S=0;S!==w;++S)_[S]=n[S];m.clippingState=_,this.numIntersection=g?this.numPlanes:0,this.numPlanes+=b}};function u(){l.value!==n&&(l.value=n,l.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0}function c(d,h,p,f){const g=d!==null?d.length:0;let y=null;if(g!==0){if(y=l.value,f!==!0||y===null){const m=p+g*4,b=h.matrixWorldInverse;o.getNormalMatrix(b),(y===null||y.length<m)&&(y=new Float32Array(m));for(let w=0,_=p;w!==g;++w,_+=4)a.copy(d[w]).applyMatrix4(b,o),a.normal.toArray(y,_),y[_+3]=a.constant}l.value=y,l.needsUpdate=!0}return e.numPlanes=g,e.numIntersection=0,y}}function Gfe(t){let e=new WeakMap;function n(a,o){return o===Dy?a.mapping=uu:o===e1&&(a.mapping=Md),a}function r(a){if(a&&a.isTexture){const o=a.mapping;if(o===Dy||o===e1)if(e.has(a)){const l=e.get(a).texture;return n(l,a.mapping)}else{const l=a.image;if(l&&l.height>0){const u=new NP(l.height);return u.fromEquirectangularTexture(t,a),e.set(a,u),a.addEventListener("dispose",i),n(u.texture,a.mapping)}else return null}}return a}function i(a){const o=a.target;o.removeEventListener("dispose",i);const l=e.get(o);l!==void 0&&(e.delete(o),l.dispose())}function s(){e=new WeakMap}return{get:r,dispose:s}}const oy=4,iH=[.125,.215,.35,.446,.526,.582],np=20,Wk=new iu,sH=new Ct;let Vk=null,jk=0,Xk=0,Kk=!1;const Yh=(1+Math.sqrt(5))/2,Pg=1/Yh,aH=[new Z(-Yh,Pg,0),new Z(Yh,Pg,0),new Z(-Pg,0,Yh),new Z(Pg,0,Yh),new Z(0,Yh,-Pg),new Z(0,Yh,Pg),new Z(-1,1,-1),new Z(1,1,-1),new Z(-1,1,1),new Z(1,1,1)],Hfe=new Z;class qR{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,n=0,r=.1,i=100,s={}){const{size:a=256,position:o=Hfe}=s;Vk=this._renderer.getRenderTarget(),jk=this._renderer.getActiveCubeFace(),Xk=this._renderer.getActiveMipmapLevel(),Kk=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(a);const l=this._allocateTargets();return l.depthBuffer=!0,this._sceneToCubeUV(e,r,i,l,o),n>0&&this._blur(l,0,0,n),this._applyPMREM(l),this._cleanup(l),l}fromEquirectangular(e,n=null){return this._fromTexture(e,n)}fromCubemap(e,n=null){return this._fromTexture(e,n)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=uH(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=lH(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(Vk,jk,Xk),this._renderer.xr.enabled=Kk,e.scissorTest=!1,aA(e,0,0,e.width,e.height)}_fromTexture(e,n){e.mapping===uu||e.mapping===Md?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),Vk=this._renderer.getRenderTarget(),jk=this._renderer.getActiveCubeFace(),Xk=this._renderer.getActiveMipmapLevel(),Kk=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const r=n||this._allocateTargets();return this._textureToCubeUV(e,r),this._applyPMREM(r),this._cleanup(r),r}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),n=4*this._cubeSize,r={magFilter:er,minFilter:er,generateMipmaps:!1,type:Wi,format:ui,colorSpace:du,depthBuffer:!1},i=oH(e,n,r);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==n){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=oH(e,n,r);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=Wfe(s)),this._blurMaterial=Vfe(s,e,n)}return i}_compileMaterial(e){const n=new Cr(this._lodPlanes[0],e);this._renderer.compile(n,Wk)}_sceneToCubeUV(e,n,r,i,s){const l=new Qr(90,1,n,r),u=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],d=this._renderer,h=d.autoClear,p=d.toneMapping;d.getClearColor(sH),d.toneMapping=ru,d.autoClear=!1;const f=new ka({name:"PMREM.Background",side:sa,depthWrite:!1,depthTest:!1}),g=new Cr(new bf,f);let y=!1;const m=e.background;m?m.isColor&&(f.color.copy(m),e.background=null,y=!0):(f.color.copy(sH),y=!0);for(let b=0;b<6;b++){const w=b%3;w===0?(l.up.set(0,u[b],0),l.position.set(s.x,s.y,s.z),l.lookAt(s.x+c[b],s.y,s.z)):w===1?(l.up.set(0,0,u[b]),l.position.set(s.x,s.y,s.z),l.lookAt(s.x,s.y+c[b],s.z)):(l.up.set(0,u[b],0),l.position.set(s.x,s.y,s.z),l.lookAt(s.x,s.y,s.z+c[b]));const _=this._cubeSize;aA(i,w*_,b>2?_:0,_,_),d.setRenderTarget(i),y&&d.render(g,l),d.render(e,l)}g.geometry.dispose(),g.material.dispose(),d.toneMapping=p,d.autoClear=h,e.background=m}_textureToCubeUV(e,n){const r=this._renderer,i=e.mapping===uu||e.mapping===Md;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=uH()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=lH());const s=i?this._cubemapMaterial:this._equirectMaterial,a=new Cr(this._lodPlanes[0],s),o=s.uniforms;o.envMap.value=e;const l=this._cubeSize;aA(n,0,0,3*l,2*l),r.setRenderTarget(n),r.render(a,Wk)}_applyPMREM(e){const n=this._renderer,r=n.autoClear;n.autoClear=!1;const i=this._lodPlanes.length;for(let s=1;s<i;s++){const a=Math.sqrt(this._sigmas[s]*this._sigmas[s]-this._sigmas[s-1]*this._sigmas[s-1]),o=aH[(i-s-1)%aH.length];this._blur(e,s-1,s,a,o)}n.autoClear=r}_blur(e,n,r,i,s){const a=this._pingPongRenderTarget;this._halfBlur(e,a,n,r,i,"latitudinal",s),this._halfBlur(a,e,r,r,i,"longitudinal",s)}_halfBlur(e,n,r,i,s,a,o){const l=this._renderer,u=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const c=3,d=new Cr(this._lodPlanes[i],u),h=u.uniforms,p=this._sizeLods[r]-1,f=isFinite(s)?Math.PI/(2*p):2*Math.PI/(2*np-1),g=s/f,y=isFinite(s)?1+Math.floor(c*g):np;y>np&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${np}`);const m=[];let b=0;for(let C=0;C<np;++C){const T=C/g,M=Math.exp(-T*T/2);m.push(M),C===0?b+=M:C<y&&(b+=2*M)}for(let C=0;C<m.length;C++)m[C]=m[C]/b;h.envMap.value=e.texture,h.samples.value=y,h.weights.value=m,h.latitudinal.value=a==="latitudinal",o&&(h.poleAxis.value=o);const{_lodMax:w}=this;h.dTheta.value=f,h.mipInt.value=w-r;const _=this._sizeLods[i],S=3*_*(i>w-oy?i-w+oy:0),E=4*(this._cubeSize-_);aA(n,S,E,3*_,2*_),l.setRenderTarget(n),l.render(d,Wk)}}function Wfe(t){const e=[],n=[],r=[];let i=t;const s=t-oy+1+iH.length;for(let a=0;a<s;a++){const o=Math.pow(2,i);n.push(o);let l=1/o;a>t-oy?l=iH[a-t+oy-1]:a===0&&(l=0),r.push(l);const u=1/(o-2),c=-u,d=1+u,h=[c,c,d,c,d,d,c,c,d,d,c,d],p=6,f=6,g=3,y=2,m=1,b=new Float32Array(g*f*p),w=new Float32Array(y*f*p),_=new Float32Array(m*f*p);for(let E=0;E<p;E++){const C=E%3*2/3-1,T=E>2?0:-1,M=[C,T,0,C+2/3,T,0,C+2/3,T+1,0,C,T,0,C+2/3,T+1,0,C,T+1,0];b.set(M,g*f*E),w.set(h,y*f*E);const k=[E,E,E,E,E,E];_.set(k,m*f*E)}const S=new An;S.setAttribute("position",new Ln(b,g)),S.setAttribute("uv",new Ln(w,y)),S.setAttribute("faceIndex",new Ln(_,m)),e.push(S),i>oy&&i--}return{lodPlanes:e,sizeLods:n,sigmas:r}}function oH(t,e,n){const r=new Oa(t,e,n);return r.texture.mapping=p0,r.texture.name="PMREM.cubeUv",r.scissorTest=!0,r}function aA(t,e,n,r,i){t.viewport.set(e,n,r,i),t.scissor.set(e,n,r,i)}function Vfe(t,e,n){const r=new Float32Array(np),i=new Z(0,1,0);return new ua({name:"SphericalGaussianBlur",defines:{n:np,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${t}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:o3(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:nu,depthTest:!1,depthWrite:!1})}function lH(){return new ua({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:o3(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:nu,depthTest:!1,depthWrite:!1})}function uH(){return new ua({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:o3(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:nu,depthTest:!1,depthWrite:!1})}function o3(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function jfe(t){let e=new WeakMap,n=null;function r(o){if(o&&o.isTexture){const l=o.mapping,u=l===Dy||l===e1,c=l===uu||l===Md;if(u||c){let d=e.get(o);const h=d!==void 0?d.texture.pmremVersion:0;if(o.isRenderTargetTexture&&o.pmremVersion!==h)return n===null&&(n=new qR(t)),d=u?n.fromEquirectangular(o,d):n.fromCubemap(o,d),d.texture.pmremVersion=o.pmremVersion,e.set(o,d),d.texture;if(d!==void 0)return d.texture;{const p=o.image;return u&&p&&p.height>0||c&&p&&i(p)?(n===null&&(n=new qR(t)),d=u?n.fromEquirectangular(o):n.fromCubemap(o),d.texture.pmremVersion=o.pmremVersion,e.set(o,d),o.addEventListener("dispose",s),d.texture):null}}}return o}function i(o){let l=0;const u=6;for(let c=0;c<u;c++)o[c]!==void 0&&l++;return l===u}function s(o){const l=o.target;l.removeEventListener("dispose",s);const u=e.get(l);u!==void 0&&(e.delete(l),u.dispose())}function a(){e=new WeakMap,n!==null&&(n.dispose(),n=null)}return{get:r,dispose:a}}function Xfe(t){const e={};function n(r){if(e[r]!==void 0)return e[r];let i;switch(r){case"WEBGL_depth_texture":i=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=t.getExtension(r)}return e[r]=i,i}return{has:function(r){return n(r)!==null},init:function(){n("EXT_color_buffer_float"),n("WEBGL_clip_cull_distance"),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture"),n("WEBGL_render_shared_exponent")},get:function(r){const i=n(r);return i===null&&gy("THREE.WebGLRenderer: "+r+" extension not supported."),i}}}function Kfe(t,e,n,r){const i={},s=new WeakMap;function a(d){const h=d.target;h.index!==null&&e.remove(h.index);for(const f in h.attributes)e.remove(h.attributes[f]);h.removeEventListener("dispose",a),delete i[h.id];const p=s.get(h);p&&(e.remove(p),s.delete(h)),r.releaseStatesOfGeometry(h),h.isInstancedBufferGeometry===!0&&delete h._maxInstanceCount,n.memory.geometries--}function o(d,h){return i[h.id]===!0||(h.addEventListener("dispose",a),i[h.id]=!0,n.memory.geometries++),h}function l(d){const h=d.attributes;for(const p in h)e.update(h[p],t.ARRAY_BUFFER)}function u(d){const h=[],p=d.index,f=d.attributes.position;let g=0;if(p!==null){const b=p.array;g=p.version;for(let w=0,_=b.length;w<_;w+=3){const S=b[w+0],E=b[w+1],C=b[w+2];h.push(S,E,E,C,C,S)}}else if(f!==void 0){const b=f.array;g=f.version;for(let w=0,_=b.length/3-1;w<_;w+=3){const S=w+0,E=w+1,C=w+2;h.push(S,E,E,C,C,S)}}else return;const y=new(d9(h)?MP:CP)(h,1);y.version=g;const m=s.get(d);m&&e.remove(m),s.set(d,y)}function c(d){const h=s.get(d);if(h){const p=d.index;p!==null&&h.version<p.version&&u(d)}else u(d);return s.get(d)}return{get:o,update:l,getWireframeAttribute:c}}function qfe(t,e,n){let r;function i(h){r=h}let s,a;function o(h){s=h.type,a=h.bytesPerElement}function l(h,p){t.drawElements(r,p,s,h*a),n.update(p,r,1)}function u(h,p,f){f!==0&&(t.drawElementsInstanced(r,p,s,h*a,f),n.update(p,r,f))}function c(h,p,f){if(f===0)return;e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r,p,0,s,h,0,f);let y=0;for(let m=0;m<f;m++)y+=p[m];n.update(y,r,1)}function d(h,p,f,g){if(f===0)return;const y=e.get("WEBGL_multi_draw");if(y===null)for(let m=0;m<h.length;m++)u(h[m]/a,p[m],g[m]);else{y.multiDrawElementsInstancedWEBGL(r,p,0,s,h,0,g,0,f);let m=0;for(let b=0;b<f;b++)m+=p[b]*g[b];n.update(m,r,1)}}this.setMode=i,this.setIndex=o,this.render=l,this.renderInstances=u,this.renderMultiDraw=c,this.renderMultiDrawInstances=d}function Jfe(t){const e={geometries:0,textures:0},n={frame:0,calls:0,triangles:0,points:0,lines:0};function r(s,a,o){switch(n.calls++,a){case t.TRIANGLES:n.triangles+=o*(s/3);break;case t.LINES:n.lines+=o*(s/2);break;case t.LINE_STRIP:n.lines+=o*(s-1);break;case t.LINE_LOOP:n.lines+=o*s;break;case t.POINTS:n.points+=o*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function i(){n.calls=0,n.triangles=0,n.points=0,n.lines=0}return{memory:e,render:n,programs:null,autoReset:!0,reset:i,update:r}}function Yfe(t,e,n){const r=new WeakMap,i=new Xn;function s(a,o,l){const u=a.morphTargetInfluences,c=o.morphAttributes.position||o.morphAttributes.normal||o.morphAttributes.color,d=c!==void 0?c.length:0;let h=r.get(o);if(h===void 0||h.count!==d){let k=function(){T.dispose(),r.delete(o),o.removeEventListener("dispose",k)};var p=k;h!==void 0&&h.texture.dispose();const f=o.morphAttributes.position!==void 0,g=o.morphAttributes.normal!==void 0,y=o.morphAttributes.color!==void 0,m=o.morphAttributes.position||[],b=o.morphAttributes.normal||[],w=o.morphAttributes.color||[];let _=0;f===!0&&(_=1),g===!0&&(_=2),y===!0&&(_=3);let S=o.attributes.position.count*_,E=1;S>e.maxTextureSize&&(E=Math.ceil(S/e.maxTextureSize),S=e.maxTextureSize);const C=new Float32Array(S*E*4*d),T=new MT(C,S,E,d);T.type=ti,T.needsUpdate=!0;const M=_*4;for(let R=0;R<d;R++){const N=m[R],B=b[R],z=w[R],V=S*E*4*R;for(let K=0;K<N.count;K++){const Q=K*M;f===!0&&(i.fromBufferAttribute(N,K),C[V+Q+0]=i.x,C[V+Q+1]=i.y,C[V+Q+2]=i.z,C[V+Q+3]=0),g===!0&&(i.fromBufferAttribute(B,K),C[V+Q+4]=i.x,C[V+Q+5]=i.y,C[V+Q+6]=i.z,C[V+Q+7]=0),y===!0&&(i.fromBufferAttribute(z,K),C[V+Q+8]=i.x,C[V+Q+9]=i.y,C[V+Q+10]=i.z,C[V+Q+11]=z.itemSize===4?i.w:1)}}h={count:d,texture:T,size:new Qe(S,E)},r.set(o,h),o.addEventListener("dispose",k)}if(a.isInstancedMesh===!0&&a.morphTexture!==null)l.getUniforms().setValue(t,"morphTexture",a.morphTexture,n);else{let f=0;for(let y=0;y<u.length;y++)f+=u[y];const g=o.morphTargetsRelative?1:1-f;l.getUniforms().setValue(t,"morphTargetBaseInfluence",g),l.getUniforms().setValue(t,"morphTargetInfluences",u)}l.getUniforms().setValue(t,"morphTargetsTexture",h.texture,n),l.getUniforms().setValue(t,"morphTargetsTextureSize",h.size)}return{update:s}}function Zfe(t,e,n,r){let i=new WeakMap;function s(l){const u=r.render.frame,c=l.geometry,d=e.get(l,c);if(i.get(d)!==u&&(e.update(d),i.set(d,u)),l.isInstancedMesh&&(l.hasEventListener("dispose",o)===!1&&l.addEventListener("dispose",o),i.get(l)!==u&&(n.update(l.instanceMatrix,t.ARRAY_BUFFER),l.instanceColor!==null&&n.update(l.instanceColor,t.ARRAY_BUFFER),i.set(l,u))),l.isSkinnedMesh){const h=l.skeleton;i.get(h)!==u&&(h.update(),i.set(h,u))}return d}function a(){i=new WeakMap}function o(l){const u=l.target;u.removeEventListener("dispose",o),n.remove(u.instanceMatrix),u.instanceColor!==null&&n.remove(u.instanceColor)}return{update:s,dispose:a}}const sX=new hr,cH=new OP(1,1),aX=new MT,oX=new kT,lX=new V1,dH=[],hH=[],pH=new Float32Array(16),fH=new Float32Array(9),mH=new Float32Array(4);function g0(t,e,n){const r=t[0];if(r<=0||r>0)return t;const i=e*n;let s=dH[i];if(s===void 0&&(s=new Float32Array(i),dH[i]=s),e!==0){r.toArray(s,0);for(let a=1,o=0;a!==e;++a)o+=n,t[a].toArray(s,o)}return s}function Ji(t,e){if(t.length!==e.length)return!1;for(let n=0,r=t.length;n<r;n++)if(t[n]!==e[n])return!1;return!0}function Yi(t,e){for(let n=0,r=e.length;n<r;n++)t[n]=e[n]}function ZT(t,e){let n=hH[e];n===void 0&&(n=new Int32Array(e),hH[e]=n);for(let r=0;r!==e;++r)n[r]=t.allocateTextureUnit();return n}function Qfe(t,e){const n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}function eme(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y)&&(t.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Ji(n,e))return;t.uniform2fv(this.addr,e),Yi(n,e)}}function tme(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z)&&(t.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(e.r!==void 0)(n[0]!==e.r||n[1]!==e.g||n[2]!==e.b)&&(t.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(Ji(n,e))return;t.uniform3fv(this.addr,e),Yi(n,e)}}function nme(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z||n[3]!==e.w)&&(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Ji(n,e))return;t.uniform4fv(this.addr,e),Yi(n,e)}}function rme(t,e){const n=this.cache,r=e.elements;if(r===void 0){if(Ji(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),Yi(n,e)}else{if(Ji(n,r))return;mH.set(r),t.uniformMatrix2fv(this.addr,!1,mH),Yi(n,r)}}function ime(t,e){const n=this.cache,r=e.elements;if(r===void 0){if(Ji(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),Yi(n,e)}else{if(Ji(n,r))return;fH.set(r),t.uniformMatrix3fv(this.addr,!1,fH),Yi(n,r)}}function sme(t,e){const n=this.cache,r=e.elements;if(r===void 0){if(Ji(n,e))return;t.uniformMatrix4fv(this.addr,!1,e),Yi(n,e)}else{if(Ji(n,r))return;pH.set(r),t.uniformMatrix4fv(this.addr,!1,pH),Yi(n,r)}}function ame(t,e){const n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function ome(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y)&&(t.uniform2i(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Ji(n,e))return;t.uniform2iv(this.addr,e),Yi(n,e)}}function lme(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z)&&(t.uniform3i(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else{if(Ji(n,e))return;t.uniform3iv(this.addr,e),Yi(n,e)}}function ume(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z||n[3]!==e.w)&&(t.uniform4i(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Ji(n,e))return;t.uniform4iv(this.addr,e),Yi(n,e)}}function cme(t,e){const n=this.cache;n[0]!==e&&(t.uniform1ui(this.addr,e),n[0]=e)}function dme(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y)&&(t.uniform2ui(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Ji(n,e))return;t.uniform2uiv(this.addr,e),Yi(n,e)}}function hme(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z)&&(t.uniform3ui(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else{if(Ji(n,e))return;t.uniform3uiv(this.addr,e),Yi(n,e)}}function pme(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z||n[3]!==e.w)&&(t.uniform4ui(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Ji(n,e))return;t.uniform4uiv(this.addr,e),Yi(n,e)}}function fme(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i);let s;this.type===t.SAMPLER_2D_SHADOW?(cH.compareFunction=AP,s=cH):s=sX,n.setTexture2D(e||s,i)}function mme(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.setTexture3D(e||oX,i)}function gme(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.setTextureCube(e||lX,i)}function yme(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.setTexture2DArray(e||aX,i)}function vme(t){switch(t){case 5126:return Qfe;case 35664:return eme;case 35665:return tme;case 35666:return nme;case 35674:return rme;case 35675:return ime;case 35676:return sme;case 5124:case 35670:return ame;case 35667:case 35671:return ome;case 35668:case 35672:return lme;case 35669:case 35673:return ume;case 5125:return cme;case 36294:return dme;case 36295:return hme;case 36296:return pme;case 35678:case 36198:case 36298:case 36306:case 35682:return fme;case 35679:case 36299:case 36307:return mme;case 35680:case 36300:case 36308:case 36293:return gme;case 36289:case 36303:case 36311:case 36292:return yme}}function xme(t,e){t.uniform1fv(this.addr,e)}function bme(t,e){const n=g0(e,this.size,2);t.uniform2fv(this.addr,n)}function wme(t,e){const n=g0(e,this.size,3);t.uniform3fv(this.addr,n)}function _me(t,e){const n=g0(e,this.size,4);t.uniform4fv(this.addr,n)}function Sme(t,e){const n=g0(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function Ame(t,e){const n=g0(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}function Eme(t,e){const n=g0(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,n)}function Ime(t,e){t.uniform1iv(this.addr,e)}function Tme(t,e){t.uniform2iv(this.addr,e)}function Cme(t,e){t.uniform3iv(this.addr,e)}function Mme(t,e){t.uniform4iv(this.addr,e)}function kme(t,e){t.uniform1uiv(this.addr,e)}function Nme(t,e){t.uniform2uiv(this.addr,e)}function Rme(t,e){t.uniform3uiv(this.addr,e)}function Fme(t,e){t.uniform4uiv(this.addr,e)}function Dme(t,e,n){const r=this.cache,i=e.length,s=ZT(n,i);Ji(r,s)||(t.uniform1iv(this.addr,s),Yi(r,s));for(let a=0;a!==i;++a)n.setTexture2D(e[a]||sX,s[a])}function Pme(t,e,n){const r=this.cache,i=e.length,s=ZT(n,i);Ji(r,s)||(t.uniform1iv(this.addr,s),Yi(r,s));for(let a=0;a!==i;++a)n.setTexture3D(e[a]||oX,s[a])}function Lme(t,e,n){const r=this.cache,i=e.length,s=ZT(n,i);Ji(r,s)||(t.uniform1iv(this.addr,s),Yi(r,s));for(let a=0;a!==i;++a)n.setTextureCube(e[a]||lX,s[a])}function Ome(t,e,n){const r=this.cache,i=e.length,s=ZT(n,i);Ji(r,s)||(t.uniform1iv(this.addr,s),Yi(r,s));for(let a=0;a!==i;++a)n.setTexture2DArray(e[a]||aX,s[a])}function Bme(t){switch(t){case 5126:return xme;case 35664:return bme;case 35665:return wme;case 35666:return _me;case 35674:return Sme;case 35675:return Ame;case 35676:return Eme;case 5124:case 35670:return Ime;case 35667:case 35671:return Tme;case 35668:case 35672:return Cme;case 35669:case 35673:return Mme;case 5125:return kme;case 36294:return Nme;case 36295:return Rme;case 36296:return Fme;case 35678:case 36198:case 36298:case 36306:case 35682:return Dme;case 35679:case 36299:case 36307:return Pme;case 35680:case 36300:case 36308:case 36293:return Lme;case 36289:case 36303:case 36311:case 36292:return Ome}}class Ume{constructor(e,n,r){this.id=e,this.addr=r,this.cache=[],this.type=n.type,this.setValue=vme(n.type)}}class $me{constructor(e,n,r){this.id=e,this.addr=r,this.cache=[],this.type=n.type,this.size=n.size,this.setValue=Bme(n.type)}}class zme{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,n,r){const i=this.seq;for(let s=0,a=i.length;s!==a;++s){const o=i[s];o.setValue(e,n[o.id],r)}}}const qk=/(\w+)(\])?(\[|\.)?/g;function gH(t,e){t.seq.push(e),t.map[e.id]=e}function Gme(t,e,n){const r=t.name,i=r.length;for(qk.lastIndex=0;;){const s=qk.exec(r),a=qk.lastIndex;let o=s[1];const l=s[2]==="]",u=s[3];if(l&&(o=o|0),u===void 0||u==="["&&a+2===i){gH(n,u===void 0?new Ume(o,t,e):new $me(o,t,e));break}else{let d=n.map[o];d===void 0&&(d=new zme(o),gH(n,d)),n=d}}}class qA{constructor(e,n){this.seq=[],this.map={};const r=e.getProgramParameter(n,e.ACTIVE_UNIFORMS);for(let i=0;i<r;++i){const s=e.getActiveUniform(n,i),a=e.getUniformLocation(n,s.name);Gme(s,a,this)}}setValue(e,n,r,i){const s=this.map[n];s!==void 0&&s.setValue(e,r,i)}setOptional(e,n,r){const i=n[r];i!==void 0&&this.setValue(e,r,i)}static upload(e,n,r,i){for(let s=0,a=n.length;s!==a;++s){const o=n[s],l=r[o.id];l.needsUpdate!==!1&&o.setValue(e,l.value,i)}}static seqWithValue(e,n){const r=[];for(let i=0,s=e.length;i!==s;++i){const a=e[i];a.id in n&&r.push(a)}return r}}function yH(t,e,n){const r=t.createShader(e);return t.shaderSource(r,n),t.compileShader(r),r}const Hme=37297;let Wme=0;function Vme(t,e){const n=t.split(`
`),r=[],i=Math.max(e-6,0),s=Math.min(e+6,n.length);for(let a=i;a<s;a++){const o=a+1;r.push(`${o===e?">":" "} ${o}: ${n[a]}`)}return r.join(`
`)}const vH=new Mn;function jme(t){Qn._getMatrix(vH,Qn.workingColorSpace,t);const e=`mat3( ${vH.elements.map(n=>n.toFixed(4))} )`;switch(Qn.getTransfer(t)){case n1:return[e,"LinearTransferOETF"];case yr:return[e,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space: ",t),[e,"LinearTransferOETF"]}}function xH(t,e,n){const r=t.getShaderParameter(e,t.COMPILE_STATUS),i=t.getShaderInfoLog(e).trim();if(r&&i==="")return"";const s=/ERROR: 0:(\d+)/.exec(i);if(s){const a=parseInt(s[1]);return n.toUpperCase()+`

`+i+`

`+Vme(t.getShaderSource(e),a)}else return i}function Xme(t,e){const n=jme(e);return[`vec4 ${t}( vec4 value ) {`,`	return ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`,"}"].join(`
`)}function Kme(t,e){let n;switch(e){case Wj:n="Linear";break;case Vj:n="Reinhard";break;case jj:n="Cineon";break;case gP:n="ACESFilmic";break;case Kj:n="AgX";break;case qj:n="Neutral";break;case Xj:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+t+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}const oA=new Z;function qme(){Qn.getLuminanceCoefficients(oA);const t=oA.x.toFixed(4),e=oA.y.toFixed(4),n=oA.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${t}, ${e}, ${n} );`,"	return dot( weights, rgb );","}"].join(`
`)}function Jme(t){return[t.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",t.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(Yx).join(`
`)}function Yme(t){const e=[];for(const n in t){const r=t[n];r!==!1&&e.push("#define "+n+" "+r)}return e.join(`
`)}function Zme(t,e){const n={},r=t.getProgramParameter(e,t.ACTIVE_ATTRIBUTES);for(let i=0;i<r;i++){const s=t.getActiveAttrib(e,i),a=s.name;let o=1;s.type===t.FLOAT_MAT2&&(o=2),s.type===t.FLOAT_MAT3&&(o=3),s.type===t.FLOAT_MAT4&&(o=4),n[a]={type:s.type,location:t.getAttribLocation(e,a),locationSize:o}}return n}function Yx(t){return t!==""}function bH(t,e){const n=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,n).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function wH(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Qme=/^[ \t]*#include +<([\w\d./]+)>/gm;function JR(t){return t.replace(Qme,tge)}const ege=new Map;function tge(t,e){let n=Dn[e];if(n===void 0){const r=ege.get(e);if(r!==void 0)n=Dn[r],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,r);else throw new Error("Can not resolve #include <"+e+">")}return JR(n)}const nge=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function _H(t){return t.replace(nge,rge)}function rge(t,e,n,r){let i="";for(let s=parseInt(e);s<parseInt(n);s++)i+=r.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return i}function SH(t){let e=`precision ${t.precision} float;
	precision ${t.precision} int;
	precision ${t.precision} sampler2D;
	precision ${t.precision} samplerCube;
	precision ${t.precision} sampler3D;
	precision ${t.precision} sampler2DArray;
	precision ${t.precision} sampler2DShadow;
	precision ${t.precision} samplerCubeShadow;
	precision ${t.precision} sampler2DArrayShadow;
	precision ${t.precision} isampler2D;
	precision ${t.precision} isampler3D;
	precision ${t.precision} isamplerCube;
	precision ${t.precision} isampler2DArray;
	precision ${t.precision} usampler2D;
	precision ${t.precision} usampler3D;
	precision ${t.precision} usamplerCube;
	precision ${t.precision} usampler2DArray;
	`;return t.precision==="highp"?e+=`
#define HIGH_PRECISION`:t.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:t.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function ige(t){let e="SHADOWMAP_TYPE_BASIC";return t.shadowMapType===wT?e="SHADOWMAP_TYPE_PCF":t.shadowMapType===vb?e="SHADOWMAP_TYPE_PCF_SOFT":t.shadowMapType===ul&&(e="SHADOWMAP_TYPE_VSM"),e}function sge(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case uu:case Md:e="ENVMAP_TYPE_CUBE";break;case p0:e="ENVMAP_TYPE_CUBE_UV";break}return e}function age(t){let e="ENVMAP_MODE_REFLECTION";if(t.envMap)switch(t.envMapMode){case Md:e="ENVMAP_MODE_REFRACTION";break}return e}function oge(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case U1:e="ENVMAP_BLENDING_MULTIPLY";break;case Gj:e="ENVMAP_BLENDING_MIX";break;case Hj:e="ENVMAP_BLENDING_ADD";break}return e}function lge(t){const e=t.envMapCubeUVHeight;if(e===null)return null;const n=Math.log2(e)-2,r=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,n),7*16)),texelHeight:r,maxMip:n}}function uge(t,e,n,r){const i=t.getContext(),s=n.defines;let a=n.vertexShader,o=n.fragmentShader;const l=ige(n),u=sge(n),c=age(n),d=oge(n),h=lge(n),p=Jme(n),f=Yme(s),g=i.createProgram();let y,m,b=n.glslVersion?"#version "+n.glslVersion+`
`:"";n.isRawShaderMaterial?(y=["#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,f].filter(Yx).join(`
`),y.length>0&&(y+=`
`),m=["#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,f].filter(Yx).join(`
`),m.length>0&&(m+=`
`)):(y=[SH(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,f,n.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",n.batching?"#define USE_BATCHING":"",n.batchingColor?"#define USE_BATCHING_COLOR":"",n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.instancingMorph?"#define USE_INSTANCING_MORPH":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.displacementMap?"#define USE_DISPLACEMENTMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.mapUv?"#define MAP_UV "+n.mapUv:"",n.alphaMapUv?"#define ALPHAMAP_UV "+n.alphaMapUv:"",n.lightMapUv?"#define LIGHTMAP_UV "+n.lightMapUv:"",n.aoMapUv?"#define AOMAP_UV "+n.aoMapUv:"",n.emissiveMapUv?"#define EMISSIVEMAP_UV "+n.emissiveMapUv:"",n.bumpMapUv?"#define BUMPMAP_UV "+n.bumpMapUv:"",n.normalMapUv?"#define NORMALMAP_UV "+n.normalMapUv:"",n.displacementMapUv?"#define DISPLACEMENTMAP_UV "+n.displacementMapUv:"",n.metalnessMapUv?"#define METALNESSMAP_UV "+n.metalnessMapUv:"",n.roughnessMapUv?"#define ROUGHNESSMAP_UV "+n.roughnessMapUv:"",n.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+n.anisotropyMapUv:"",n.clearcoatMapUv?"#define CLEARCOATMAP_UV "+n.clearcoatMapUv:"",n.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+n.clearcoatNormalMapUv:"",n.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+n.clearcoatRoughnessMapUv:"",n.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+n.iridescenceMapUv:"",n.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+n.iridescenceThicknessMapUv:"",n.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+n.sheenColorMapUv:"",n.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+n.sheenRoughnessMapUv:"",n.specularMapUv?"#define SPECULARMAP_UV "+n.specularMapUv:"",n.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+n.specularColorMapUv:"",n.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+n.specularIntensityMapUv:"",n.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+n.transmissionMapUv:"",n.thicknessMapUv?"#define THICKNESSMAP_UV "+n.thicknessMapUv:"",n.vertexTangents&&n.flatShading===!1?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&n.flatShading===!1?"#define USE_MORPHNORMALS":"",n.morphColors?"#define USE_MORPHCOLORS":"",n.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Yx).join(`
`),m=[SH(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,f,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+u:"",n.envMap?"#define "+c:"",n.envMap?"#define "+d:"",h?"#define CUBEUV_TEXEL_WIDTH "+h.texelWidth:"",h?"#define CUBEUV_TEXEL_HEIGHT "+h.texelHeight:"",h?"#define CUBEUV_MAX_MIP "+h.maxMip+".0":"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.dispersion?"#define USE_DISPERSION":"",n.iridescence?"#define USE_IRIDESCENCE":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.vertexTangents&&n.flatShading===!1?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor||n.batchingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",n.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==ru?"#define TONE_MAPPING":"",n.toneMapping!==ru?Dn.tonemapping_pars_fragment:"",n.toneMapping!==ru?Kme("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque?"#define OPAQUE":"",Dn.colorspace_pars_fragment,Xme("linearToOutputTexel",n.outputColorSpace),qme(),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"",`
`].filter(Yx).join(`
`)),a=JR(a),a=bH(a,n),a=wH(a,n),o=JR(o),o=bH(o,n),o=wH(o,n),a=_H(a),o=_H(o),n.isRawShaderMaterial!==!0&&(b=`#version 300 es
`,y=[p,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+y,m=["#define varying in",n.glslVersion===GR?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===GR?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+m);const w=b+y+a,_=b+m+o,S=yH(i,i.VERTEX_SHADER,w),E=yH(i,i.FRAGMENT_SHADER,_);i.attachShader(g,S),i.attachShader(g,E),n.index0AttributeName!==void 0?i.bindAttribLocation(g,0,n.index0AttributeName):n.morphTargets===!0&&i.bindAttribLocation(g,0,"position"),i.linkProgram(g);function C(R){if(t.debug.checkShaderErrors){const N=i.getProgramInfoLog(g).trim(),B=i.getShaderInfoLog(S).trim(),z=i.getShaderInfoLog(E).trim();let V=!0,K=!0;if(i.getProgramParameter(g,i.LINK_STATUS)===!1)if(V=!1,typeof t.debug.onShaderError=="function")t.debug.onShaderError(i,g,S,E);else{const Q=xH(i,S,"vertex"),O=xH(i,E,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(g,i.VALIDATE_STATUS)+`

Material Name: `+R.name+`
Material Type: `+R.type+`

Program Info Log: `+N+`
`+Q+`
`+O)}else N!==""?console.warn("THREE.WebGLProgram: Program Info Log:",N):(B===""||z==="")&&(K=!1);K&&(R.diagnostics={runnable:V,programLog:N,vertexShader:{log:B,prefix:y},fragmentShader:{log:z,prefix:m}})}i.deleteShader(S),i.deleteShader(E),T=new qA(i,g),M=Zme(i,g)}let T;this.getUniforms=function(){return T===void 0&&C(this),T};let M;this.getAttributes=function(){return M===void 0&&C(this),M};let k=n.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return k===!1&&(k=i.getProgramParameter(g,Hme)),k},this.destroy=function(){r.releaseStatesOfProgram(this),i.deleteProgram(g),this.program=void 0},this.type=n.shaderType,this.name=n.shaderName,this.id=Wme++,this.cacheKey=e,this.usedTimes=1,this.program=g,this.vertexShader=S,this.fragmentShader=E,this}let cge=0;class dge{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const n=e.vertexShader,r=e.fragmentShader,i=this._getShaderStage(n),s=this._getShaderStage(r),a=this._getShaderCacheForMaterial(e);return a.has(i)===!1&&(a.add(i),i.usedTimes++),a.has(s)===!1&&(a.add(s),s.usedTimes++),this}remove(e){const n=this.materialCache.get(e);for(const r of n)r.usedTimes--,r.usedTimes===0&&this.shaderCache.delete(r.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const n=this.materialCache;let r=n.get(e);return r===void 0&&(r=new Set,n.set(e,r)),r}_getShaderStage(e){const n=this.shaderCache;let r=n.get(e);return r===void 0&&(r=new hge(e),n.set(e,r)),r}}class hge{constructor(e){this.id=cge++,this.code=e,this.usedTimes=0}}function pge(t,e,n,r,i,s,a){const o=new Ip,l=new dge,u=new Set,c=[],d=i.logarithmicDepthBuffer,h=i.vertexTextures;let p=i.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function g(M){return u.add(M),M===0?"uv":`uv${M}`}function y(M,k,R,N,B){const z=N.fog,V=B.geometry,K=M.isMeshStandardMaterial?N.environment:null,Q=(M.isMeshStandardMaterial?n:e).get(M.envMap||K),O=Q&&Q.mapping===p0?Q.image.height:null,j=f[M.type];M.precision!==null&&(p=i.getMaxPrecision(M.precision),p!==M.precision&&console.warn("THREE.WebGLProgram.getParameters:",M.precision,"not supported, using",p,"instead."));const X=V.morphAttributes.position||V.morphAttributes.normal||V.morphAttributes.color,te=X!==void 0?X.length:0;let le=0;V.morphAttributes.position!==void 0&&(le=1),V.morphAttributes.normal!==void 0&&(le=2),V.morphAttributes.color!==void 0&&(le=3);let ge,ie,we,Ce;if(j){const pt=hl[j];ge=pt.vertexShader,ie=pt.fragmentShader}else ge=M.vertexShader,ie=M.fragmentShader,l.update(M),we=l.getVertexShaderID(M),Ce=l.getFragmentShaderID(M);const Re=t.getRenderTarget(),Le=t.state.buffers.depth.getReversed(),lt=B.isInstancedMesh===!0,st=B.isBatchedMesh===!0,Et=!!M.map,Tt=!!M.matcap,xt=!!Q,J=!!M.aoMap,Ye=!!M.lightMap,Be=!!M.bumpMap,tt=!!M.normalMap,Ue=!!M.displacementMap,St=!!M.emissiveMap,Je=!!M.metalnessMap,At=!!M.roughnessMap,Vt=M.anisotropy>0,re=M.clearcoat>0,H=M.dispersion>0,Ee=M.iridescence>0,Oe=M.sheen>0,Xe=M.transmission>0,$e=Vt&&!!M.anisotropyMap,Lt=re&&!!M.clearcoatMap,wt=re&&!!M.clearcoatNormalMap,Pt=re&&!!M.clearcoatRoughnessMap,Ht=Ee&&!!M.iridescenceMap,et=Ee&&!!M.iridescenceThicknessMap,mt=Oe&&!!M.sheenColorMap,Ot=Oe&&!!M.sheenRoughnessMap,he=!!M.specularMap,Me=!!M.specularColorMap,it=!!M.specularIntensityMap,de=Xe&&!!M.transmissionMap,Ne=Xe&&!!M.thicknessMap,nt=!!M.gradientMap,Mt=!!M.alphaMap,ut=M.alphaTest>0,Ze=!!M.alphaHash,kt=!!M.extensions;let Se=ru;M.toneMapped&&(Re===null||Re.isXRRenderTarget===!0)&&(Se=t.toneMapping);const qe={shaderID:j,shaderType:M.type,shaderName:M.name,vertexShader:ge,fragmentShader:ie,defines:M.defines,customVertexShaderID:we,customFragmentShaderID:Ce,isRawShaderMaterial:M.isRawShaderMaterial===!0,glslVersion:M.glslVersion,precision:p,batching:st,batchingColor:st&&B._colorsTexture!==null,instancing:lt,instancingColor:lt&&B.instanceColor!==null,instancingMorph:lt&&B.morphTexture!==null,supportsVertexTextures:h,outputColorSpace:Re===null?t.outputColorSpace:Re.isXRRenderTarget===!0?Re.texture.colorSpace:du,alphaToCoverage:!!M.alphaToCoverage,map:Et,matcap:Tt,envMap:xt,envMapMode:xt&&Q.mapping,envMapCubeUVHeight:O,aoMap:J,lightMap:Ye,bumpMap:Be,normalMap:tt,displacementMap:h&&Ue,emissiveMap:St,normalMapObjectSpace:tt&&M.normalMapType===r9,normalMapTangentSpace:tt&&M.normalMapType===Jd,metalnessMap:Je,roughnessMap:At,anisotropy:Vt,anisotropyMap:$e,clearcoat:re,clearcoatMap:Lt,clearcoatNormalMap:wt,clearcoatRoughnessMap:Pt,dispersion:H,iridescence:Ee,iridescenceMap:Ht,iridescenceThicknessMap:et,sheen:Oe,sheenColorMap:mt,sheenRoughnessMap:Ot,specularMap:he,specularColorMap:Me,specularIntensityMap:it,transmission:Xe,transmissionMap:de,thicknessMap:Ne,gradientMap:nt,opaque:M.transparent===!1&&M.blending===Sp&&M.alphaToCoverage===!1,alphaMap:Mt,alphaTest:ut,alphaHash:Ze,combine:M.combine,mapUv:Et&&g(M.map.channel),aoMapUv:J&&g(M.aoMap.channel),lightMapUv:Ye&&g(M.lightMap.channel),bumpMapUv:Be&&g(M.bumpMap.channel),normalMapUv:tt&&g(M.normalMap.channel),displacementMapUv:Ue&&g(M.displacementMap.channel),emissiveMapUv:St&&g(M.emissiveMap.channel),metalnessMapUv:Je&&g(M.metalnessMap.channel),roughnessMapUv:At&&g(M.roughnessMap.channel),anisotropyMapUv:$e&&g(M.anisotropyMap.channel),clearcoatMapUv:Lt&&g(M.clearcoatMap.channel),clearcoatNormalMapUv:wt&&g(M.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:Pt&&g(M.clearcoatRoughnessMap.channel),iridescenceMapUv:Ht&&g(M.iridescenceMap.channel),iridescenceThicknessMapUv:et&&g(M.iridescenceThicknessMap.channel),sheenColorMapUv:mt&&g(M.sheenColorMap.channel),sheenRoughnessMapUv:Ot&&g(M.sheenRoughnessMap.channel),specularMapUv:he&&g(M.specularMap.channel),specularColorMapUv:Me&&g(M.specularColorMap.channel),specularIntensityMapUv:it&&g(M.specularIntensityMap.channel),transmissionMapUv:de&&g(M.transmissionMap.channel),thicknessMapUv:Ne&&g(M.thicknessMap.channel),alphaMapUv:Mt&&g(M.alphaMap.channel),vertexTangents:!!V.attributes.tangent&&(tt||Vt),vertexColors:M.vertexColors,vertexAlphas:M.vertexColors===!0&&!!V.attributes.color&&V.attributes.color.itemSize===4,pointsUvs:B.isPoints===!0&&!!V.attributes.uv&&(Et||Mt),fog:!!z,useFog:M.fog===!0,fogExp2:!!z&&z.isFogExp2,flatShading:M.flatShading===!0,sizeAttenuation:M.sizeAttenuation===!0,logarithmicDepthBuffer:d,reverseDepthBuffer:Le,skinning:B.isSkinnedMesh===!0,morphTargets:V.morphAttributes.position!==void 0,morphNormals:V.morphAttributes.normal!==void 0,morphColors:V.morphAttributes.color!==void 0,morphTargetsCount:te,morphTextureStride:le,numDirLights:k.directional.length,numPointLights:k.point.length,numSpotLights:k.spot.length,numSpotLightMaps:k.spotLightMap.length,numRectAreaLights:k.rectArea.length,numHemiLights:k.hemi.length,numDirLightShadows:k.directionalShadowMap.length,numPointLightShadows:k.pointShadowMap.length,numSpotLightShadows:k.spotShadowMap.length,numSpotLightShadowsWithMaps:k.numSpotLightShadowsWithMaps,numLightProbes:k.numLightProbes,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:M.dithering,shadowMapEnabled:t.shadowMap.enabled&&R.length>0,shadowMapType:t.shadowMap.type,toneMapping:Se,decodeVideoTexture:Et&&M.map.isVideoTexture===!0&&Qn.getTransfer(M.map.colorSpace)===yr,decodeVideoTextureEmissive:St&&M.emissiveMap.isVideoTexture===!0&&Qn.getTransfer(M.emissiveMap.colorSpace)===yr,premultipliedAlpha:M.premultipliedAlpha,doubleSided:M.side===ta,flipSided:M.side===sa,useDepthPacking:M.depthPacking>=0,depthPacking:M.depthPacking||0,index0AttributeName:M.index0AttributeName,extensionClipCullDistance:kt&&M.extensions.clipCullDistance===!0&&r.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(kt&&M.extensions.multiDraw===!0||st)&&r.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:r.has("KHR_parallel_shader_compile"),customProgramCacheKey:M.customProgramCacheKey()};return qe.vertexUv1s=u.has(1),qe.vertexUv2s=u.has(2),qe.vertexUv3s=u.has(3),u.clear(),qe}function m(M){const k=[];if(M.shaderID?k.push(M.shaderID):(k.push(M.customVertexShaderID),k.push(M.customFragmentShaderID)),M.defines!==void 0)for(const R in M.defines)k.push(R),k.push(M.defines[R]);return M.isRawShaderMaterial===!1&&(b(k,M),w(k,M),k.push(t.outputColorSpace)),k.push(M.customProgramCacheKey),k.join()}function b(M,k){M.push(k.precision),M.push(k.outputColorSpace),M.push(k.envMapMode),M.push(k.envMapCubeUVHeight),M.push(k.mapUv),M.push(k.alphaMapUv),M.push(k.lightMapUv),M.push(k.aoMapUv),M.push(k.bumpMapUv),M.push(k.normalMapUv),M.push(k.displacementMapUv),M.push(k.emissiveMapUv),M.push(k.metalnessMapUv),M.push(k.roughnessMapUv),M.push(k.anisotropyMapUv),M.push(k.clearcoatMapUv),M.push(k.clearcoatNormalMapUv),M.push(k.clearcoatRoughnessMapUv),M.push(k.iridescenceMapUv),M.push(k.iridescenceThicknessMapUv),M.push(k.sheenColorMapUv),M.push(k.sheenRoughnessMapUv),M.push(k.specularMapUv),M.push(k.specularColorMapUv),M.push(k.specularIntensityMapUv),M.push(k.transmissionMapUv),M.push(k.thicknessMapUv),M.push(k.combine),M.push(k.fogExp2),M.push(k.sizeAttenuation),M.push(k.morphTargetsCount),M.push(k.morphAttributeCount),M.push(k.numDirLights),M.push(k.numPointLights),M.push(k.numSpotLights),M.push(k.numSpotLightMaps),M.push(k.numHemiLights),M.push(k.numRectAreaLights),M.push(k.numDirLightShadows),M.push(k.numPointLightShadows),M.push(k.numSpotLightShadows),M.push(k.numSpotLightShadowsWithMaps),M.push(k.numLightProbes),M.push(k.shadowMapType),M.push(k.toneMapping),M.push(k.numClippingPlanes),M.push(k.numClipIntersection),M.push(k.depthPacking)}function w(M,k){o.disableAll(),k.supportsVertexTextures&&o.enable(0),k.instancing&&o.enable(1),k.instancingColor&&o.enable(2),k.instancingMorph&&o.enable(3),k.matcap&&o.enable(4),k.envMap&&o.enable(5),k.normalMapObjectSpace&&o.enable(6),k.normalMapTangentSpace&&o.enable(7),k.clearcoat&&o.enable(8),k.iridescence&&o.enable(9),k.alphaTest&&o.enable(10),k.vertexColors&&o.enable(11),k.vertexAlphas&&o.enable(12),k.vertexUv1s&&o.enable(13),k.vertexUv2s&&o.enable(14),k.vertexUv3s&&o.enable(15),k.vertexTangents&&o.enable(16),k.anisotropy&&o.enable(17),k.alphaHash&&o.enable(18),k.batching&&o.enable(19),k.dispersion&&o.enable(20),k.batchingColor&&o.enable(21),M.push(o.mask),o.disableAll(),k.fog&&o.enable(0),k.useFog&&o.enable(1),k.flatShading&&o.enable(2),k.logarithmicDepthBuffer&&o.enable(3),k.reverseDepthBuffer&&o.enable(4),k.skinning&&o.enable(5),k.morphTargets&&o.enable(6),k.morphNormals&&o.enable(7),k.morphColors&&o.enable(8),k.premultipliedAlpha&&o.enable(9),k.shadowMapEnabled&&o.enable(10),k.doubleSided&&o.enable(11),k.flipSided&&o.enable(12),k.useDepthPacking&&o.enable(13),k.dithering&&o.enable(14),k.transmission&&o.enable(15),k.sheen&&o.enable(16),k.opaque&&o.enable(17),k.pointsUvs&&o.enable(18),k.decodeVideoTexture&&o.enable(19),k.decodeVideoTextureEmissive&&o.enable(20),k.alphaToCoverage&&o.enable(21),M.push(o.mask)}function _(M){const k=f[M.type];let R;if(k){const N=hl[k];R=kP.clone(N.uniforms)}else R=M.uniforms;return R}function S(M,k){let R;for(let N=0,B=c.length;N<B;N++){const z=c[N];if(z.cacheKey===k){R=z,++R.usedTimes;break}}return R===void 0&&(R=new uge(t,k,M,s),c.push(R)),R}function E(M){if(--M.usedTimes===0){const k=c.indexOf(M);c[k]=c[c.length-1],c.pop(),M.destroy()}}function C(M){l.remove(M)}function T(){l.dispose()}return{getParameters:y,getProgramCacheKey:m,getUniforms:_,acquireProgram:S,releaseProgram:E,releaseShaderCache:C,programs:c,dispose:T}}function fge(){let t=new WeakMap;function e(a){return t.has(a)}function n(a){let o=t.get(a);return o===void 0&&(o={},t.set(a,o)),o}function r(a){t.delete(a)}function i(a,o,l){t.get(a)[o]=l}function s(){t=new WeakMap}return{has:e,get:n,remove:r,update:i,dispose:s}}function mge(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function AH(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function EH(){const t=[];let e=0;const n=[],r=[],i=[];function s(){e=0,n.length=0,r.length=0,i.length=0}function a(d,h,p,f,g,y){let m=t[e];return m===void 0?(m={id:d.id,object:d,geometry:h,material:p,groupOrder:f,renderOrder:d.renderOrder,z:g,group:y},t[e]=m):(m.id=d.id,m.object=d,m.geometry=h,m.material=p,m.groupOrder=f,m.renderOrder=d.renderOrder,m.z=g,m.group=y),e++,m}function o(d,h,p,f,g,y){const m=a(d,h,p,f,g,y);p.transmission>0?r.push(m):p.transparent===!0?i.push(m):n.push(m)}function l(d,h,p,f,g,y){const m=a(d,h,p,f,g,y);p.transmission>0?r.unshift(m):p.transparent===!0?i.unshift(m):n.unshift(m)}function u(d,h){n.length>1&&n.sort(d||mge),r.length>1&&r.sort(h||AH),i.length>1&&i.sort(h||AH)}function c(){for(let d=e,h=t.length;d<h;d++){const p=t[d];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.group=null}}return{opaque:n,transmissive:r,transparent:i,init:s,push:o,unshift:l,finish:c,sort:u}}function gge(){let t=new WeakMap;function e(r,i){const s=t.get(r);let a;return s===void 0?(a=new EH,t.set(r,[a])):i>=s.length?(a=new EH,s.push(a)):a=s[i],a}function n(){t=new WeakMap}return{get:e,dispose:n}}function yge(){const t={};return{get:function(e){if(t[e.id]!==void 0)return t[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new Z,color:new Ct};break;case"SpotLight":n={position:new Z,direction:new Z,color:new Ct,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new Z,color:new Ct,distance:0,decay:0};break;case"HemisphereLight":n={direction:new Z,skyColor:new Ct,groundColor:new Ct};break;case"RectAreaLight":n={color:new Ct,position:new Z,halfWidth:new Z,halfHeight:new Z};break}return t[e.id]=n,n}}}function vge(){const t={};return{get:function(e){if(t[e.id]!==void 0)return t[e.id];let n;switch(e.type){case"DirectionalLight":n={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Qe};break;case"SpotLight":n={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Qe};break;case"PointLight":n={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Qe,shadowCameraNear:1,shadowCameraFar:1e3};break}return t[e.id]=n,n}}}let xge=0;function bge(t,e){return(e.castShadow?2:0)-(t.castShadow?2:0)+(e.map?1:0)-(t.map?1:0)}function wge(t){const e=new yge,n=vge(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let u=0;u<9;u++)r.probe.push(new Z);const i=new Z,s=new ln,a=new ln;function o(u){let c=0,d=0,h=0;for(let M=0;M<9;M++)r.probe[M].set(0,0,0);let p=0,f=0,g=0,y=0,m=0,b=0,w=0,_=0,S=0,E=0,C=0;u.sort(bge);for(let M=0,k=u.length;M<k;M++){const R=u[M],N=R.color,B=R.intensity,z=R.distance,V=R.shadow&&R.shadow.map?R.shadow.map.texture:null;if(R.isAmbientLight)c+=N.r*B,d+=N.g*B,h+=N.b*B;else if(R.isLightProbe){for(let K=0;K<9;K++)r.probe[K].addScaledVector(R.sh.coefficients[K],B);C++}else if(R.isDirectionalLight){const K=e.get(R);if(K.color.copy(R.color).multiplyScalar(R.intensity),R.castShadow){const Q=R.shadow,O=n.get(R);O.shadowIntensity=Q.intensity,O.shadowBias=Q.bias,O.shadowNormalBias=Q.normalBias,O.shadowRadius=Q.radius,O.shadowMapSize=Q.mapSize,r.directionalShadow[p]=O,r.directionalShadowMap[p]=V,r.directionalShadowMatrix[p]=R.shadow.matrix,b++}r.directional[p]=K,p++}else if(R.isSpotLight){const K=e.get(R);K.position.setFromMatrixPosition(R.matrixWorld),K.color.copy(N).multiplyScalar(B),K.distance=z,K.coneCos=Math.cos(R.angle),K.penumbraCos=Math.cos(R.angle*(1-R.penumbra)),K.decay=R.decay,r.spot[g]=K;const Q=R.shadow;if(R.map&&(r.spotLightMap[S]=R.map,S++,Q.updateMatrices(R),R.castShadow&&E++),r.spotLightMatrix[g]=Q.matrix,R.castShadow){const O=n.get(R);O.shadowIntensity=Q.intensity,O.shadowBias=Q.bias,O.shadowNormalBias=Q.normalBias,O.shadowRadius=Q.radius,O.shadowMapSize=Q.mapSize,r.spotShadow[g]=O,r.spotShadowMap[g]=V,_++}g++}else if(R.isRectAreaLight){const K=e.get(R);K.color.copy(N).multiplyScalar(B),K.halfWidth.set(R.width*.5,0,0),K.halfHeight.set(0,R.height*.5,0),r.rectArea[y]=K,y++}else if(R.isPointLight){const K=e.get(R);if(K.color.copy(R.color).multiplyScalar(R.intensity),K.distance=R.distance,K.decay=R.decay,R.castShadow){const Q=R.shadow,O=n.get(R);O.shadowIntensity=Q.intensity,O.shadowBias=Q.bias,O.shadowNormalBias=Q.normalBias,O.shadowRadius=Q.radius,O.shadowMapSize=Q.mapSize,O.shadowCameraNear=Q.camera.near,O.shadowCameraFar=Q.camera.far,r.pointShadow[f]=O,r.pointShadowMap[f]=V,r.pointShadowMatrix[f]=R.shadow.matrix,w++}r.point[f]=K,f++}else if(R.isHemisphereLight){const K=e.get(R);K.skyColor.copy(R.color).multiplyScalar(B),K.groundColor.copy(R.groundColor).multiplyScalar(B),r.hemi[m]=K,m++}}y>0&&(t.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=Bt.LTC_FLOAT_1,r.rectAreaLTC2=Bt.LTC_FLOAT_2):(r.rectAreaLTC1=Bt.LTC_HALF_1,r.rectAreaLTC2=Bt.LTC_HALF_2)),r.ambient[0]=c,r.ambient[1]=d,r.ambient[2]=h;const T=r.hash;(T.directionalLength!==p||T.pointLength!==f||T.spotLength!==g||T.rectAreaLength!==y||T.hemiLength!==m||T.numDirectionalShadows!==b||T.numPointShadows!==w||T.numSpotShadows!==_||T.numSpotMaps!==S||T.numLightProbes!==C)&&(r.directional.length=p,r.spot.length=g,r.rectArea.length=y,r.point.length=f,r.hemi.length=m,r.directionalShadow.length=b,r.directionalShadowMap.length=b,r.pointShadow.length=w,r.pointShadowMap.length=w,r.spotShadow.length=_,r.spotShadowMap.length=_,r.directionalShadowMatrix.length=b,r.pointShadowMatrix.length=w,r.spotLightMatrix.length=_+S-E,r.spotLightMap.length=S,r.numSpotLightShadowsWithMaps=E,r.numLightProbes=C,T.directionalLength=p,T.pointLength=f,T.spotLength=g,T.rectAreaLength=y,T.hemiLength=m,T.numDirectionalShadows=b,T.numPointShadows=w,T.numSpotShadows=_,T.numSpotMaps=S,T.numLightProbes=C,r.version=xge++)}function l(u,c){let d=0,h=0,p=0,f=0,g=0;const y=c.matrixWorldInverse;for(let m=0,b=u.length;m<b;m++){const w=u[m];if(w.isDirectionalLight){const _=r.directional[d];_.direction.setFromMatrixPosition(w.matrixWorld),i.setFromMatrixPosition(w.target.matrixWorld),_.direction.sub(i),_.direction.transformDirection(y),d++}else if(w.isSpotLight){const _=r.spot[p];_.position.setFromMatrixPosition(w.matrixWorld),_.position.applyMatrix4(y),_.direction.setFromMatrixPosition(w.matrixWorld),i.setFromMatrixPosition(w.target.matrixWorld),_.direction.sub(i),_.direction.transformDirection(y),p++}else if(w.isRectAreaLight){const _=r.rectArea[f];_.position.setFromMatrixPosition(w.matrixWorld),_.position.applyMatrix4(y),a.identity(),s.copy(w.matrixWorld),s.premultiply(y),a.extractRotation(s),_.halfWidth.set(w.width*.5,0,0),_.halfHeight.set(0,w.height*.5,0),_.halfWidth.applyMatrix4(a),_.halfHeight.applyMatrix4(a),f++}else if(w.isPointLight){const _=r.point[h];_.position.setFromMatrixPosition(w.matrixWorld),_.position.applyMatrix4(y),h++}else if(w.isHemisphereLight){const _=r.hemi[g];_.direction.setFromMatrixPosition(w.matrixWorld),_.direction.transformDirection(y),g++}}}return{setup:o,setupView:l,state:r}}function IH(t){const e=new wge(t),n=[],r=[];function i(c){u.camera=c,n.length=0,r.length=0}function s(c){n.push(c)}function a(c){r.push(c)}function o(){e.setup(n)}function l(c){e.setupView(n,c)}const u={lightsArray:n,shadowsArray:r,camera:null,lights:e,transmissionRenderTarget:{}};return{init:i,state:u,setupLights:o,setupLightsView:l,pushLight:s,pushShadow:a}}function _ge(t){let e=new WeakMap;function n(i,s=0){const a=e.get(i);let o;return a===void 0?(o=new IH(t),e.set(i,[o])):s>=a.length?(o=new IH(t),a.push(o)):o=a[s],o}function r(){e=new WeakMap}return{get:n,dispose:r}}const Sge=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,Age=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function Ege(t,e,n){let r=new f0;const i=new Qe,s=new Qe,a=new Xn,o=new VP({depthPacking:n9}),l=new jP,u={},c=n.maxTextureSize,d={[lu]:sa,[sa]:lu,[ta]:ta},h=new ua({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Qe},radius:{value:4}},vertexShader:Sge,fragmentShader:Age}),p=h.clone();p.defines.HORIZONTAL_PASS=1;const f=new An;f.setAttribute("position",new Ln(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const g=new Cr(f,h),y=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=wT;let m=this.type;this.render=function(E,C,T){if(y.enabled===!1||y.autoUpdate===!1&&y.needsUpdate===!1||E.length===0)return;const M=t.getRenderTarget(),k=t.getActiveCubeFace(),R=t.getActiveMipmapLevel(),N=t.state;N.setBlending(nu),N.buffers.color.setClear(1,1,1,1),N.buffers.depth.setTest(!0),N.setScissorTest(!1);const B=m!==ul&&this.type===ul,z=m===ul&&this.type!==ul;for(let V=0,K=E.length;V<K;V++){const Q=E[V],O=Q.shadow;if(O===void 0){console.warn("THREE.WebGLShadowMap:",Q,"has no shadow.");continue}if(O.autoUpdate===!1&&O.needsUpdate===!1)continue;i.copy(O.mapSize);const j=O.getFrameExtents();if(i.multiply(j),s.copy(O.mapSize),(i.x>c||i.y>c)&&(i.x>c&&(s.x=Math.floor(c/j.x),i.x=s.x*j.x,O.mapSize.x=s.x),i.y>c&&(s.y=Math.floor(c/j.y),i.y=s.y*j.y,O.mapSize.y=s.y)),O.map===null||B===!0||z===!0){const te=this.type!==ul?{minFilter:yi,magFilter:yi}:{};O.map!==null&&O.map.dispose(),O.map=new Oa(i.x,i.y,te),O.map.texture.name=Q.name+".shadowMap",O.camera.updateProjectionMatrix()}t.setRenderTarget(O.map),t.clear();const X=O.getViewportCount();for(let te=0;te<X;te++){const le=O.getViewport(te);a.set(s.x*le.x,s.y*le.y,s.x*le.z,s.y*le.w),N.viewport(a),O.updateMatrices(Q,te),r=O.getFrustum(),_(C,T,O.camera,Q,this.type)}O.isPointLightShadow!==!0&&this.type===ul&&b(O,T),O.needsUpdate=!1}m=this.type,y.needsUpdate=!1,t.setRenderTarget(M,k,R)};function b(E,C){const T=e.update(g);h.defines.VSM_SAMPLES!==E.blurSamples&&(h.defines.VSM_SAMPLES=E.blurSamples,p.defines.VSM_SAMPLES=E.blurSamples,h.needsUpdate=!0,p.needsUpdate=!0),E.mapPass===null&&(E.mapPass=new Oa(i.x,i.y)),h.uniforms.shadow_pass.value=E.map.texture,h.uniforms.resolution.value=E.mapSize,h.uniforms.radius.value=E.radius,t.setRenderTarget(E.mapPass),t.clear(),t.renderBufferDirect(C,null,T,h,g,null),p.uniforms.shadow_pass.value=E.mapPass.texture,p.uniforms.resolution.value=E.mapSize,p.uniforms.radius.value=E.radius,t.setRenderTarget(E.map),t.clear(),t.renderBufferDirect(C,null,T,p,g,null)}function w(E,C,T,M){let k=null;const R=T.isPointLight===!0?E.customDistanceMaterial:E.customDepthMaterial;if(R!==void 0)k=R;else if(k=T.isPointLight===!0?l:o,t.localClippingEnabled&&C.clipShadows===!0&&Array.isArray(C.clippingPlanes)&&C.clippingPlanes.length!==0||C.displacementMap&&C.displacementScale!==0||C.alphaMap&&C.alphaTest>0||C.map&&C.alphaTest>0||C.alphaToCoverage===!0){const N=k.uuid,B=C.uuid;let z=u[N];z===void 0&&(z={},u[N]=z);let V=z[B];V===void 0&&(V=k.clone(),z[B]=V,C.addEventListener("dispose",S)),k=V}if(k.visible=C.visible,k.wireframe=C.wireframe,M===ul?k.side=C.shadowSide!==null?C.shadowSide:C.side:k.side=C.shadowSide!==null?C.shadowSide:d[C.side],k.alphaMap=C.alphaMap,k.alphaTest=C.alphaToCoverage===!0?.5:C.alphaTest,k.map=C.map,k.clipShadows=C.clipShadows,k.clippingPlanes=C.clippingPlanes,k.clipIntersection=C.clipIntersection,k.displacementMap=C.displacementMap,k.displacementScale=C.displacementScale,k.displacementBias=C.displacementBias,k.wireframeLinewidth=C.wireframeLinewidth,k.linewidth=C.linewidth,T.isPointLight===!0&&k.isMeshDistanceMaterial===!0){const N=t.properties.get(k);N.light=T}return k}function _(E,C,T,M,k){if(E.visible===!1)return;if(E.layers.test(C.layers)&&(E.isMesh||E.isLine||E.isPoints)&&(E.castShadow||E.receiveShadow&&k===ul)&&(!E.frustumCulled||r.intersectsObject(E))){E.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse,E.matrixWorld);const B=e.update(E),z=E.material;if(Array.isArray(z)){const V=B.groups;for(let K=0,Q=V.length;K<Q;K++){const O=V[K],j=z[O.materialIndex];if(j&&j.visible){const X=w(E,j,M,k);E.onBeforeShadow(t,E,C,T,B,X,O),t.renderBufferDirect(T,null,B,X,E,O),E.onAfterShadow(t,E,C,T,B,X,O)}}}else if(z.visible){const V=w(E,z,M,k);E.onBeforeShadow(t,E,C,T,B,V,null),t.renderBufferDirect(T,null,B,V,E,null),E.onAfterShadow(t,E,C,T,B,V,null)}}const N=E.children;for(let B=0,z=N.length;B<z;B++)_(N[B],C,T,M,k)}function S(E){E.target.removeEventListener("dispose",S);for(const T in u){const M=u[T],k=E.target.uuid;k in M&&(M[k].dispose(),delete M[k])}}}const Ige={[LE]:OE,[BE]:zE,[UE]:GE,[Bp]:$E,[OE]:LE,[zE]:BE,[GE]:UE,[$E]:Bp};function Tge(t,e){function n(){let de=!1;const Ne=new Xn;let nt=null;const Mt=new Xn(0,0,0,0);return{setMask:function(ut){nt!==ut&&!de&&(t.colorMask(ut,ut,ut,ut),nt=ut)},setLocked:function(ut){de=ut},setClear:function(ut,Ze,kt,Se,qe){qe===!0&&(ut*=Se,Ze*=Se,kt*=Se),Ne.set(ut,Ze,kt,Se),Mt.equals(Ne)===!1&&(t.clearColor(ut,Ze,kt,Se),Mt.copy(Ne))},reset:function(){de=!1,nt=null,Mt.set(-1,0,0,0)}}}function r(){let de=!1,Ne=!1,nt=null,Mt=null,ut=null;return{setReversed:function(Ze){if(Ne!==Ze){const kt=e.get("EXT_clip_control");Ze?kt.clipControlEXT(kt.LOWER_LEFT_EXT,kt.ZERO_TO_ONE_EXT):kt.clipControlEXT(kt.LOWER_LEFT_EXT,kt.NEGATIVE_ONE_TO_ONE_EXT),Ne=Ze;const Se=ut;ut=null,this.setClear(Se)}},getReversed:function(){return Ne},setTest:function(Ze){Ze?Re(t.DEPTH_TEST):Le(t.DEPTH_TEST)},setMask:function(Ze){nt!==Ze&&!de&&(t.depthMask(Ze),nt=Ze)},setFunc:function(Ze){if(Ne&&(Ze=Ige[Ze]),Mt!==Ze){switch(Ze){case LE:t.depthFunc(t.NEVER);break;case OE:t.depthFunc(t.ALWAYS);break;case BE:t.depthFunc(t.LESS);break;case Bp:t.depthFunc(t.LEQUAL);break;case UE:t.depthFunc(t.EQUAL);break;case $E:t.depthFunc(t.GEQUAL);break;case zE:t.depthFunc(t.GREATER);break;case GE:t.depthFunc(t.NOTEQUAL);break;default:t.depthFunc(t.LEQUAL)}Mt=Ze}},setLocked:function(Ze){de=Ze},setClear:function(Ze){ut!==Ze&&(Ne&&(Ze=1-Ze),t.clearDepth(Ze),ut=Ze)},reset:function(){de=!1,nt=null,Mt=null,ut=null,Ne=!1}}}function i(){let de=!1,Ne=null,nt=null,Mt=null,ut=null,Ze=null,kt=null,Se=null,qe=null;return{setTest:function(pt){de||(pt?Re(t.STENCIL_TEST):Le(t.STENCIL_TEST))},setMask:function(pt){Ne!==pt&&!de&&(t.stencilMask(pt),Ne=pt)},setFunc:function(pt,ht,xn){(nt!==pt||Mt!==ht||ut!==xn)&&(t.stencilFunc(pt,ht,xn),nt=pt,Mt=ht,ut=xn)},setOp:function(pt,ht,xn){(Ze!==pt||kt!==ht||Se!==xn)&&(t.stencilOp(pt,ht,xn),Ze=pt,kt=ht,Se=xn)},setLocked:function(pt){de=pt},setClear:function(pt){qe!==pt&&(t.clearStencil(pt),qe=pt)},reset:function(){de=!1,Ne=null,nt=null,Mt=null,ut=null,Ze=null,kt=null,Se=null,qe=null}}}const s=new n,a=new r,o=new i,l=new WeakMap,u=new WeakMap;let c={},d={},h=new WeakMap,p=[],f=null,g=!1,y=null,m=null,b=null,w=null,_=null,S=null,E=null,C=new Ct(0,0,0),T=0,M=!1,k=null,R=null,N=null,B=null,z=null;const V=t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let K=!1,Q=0;const O=t.getParameter(t.VERSION);O.indexOf("WebGL")!==-1?(Q=parseFloat(/^WebGL (\d)/.exec(O)[1]),K=Q>=1):O.indexOf("OpenGL ES")!==-1&&(Q=parseFloat(/^OpenGL ES (\d)/.exec(O)[1]),K=Q>=2);let j=null,X={};const te=t.getParameter(t.SCISSOR_BOX),le=t.getParameter(t.VIEWPORT),ge=new Xn().fromArray(te),ie=new Xn().fromArray(le);function we(de,Ne,nt,Mt){const ut=new Uint8Array(4),Ze=t.createTexture();t.bindTexture(de,Ze),t.texParameteri(de,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(de,t.TEXTURE_MAG_FILTER,t.NEAREST);for(let kt=0;kt<nt;kt++)de===t.TEXTURE_3D||de===t.TEXTURE_2D_ARRAY?t.texImage3D(Ne,0,t.RGBA,1,1,Mt,0,t.RGBA,t.UNSIGNED_BYTE,ut):t.texImage2D(Ne+kt,0,t.RGBA,1,1,0,t.RGBA,t.UNSIGNED_BYTE,ut);return Ze}const Ce={};Ce[t.TEXTURE_2D]=we(t.TEXTURE_2D,t.TEXTURE_2D,1),Ce[t.TEXTURE_CUBE_MAP]=we(t.TEXTURE_CUBE_MAP,t.TEXTURE_CUBE_MAP_POSITIVE_X,6),Ce[t.TEXTURE_2D_ARRAY]=we(t.TEXTURE_2D_ARRAY,t.TEXTURE_2D_ARRAY,1,1),Ce[t.TEXTURE_3D]=we(t.TEXTURE_3D,t.TEXTURE_3D,1,1),s.setClear(0,0,0,1),a.setClear(1),o.setClear(0),Re(t.DEPTH_TEST),a.setFunc(Bp),Be(!1),tt(LR),Re(t.CULL_FACE),J(nu);function Re(de){c[de]!==!0&&(t.enable(de),c[de]=!0)}function Le(de){c[de]!==!1&&(t.disable(de),c[de]=!1)}function lt(de,Ne){return d[de]!==Ne?(t.bindFramebuffer(de,Ne),d[de]=Ne,de===t.DRAW_FRAMEBUFFER&&(d[t.FRAMEBUFFER]=Ne),de===t.FRAMEBUFFER&&(d[t.DRAW_FRAMEBUFFER]=Ne),!0):!1}function st(de,Ne){let nt=p,Mt=!1;if(de){nt=h.get(Ne),nt===void 0&&(nt=[],h.set(Ne,nt));const ut=de.textures;if(nt.length!==ut.length||nt[0]!==t.COLOR_ATTACHMENT0){for(let Ze=0,kt=ut.length;Ze<kt;Ze++)nt[Ze]=t.COLOR_ATTACHMENT0+Ze;nt.length=ut.length,Mt=!0}}else nt[0]!==t.BACK&&(nt[0]=t.BACK,Mt=!0);Mt&&t.drawBuffers(nt)}function Et(de){return f!==de?(t.useProgram(de),f=de,!0):!1}const Tt={[nd]:t.FUNC_ADD,[Ej]:t.FUNC_SUBTRACT,[Ij]:t.FUNC_REVERSE_SUBTRACT};Tt[Tj]=t.MIN,Tt[Cj]=t.MAX;const xt={[Mj]:t.ZERO,[kj]:t.ONE,[Nj]:t.SRC_COLOR,[DE]:t.SRC_ALPHA,[Oj]:t.SRC_ALPHA_SATURATE,[Pj]:t.DST_COLOR,[Fj]:t.DST_ALPHA,[Rj]:t.ONE_MINUS_SRC_COLOR,[PE]:t.ONE_MINUS_SRC_ALPHA,[Lj]:t.ONE_MINUS_DST_COLOR,[Dj]:t.ONE_MINUS_DST_ALPHA,[Bj]:t.CONSTANT_COLOR,[Uj]:t.ONE_MINUS_CONSTANT_COLOR,[$j]:t.CONSTANT_ALPHA,[zj]:t.ONE_MINUS_CONSTANT_ALPHA};function J(de,Ne,nt,Mt,ut,Ze,kt,Se,qe,pt){if(de===nu){g===!0&&(Le(t.BLEND),g=!1);return}if(g===!1&&(Re(t.BLEND),g=!0),de!==Aj){if(de!==y||pt!==M){if((m!==nd||_!==nd)&&(t.blendEquation(t.FUNC_ADD),m=nd,_=nd),pt)switch(de){case Sp:t.blendFuncSeparate(t.ONE,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case OR:t.blendFunc(t.ONE,t.ONE);break;case BR:t.blendFuncSeparate(t.ZERO,t.ONE_MINUS_SRC_COLOR,t.ZERO,t.ONE);break;case UR:t.blendFuncSeparate(t.ZERO,t.SRC_COLOR,t.ZERO,t.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",de);break}else switch(de){case Sp:t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case OR:t.blendFunc(t.SRC_ALPHA,t.ONE);break;case BR:t.blendFuncSeparate(t.ZERO,t.ONE_MINUS_SRC_COLOR,t.ZERO,t.ONE);break;case UR:t.blendFunc(t.ZERO,t.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",de);break}b=null,w=null,S=null,E=null,C.set(0,0,0),T=0,y=de,M=pt}return}ut=ut||Ne,Ze=Ze||nt,kt=kt||Mt,(Ne!==m||ut!==_)&&(t.blendEquationSeparate(Tt[Ne],Tt[ut]),m=Ne,_=ut),(nt!==b||Mt!==w||Ze!==S||kt!==E)&&(t.blendFuncSeparate(xt[nt],xt[Mt],xt[Ze],xt[kt]),b=nt,w=Mt,S=Ze,E=kt),(Se.equals(C)===!1||qe!==T)&&(t.blendColor(Se.r,Se.g,Se.b,qe),C.copy(Se),T=qe),y=de,M=!1}function Ye(de,Ne){de.side===ta?Le(t.CULL_FACE):Re(t.CULL_FACE);let nt=de.side===sa;Ne&&(nt=!nt),Be(nt),de.blending===Sp&&de.transparent===!1?J(nu):J(de.blending,de.blendEquation,de.blendSrc,de.blendDst,de.blendEquationAlpha,de.blendSrcAlpha,de.blendDstAlpha,de.blendColor,de.blendAlpha,de.premultipliedAlpha),a.setFunc(de.depthFunc),a.setTest(de.depthTest),a.setMask(de.depthWrite),s.setMask(de.colorWrite);const Mt=de.stencilWrite;o.setTest(Mt),Mt&&(o.setMask(de.stencilWriteMask),o.setFunc(de.stencilFunc,de.stencilRef,de.stencilFuncMask),o.setOp(de.stencilFail,de.stencilZFail,de.stencilZPass)),St(de.polygonOffset,de.polygonOffsetFactor,de.polygonOffsetUnits),de.alphaToCoverage===!0?Re(t.SAMPLE_ALPHA_TO_COVERAGE):Le(t.SAMPLE_ALPHA_TO_COVERAGE)}function Be(de){k!==de&&(de?t.frontFace(t.CW):t.frontFace(t.CCW),k=de)}function tt(de){de!==wj?(Re(t.CULL_FACE),de!==R&&(de===LR?t.cullFace(t.BACK):de===_j?t.cullFace(t.FRONT):t.cullFace(t.FRONT_AND_BACK))):Le(t.CULL_FACE),R=de}function Ue(de){de!==N&&(K&&t.lineWidth(de),N=de)}function St(de,Ne,nt){de?(Re(t.POLYGON_OFFSET_FILL),(B!==Ne||z!==nt)&&(t.polygonOffset(Ne,nt),B=Ne,z=nt)):Le(t.POLYGON_OFFSET_FILL)}function Je(de){de?Re(t.SCISSOR_TEST):Le(t.SCISSOR_TEST)}function At(de){de===void 0&&(de=t.TEXTURE0+V-1),j!==de&&(t.activeTexture(de),j=de)}function Vt(de,Ne,nt){nt===void 0&&(j===null?nt=t.TEXTURE0+V-1:nt=j);let Mt=X[nt];Mt===void 0&&(Mt={type:void 0,texture:void 0},X[nt]=Mt),(Mt.type!==de||Mt.texture!==Ne)&&(j!==nt&&(t.activeTexture(nt),j=nt),t.bindTexture(de,Ne||Ce[de]),Mt.type=de,Mt.texture=Ne)}function re(){const de=X[j];de!==void 0&&de.type!==void 0&&(t.bindTexture(de.type,null),de.type=void 0,de.texture=void 0)}function H(){try{t.compressedTexImage2D(...arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function Ee(){try{t.compressedTexImage3D(...arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function Oe(){try{t.texSubImage2D(...arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function Xe(){try{t.texSubImage3D(...arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function $e(){try{t.compressedTexSubImage2D(...arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function Lt(){try{t.compressedTexSubImage3D(...arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function wt(){try{t.texStorage2D(...arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function Pt(){try{t.texStorage3D(...arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function Ht(){try{t.texImage2D(...arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function et(){try{t.texImage3D(...arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function mt(de){ge.equals(de)===!1&&(t.scissor(de.x,de.y,de.z,de.w),ge.copy(de))}function Ot(de){ie.equals(de)===!1&&(t.viewport(de.x,de.y,de.z,de.w),ie.copy(de))}function he(de,Ne){let nt=u.get(Ne);nt===void 0&&(nt=new WeakMap,u.set(Ne,nt));let Mt=nt.get(de);Mt===void 0&&(Mt=t.getUniformBlockIndex(Ne,de.name),nt.set(de,Mt))}function Me(de,Ne){const Mt=u.get(Ne).get(de);l.get(Ne)!==Mt&&(t.uniformBlockBinding(Ne,Mt,de.__bindingPointIndex),l.set(Ne,Mt))}function it(){t.disable(t.BLEND),t.disable(t.CULL_FACE),t.disable(t.DEPTH_TEST),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SCISSOR_TEST),t.disable(t.STENCIL_TEST),t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),t.blendEquation(t.FUNC_ADD),t.blendFunc(t.ONE,t.ZERO),t.blendFuncSeparate(t.ONE,t.ZERO,t.ONE,t.ZERO),t.blendColor(0,0,0,0),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(t.LESS),a.setReversed(!1),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(t.ALWAYS,0,4294967295),t.stencilOp(t.KEEP,t.KEEP,t.KEEP),t.clearStencil(0),t.cullFace(t.BACK),t.frontFace(t.CCW),t.polygonOffset(0,0),t.activeTexture(t.TEXTURE0),t.bindFramebuffer(t.FRAMEBUFFER,null),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),t.bindFramebuffer(t.READ_FRAMEBUFFER,null),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),c={},j=null,X={},d={},h=new WeakMap,p=[],f=null,g=!1,y=null,m=null,b=null,w=null,_=null,S=null,E=null,C=new Ct(0,0,0),T=0,M=!1,k=null,R=null,N=null,B=null,z=null,ge.set(0,0,t.canvas.width,t.canvas.height),ie.set(0,0,t.canvas.width,t.canvas.height),s.reset(),a.reset(),o.reset()}return{buffers:{color:s,depth:a,stencil:o},enable:Re,disable:Le,bindFramebuffer:lt,drawBuffers:st,useProgram:Et,setBlending:J,setMaterial:Ye,setFlipSided:Be,setCullFace:tt,setLineWidth:Ue,setPolygonOffset:St,setScissorTest:Je,activeTexture:At,bindTexture:Vt,unbindTexture:re,compressedTexImage2D:H,compressedTexImage3D:Ee,texImage2D:Ht,texImage3D:et,updateUBOMapping:he,uniformBlockBinding:Me,texStorage2D:wt,texStorage3D:Pt,texSubImage2D:Oe,texSubImage3D:Xe,compressedTexSubImage2D:$e,compressedTexSubImage3D:Lt,scissor:mt,viewport:Ot,reset:it}}function Cge(t,e,n,r,i,s,a){const o=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,l=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),u=new Qe,c=new WeakMap;let d;const h=new WeakMap;let p=!1;try{p=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function f(re,H){return p?new OffscreenCanvas(re,H):s1("canvas")}function g(re,H,Ee){let Oe=1;const Xe=Vt(re);if((Xe.width>Ee||Xe.height>Ee)&&(Oe=Ee/Math.max(Xe.width,Xe.height)),Oe<1)if(typeof HTMLImageElement<"u"&&re instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&re instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&re instanceof ImageBitmap||typeof VideoFrame<"u"&&re instanceof VideoFrame){const $e=Math.floor(Oe*Xe.width),Lt=Math.floor(Oe*Xe.height);d===void 0&&(d=f($e,Lt));const wt=H?f($e,Lt):d;return wt.width=$e,wt.height=Lt,wt.getContext("2d").drawImage(re,0,0,$e,Lt),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+Xe.width+"x"+Xe.height+") to ("+$e+"x"+Lt+")."),wt}else return"data"in re&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+Xe.width+"x"+Xe.height+")."),re;return re}function y(re){return re.generateMipmaps}function m(re){t.generateMipmap(re)}function b(re){return re.isWebGLCubeRenderTarget?t.TEXTURE_CUBE_MAP:re.isWebGL3DRenderTarget?t.TEXTURE_3D:re.isWebGLArrayRenderTarget||re.isCompressedArrayTexture?t.TEXTURE_2D_ARRAY:t.TEXTURE_2D}function w(re,H,Ee,Oe,Xe=!1){if(re!==null){if(t[re]!==void 0)return t[re];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+re+"'")}let $e=H;if(H===t.RED&&(Ee===t.FLOAT&&($e=t.R32F),Ee===t.HALF_FLOAT&&($e=t.R16F),Ee===t.UNSIGNED_BYTE&&($e=t.R8)),H===t.RED_INTEGER&&(Ee===t.UNSIGNED_BYTE&&($e=t.R8UI),Ee===t.UNSIGNED_SHORT&&($e=t.R16UI),Ee===t.UNSIGNED_INT&&($e=t.R32UI),Ee===t.BYTE&&($e=t.R8I),Ee===t.SHORT&&($e=t.R16I),Ee===t.INT&&($e=t.R32I)),H===t.RG&&(Ee===t.FLOAT&&($e=t.RG32F),Ee===t.HALF_FLOAT&&($e=t.RG16F),Ee===t.UNSIGNED_BYTE&&($e=t.RG8)),H===t.RG_INTEGER&&(Ee===t.UNSIGNED_BYTE&&($e=t.RG8UI),Ee===t.UNSIGNED_SHORT&&($e=t.RG16UI),Ee===t.UNSIGNED_INT&&($e=t.RG32UI),Ee===t.BYTE&&($e=t.RG8I),Ee===t.SHORT&&($e=t.RG16I),Ee===t.INT&&($e=t.RG32I)),H===t.RGB_INTEGER&&(Ee===t.UNSIGNED_BYTE&&($e=t.RGB8UI),Ee===t.UNSIGNED_SHORT&&($e=t.RGB16UI),Ee===t.UNSIGNED_INT&&($e=t.RGB32UI),Ee===t.BYTE&&($e=t.RGB8I),Ee===t.SHORT&&($e=t.RGB16I),Ee===t.INT&&($e=t.RGB32I)),H===t.RGBA_INTEGER&&(Ee===t.UNSIGNED_BYTE&&($e=t.RGBA8UI),Ee===t.UNSIGNED_SHORT&&($e=t.RGBA16UI),Ee===t.UNSIGNED_INT&&($e=t.RGBA32UI),Ee===t.BYTE&&($e=t.RGBA8I),Ee===t.SHORT&&($e=t.RGBA16I),Ee===t.INT&&($e=t.RGBA32I)),H===t.RGB&&Ee===t.UNSIGNED_INT_5_9_9_9_REV&&($e=t.RGB9_E5),H===t.RGBA){const Lt=Xe?n1:Qn.getTransfer(Oe);Ee===t.FLOAT&&($e=t.RGBA32F),Ee===t.HALF_FLOAT&&($e=t.RGBA16F),Ee===t.UNSIGNED_BYTE&&($e=Lt===yr?t.SRGB8_ALPHA8:t.RGBA8),Ee===t.UNSIGNED_SHORT_4_4_4_4&&($e=t.RGBA4),Ee===t.UNSIGNED_SHORT_5_5_5_1&&($e=t.RGB5_A1)}return($e===t.R16F||$e===t.R32F||$e===t.RG16F||$e===t.RG32F||$e===t.RGBA16F||$e===t.RGBA32F)&&e.get("EXT_color_buffer_float"),$e}function _(re,H){let Ee;return re?H===null||H===cu||H===Ly?Ee=t.DEPTH24_STENCIL8:H===ti?Ee=t.DEPTH32F_STENCIL8:H===Py&&(Ee=t.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):H===null||H===cu||H===Ly?Ee=t.DEPTH_COMPONENT24:H===ti?Ee=t.DEPTH_COMPONENT32F:H===Py&&(Ee=t.DEPTH_COMPONENT16),Ee}function S(re,H){return y(re)===!0||re.isFramebufferTexture&&re.minFilter!==yi&&re.minFilter!==er?Math.log2(Math.max(H.width,H.height))+1:re.mipmaps!==void 0&&re.mipmaps.length>0?re.mipmaps.length:re.isCompressedTexture&&Array.isArray(re.image)?H.mipmaps.length:1}function E(re){const H=re.target;H.removeEventListener("dispose",E),T(H),H.isVideoTexture&&c.delete(H)}function C(re){const H=re.target;H.removeEventListener("dispose",C),k(H)}function T(re){const H=r.get(re);if(H.__webglInit===void 0)return;const Ee=re.source,Oe=h.get(Ee);if(Oe){const Xe=Oe[H.__cacheKey];Xe.usedTimes--,Xe.usedTimes===0&&M(re),Object.keys(Oe).length===0&&h.delete(Ee)}r.remove(re)}function M(re){const H=r.get(re);t.deleteTexture(H.__webglTexture);const Ee=re.source,Oe=h.get(Ee);delete Oe[H.__cacheKey],a.memory.textures--}function k(re){const H=r.get(re);if(re.depthTexture&&(re.depthTexture.dispose(),r.remove(re.depthTexture)),re.isWebGLCubeRenderTarget)for(let Oe=0;Oe<6;Oe++){if(Array.isArray(H.__webglFramebuffer[Oe]))for(let Xe=0;Xe<H.__webglFramebuffer[Oe].length;Xe++)t.deleteFramebuffer(H.__webglFramebuffer[Oe][Xe]);else t.deleteFramebuffer(H.__webglFramebuffer[Oe]);H.__webglDepthbuffer&&t.deleteRenderbuffer(H.__webglDepthbuffer[Oe])}else{if(Array.isArray(H.__webglFramebuffer))for(let Oe=0;Oe<H.__webglFramebuffer.length;Oe++)t.deleteFramebuffer(H.__webglFramebuffer[Oe]);else t.deleteFramebuffer(H.__webglFramebuffer);if(H.__webglDepthbuffer&&t.deleteRenderbuffer(H.__webglDepthbuffer),H.__webglMultisampledFramebuffer&&t.deleteFramebuffer(H.__webglMultisampledFramebuffer),H.__webglColorRenderbuffer)for(let Oe=0;Oe<H.__webglColorRenderbuffer.length;Oe++)H.__webglColorRenderbuffer[Oe]&&t.deleteRenderbuffer(H.__webglColorRenderbuffer[Oe]);H.__webglDepthRenderbuffer&&t.deleteRenderbuffer(H.__webglDepthRenderbuffer)}const Ee=re.textures;for(let Oe=0,Xe=Ee.length;Oe<Xe;Oe++){const $e=r.get(Ee[Oe]);$e.__webglTexture&&(t.deleteTexture($e.__webglTexture),a.memory.textures--),r.remove(Ee[Oe])}r.remove(re)}let R=0;function N(){R=0}function B(){const re=R;return re>=i.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+re+" texture units while this GPU supports only "+i.maxTextures),R+=1,re}function z(re){const H=[];return H.push(re.wrapS),H.push(re.wrapT),H.push(re.wrapR||0),H.push(re.magFilter),H.push(re.minFilter),H.push(re.anisotropy),H.push(re.internalFormat),H.push(re.format),H.push(re.type),H.push(re.generateMipmaps),H.push(re.premultiplyAlpha),H.push(re.flipY),H.push(re.unpackAlignment),H.push(re.colorSpace),H.join()}function V(re,H){const Ee=r.get(re);if(re.isVideoTexture&&Je(re),re.isRenderTargetTexture===!1&&re.version>0&&Ee.__version!==re.version){const Oe=re.image;if(Oe===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(Oe.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Ce(Ee,re,H);return}}n.bindTexture(t.TEXTURE_2D,Ee.__webglTexture,t.TEXTURE0+H)}function K(re,H){const Ee=r.get(re);if(re.version>0&&Ee.__version!==re.version){Ce(Ee,re,H);return}n.bindTexture(t.TEXTURE_2D_ARRAY,Ee.__webglTexture,t.TEXTURE0+H)}function Q(re,H){const Ee=r.get(re);if(re.version>0&&Ee.__version!==re.version){Ce(Ee,re,H);return}n.bindTexture(t.TEXTURE_3D,Ee.__webglTexture,t.TEXTURE0+H)}function O(re,H){const Ee=r.get(re);if(re.version>0&&Ee.__version!==re.version){Re(Ee,re,H);return}n.bindTexture(t.TEXTURE_CUBE_MAP,Ee.__webglTexture,t.TEXTURE0+H)}const j={[ac]:t.REPEAT,[jr]:t.CLAMP_TO_EDGE,[Up]:t.MIRRORED_REPEAT},X={[yi]:t.NEAREST,[$1]:t.NEAREST_MIPMAP_NEAREST,[od]:t.NEAREST_MIPMAP_LINEAR,[er]:t.LINEAR,[Ap]:t.LINEAR_MIPMAP_NEAREST,[Ma]:t.LINEAR_MIPMAP_LINEAR},te={[i9]:t.NEVER,[c9]:t.ALWAYS,[s9]:t.LESS,[AP]:t.LEQUAL,[a9]:t.EQUAL,[u9]:t.GEQUAL,[o9]:t.GREATER,[l9]:t.NOTEQUAL};function le(re,H){if(H.type===ti&&e.has("OES_texture_float_linear")===!1&&(H.magFilter===er||H.magFilter===Ap||H.magFilter===od||H.magFilter===Ma||H.minFilter===er||H.minFilter===Ap||H.minFilter===od||H.minFilter===Ma)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),t.texParameteri(re,t.TEXTURE_WRAP_S,j[H.wrapS]),t.texParameteri(re,t.TEXTURE_WRAP_T,j[H.wrapT]),(re===t.TEXTURE_3D||re===t.TEXTURE_2D_ARRAY)&&t.texParameteri(re,t.TEXTURE_WRAP_R,j[H.wrapR]),t.texParameteri(re,t.TEXTURE_MAG_FILTER,X[H.magFilter]),t.texParameteri(re,t.TEXTURE_MIN_FILTER,X[H.minFilter]),H.compareFunction&&(t.texParameteri(re,t.TEXTURE_COMPARE_MODE,t.COMPARE_REF_TO_TEXTURE),t.texParameteri(re,t.TEXTURE_COMPARE_FUNC,te[H.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){if(H.magFilter===yi||H.minFilter!==od&&H.minFilter!==Ma||H.type===ti&&e.has("OES_texture_float_linear")===!1)return;if(H.anisotropy>1||r.get(H).__currentAnisotropy){const Ee=e.get("EXT_texture_filter_anisotropic");t.texParameterf(re,Ee.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(H.anisotropy,i.getMaxAnisotropy())),r.get(H).__currentAnisotropy=H.anisotropy}}}function ge(re,H){let Ee=!1;re.__webglInit===void 0&&(re.__webglInit=!0,H.addEventListener("dispose",E));const Oe=H.source;let Xe=h.get(Oe);Xe===void 0&&(Xe={},h.set(Oe,Xe));const $e=z(H);if($e!==re.__cacheKey){Xe[$e]===void 0&&(Xe[$e]={texture:t.createTexture(),usedTimes:0},a.memory.textures++,Ee=!0),Xe[$e].usedTimes++;const Lt=Xe[re.__cacheKey];Lt!==void 0&&(Xe[re.__cacheKey].usedTimes--,Lt.usedTimes===0&&M(H)),re.__cacheKey=$e,re.__webglTexture=Xe[$e].texture}return Ee}function ie(re,H,Ee){return Math.floor(Math.floor(re/Ee)/H)}function we(re,H,Ee,Oe){const $e=re.updateRanges;if($e.length===0)n.texSubImage2D(t.TEXTURE_2D,0,0,0,H.width,H.height,Ee,Oe,H.data);else{$e.sort((et,mt)=>et.start-mt.start);let Lt=0;for(let et=1;et<$e.length;et++){const mt=$e[Lt],Ot=$e[et],he=mt.start+mt.count,Me=ie(Ot.start,H.width,4),it=ie(mt.start,H.width,4);Ot.start<=he+1&&Me===it&&ie(Ot.start+Ot.count-1,H.width,4)===Me?mt.count=Math.max(mt.count,Ot.start+Ot.count-mt.start):(++Lt,$e[Lt]=Ot)}$e.length=Lt+1;const wt=t.getParameter(t.UNPACK_ROW_LENGTH),Pt=t.getParameter(t.UNPACK_SKIP_PIXELS),Ht=t.getParameter(t.UNPACK_SKIP_ROWS);t.pixelStorei(t.UNPACK_ROW_LENGTH,H.width);for(let et=0,mt=$e.length;et<mt;et++){const Ot=$e[et],he=Math.floor(Ot.start/4),Me=Math.ceil(Ot.count/4),it=he%H.width,de=Math.floor(he/H.width),Ne=Me,nt=1;t.pixelStorei(t.UNPACK_SKIP_PIXELS,it),t.pixelStorei(t.UNPACK_SKIP_ROWS,de),n.texSubImage2D(t.TEXTURE_2D,0,it,de,Ne,nt,Ee,Oe,H.data)}re.clearUpdateRanges(),t.pixelStorei(t.UNPACK_ROW_LENGTH,wt),t.pixelStorei(t.UNPACK_SKIP_PIXELS,Pt),t.pixelStorei(t.UNPACK_SKIP_ROWS,Ht)}}function Ce(re,H,Ee){let Oe=t.TEXTURE_2D;(H.isDataArrayTexture||H.isCompressedArrayTexture)&&(Oe=t.TEXTURE_2D_ARRAY),H.isData3DTexture&&(Oe=t.TEXTURE_3D);const Xe=ge(re,H),$e=H.source;n.bindTexture(Oe,re.__webglTexture,t.TEXTURE0+Ee);const Lt=r.get($e);if($e.version!==Lt.__version||Xe===!0){n.activeTexture(t.TEXTURE0+Ee);const wt=Qn.getPrimaries(Qn.workingColorSpace),Pt=H.colorSpace===Jl?null:Qn.getPrimaries(H.colorSpace),Ht=H.colorSpace===Jl||wt===Pt?t.NONE:t.BROWSER_DEFAULT_WEBGL;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,H.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,H.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,H.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,Ht);let et=g(H.image,!1,i.maxTextureSize);et=At(H,et);const mt=s.convert(H.format,H.colorSpace),Ot=s.convert(H.type);let he=w(H.internalFormat,mt,Ot,H.colorSpace,H.isVideoTexture);le(Oe,H);let Me;const it=H.mipmaps,de=H.isVideoTexture!==!0,Ne=Lt.__version===void 0||Xe===!0,nt=$e.dataReady,Mt=S(H,et);if(H.isDepthTexture)he=_(H.format===By,H.type),Ne&&(de?n.texStorage2D(t.TEXTURE_2D,1,he,et.width,et.height):n.texImage2D(t.TEXTURE_2D,0,he,et.width,et.height,0,mt,Ot,null));else if(H.isDataTexture)if(it.length>0){de&&Ne&&n.texStorage2D(t.TEXTURE_2D,Mt,he,it[0].width,it[0].height);for(let ut=0,Ze=it.length;ut<Ze;ut++)Me=it[ut],de?nt&&n.texSubImage2D(t.TEXTURE_2D,ut,0,0,Me.width,Me.height,mt,Ot,Me.data):n.texImage2D(t.TEXTURE_2D,ut,he,Me.width,Me.height,0,mt,Ot,Me.data);H.generateMipmaps=!1}else de?(Ne&&n.texStorage2D(t.TEXTURE_2D,Mt,he,et.width,et.height),nt&&we(H,et,mt,Ot)):n.texImage2D(t.TEXTURE_2D,0,he,et.width,et.height,0,mt,Ot,et.data);else if(H.isCompressedTexture)if(H.isCompressedArrayTexture){de&&Ne&&n.texStorage3D(t.TEXTURE_2D_ARRAY,Mt,he,it[0].width,it[0].height,et.depth);for(let ut=0,Ze=it.length;ut<Ze;ut++)if(Me=it[ut],H.format!==ui)if(mt!==null)if(de){if(nt)if(H.layerUpdates.size>0){const kt=KR(Me.width,Me.height,H.format,H.type);for(const Se of H.layerUpdates){const qe=Me.data.subarray(Se*kt/Me.data.BYTES_PER_ELEMENT,(Se+1)*kt/Me.data.BYTES_PER_ELEMENT);n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY,ut,0,0,Se,Me.width,Me.height,1,mt,qe)}H.clearLayerUpdates()}else n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY,ut,0,0,0,Me.width,Me.height,et.depth,mt,Me.data)}else n.compressedTexImage3D(t.TEXTURE_2D_ARRAY,ut,he,Me.width,Me.height,et.depth,0,Me.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else de?nt&&n.texSubImage3D(t.TEXTURE_2D_ARRAY,ut,0,0,0,Me.width,Me.height,et.depth,mt,Ot,Me.data):n.texImage3D(t.TEXTURE_2D_ARRAY,ut,he,Me.width,Me.height,et.depth,0,mt,Ot,Me.data)}else{de&&Ne&&n.texStorage2D(t.TEXTURE_2D,Mt,he,it[0].width,it[0].height);for(let ut=0,Ze=it.length;ut<Ze;ut++)Me=it[ut],H.format!==ui?mt!==null?de?nt&&n.compressedTexSubImage2D(t.TEXTURE_2D,ut,0,0,Me.width,Me.height,mt,Me.data):n.compressedTexImage2D(t.TEXTURE_2D,ut,he,Me.width,Me.height,0,Me.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):de?nt&&n.texSubImage2D(t.TEXTURE_2D,ut,0,0,Me.width,Me.height,mt,Ot,Me.data):n.texImage2D(t.TEXTURE_2D,ut,he,Me.width,Me.height,0,mt,Ot,Me.data)}else if(H.isDataArrayTexture)if(de){if(Ne&&n.texStorage3D(t.TEXTURE_2D_ARRAY,Mt,he,et.width,et.height,et.depth),nt)if(H.layerUpdates.size>0){const ut=KR(et.width,et.height,H.format,H.type);for(const Ze of H.layerUpdates){const kt=et.data.subarray(Ze*ut/et.data.BYTES_PER_ELEMENT,(Ze+1)*ut/et.data.BYTES_PER_ELEMENT);n.texSubImage3D(t.TEXTURE_2D_ARRAY,0,0,0,Ze,et.width,et.height,1,mt,Ot,kt)}H.clearLayerUpdates()}else n.texSubImage3D(t.TEXTURE_2D_ARRAY,0,0,0,0,et.width,et.height,et.depth,mt,Ot,et.data)}else n.texImage3D(t.TEXTURE_2D_ARRAY,0,he,et.width,et.height,et.depth,0,mt,Ot,et.data);else if(H.isData3DTexture)de?(Ne&&n.texStorage3D(t.TEXTURE_3D,Mt,he,et.width,et.height,et.depth),nt&&n.texSubImage3D(t.TEXTURE_3D,0,0,0,0,et.width,et.height,et.depth,mt,Ot,et.data)):n.texImage3D(t.TEXTURE_3D,0,he,et.width,et.height,et.depth,0,mt,Ot,et.data);else if(H.isFramebufferTexture){if(Ne)if(de)n.texStorage2D(t.TEXTURE_2D,Mt,he,et.width,et.height);else{let ut=et.width,Ze=et.height;for(let kt=0;kt<Mt;kt++)n.texImage2D(t.TEXTURE_2D,kt,he,ut,Ze,0,mt,Ot,null),ut>>=1,Ze>>=1}}else if(it.length>0){if(de&&Ne){const ut=Vt(it[0]);n.texStorage2D(t.TEXTURE_2D,Mt,he,ut.width,ut.height)}for(let ut=0,Ze=it.length;ut<Ze;ut++)Me=it[ut],de?nt&&n.texSubImage2D(t.TEXTURE_2D,ut,0,0,mt,Ot,Me):n.texImage2D(t.TEXTURE_2D,ut,he,mt,Ot,Me);H.generateMipmaps=!1}else if(de){if(Ne){const ut=Vt(et);n.texStorage2D(t.TEXTURE_2D,Mt,he,ut.width,ut.height)}nt&&n.texSubImage2D(t.TEXTURE_2D,0,0,0,mt,Ot,et)}else n.texImage2D(t.TEXTURE_2D,0,he,mt,Ot,et);y(H)&&m(Oe),Lt.__version=$e.version,H.onUpdate&&H.onUpdate(H)}re.__version=H.version}function Re(re,H,Ee){if(H.image.length!==6)return;const Oe=ge(re,H),Xe=H.source;n.bindTexture(t.TEXTURE_CUBE_MAP,re.__webglTexture,t.TEXTURE0+Ee);const $e=r.get(Xe);if(Xe.version!==$e.__version||Oe===!0){n.activeTexture(t.TEXTURE0+Ee);const Lt=Qn.getPrimaries(Qn.workingColorSpace),wt=H.colorSpace===Jl?null:Qn.getPrimaries(H.colorSpace),Pt=H.colorSpace===Jl||Lt===wt?t.NONE:t.BROWSER_DEFAULT_WEBGL;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,H.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,H.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,H.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,Pt);const Ht=H.isCompressedTexture||H.image[0].isCompressedTexture,et=H.image[0]&&H.image[0].isDataTexture,mt=[];for(let Ze=0;Ze<6;Ze++)!Ht&&!et?mt[Ze]=g(H.image[Ze],!0,i.maxCubemapSize):mt[Ze]=et?H.image[Ze].image:H.image[Ze],mt[Ze]=At(H,mt[Ze]);const Ot=mt[0],he=s.convert(H.format,H.colorSpace),Me=s.convert(H.type),it=w(H.internalFormat,he,Me,H.colorSpace),de=H.isVideoTexture!==!0,Ne=$e.__version===void 0||Oe===!0,nt=Xe.dataReady;let Mt=S(H,Ot);le(t.TEXTURE_CUBE_MAP,H);let ut;if(Ht){de&&Ne&&n.texStorage2D(t.TEXTURE_CUBE_MAP,Mt,it,Ot.width,Ot.height);for(let Ze=0;Ze<6;Ze++){ut=mt[Ze].mipmaps;for(let kt=0;kt<ut.length;kt++){const Se=ut[kt];H.format!==ui?he!==null?de?nt&&n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,kt,0,0,Se.width,Se.height,he,Se.data):n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,kt,it,Se.width,Se.height,0,Se.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):de?nt&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,kt,0,0,Se.width,Se.height,he,Me,Se.data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,kt,it,Se.width,Se.height,0,he,Me,Se.data)}}}else{if(ut=H.mipmaps,de&&Ne){ut.length>0&&Mt++;const Ze=Vt(mt[0]);n.texStorage2D(t.TEXTURE_CUBE_MAP,Mt,it,Ze.width,Ze.height)}for(let Ze=0;Ze<6;Ze++)if(et){de?nt&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,0,0,0,mt[Ze].width,mt[Ze].height,he,Me,mt[Ze].data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,0,it,mt[Ze].width,mt[Ze].height,0,he,Me,mt[Ze].data);for(let kt=0;kt<ut.length;kt++){const qe=ut[kt].image[Ze].image;de?nt&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,kt+1,0,0,qe.width,qe.height,he,Me,qe.data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,kt+1,it,qe.width,qe.height,0,he,Me,qe.data)}}else{de?nt&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,0,0,0,he,Me,mt[Ze]):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,0,it,he,Me,mt[Ze]);for(let kt=0;kt<ut.length;kt++){const Se=ut[kt];de?nt&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,kt+1,0,0,he,Me,Se.image[Ze]):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,kt+1,it,he,Me,Se.image[Ze])}}}y(H)&&m(t.TEXTURE_CUBE_MAP),$e.__version=Xe.version,H.onUpdate&&H.onUpdate(H)}re.__version=H.version}function Le(re,H,Ee,Oe,Xe,$e){const Lt=s.convert(Ee.format,Ee.colorSpace),wt=s.convert(Ee.type),Pt=w(Ee.internalFormat,Lt,wt,Ee.colorSpace),Ht=r.get(H),et=r.get(Ee);if(et.__renderTarget=H,!Ht.__hasExternalTextures){const mt=Math.max(1,H.width>>$e),Ot=Math.max(1,H.height>>$e);Xe===t.TEXTURE_3D||Xe===t.TEXTURE_2D_ARRAY?n.texImage3D(Xe,$e,Pt,mt,Ot,H.depth,0,Lt,wt,null):n.texImage2D(Xe,$e,Pt,mt,Ot,0,Lt,wt,null)}n.bindFramebuffer(t.FRAMEBUFFER,re),St(H)?o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,Oe,Xe,et.__webglTexture,0,Ue(H)):(Xe===t.TEXTURE_2D||Xe>=t.TEXTURE_CUBE_MAP_POSITIVE_X&&Xe<=t.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&t.framebufferTexture2D(t.FRAMEBUFFER,Oe,Xe,et.__webglTexture,$e),n.bindFramebuffer(t.FRAMEBUFFER,null)}function lt(re,H,Ee){if(t.bindRenderbuffer(t.RENDERBUFFER,re),H.depthBuffer){const Oe=H.depthTexture,Xe=Oe&&Oe.isDepthTexture?Oe.type:null,$e=_(H.stencilBuffer,Xe),Lt=H.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,wt=Ue(H);St(H)?o.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,wt,$e,H.width,H.height):Ee?t.renderbufferStorageMultisample(t.RENDERBUFFER,wt,$e,H.width,H.height):t.renderbufferStorage(t.RENDERBUFFER,$e,H.width,H.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,Lt,t.RENDERBUFFER,re)}else{const Oe=H.textures;for(let Xe=0;Xe<Oe.length;Xe++){const $e=Oe[Xe],Lt=s.convert($e.format,$e.colorSpace),wt=s.convert($e.type),Pt=w($e.internalFormat,Lt,wt,$e.colorSpace),Ht=Ue(H);Ee&&St(H)===!1?t.renderbufferStorageMultisample(t.RENDERBUFFER,Ht,Pt,H.width,H.height):St(H)?o.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,Ht,Pt,H.width,H.height):t.renderbufferStorage(t.RENDERBUFFER,Pt,H.width,H.height)}}t.bindRenderbuffer(t.RENDERBUFFER,null)}function st(re,H){if(H&&H.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(t.FRAMEBUFFER,re),!(H.depthTexture&&H.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const Oe=r.get(H.depthTexture);Oe.__renderTarget=H,(!Oe.__webglTexture||H.depthTexture.image.width!==H.width||H.depthTexture.image.height!==H.height)&&(H.depthTexture.image.width=H.width,H.depthTexture.image.height=H.height,H.depthTexture.needsUpdate=!0),V(H.depthTexture,0);const Xe=Oe.__webglTexture,$e=Ue(H);if(H.depthTexture.format===Oy)St(H)?o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,Xe,0,$e):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,Xe,0);else if(H.depthTexture.format===By)St(H)?o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,Xe,0,$e):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,Xe,0);else throw new Error("Unknown depthTexture format")}function Et(re){const H=r.get(re),Ee=re.isWebGLCubeRenderTarget===!0;if(H.__boundDepthTexture!==re.depthTexture){const Oe=re.depthTexture;if(H.__depthDisposeCallback&&H.__depthDisposeCallback(),Oe){const Xe=()=>{delete H.__boundDepthTexture,delete H.__depthDisposeCallback,Oe.removeEventListener("dispose",Xe)};Oe.addEventListener("dispose",Xe),H.__depthDisposeCallback=Xe}H.__boundDepthTexture=Oe}if(re.depthTexture&&!H.__autoAllocateDepthBuffer){if(Ee)throw new Error("target.depthTexture not supported in Cube render targets");const Oe=re.texture.mipmaps;Oe&&Oe.length>0?st(H.__webglFramebuffer[0],re):st(H.__webglFramebuffer,re)}else if(Ee){H.__webglDepthbuffer=[];for(let Oe=0;Oe<6;Oe++)if(n.bindFramebuffer(t.FRAMEBUFFER,H.__webglFramebuffer[Oe]),H.__webglDepthbuffer[Oe]===void 0)H.__webglDepthbuffer[Oe]=t.createRenderbuffer(),lt(H.__webglDepthbuffer[Oe],re,!1);else{const Xe=re.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,$e=H.__webglDepthbuffer[Oe];t.bindRenderbuffer(t.RENDERBUFFER,$e),t.framebufferRenderbuffer(t.FRAMEBUFFER,Xe,t.RENDERBUFFER,$e)}}else{const Oe=re.texture.mipmaps;if(Oe&&Oe.length>0?n.bindFramebuffer(t.FRAMEBUFFER,H.__webglFramebuffer[0]):n.bindFramebuffer(t.FRAMEBUFFER,H.__webglFramebuffer),H.__webglDepthbuffer===void 0)H.__webglDepthbuffer=t.createRenderbuffer(),lt(H.__webglDepthbuffer,re,!1);else{const Xe=re.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,$e=H.__webglDepthbuffer;t.bindRenderbuffer(t.RENDERBUFFER,$e),t.framebufferRenderbuffer(t.FRAMEBUFFER,Xe,t.RENDERBUFFER,$e)}}n.bindFramebuffer(t.FRAMEBUFFER,null)}function Tt(re,H,Ee){const Oe=r.get(re);H!==void 0&&Le(Oe.__webglFramebuffer,re,re.texture,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,0),Ee!==void 0&&Et(re)}function xt(re){const H=re.texture,Ee=r.get(re),Oe=r.get(H);re.addEventListener("dispose",C);const Xe=re.textures,$e=re.isWebGLCubeRenderTarget===!0,Lt=Xe.length>1;if(Lt||(Oe.__webglTexture===void 0&&(Oe.__webglTexture=t.createTexture()),Oe.__version=H.version,a.memory.textures++),$e){Ee.__webglFramebuffer=[];for(let wt=0;wt<6;wt++)if(H.mipmaps&&H.mipmaps.length>0){Ee.__webglFramebuffer[wt]=[];for(let Pt=0;Pt<H.mipmaps.length;Pt++)Ee.__webglFramebuffer[wt][Pt]=t.createFramebuffer()}else Ee.__webglFramebuffer[wt]=t.createFramebuffer()}else{if(H.mipmaps&&H.mipmaps.length>0){Ee.__webglFramebuffer=[];for(let wt=0;wt<H.mipmaps.length;wt++)Ee.__webglFramebuffer[wt]=t.createFramebuffer()}else Ee.__webglFramebuffer=t.createFramebuffer();if(Lt)for(let wt=0,Pt=Xe.length;wt<Pt;wt++){const Ht=r.get(Xe[wt]);Ht.__webglTexture===void 0&&(Ht.__webglTexture=t.createTexture(),a.memory.textures++)}if(re.samples>0&&St(re)===!1){Ee.__webglMultisampledFramebuffer=t.createFramebuffer(),Ee.__webglColorRenderbuffer=[],n.bindFramebuffer(t.FRAMEBUFFER,Ee.__webglMultisampledFramebuffer);for(let wt=0;wt<Xe.length;wt++){const Pt=Xe[wt];Ee.__webglColorRenderbuffer[wt]=t.createRenderbuffer(),t.bindRenderbuffer(t.RENDERBUFFER,Ee.__webglColorRenderbuffer[wt]);const Ht=s.convert(Pt.format,Pt.colorSpace),et=s.convert(Pt.type),mt=w(Pt.internalFormat,Ht,et,Pt.colorSpace,re.isXRRenderTarget===!0),Ot=Ue(re);t.renderbufferStorageMultisample(t.RENDERBUFFER,Ot,mt,re.width,re.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+wt,t.RENDERBUFFER,Ee.__webglColorRenderbuffer[wt])}t.bindRenderbuffer(t.RENDERBUFFER,null),re.depthBuffer&&(Ee.__webglDepthRenderbuffer=t.createRenderbuffer(),lt(Ee.__webglDepthRenderbuffer,re,!0)),n.bindFramebuffer(t.FRAMEBUFFER,null)}}if($e){n.bindTexture(t.TEXTURE_CUBE_MAP,Oe.__webglTexture),le(t.TEXTURE_CUBE_MAP,H);for(let wt=0;wt<6;wt++)if(H.mipmaps&&H.mipmaps.length>0)for(let Pt=0;Pt<H.mipmaps.length;Pt++)Le(Ee.__webglFramebuffer[wt][Pt],re,H,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+wt,Pt);else Le(Ee.__webglFramebuffer[wt],re,H,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+wt,0);y(H)&&m(t.TEXTURE_CUBE_MAP),n.unbindTexture()}else if(Lt){for(let wt=0,Pt=Xe.length;wt<Pt;wt++){const Ht=Xe[wt],et=r.get(Ht);n.bindTexture(t.TEXTURE_2D,et.__webglTexture),le(t.TEXTURE_2D,Ht),Le(Ee.__webglFramebuffer,re,Ht,t.COLOR_ATTACHMENT0+wt,t.TEXTURE_2D,0),y(Ht)&&m(t.TEXTURE_2D)}n.unbindTexture()}else{let wt=t.TEXTURE_2D;if((re.isWebGL3DRenderTarget||re.isWebGLArrayRenderTarget)&&(wt=re.isWebGL3DRenderTarget?t.TEXTURE_3D:t.TEXTURE_2D_ARRAY),n.bindTexture(wt,Oe.__webglTexture),le(wt,H),H.mipmaps&&H.mipmaps.length>0)for(let Pt=0;Pt<H.mipmaps.length;Pt++)Le(Ee.__webglFramebuffer[Pt],re,H,t.COLOR_ATTACHMENT0,wt,Pt);else Le(Ee.__webglFramebuffer,re,H,t.COLOR_ATTACHMENT0,wt,0);y(H)&&m(wt),n.unbindTexture()}re.depthBuffer&&Et(re)}function J(re){const H=re.textures;for(let Ee=0,Oe=H.length;Ee<Oe;Ee++){const Xe=H[Ee];if(y(Xe)){const $e=b(re),Lt=r.get(Xe).__webglTexture;n.bindTexture($e,Lt),m($e),n.unbindTexture()}}}const Ye=[],Be=[];function tt(re){if(re.samples>0){if(St(re)===!1){const H=re.textures,Ee=re.width,Oe=re.height;let Xe=t.COLOR_BUFFER_BIT;const $e=re.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,Lt=r.get(re),wt=H.length>1;if(wt)for(let Ht=0;Ht<H.length;Ht++)n.bindFramebuffer(t.FRAMEBUFFER,Lt.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+Ht,t.RENDERBUFFER,null),n.bindFramebuffer(t.FRAMEBUFFER,Lt.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+Ht,t.TEXTURE_2D,null,0);n.bindFramebuffer(t.READ_FRAMEBUFFER,Lt.__webglMultisampledFramebuffer);const Pt=re.texture.mipmaps;Pt&&Pt.length>0?n.bindFramebuffer(t.DRAW_FRAMEBUFFER,Lt.__webglFramebuffer[0]):n.bindFramebuffer(t.DRAW_FRAMEBUFFER,Lt.__webglFramebuffer);for(let Ht=0;Ht<H.length;Ht++){if(re.resolveDepthBuffer&&(re.depthBuffer&&(Xe|=t.DEPTH_BUFFER_BIT),re.stencilBuffer&&re.resolveStencilBuffer&&(Xe|=t.STENCIL_BUFFER_BIT)),wt){t.framebufferRenderbuffer(t.READ_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.RENDERBUFFER,Lt.__webglColorRenderbuffer[Ht]);const et=r.get(H[Ht]).__webglTexture;t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,et,0)}t.blitFramebuffer(0,0,Ee,Oe,0,0,Ee,Oe,Xe,t.NEAREST),l===!0&&(Ye.length=0,Be.length=0,Ye.push(t.COLOR_ATTACHMENT0+Ht),re.depthBuffer&&re.resolveDepthBuffer===!1&&(Ye.push($e),Be.push($e),t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER,Be)),t.invalidateFramebuffer(t.READ_FRAMEBUFFER,Ye))}if(n.bindFramebuffer(t.READ_FRAMEBUFFER,null),n.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),wt)for(let Ht=0;Ht<H.length;Ht++){n.bindFramebuffer(t.FRAMEBUFFER,Lt.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+Ht,t.RENDERBUFFER,Lt.__webglColorRenderbuffer[Ht]);const et=r.get(H[Ht]).__webglTexture;n.bindFramebuffer(t.FRAMEBUFFER,Lt.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+Ht,t.TEXTURE_2D,et,0)}n.bindFramebuffer(t.DRAW_FRAMEBUFFER,Lt.__webglMultisampledFramebuffer)}else if(re.depthBuffer&&re.resolveDepthBuffer===!1&&l){const H=re.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT;t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER,[H])}}}function Ue(re){return Math.min(i.maxSamples,re.samples)}function St(re){const H=r.get(re);return re.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&H.__useRenderToTexture!==!1}function Je(re){const H=a.render.frame;c.get(re)!==H&&(c.set(re,H),re.update())}function At(re,H){const Ee=re.colorSpace,Oe=re.format,Xe=re.type;return re.isCompressedTexture===!0||re.isVideoTexture===!0||Ee!==du&&Ee!==Jl&&(Qn.getTransfer(Ee)===yr?(Oe!==ui||Xe!==la)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",Ee)),H}function Vt(re){return typeof HTMLImageElement<"u"&&re instanceof HTMLImageElement?(u.width=re.naturalWidth||re.width,u.height=re.naturalHeight||re.height):typeof VideoFrame<"u"&&re instanceof VideoFrame?(u.width=re.displayWidth,u.height=re.displayHeight):(u.width=re.width,u.height=re.height),u}this.allocateTextureUnit=B,this.resetTextureUnits=N,this.setTexture2D=V,this.setTexture2DArray=K,this.setTexture3D=Q,this.setTextureCube=O,this.rebindTextures=Tt,this.setupRenderTarget=xt,this.updateRenderTargetMipmap=J,this.updateMultisampleRenderTarget=tt,this.setupDepthRenderbuffer=Et,this.setupFrameBufferTexture=Le,this.useMultisampledRTT=St}function uX(t,e){function n(r,i=Jl){let s;const a=Qn.getTransfer(i);if(r===la)return t.UNSIGNED_BYTE;if(r===AT)return t.UNSIGNED_SHORT_4_4_4_4;if(r===ET)return t.UNSIGNED_SHORT_5_5_5_1;if(r===yP)return t.UNSIGNED_INT_5_9_9_9_REV;if(r===_T)return t.BYTE;if(r===ST)return t.SHORT;if(r===Py)return t.UNSIGNED_SHORT;if(r===z1)return t.INT;if(r===cu)return t.UNSIGNED_INT;if(r===ti)return t.FLOAT;if(r===Wi)return t.HALF_FLOAT;if(r===vP)return t.ALPHA;if(r===xP)return t.RGB;if(r===ui)return t.RGBA;if(r===Oy)return t.DEPTH_COMPONENT;if(r===By)return t.DEPTH_STENCIL;if(r===G1)return t.RED;if(r===H1)return t.RED_INTEGER;if(r===bP)return t.RG;if(r===IT)return t.RG_INTEGER;if(r===TT)return t.RGBA_INTEGER;if(r===xb||r===bb||r===wb||r===_b)if(a===yr)if(s=e.get("WEBGL_compressed_texture_s3tc_srgb"),s!==null){if(r===xb)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(r===bb)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(r===wb)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(r===_b)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(s=e.get("WEBGL_compressed_texture_s3tc"),s!==null){if(r===xb)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(r===bb)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(r===wb)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(r===_b)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(r===WE||r===VE||r===jE||r===XE)if(s=e.get("WEBGL_compressed_texture_pvrtc"),s!==null){if(r===WE)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(r===VE)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(r===jE)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(r===XE)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(r===KE||r===qE||r===JE)if(s=e.get("WEBGL_compressed_texture_etc"),s!==null){if(r===KE||r===qE)return a===yr?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(r===JE)return a===yr?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(r===YE||r===ZE||r===QE||r===eI||r===tI||r===nI||r===rI||r===iI||r===sI||r===aI||r===oI||r===lI||r===uI||r===cI)if(s=e.get("WEBGL_compressed_texture_astc"),s!==null){if(r===YE)return a===yr?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(r===ZE)return a===yr?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(r===QE)return a===yr?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(r===eI)return a===yr?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(r===tI)return a===yr?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(r===nI)return a===yr?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(r===rI)return a===yr?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(r===iI)return a===yr?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(r===sI)return a===yr?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(r===aI)return a===yr?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(r===oI)return a===yr?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(r===lI)return a===yr?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(r===uI)return a===yr?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(r===cI)return a===yr?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(r===Sb||r===dI||r===hI)if(s=e.get("EXT_texture_compression_bptc"),s!==null){if(r===Sb)return a===yr?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(r===dI)return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(r===hI)return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(r===wP||r===pI||r===fI||r===mI)if(s=e.get("EXT_texture_compression_rgtc"),s!==null){if(r===Sb)return s.COMPRESSED_RED_RGTC1_EXT;if(r===pI)return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(r===fI)return s.COMPRESSED_RED_GREEN_RGTC2_EXT;if(r===mI)return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return r===Ly?t.UNSIGNED_INT_24_8:t[r]!==void 0?t[r]:null}return{convert:n}}const Mge=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,kge=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class Nge{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,n,r){if(this.texture===null){const i=new hr,s=e.properties.get(i);s.__webglTexture=n.texture,(n.depthNear!==r.depthNear||n.depthFar!==r.depthFar)&&(this.depthNear=n.depthNear,this.depthFar=n.depthFar),this.texture=i}}getMesh(e){if(this.texture!==null&&this.mesh===null){const n=e.cameras[0].viewport,r=new ua({vertexShader:Mge,fragmentShader:kge,uniforms:{depthColor:{value:this.texture},depthWidth:{value:n.z},depthHeight:{value:n.w}}});this.mesh=new Cr(new yu(20,20),r)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class Rge extends gu{constructor(e,n){super();const r=this;let i=null,s=1,a=null,o="local-floor",l=1,u=null,c=null,d=null,h=null,p=null,f=null;const g=new Nge,y=n.getContextAttributes();let m=null,b=null;const w=[],_=[],S=new Qe;let E=null;const C=new Qr;C.viewport=new Xn;const T=new Qr;T.viewport=new Xn;const M=[C,T],k=new Q9;let R=null,N=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(ie){let we=w[ie];return we===void 0&&(we=new KA,w[ie]=we),we.getTargetRaySpace()},this.getControllerGrip=function(ie){let we=w[ie];return we===void 0&&(we=new KA,w[ie]=we),we.getGripSpace()},this.getHand=function(ie){let we=w[ie];return we===void 0&&(we=new KA,w[ie]=we),we.getHandSpace()};function B(ie){const we=_.indexOf(ie.inputSource);if(we===-1)return;const Ce=w[we];Ce!==void 0&&(Ce.update(ie.inputSource,ie.frame,u||a),Ce.dispatchEvent({type:ie.type,data:ie.inputSource}))}function z(){i.removeEventListener("select",B),i.removeEventListener("selectstart",B),i.removeEventListener("selectend",B),i.removeEventListener("squeeze",B),i.removeEventListener("squeezestart",B),i.removeEventListener("squeezeend",B),i.removeEventListener("end",z),i.removeEventListener("inputsourceschange",V);for(let ie=0;ie<w.length;ie++){const we=_[ie];we!==null&&(_[ie]=null,w[ie].disconnect(we))}R=null,N=null,g.reset(),e.setRenderTarget(m),p=null,h=null,d=null,i=null,b=null,ge.stop(),r.isPresenting=!1,e.setPixelRatio(E),e.setSize(S.width,S.height,!1),r.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(ie){s=ie,r.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(ie){o=ie,r.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return u||a},this.setReferenceSpace=function(ie){u=ie},this.getBaseLayer=function(){return h!==null?h:p},this.getBinding=function(){return d},this.getFrame=function(){return f},this.getSession=function(){return i},this.setSession=async function(ie){if(i=ie,i!==null){if(m=e.getRenderTarget(),i.addEventListener("select",B),i.addEventListener("selectstart",B),i.addEventListener("selectend",B),i.addEventListener("squeeze",B),i.addEventListener("squeezestart",B),i.addEventListener("squeezeend",B),i.addEventListener("end",z),i.addEventListener("inputsourceschange",V),y.xrCompatible!==!0&&await n.makeXRCompatible(),E=e.getPixelRatio(),e.getSize(S),typeof XRWebGLBinding<"u"&&"createProjectionLayer"in XRWebGLBinding.prototype){let Ce=null,Re=null,Le=null;y.depth&&(Le=y.stencil?n.DEPTH24_STENCIL8:n.DEPTH_COMPONENT24,Ce=y.stencil?By:Oy,Re=y.stencil?Ly:cu);const lt={colorFormat:n.RGBA8,depthFormat:Le,scaleFactor:s};d=new XRWebGLBinding(i,n),h=d.createProjectionLayer(lt),i.updateRenderState({layers:[h]}),e.setPixelRatio(1),e.setSize(h.textureWidth,h.textureHeight,!1),b=new Oa(h.textureWidth,h.textureHeight,{format:ui,type:la,depthTexture:new OP(h.textureWidth,h.textureHeight,Re,void 0,void 0,void 0,void 0,void 0,void 0,Ce),stencilBuffer:y.stencil,colorSpace:e.outputColorSpace,samples:y.antialias?4:0,resolveDepthBuffer:h.ignoreDepthValues===!1,resolveStencilBuffer:h.ignoreDepthValues===!1})}else{const Ce={antialias:y.antialias,alpha:!0,depth:y.depth,stencil:y.stencil,framebufferScaleFactor:s};p=new XRWebGLLayer(i,n,Ce),i.updateRenderState({baseLayer:p}),e.setPixelRatio(1),e.setSize(p.framebufferWidth,p.framebufferHeight,!1),b=new Oa(p.framebufferWidth,p.framebufferHeight,{format:ui,type:la,colorSpace:e.outputColorSpace,stencilBuffer:y.stencil,resolveDepthBuffer:p.ignoreDepthValues===!1,resolveStencilBuffer:p.ignoreDepthValues===!1})}b.isXRRenderTarget=!0,this.setFoveation(l),u=null,a=await i.requestReferenceSpace(o),ge.setContext(i),ge.start(),r.isPresenting=!0,r.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode},this.getDepthTexture=function(){return g.getDepthTexture()};function V(ie){for(let we=0;we<ie.removed.length;we++){const Ce=ie.removed[we],Re=_.indexOf(Ce);Re>=0&&(_[Re]=null,w[Re].disconnect(Ce))}for(let we=0;we<ie.added.length;we++){const Ce=ie.added[we];let Re=_.indexOf(Ce);if(Re===-1){for(let lt=0;lt<w.length;lt++)if(lt>=_.length){_.push(Ce),Re=lt;break}else if(_[lt]===null){_[lt]=Ce,Re=lt;break}if(Re===-1)break}const Le=w[Re];Le&&Le.connect(Ce)}}const K=new Z,Q=new Z;function O(ie,we,Ce){K.setFromMatrixPosition(we.matrixWorld),Q.setFromMatrixPosition(Ce.matrixWorld);const Re=K.distanceTo(Q),Le=we.projectionMatrix.elements,lt=Ce.projectionMatrix.elements,st=Le[14]/(Le[10]-1),Et=Le[14]/(Le[10]+1),Tt=(Le[9]+1)/Le[5],xt=(Le[9]-1)/Le[5],J=(Le[8]-1)/Le[0],Ye=(lt[8]+1)/lt[0],Be=st*J,tt=st*Ye,Ue=Re/(-J+Ye),St=Ue*-J;if(we.matrixWorld.decompose(ie.position,ie.quaternion,ie.scale),ie.translateX(St),ie.translateZ(Ue),ie.matrixWorld.compose(ie.position,ie.quaternion,ie.scale),ie.matrixWorldInverse.copy(ie.matrixWorld).invert(),Le[10]===-1)ie.projectionMatrix.copy(we.projectionMatrix),ie.projectionMatrixInverse.copy(we.projectionMatrixInverse);else{const Je=st+Ue,At=Et+Ue,Vt=Be-St,re=tt+(Re-St),H=Tt*Et/At*Je,Ee=xt*Et/At*Je;ie.projectionMatrix.makePerspective(Vt,re,H,Ee,Je,At),ie.projectionMatrixInverse.copy(ie.projectionMatrix).invert()}}function j(ie,we){we===null?ie.matrixWorld.copy(ie.matrix):ie.matrixWorld.multiplyMatrices(we.matrixWorld,ie.matrix),ie.matrixWorldInverse.copy(ie.matrixWorld).invert()}this.updateCamera=function(ie){if(i===null)return;let we=ie.near,Ce=ie.far;g.texture!==null&&(g.depthNear>0&&(we=g.depthNear),g.depthFar>0&&(Ce=g.depthFar)),k.near=T.near=C.near=we,k.far=T.far=C.far=Ce,(R!==k.near||N!==k.far)&&(i.updateRenderState({depthNear:k.near,depthFar:k.far}),R=k.near,N=k.far),C.layers.mask=ie.layers.mask|2,T.layers.mask=ie.layers.mask|4,k.layers.mask=C.layers.mask|T.layers.mask;const Re=ie.parent,Le=k.cameras;j(k,Re);for(let lt=0;lt<Le.length;lt++)j(Le[lt],Re);Le.length===2?O(k,C,T):k.projectionMatrix.copy(C.projectionMatrix),X(ie,k,Re)};function X(ie,we,Ce){Ce===null?ie.matrix.copy(we.matrixWorld):(ie.matrix.copy(Ce.matrixWorld),ie.matrix.invert(),ie.matrix.multiply(we.matrixWorld)),ie.matrix.decompose(ie.position,ie.quaternion,ie.scale),ie.updateMatrixWorld(!0),ie.projectionMatrix.copy(we.projectionMatrix),ie.projectionMatrixInverse.copy(we.projectionMatrixInverse),ie.isPerspectiveCamera&&(ie.fov=Uy*2*Math.atan(1/ie.projectionMatrix.elements[5]),ie.zoom=1)}this.getCamera=function(){return k},this.getFoveation=function(){if(!(h===null&&p===null))return l},this.setFoveation=function(ie){l=ie,h!==null&&(h.fixedFoveation=ie),p!==null&&p.fixedFoveation!==void 0&&(p.fixedFoveation=ie)},this.hasDepthSensing=function(){return g.texture!==null},this.getDepthSensingMesh=function(){return g.getMesh(k)};let te=null;function le(ie,we){if(c=we.getViewerPose(u||a),f=we,c!==null){const Ce=c.views;p!==null&&(e.setRenderTargetFramebuffer(b,p.framebuffer),e.setRenderTarget(b));let Re=!1;Ce.length!==k.cameras.length&&(k.cameras.length=0,Re=!0);for(let st=0;st<Ce.length;st++){const Et=Ce[st];let Tt=null;if(p!==null)Tt=p.getViewport(Et);else{const J=d.getViewSubImage(h,Et);Tt=J.viewport,st===0&&(e.setRenderTargetTextures(b,J.colorTexture,J.depthStencilTexture),e.setRenderTarget(b))}let xt=M[st];xt===void 0&&(xt=new Qr,xt.layers.enable(st),xt.viewport=new Xn,M[st]=xt),xt.matrix.fromArray(Et.transform.matrix),xt.matrix.decompose(xt.position,xt.quaternion,xt.scale),xt.projectionMatrix.fromArray(Et.projectionMatrix),xt.projectionMatrixInverse.copy(xt.projectionMatrix).invert(),xt.viewport.set(Tt.x,Tt.y,Tt.width,Tt.height),st===0&&(k.matrix.copy(xt.matrix),k.matrix.decompose(k.position,k.quaternion,k.scale)),Re===!0&&k.cameras.push(xt)}const Le=i.enabledFeatures;if(Le&&Le.includes("depth-sensing")&&i.depthUsage=="gpu-optimized"&&d){const st=d.getDepthInformation(Ce[0]);st&&st.isValid&&st.texture&&g.init(e,st,i.renderState)}}for(let Ce=0;Ce<w.length;Ce++){const Re=_[Ce],Le=w[Ce];Re!==null&&Le!==void 0&&Le.update(Re,we,u||a)}te&&te(ie,we),we.detectedPlanes&&r.dispatchEvent({type:"planesdetected",data:we}),f=null}const ge=new iX;ge.setAnimationLoop(le),this.setAnimationLoop=function(ie){te=ie},this.dispose=function(){}}}const $h=new Ba,Fge=new ln;function Dge(t,e){function n(y,m){y.matrixAutoUpdate===!0&&y.updateMatrix(),m.value.copy(y.matrix)}function r(y,m){m.color.getRGB(y.fogColor.value,f9(t)),m.isFog?(y.fogNear.value=m.near,y.fogFar.value=m.far):m.isFogExp2&&(y.fogDensity.value=m.density)}function i(y,m,b,w,_){m.isMeshBasicMaterial||m.isMeshLambertMaterial?s(y,m):m.isMeshToonMaterial?(s(y,m),d(y,m)):m.isMeshPhongMaterial?(s(y,m),c(y,m)):m.isMeshStandardMaterial?(s(y,m),h(y,m),m.isMeshPhysicalMaterial&&p(y,m,_)):m.isMeshMatcapMaterial?(s(y,m),f(y,m)):m.isMeshDepthMaterial?s(y,m):m.isMeshDistanceMaterial?(s(y,m),g(y,m)):m.isMeshNormalMaterial?s(y,m):m.isLineBasicMaterial?(a(y,m),m.isLineDashedMaterial&&o(y,m)):m.isPointsMaterial?l(y,m,b,w):m.isSpriteMaterial?u(y,m):m.isShadowMaterial?(y.color.value.copy(m.color),y.opacity.value=m.opacity):m.isShaderMaterial&&(m.uniformsNeedUpdate=!1)}function s(y,m){y.opacity.value=m.opacity,m.color&&y.diffuse.value.copy(m.color),m.emissive&&y.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity),m.map&&(y.map.value=m.map,n(m.map,y.mapTransform)),m.alphaMap&&(y.alphaMap.value=m.alphaMap,n(m.alphaMap,y.alphaMapTransform)),m.bumpMap&&(y.bumpMap.value=m.bumpMap,n(m.bumpMap,y.bumpMapTransform),y.bumpScale.value=m.bumpScale,m.side===sa&&(y.bumpScale.value*=-1)),m.normalMap&&(y.normalMap.value=m.normalMap,n(m.normalMap,y.normalMapTransform),y.normalScale.value.copy(m.normalScale),m.side===sa&&y.normalScale.value.negate()),m.displacementMap&&(y.displacementMap.value=m.displacementMap,n(m.displacementMap,y.displacementMapTransform),y.displacementScale.value=m.displacementScale,y.displacementBias.value=m.displacementBias),m.emissiveMap&&(y.emissiveMap.value=m.emissiveMap,n(m.emissiveMap,y.emissiveMapTransform)),m.specularMap&&(y.specularMap.value=m.specularMap,n(m.specularMap,y.specularMapTransform)),m.alphaTest>0&&(y.alphaTest.value=m.alphaTest);const b=e.get(m),w=b.envMap,_=b.envMapRotation;w&&(y.envMap.value=w,$h.copy(_),$h.x*=-1,$h.y*=-1,$h.z*=-1,w.isCubeTexture&&w.isRenderTargetTexture===!1&&($h.y*=-1,$h.z*=-1),y.envMapRotation.value.setFromMatrix4(Fge.makeRotationFromEuler($h)),y.flipEnvMap.value=w.isCubeTexture&&w.isRenderTargetTexture===!1?-1:1,y.reflectivity.value=m.reflectivity,y.ior.value=m.ior,y.refractionRatio.value=m.refractionRatio),m.lightMap&&(y.lightMap.value=m.lightMap,y.lightMapIntensity.value=m.lightMapIntensity,n(m.lightMap,y.lightMapTransform)),m.aoMap&&(y.aoMap.value=m.aoMap,y.aoMapIntensity.value=m.aoMapIntensity,n(m.aoMap,y.aoMapTransform))}function a(y,m){y.diffuse.value.copy(m.color),y.opacity.value=m.opacity,m.map&&(y.map.value=m.map,n(m.map,y.mapTransform))}function o(y,m){y.dashSize.value=m.dashSize,y.totalSize.value=m.dashSize+m.gapSize,y.scale.value=m.scale}function l(y,m,b,w){y.diffuse.value.copy(m.color),y.opacity.value=m.opacity,y.size.value=m.size*b,y.scale.value=w*.5,m.map&&(y.map.value=m.map,n(m.map,y.uvTransform)),m.alphaMap&&(y.alphaMap.value=m.alphaMap,n(m.alphaMap,y.alphaMapTransform)),m.alphaTest>0&&(y.alphaTest.value=m.alphaTest)}function u(y,m){y.diffuse.value.copy(m.color),y.opacity.value=m.opacity,y.rotation.value=m.rotation,m.map&&(y.map.value=m.map,n(m.map,y.mapTransform)),m.alphaMap&&(y.alphaMap.value=m.alphaMap,n(m.alphaMap,y.alphaMapTransform)),m.alphaTest>0&&(y.alphaTest.value=m.alphaTest)}function c(y,m){y.specular.value.copy(m.specular),y.shininess.value=Math.max(m.shininess,1e-4)}function d(y,m){m.gradientMap&&(y.gradientMap.value=m.gradientMap)}function h(y,m){y.metalness.value=m.metalness,m.metalnessMap&&(y.metalnessMap.value=m.metalnessMap,n(m.metalnessMap,y.metalnessMapTransform)),y.roughness.value=m.roughness,m.roughnessMap&&(y.roughnessMap.value=m.roughnessMap,n(m.roughnessMap,y.roughnessMapTransform)),m.envMap&&(y.envMapIntensity.value=m.envMapIntensity)}function p(y,m,b){y.ior.value=m.ior,m.sheen>0&&(y.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen),y.sheenRoughness.value=m.sheenRoughness,m.sheenColorMap&&(y.sheenColorMap.value=m.sheenColorMap,n(m.sheenColorMap,y.sheenColorMapTransform)),m.sheenRoughnessMap&&(y.sheenRoughnessMap.value=m.sheenRoughnessMap,n(m.sheenRoughnessMap,y.sheenRoughnessMapTransform))),m.clearcoat>0&&(y.clearcoat.value=m.clearcoat,y.clearcoatRoughness.value=m.clearcoatRoughness,m.clearcoatMap&&(y.clearcoatMap.value=m.clearcoatMap,n(m.clearcoatMap,y.clearcoatMapTransform)),m.clearcoatRoughnessMap&&(y.clearcoatRoughnessMap.value=m.clearcoatRoughnessMap,n(m.clearcoatRoughnessMap,y.clearcoatRoughnessMapTransform)),m.clearcoatNormalMap&&(y.clearcoatNormalMap.value=m.clearcoatNormalMap,n(m.clearcoatNormalMap,y.clearcoatNormalMapTransform),y.clearcoatNormalScale.value.copy(m.clearcoatNormalScale),m.side===sa&&y.clearcoatNormalScale.value.negate())),m.dispersion>0&&(y.dispersion.value=m.dispersion),m.iridescence>0&&(y.iridescence.value=m.iridescence,y.iridescenceIOR.value=m.iridescenceIOR,y.iridescenceThicknessMinimum.value=m.iridescenceThicknessRange[0],y.iridescenceThicknessMaximum.value=m.iridescenceThicknessRange[1],m.iridescenceMap&&(y.iridescenceMap.value=m.iridescenceMap,n(m.iridescenceMap,y.iridescenceMapTransform)),m.iridescenceThicknessMap&&(y.iridescenceThicknessMap.value=m.iridescenceThicknessMap,n(m.iridescenceThicknessMap,y.iridescenceThicknessMapTransform))),m.transmission>0&&(y.transmission.value=m.transmission,y.transmissionSamplerMap.value=b.texture,y.transmissionSamplerSize.value.set(b.width,b.height),m.transmissionMap&&(y.transmissionMap.value=m.transmissionMap,n(m.transmissionMap,y.transmissionMapTransform)),y.thickness.value=m.thickness,m.thicknessMap&&(y.thicknessMap.value=m.thicknessMap,n(m.thicknessMap,y.thicknessMapTransform)),y.attenuationDistance.value=m.attenuationDistance,y.attenuationColor.value.copy(m.attenuationColor)),m.anisotropy>0&&(y.anisotropyVector.value.set(m.anisotropy*Math.cos(m.anisotropyRotation),m.anisotropy*Math.sin(m.anisotropyRotation)),m.anisotropyMap&&(y.anisotropyMap.value=m.anisotropyMap,n(m.anisotropyMap,y.anisotropyMapTransform))),y.specularIntensity.value=m.specularIntensity,y.specularColor.value.copy(m.specularColor),m.specularColorMap&&(y.specularColorMap.value=m.specularColorMap,n(m.specularColorMap,y.specularColorMapTransform)),m.specularIntensityMap&&(y.specularIntensityMap.value=m.specularIntensityMap,n(m.specularIntensityMap,y.specularIntensityMapTransform))}function f(y,m){m.matcap&&(y.matcap.value=m.matcap)}function g(y,m){const b=e.get(m).light;y.referencePosition.value.setFromMatrixPosition(b.matrixWorld),y.nearDistance.value=b.shadow.camera.near,y.farDistance.value=b.shadow.camera.far}return{refreshFogUniforms:r,refreshMaterialUniforms:i}}function Pge(t,e,n,r){let i={},s={},a=[];const o=t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS);function l(b,w){const _=w.program;r.uniformBlockBinding(b,_)}function u(b,w){let _=i[b.id];_===void 0&&(f(b),_=c(b),i[b.id]=_,b.addEventListener("dispose",y));const S=w.program;r.updateUBOMapping(b,S);const E=e.render.frame;s[b.id]!==E&&(h(b),s[b.id]=E)}function c(b){const w=d();b.__bindingPointIndex=w;const _=t.createBuffer(),S=b.__size,E=b.usage;return t.bindBuffer(t.UNIFORM_BUFFER,_),t.bufferData(t.UNIFORM_BUFFER,S,E),t.bindBuffer(t.UNIFORM_BUFFER,null),t.bindBufferBase(t.UNIFORM_BUFFER,w,_),_}function d(){for(let b=0;b<o;b++)if(a.indexOf(b)===-1)return a.push(b),b;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function h(b){const w=i[b.id],_=b.uniforms,S=b.__cache;t.bindBuffer(t.UNIFORM_BUFFER,w);for(let E=0,C=_.length;E<C;E++){const T=Array.isArray(_[E])?_[E]:[_[E]];for(let M=0,k=T.length;M<k;M++){const R=T[M];if(p(R,E,M,S)===!0){const N=R.__offset,B=Array.isArray(R.value)?R.value:[R.value];let z=0;for(let V=0;V<B.length;V++){const K=B[V],Q=g(K);typeof K=="number"||typeof K=="boolean"?(R.__data[0]=K,t.bufferSubData(t.UNIFORM_BUFFER,N+z,R.__data)):K.isMatrix3?(R.__data[0]=K.elements[0],R.__data[1]=K.elements[1],R.__data[2]=K.elements[2],R.__data[3]=0,R.__data[4]=K.elements[3],R.__data[5]=K.elements[4],R.__data[6]=K.elements[5],R.__data[7]=0,R.__data[8]=K.elements[6],R.__data[9]=K.elements[7],R.__data[10]=K.elements[8],R.__data[11]=0):(K.toArray(R.__data,z),z+=Q.storage/Float32Array.BYTES_PER_ELEMENT)}t.bufferSubData(t.UNIFORM_BUFFER,N,R.__data)}}}t.bindBuffer(t.UNIFORM_BUFFER,null)}function p(b,w,_,S){const E=b.value,C=w+"_"+_;if(S[C]===void 0)return typeof E=="number"||typeof E=="boolean"?S[C]=E:S[C]=E.clone(),!0;{const T=S[C];if(typeof E=="number"||typeof E=="boolean"){if(T!==E)return S[C]=E,!0}else if(T.equals(E)===!1)return T.copy(E),!0}return!1}function f(b){const w=b.uniforms;let _=0;const S=16;for(let C=0,T=w.length;C<T;C++){const M=Array.isArray(w[C])?w[C]:[w[C]];for(let k=0,R=M.length;k<R;k++){const N=M[k],B=Array.isArray(N.value)?N.value:[N.value];for(let z=0,V=B.length;z<V;z++){const K=B[z],Q=g(K),O=_%S,j=O%Q.boundary,X=O+j;_+=j,X!==0&&S-X<Q.storage&&(_+=S-X),N.__data=new Float32Array(Q.storage/Float32Array.BYTES_PER_ELEMENT),N.__offset=_,_+=Q.storage}}}const E=_%S;return E>0&&(_+=S-E),b.__size=_,b.__cache={},this}function g(b){const w={boundary:0,storage:0};return typeof b=="number"||typeof b=="boolean"?(w.boundary=4,w.storage=4):b.isVector2?(w.boundary=8,w.storage=8):b.isVector3||b.isColor?(w.boundary=16,w.storage=12):b.isVector4?(w.boundary=16,w.storage=16):b.isMatrix3?(w.boundary=48,w.storage=48):b.isMatrix4?(w.boundary=64,w.storage=64):b.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",b),w}function y(b){const w=b.target;w.removeEventListener("dispose",y);const _=a.indexOf(w.__bindingPointIndex);a.splice(_,1),t.deleteBuffer(i[w.id]),delete i[w.id],delete s[w.id]}function m(){for(const b in i)t.deleteBuffer(i[b]);a=[],i={},s={}}return{bind:l,update:u,dispose:m}}class l3{constructor(e={}){const{canvas:n=h9(),context:r=null,depth:i=!0,stencil:s=!1,alpha:a=!1,antialias:o=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:u=!1,powerPreference:c="default",failIfMajorPerformanceCaveat:d=!1,reverseDepthBuffer:h=!1}=e;this.isWebGLRenderer=!0;let p;if(r!==null){if(typeof WebGLRenderingContext<"u"&&r instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");p=r.getContextAttributes().alpha}else p=a;const f=new Uint32Array(4),g=new Int32Array(4);let y=null,m=null;const b=[],w=[];this.domElement=n,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.toneMapping=ru,this.toneMappingExposure=1,this.transmissionResolutionScale=1;const _=this;let S=!1;this._outputColorSpace=Ui;let E=0,C=0,T=null,M=-1,k=null;const R=new Xn,N=new Xn;let B=null;const z=new Ct(0);let V=0,K=n.width,Q=n.height,O=1,j=null,X=null;const te=new Xn(0,0,K,Q),le=new Xn(0,0,K,Q);let ge=!1;const ie=new f0;let we=!1,Ce=!1;const Re=new ln,Le=new ln,lt=new Z,st=new Xn,Et={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let Tt=!1;function xt(){return T===null?O:1}let J=r;function Ye(G,ae){return n.getContext(G,ae)}try{const G={alpha:!0,depth:i,stencil:s,antialias:o,premultipliedAlpha:l,preserveDrawingBuffer:u,powerPreference:c,failIfMajorPerformanceCaveat:d};if("setAttribute"in n&&n.setAttribute("data-engine",`three.js r${vf}`),n.addEventListener("webglcontextlost",Mt,!1),n.addEventListener("webglcontextrestored",ut,!1),n.addEventListener("webglcontextcreationerror",Ze,!1),J===null){const ae="webgl2";if(J=Ye(ae,G),J===null)throw Ye(ae)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(G){throw console.error("THREE.WebGLRenderer: "+G.message),G}let Be,tt,Ue,St,Je,At,Vt,re,H,Ee,Oe,Xe,$e,Lt,wt,Pt,Ht,et,mt,Ot,he,Me,it,de;function Ne(){Be=new Xfe(J),Be.init(),Me=new uX(J,Be),tt=new $fe(J,Be,e,Me),Ue=new Tge(J,Be),tt.reverseDepthBuffer&&h&&Ue.buffers.depth.setReversed(!0),St=new Jfe(J),Je=new fge,At=new Cge(J,Be,Ue,Je,tt,Me,St),Vt=new Gfe(_),re=new jfe(_),H=new nhe(J),it=new Bfe(J,H),Ee=new Kfe(J,H,St,it),Oe=new Zfe(J,Ee,H,St),mt=new Yfe(J,tt,At),Pt=new zfe(Je),Xe=new pge(_,Vt,re,Be,tt,it,Pt),$e=new Dge(_,Je),Lt=new gge,wt=new _ge(Be),et=new Ofe(_,Vt,re,Ue,Oe,p,l),Ht=new Ege(_,Oe,tt),de=new Pge(J,St,tt,Ue),Ot=new Ufe(J,Be,St),he=new qfe(J,Be,St),St.programs=Xe.programs,_.capabilities=tt,_.extensions=Be,_.properties=Je,_.renderLists=Lt,_.shadowMap=Ht,_.state=Ue,_.info=St}Ne();const nt=new Rge(_,J);this.xr=nt,this.getContext=function(){return J},this.getContextAttributes=function(){return J.getContextAttributes()},this.forceContextLoss=function(){const G=Be.get("WEBGL_lose_context");G&&G.loseContext()},this.forceContextRestore=function(){const G=Be.get("WEBGL_lose_context");G&&G.restoreContext()},this.getPixelRatio=function(){return O},this.setPixelRatio=function(G){G!==void 0&&(O=G,this.setSize(K,Q,!1))},this.getSize=function(G){return G.set(K,Q)},this.setSize=function(G,ae,me=!0){if(nt.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}K=G,Q=ae,n.width=Math.floor(G*O),n.height=Math.floor(ae*O),me===!0&&(n.style.width=G+"px",n.style.height=ae+"px"),this.setViewport(0,0,G,ae)},this.getDrawingBufferSize=function(G){return G.set(K*O,Q*O).floor()},this.setDrawingBufferSize=function(G,ae,me){K=G,Q=ae,O=me,n.width=Math.floor(G*me),n.height=Math.floor(ae*me),this.setViewport(0,0,G,ae)},this.getCurrentViewport=function(G){return G.copy(R)},this.getViewport=function(G){return G.copy(te)},this.setViewport=function(G,ae,me,pe){G.isVector4?te.set(G.x,G.y,G.z,G.w):te.set(G,ae,me,pe),Ue.viewport(R.copy(te).multiplyScalar(O).round())},this.getScissor=function(G){return G.copy(le)},this.setScissor=function(G,ae,me,pe){G.isVector4?le.set(G.x,G.y,G.z,G.w):le.set(G,ae,me,pe),Ue.scissor(N.copy(le).multiplyScalar(O).round())},this.getScissorTest=function(){return ge},this.setScissorTest=function(G){Ue.setScissorTest(ge=G)},this.setOpaqueSort=function(G){j=G},this.setTransparentSort=function(G){X=G},this.getClearColor=function(G){return G.copy(et.getClearColor())},this.setClearColor=function(){et.setClearColor(...arguments)},this.getClearAlpha=function(){return et.getClearAlpha()},this.setClearAlpha=function(){et.setClearAlpha(...arguments)},this.clear=function(G=!0,ae=!0,me=!0){let pe=0;if(G){let _e=!1;if(T!==null){const Fe=T.texture.format;_e=Fe===TT||Fe===IT||Fe===H1}if(_e){const Fe=T.texture.type,je=Fe===la||Fe===cu||Fe===Py||Fe===Ly||Fe===AT||Fe===ET,ot=et.getClearColor(),at=et.getClearAlpha(),bt=ot.r,It=ot.g,ct=ot.b;je?(f[0]=bt,f[1]=It,f[2]=ct,f[3]=at,J.clearBufferuiv(J.COLOR,0,f)):(g[0]=bt,g[1]=It,g[2]=ct,g[3]=at,J.clearBufferiv(J.COLOR,0,g))}else pe|=J.COLOR_BUFFER_BIT}ae&&(pe|=J.DEPTH_BUFFER_BIT),me&&(pe|=J.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),J.clear(pe)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){n.removeEventListener("webglcontextlost",Mt,!1),n.removeEventListener("webglcontextrestored",ut,!1),n.removeEventListener("webglcontextcreationerror",Ze,!1),et.dispose(),Lt.dispose(),wt.dispose(),Je.dispose(),Vt.dispose(),re.dispose(),Oe.dispose(),it.dispose(),de.dispose(),Xe.dispose(),nt.dispose(),nt.removeEventListener("sessionstart",ar),nt.removeEventListener("sessionend",gn),sn.stop()};function Mt(G){G.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),S=!0}function ut(){console.log("THREE.WebGLRenderer: Context Restored."),S=!1;const G=St.autoReset,ae=Ht.enabled,me=Ht.autoUpdate,pe=Ht.needsUpdate,_e=Ht.type;Ne(),St.autoReset=G,Ht.enabled=ae,Ht.autoUpdate=me,Ht.needsUpdate=pe,Ht.type=_e}function Ze(G){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",G.statusMessage)}function kt(G){const ae=G.target;ae.removeEventListener("dispose",kt),Se(ae)}function Se(G){qe(G),Je.remove(G)}function qe(G){const ae=Je.get(G).programs;ae!==void 0&&(ae.forEach(function(me){Xe.releaseProgram(me)}),G.isShaderMaterial&&Xe.releaseShaderCache(G))}this.renderBufferDirect=function(G,ae,me,pe,_e,Fe){ae===null&&(ae=Et);const je=_e.isMesh&&_e.matrixWorld.determinant()<0,ot=ye(G,ae,me,pe,_e);Ue.setMaterial(pe,je);let at=me.index,bt=1;if(pe.wireframe===!0){if(at=Ee.getWireframeAttribute(me),at===void 0)return;bt=2}const It=me.drawRange,ct=me.attributes.position;let Rt=It.start*bt,jt=(It.start+It.count)*bt;Fe!==null&&(Rt=Math.max(Rt,Fe.start*bt),jt=Math.min(jt,(Fe.start+Fe.count)*bt)),at!==null?(Rt=Math.max(Rt,0),jt=Math.min(jt,at.count)):ct!=null&&(Rt=Math.max(Rt,0),jt=Math.min(jt,ct.count));const un=jt-Rt;if(un<0||un===1/0)return;it.setup(_e,pe,ot,me,at);let Kt,tn=Ot;if(at!==null&&(Kt=H.get(at),tn=he,tn.setIndex(Kt)),_e.isMesh)pe.wireframe===!0?(Ue.setLineWidth(pe.wireframeLinewidth*xt()),tn.setMode(J.LINES)):tn.setMode(J.TRIANGLES);else if(_e.isLine){let Wt=pe.linewidth;Wt===void 0&&(Wt=1),Ue.setLineWidth(Wt*xt()),_e.isLineSegments?tn.setMode(J.LINES):_e.isLineLoop?tn.setMode(J.LINE_LOOP):tn.setMode(J.LINE_STRIP)}else _e.isPoints?tn.setMode(J.POINTS):_e.isSprite&&tn.setMode(J.TRIANGLES);if(_e.isBatchedMesh)if(_e._multiDrawInstances!==null)gy("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),tn.renderMultiDrawInstances(_e._multiDrawStarts,_e._multiDrawCounts,_e._multiDrawCount,_e._multiDrawInstances);else if(Be.get("WEBGL_multi_draw"))tn.renderMultiDraw(_e._multiDrawStarts,_e._multiDrawCounts,_e._multiDrawCount);else{const Wt=_e._multiDrawStarts,Bn=_e._multiDrawCounts,pn=_e._multiDrawCount,_n=at?H.get(at).bytesPerElement:1,Ar=Je.get(pe).currentProgram.getUniforms();for(let Sn=0;Sn<pn;Sn++)Ar.setValue(J,"_gl_DrawID",Sn),tn.render(Wt[Sn]/_n,Bn[Sn])}else if(_e.isInstancedMesh)tn.renderInstances(Rt,un,_e.count);else if(me.isInstancedBufferGeometry){const Wt=me._maxInstanceCount!==void 0?me._maxInstanceCount:1/0,Bn=Math.min(me.instanceCount,Wt);tn.renderInstances(Rt,un,Bn)}else tn.render(Rt,un)};function pt(G,ae,me){G.transparent===!0&&G.side===ta&&G.forceSinglePass===!1?(G.side=sa,G.needsUpdate=!0,Va(G,ae,me),G.side=lu,G.needsUpdate=!0,Va(G,ae,me),G.side=ta):Va(G,ae,me)}this.compile=function(G,ae,me=null){me===null&&(me=G),m=wt.get(me),m.init(ae),w.push(m),me.traverseVisible(function(_e){_e.isLight&&_e.layers.test(ae.layers)&&(m.pushLight(_e),_e.castShadow&&m.pushShadow(_e))}),G!==me&&G.traverseVisible(function(_e){_e.isLight&&_e.layers.test(ae.layers)&&(m.pushLight(_e),_e.castShadow&&m.pushShadow(_e))}),m.setupLights();const pe=new Set;return G.traverse(function(_e){if(!(_e.isMesh||_e.isPoints||_e.isLine||_e.isSprite))return;const Fe=_e.material;if(Fe)if(Array.isArray(Fe))for(let je=0;je<Fe.length;je++){const ot=Fe[je];pt(ot,me,_e),pe.add(ot)}else pt(Fe,me,_e),pe.add(Fe)}),m=w.pop(),pe},this.compileAsync=function(G,ae,me=null){const pe=this.compile(G,ae,me);return new Promise(_e=>{function Fe(){if(pe.forEach(function(je){Je.get(je).currentProgram.isReady()&&pe.delete(je)}),pe.size===0){_e(G);return}setTimeout(Fe,10)}Be.get("KHR_parallel_shader_compile")!==null?Fe():setTimeout(Fe,10)})};let ht=null;function xn(G){ht&&ht(G)}function ar(){sn.stop()}function gn(){sn.start()}const sn=new iX;sn.setAnimationLoop(xn),typeof self<"u"&&sn.setContext(self),this.setAnimationLoop=function(G){ht=G,nt.setAnimationLoop(G),G===null?sn.stop():sn.start()},nt.addEventListener("sessionstart",ar),nt.addEventListener("sessionend",gn),this.render=function(G,ae){if(ae!==void 0&&ae.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(S===!0)return;if(G.matrixWorldAutoUpdate===!0&&G.updateMatrixWorld(),ae.parent===null&&ae.matrixWorldAutoUpdate===!0&&ae.updateMatrixWorld(),nt.enabled===!0&&nt.isPresenting===!0&&(nt.cameraAutoUpdate===!0&&nt.updateCamera(ae),ae=nt.getCamera()),G.isScene===!0&&G.onBeforeRender(_,G,ae,T),m=wt.get(G,w.length),m.init(ae),w.push(m),Le.multiplyMatrices(ae.projectionMatrix,ae.matrixWorldInverse),ie.setFromProjectionMatrix(Le),Ce=this.localClippingEnabled,we=Pt.init(this.clippingPlanes,Ce),y=Lt.get(G,b.length),y.init(),b.push(y),nt.enabled===!0&&nt.isPresenting===!0){const Fe=_.xr.getDepthSensingMesh();Fe!==null&&ur(Fe,ae,-1/0,_.sortObjects)}ur(G,ae,0,_.sortObjects),y.finish(),_.sortObjects===!0&&y.sort(j,X),Tt=nt.enabled===!1||nt.isPresenting===!1||nt.hasDepthSensing()===!1,Tt&&et.addToRenderList(y,G),this.info.render.frame++,we===!0&&Pt.beginShadows();const me=m.state.shadowsArray;Ht.render(me,G,ae),we===!0&&Pt.endShadows(),this.info.autoReset===!0&&this.info.reset();const pe=y.opaque,_e=y.transmissive;if(m.setupLights(),ae.isArrayCamera){const Fe=ae.cameras;if(_e.length>0)for(let je=0,ot=Fe.length;je<ot;je++){const at=Fe[je];zr(pe,_e,G,at)}Tt&&et.render(G);for(let je=0,ot=Fe.length;je<ot;je++){const at=Fe[je];$r(y,G,at,at.viewport)}}else _e.length>0&&zr(pe,_e,G,ae),Tt&&et.render(G),$r(y,G,ae);T!==null&&C===0&&(At.updateMultisampleRenderTarget(T),At.updateRenderTargetMipmap(T)),G.isScene===!0&&G.onAfterRender(_,G,ae),it.resetDefaultState(),M=-1,k=null,w.pop(),w.length>0?(m=w[w.length-1],we===!0&&Pt.setGlobalState(_.clippingPlanes,m.state.camera)):m=null,b.pop(),b.length>0?y=b[b.length-1]:y=null};function ur(G,ae,me,pe){if(G.visible===!1)return;if(G.layers.test(ae.layers)){if(G.isGroup)me=G.renderOrder;else if(G.isLOD)G.autoUpdate===!0&&G.update(ae);else if(G.isLight)m.pushLight(G),G.castShadow&&m.pushShadow(G);else if(G.isSprite){if(!G.frustumCulled||ie.intersectsSprite(G)){pe&&st.setFromMatrixPosition(G.matrixWorld).applyMatrix4(Le);const je=Oe.update(G),ot=G.material;ot.visible&&y.push(G,je,ot,me,st.z,null)}}else if((G.isMesh||G.isLine||G.isPoints)&&(!G.frustumCulled||ie.intersectsObject(G))){const je=Oe.update(G),ot=G.material;if(pe&&(G.boundingSphere!==void 0?(G.boundingSphere===null&&G.computeBoundingSphere(),st.copy(G.boundingSphere.center)):(je.boundingSphere===null&&je.computeBoundingSphere(),st.copy(je.boundingSphere.center)),st.applyMatrix4(G.matrixWorld).applyMatrix4(Le)),Array.isArray(ot)){const at=je.groups;for(let bt=0,It=at.length;bt<It;bt++){const ct=at[bt],Rt=ot[ct.materialIndex];Rt&&Rt.visible&&y.push(G,je,Rt,me,st.z,ct)}}else ot.visible&&y.push(G,je,ot,me,st.z,null)}}const Fe=G.children;for(let je=0,ot=Fe.length;je<ot;je++)ur(Fe[je],ae,me,pe)}function $r(G,ae,me,pe){const _e=G.opaque,Fe=G.transmissive,je=G.transparent;m.setupLightsView(me),we===!0&&Pt.setGlobalState(_.clippingPlanes,me),pe&&Ue.viewport(R.copy(pe)),_e.length>0&&yn(_e,ae,me),Fe.length>0&&yn(Fe,ae,me),je.length>0&&yn(je,ae,me),Ue.buffers.depth.setTest(!0),Ue.buffers.depth.setMask(!0),Ue.buffers.color.setMask(!0),Ue.setPolygonOffset(!1)}function zr(G,ae,me,pe){if((me.isScene===!0?me.overrideMaterial:null)!==null)return;m.state.transmissionRenderTarget[pe.id]===void 0&&(m.state.transmissionRenderTarget[pe.id]=new Oa(1,1,{generateMipmaps:!0,type:Be.has("EXT_color_buffer_half_float")||Be.has("EXT_color_buffer_float")?Wi:la,minFilter:Ma,samples:4,stencilBuffer:s,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:Qn.workingColorSpace}));const Fe=m.state.transmissionRenderTarget[pe.id],je=pe.viewport||R;Fe.setSize(je.z*_.transmissionResolutionScale,je.w*_.transmissionResolutionScale);const ot=_.getRenderTarget();_.setRenderTarget(Fe),_.getClearColor(z),V=_.getClearAlpha(),V<1&&_.setClearColor(16777215,.5),_.clear(),Tt&&et.render(me);const at=_.toneMapping;_.toneMapping=ru;const bt=pe.viewport;if(pe.viewport!==void 0&&(pe.viewport=void 0),m.setupLightsView(pe),we===!0&&Pt.setGlobalState(_.clippingPlanes,pe),yn(G,me,pe),At.updateMultisampleRenderTarget(Fe),At.updateRenderTargetMipmap(Fe),Be.has("WEBGL_multisampled_render_to_texture")===!1){let It=!1;for(let ct=0,Rt=ae.length;ct<Rt;ct++){const jt=ae[ct],un=jt.object,Kt=jt.geometry,tn=jt.material,Wt=jt.group;if(tn.side===ta&&un.layers.test(pe.layers)){const Bn=tn.side;tn.side=sa,tn.needsUpdate=!0,Wa(un,me,pe,Kt,tn,Wt),tn.side=Bn,tn.needsUpdate=!0,It=!0}}It===!0&&(At.updateMultisampleRenderTarget(Fe),At.updateRenderTargetMipmap(Fe))}_.setRenderTarget(ot),_.setClearColor(z,V),bt!==void 0&&(pe.viewport=bt),_.toneMapping=at}function yn(G,ae,me){const pe=ae.isScene===!0?ae.overrideMaterial:null;for(let _e=0,Fe=G.length;_e<Fe;_e++){const je=G[_e],ot=je.object,at=je.geometry,bt=je.group;let It=je.material;It.allowOverride===!0&&pe!==null&&(It=pe),ot.layers.test(me.layers)&&Wa(ot,ae,me,at,It,bt)}}function Wa(G,ae,me,pe,_e,Fe){G.onBeforeRender(_,ae,me,pe,_e,Fe),G.modelViewMatrix.multiplyMatrices(me.matrixWorldInverse,G.matrixWorld),G.normalMatrix.getNormalMatrix(G.modelViewMatrix),_e.onBeforeRender(_,ae,me,pe,G,Fe),_e.transparent===!0&&_e.side===ta&&_e.forceSinglePass===!1?(_e.side=sa,_e.needsUpdate=!0,_.renderBufferDirect(me,ae,pe,_e,G,Fe),_e.side=lu,_e.needsUpdate=!0,_.renderBufferDirect(me,ae,pe,_e,G,Fe),_e.side=ta):_.renderBufferDirect(me,ae,pe,_e,G,Fe),G.onAfterRender(_,ae,me,pe,_e,Fe)}function Va(G,ae,me){ae.isScene!==!0&&(ae=Et);const pe=Je.get(G),_e=m.state.lights,Fe=m.state.shadowsArray,je=_e.state.version,ot=Xe.getParameters(G,_e.state,Fe,ae,me),at=Xe.getProgramCacheKey(ot);let bt=pe.programs;pe.environment=G.isMeshStandardMaterial?ae.environment:null,pe.fog=ae.fog,pe.envMap=(G.isMeshStandardMaterial?re:Vt).get(G.envMap||pe.environment),pe.envMapRotation=pe.environment!==null&&G.envMap===null?ae.environmentRotation:G.envMapRotation,bt===void 0&&(G.addEventListener("dispose",kt),bt=new Map,pe.programs=bt);let It=bt.get(at);if(It!==void 0){if(pe.currentProgram===It&&pe.lightsStateVersion===je)return Y(G,ot),It}else ot.uniforms=Xe.getUniforms(G),G.onBeforeCompile(ot,_),It=Xe.acquireProgram(ot,at),bt.set(at,It),pe.uniforms=ot.uniforms;const ct=pe.uniforms;return(!G.isShaderMaterial&&!G.isRawShaderMaterial||G.clipping===!0)&&(ct.clippingPlanes=Pt.uniform),Y(G,ot),pe.needsLights=He(G),pe.lightsStateVersion=je,pe.needsLights&&(ct.ambientLightColor.value=_e.state.ambient,ct.lightProbe.value=_e.state.probe,ct.directionalLights.value=_e.state.directional,ct.directionalLightShadows.value=_e.state.directionalShadow,ct.spotLights.value=_e.state.spot,ct.spotLightShadows.value=_e.state.spotShadow,ct.rectAreaLights.value=_e.state.rectArea,ct.ltc_1.value=_e.state.rectAreaLTC1,ct.ltc_2.value=_e.state.rectAreaLTC2,ct.pointLights.value=_e.state.point,ct.pointLightShadows.value=_e.state.pointShadow,ct.hemisphereLights.value=_e.state.hemi,ct.directionalShadowMap.value=_e.state.directionalShadowMap,ct.directionalShadowMatrix.value=_e.state.directionalShadowMatrix,ct.spotShadowMap.value=_e.state.spotShadowMap,ct.spotLightMatrix.value=_e.state.spotLightMatrix,ct.spotLightMap.value=_e.state.spotLightMap,ct.pointShadowMap.value=_e.state.pointShadowMap,ct.pointShadowMatrix.value=_e.state.pointShadowMatrix),pe.currentProgram=It,pe.uniformsList=null,It}function $(G){if(G.uniformsList===null){const ae=G.currentProgram.getUniforms();G.uniformsList=qA.seqWithValue(ae.seq,G.uniforms)}return G.uniformsList}function Y(G,ae){const me=Je.get(G);me.outputColorSpace=ae.outputColorSpace,me.batching=ae.batching,me.batchingColor=ae.batchingColor,me.instancing=ae.instancing,me.instancingColor=ae.instancingColor,me.instancingMorph=ae.instancingMorph,me.skinning=ae.skinning,me.morphTargets=ae.morphTargets,me.morphNormals=ae.morphNormals,me.morphColors=ae.morphColors,me.morphTargetsCount=ae.morphTargetsCount,me.numClippingPlanes=ae.numClippingPlanes,me.numIntersection=ae.numClipIntersection,me.vertexAlphas=ae.vertexAlphas,me.vertexTangents=ae.vertexTangents,me.toneMapping=ae.toneMapping}function ye(G,ae,me,pe,_e){ae.isScene!==!0&&(ae=Et),At.resetTextureUnits();const Fe=ae.fog,je=pe.isMeshStandardMaterial?ae.environment:null,ot=T===null?_.outputColorSpace:T.isXRRenderTarget===!0?T.texture.colorSpace:du,at=(pe.isMeshStandardMaterial?re:Vt).get(pe.envMap||je),bt=pe.vertexColors===!0&&!!me.attributes.color&&me.attributes.color.itemSize===4,It=!!me.attributes.tangent&&(!!pe.normalMap||pe.anisotropy>0),ct=!!me.morphAttributes.position,Rt=!!me.morphAttributes.normal,jt=!!me.morphAttributes.color;let un=ru;pe.toneMapped&&(T===null||T.isXRRenderTarget===!0)&&(un=_.toneMapping);const Kt=me.morphAttributes.position||me.morphAttributes.normal||me.morphAttributes.color,tn=Kt!==void 0?Kt.length:0,Wt=Je.get(pe),Bn=m.state.lights;if(we===!0&&(Ce===!0||G!==k)){const gr=G===k&&pe.id===M;Pt.setState(pe,G,gr)}let pn=!1;pe.version===Wt.__version?(Wt.needsLights&&Wt.lightsStateVersion!==Bn.state.version||Wt.outputColorSpace!==ot||_e.isBatchedMesh&&Wt.batching===!1||!_e.isBatchedMesh&&Wt.batching===!0||_e.isBatchedMesh&&Wt.batchingColor===!0&&_e.colorTexture===null||_e.isBatchedMesh&&Wt.batchingColor===!1&&_e.colorTexture!==null||_e.isInstancedMesh&&Wt.instancing===!1||!_e.isInstancedMesh&&Wt.instancing===!0||_e.isSkinnedMesh&&Wt.skinning===!1||!_e.isSkinnedMesh&&Wt.skinning===!0||_e.isInstancedMesh&&Wt.instancingColor===!0&&_e.instanceColor===null||_e.isInstancedMesh&&Wt.instancingColor===!1&&_e.instanceColor!==null||_e.isInstancedMesh&&Wt.instancingMorph===!0&&_e.morphTexture===null||_e.isInstancedMesh&&Wt.instancingMorph===!1&&_e.morphTexture!==null||Wt.envMap!==at||pe.fog===!0&&Wt.fog!==Fe||Wt.numClippingPlanes!==void 0&&(Wt.numClippingPlanes!==Pt.numPlanes||Wt.numIntersection!==Pt.numIntersection)||Wt.vertexAlphas!==bt||Wt.vertexTangents!==It||Wt.morphTargets!==ct||Wt.morphNormals!==Rt||Wt.morphColors!==jt||Wt.toneMapping!==un||Wt.morphTargetsCount!==tn)&&(pn=!0):(pn=!0,Wt.__version=pe.version);let _n=Wt.currentProgram;pn===!0&&(_n=Va(pe,ae,_e));let Ar=!1,Sn=!1,Un=!1;const fn=_n.getUniforms(),Dr=Wt.uniforms;if(Ue.useProgram(_n.program)&&(Ar=!0,Sn=!0,Un=!0),pe.id!==M&&(M=pe.id,Sn=!0),Ar||k!==G){Ue.buffers.depth.getReversed()?(Re.copy(G.projectionMatrix),Mue(Re),kue(Re),fn.setValue(J,"projectionMatrix",Re)):fn.setValue(J,"projectionMatrix",G.projectionMatrix),fn.setValue(J,"viewMatrix",G.matrixWorldInverse);const si=fn.map.cameraPosition;si!==void 0&&si.setValue(J,lt.setFromMatrixPosition(G.matrixWorld)),tt.logarithmicDepthBuffer&&fn.setValue(J,"logDepthBufFC",2/(Math.log(G.far+1)/Math.LN2)),(pe.isMeshPhongMaterial||pe.isMeshToonMaterial||pe.isMeshLambertMaterial||pe.isMeshBasicMaterial||pe.isMeshStandardMaterial||pe.isShaderMaterial)&&fn.setValue(J,"isOrthographic",G.isOrthographicCamera===!0),k!==G&&(k=G,Sn=!0,Un=!0)}if(_e.isSkinnedMesh){fn.setOptional(J,_e,"bindMatrix"),fn.setOptional(J,_e,"bindMatrixInverse");const gr=_e.skeleton;gr&&(gr.boneTexture===null&&gr.computeBoneTexture(),fn.setValue(J,"boneTexture",gr.boneTexture,At))}_e.isBatchedMesh&&(fn.setOptional(J,_e,"batchingTexture"),fn.setValue(J,"batchingTexture",_e._matricesTexture,At),fn.setOptional(J,_e,"batchingIdTexture"),fn.setValue(J,"batchingIdTexture",_e._indirectTexture,At),fn.setOptional(J,_e,"batchingColorTexture"),_e._colorsTexture!==null&&fn.setValue(J,"batchingColorTexture",_e._colorsTexture,At));const ir=me.morphAttributes;if((ir.position!==void 0||ir.normal!==void 0||ir.color!==void 0)&&mt.update(_e,me,_n),(Sn||Wt.receiveShadow!==_e.receiveShadow)&&(Wt.receiveShadow=_e.receiveShadow,fn.setValue(J,"receiveShadow",_e.receiveShadow)),pe.isMeshGouraudMaterial&&pe.envMap!==null&&(Dr.envMap.value=at,Dr.flipEnvMap.value=at.isCubeTexture&&at.isRenderTargetTexture===!1?-1:1),pe.isMeshStandardMaterial&&pe.envMap===null&&ae.environment!==null&&(Dr.envMapIntensity.value=ae.environmentIntensity),Sn&&(fn.setValue(J,"toneMappingExposure",_.toneMappingExposure),Wt.needsLights&&De(Dr,Un),Fe&&pe.fog===!0&&$e.refreshFogUniforms(Dr,Fe),$e.refreshMaterialUniforms(Dr,pe,O,Q,m.state.transmissionRenderTarget[G.id]),qA.upload(J,$(Wt),Dr,At)),pe.isShaderMaterial&&pe.uniformsNeedUpdate===!0&&(qA.upload(J,$(Wt),Dr,At),pe.uniformsNeedUpdate=!1),pe.isSpriteMaterial&&fn.setValue(J,"center",_e.center),fn.setValue(J,"modelViewMatrix",_e.modelViewMatrix),fn.setValue(J,"normalMatrix",_e.normalMatrix),fn.setValue(J,"modelMatrix",_e.matrixWorld),pe.isShaderMaterial||pe.isRawShaderMaterial){const gr=pe.uniformsGroups;for(let si=0,Ko=gr.length;si<Ko;si++){const ps=gr[si];de.update(ps,_n),de.bind(ps,_n)}}return _n}function De(G,ae){G.ambientLightColor.needsUpdate=ae,G.lightProbe.needsUpdate=ae,G.directionalLights.needsUpdate=ae,G.directionalLightShadows.needsUpdate=ae,G.pointLights.needsUpdate=ae,G.pointLightShadows.needsUpdate=ae,G.spotLights.needsUpdate=ae,G.spotLightShadows.needsUpdate=ae,G.rectAreaLights.needsUpdate=ae,G.hemisphereLights.needsUpdate=ae}function He(G){return G.isMeshLambertMaterial||G.isMeshToonMaterial||G.isMeshPhongMaterial||G.isMeshStandardMaterial||G.isShadowMaterial||G.isShaderMaterial&&G.lights===!0}this.getActiveCubeFace=function(){return E},this.getActiveMipmapLevel=function(){return C},this.getRenderTarget=function(){return T},this.setRenderTargetTextures=function(G,ae,me){const pe=Je.get(G);pe.__autoAllocateDepthBuffer=G.resolveDepthBuffer===!1,pe.__autoAllocateDepthBuffer===!1&&(pe.__useRenderToTexture=!1),Je.get(G.texture).__webglTexture=ae,Je.get(G.depthTexture).__webglTexture=pe.__autoAllocateDepthBuffer?void 0:me,pe.__hasExternalTextures=!0},this.setRenderTargetFramebuffer=function(G,ae){const me=Je.get(G);me.__webglFramebuffer=ae,me.__useDefaultFramebuffer=ae===void 0};const Ve=J.createFramebuffer();this.setRenderTarget=function(G,ae=0,me=0){T=G,E=ae,C=me;let pe=!0,_e=null,Fe=!1,je=!1;if(G){const at=Je.get(G);if(at.__useDefaultFramebuffer!==void 0)Ue.bindFramebuffer(J.FRAMEBUFFER,null),pe=!1;else if(at.__webglFramebuffer===void 0)At.setupRenderTarget(G);else if(at.__hasExternalTextures)At.rebindTextures(G,Je.get(G.texture).__webglTexture,Je.get(G.depthTexture).__webglTexture);else if(G.depthBuffer){const ct=G.depthTexture;if(at.__boundDepthTexture!==ct){if(ct!==null&&Je.has(ct)&&(G.width!==ct.image.width||G.height!==ct.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");At.setupDepthRenderbuffer(G)}}const bt=G.texture;(bt.isData3DTexture||bt.isDataArrayTexture||bt.isCompressedArrayTexture)&&(je=!0);const It=Je.get(G).__webglFramebuffer;G.isWebGLCubeRenderTarget?(Array.isArray(It[ae])?_e=It[ae][me]:_e=It[ae],Fe=!0):G.samples>0&&At.useMultisampledRTT(G)===!1?_e=Je.get(G).__webglMultisampledFramebuffer:Array.isArray(It)?_e=It[me]:_e=It,R.copy(G.viewport),N.copy(G.scissor),B=G.scissorTest}else R.copy(te).multiplyScalar(O).floor(),N.copy(le).multiplyScalar(O).floor(),B=ge;if(me!==0&&(_e=Ve),Ue.bindFramebuffer(J.FRAMEBUFFER,_e)&&pe&&Ue.drawBuffers(G,_e),Ue.viewport(R),Ue.scissor(N),Ue.setScissorTest(B),Fe){const at=Je.get(G.texture);J.framebufferTexture2D(J.FRAMEBUFFER,J.COLOR_ATTACHMENT0,J.TEXTURE_CUBE_MAP_POSITIVE_X+ae,at.__webglTexture,me)}else if(je){const at=Je.get(G.texture),bt=ae;J.framebufferTextureLayer(J.FRAMEBUFFER,J.COLOR_ATTACHMENT0,at.__webglTexture,me,bt)}else if(G!==null&&me!==0){const at=Je.get(G.texture);J.framebufferTexture2D(J.FRAMEBUFFER,J.COLOR_ATTACHMENT0,J.TEXTURE_2D,at.__webglTexture,me)}M=-1},this.readRenderTargetPixels=function(G,ae,me,pe,_e,Fe,je,ot=0){if(!(G&&G.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let at=Je.get(G).__webglFramebuffer;if(G.isWebGLCubeRenderTarget&&je!==void 0&&(at=at[je]),at){Ue.bindFramebuffer(J.FRAMEBUFFER,at);try{const bt=G.textures[ot],It=bt.format,ct=bt.type;if(!tt.textureFormatReadable(It)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!tt.textureTypeReadable(ct)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}ae>=0&&ae<=G.width-pe&&me>=0&&me<=G.height-_e&&(G.textures.length>1&&J.readBuffer(J.COLOR_ATTACHMENT0+ot),J.readPixels(ae,me,pe,_e,Me.convert(It),Me.convert(ct),Fe))}finally{const bt=T!==null?Je.get(T).__webglFramebuffer:null;Ue.bindFramebuffer(J.FRAMEBUFFER,bt)}}},this.readRenderTargetPixelsAsync=async function(G,ae,me,pe,_e,Fe,je,ot=0){if(!(G&&G.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let at=Je.get(G).__webglFramebuffer;if(G.isWebGLCubeRenderTarget&&je!==void 0&&(at=at[je]),at)if(ae>=0&&ae<=G.width-pe&&me>=0&&me<=G.height-_e){Ue.bindFramebuffer(J.FRAMEBUFFER,at);const bt=G.textures[ot],It=bt.format,ct=bt.type;if(!tt.textureFormatReadable(It))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!tt.textureTypeReadable(ct))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");const Rt=J.createBuffer();J.bindBuffer(J.PIXEL_PACK_BUFFER,Rt),J.bufferData(J.PIXEL_PACK_BUFFER,Fe.byteLength,J.STREAM_READ),G.textures.length>1&&J.readBuffer(J.COLOR_ATTACHMENT0+ot),J.readPixels(ae,me,pe,_e,Me.convert(It),Me.convert(ct),0);const jt=T!==null?Je.get(T).__webglFramebuffer:null;Ue.bindFramebuffer(J.FRAMEBUFFER,jt);const un=J.fenceSync(J.SYNC_GPU_COMMANDS_COMPLETE,0);return J.flush(),await Cue(J,un,4),J.bindBuffer(J.PIXEL_PACK_BUFFER,Rt),J.getBufferSubData(J.PIXEL_PACK_BUFFER,0,Fe),J.deleteBuffer(Rt),J.deleteSync(un),Fe}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")},this.copyFramebufferToTexture=function(G,ae=null,me=0){const pe=Math.pow(2,-me),_e=Math.floor(G.image.width*pe),Fe=Math.floor(G.image.height*pe),je=ae!==null?ae.x:0,ot=ae!==null?ae.y:0;At.setTexture2D(G,0),J.copyTexSubImage2D(J.TEXTURE_2D,me,0,0,je,ot,_e,Fe),Ue.unbindTexture()};const gt=J.createFramebuffer(),dt=J.createFramebuffer();this.copyTextureToTexture=function(G,ae,me=null,pe=null,_e=0,Fe=null){Fe===null&&(_e!==0?(gy("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),Fe=_e,_e=0):Fe=0);let je,ot,at,bt,It,ct,Rt,jt,un;const Kt=G.isCompressedTexture?G.mipmaps[Fe]:G.image;if(me!==null)je=me.max.x-me.min.x,ot=me.max.y-me.min.y,at=me.isBox3?me.max.z-me.min.z:1,bt=me.min.x,It=me.min.y,ct=me.isBox3?me.min.z:0;else{const ir=Math.pow(2,-_e);je=Math.floor(Kt.width*ir),ot=Math.floor(Kt.height*ir),G.isDataArrayTexture?at=Kt.depth:G.isData3DTexture?at=Math.floor(Kt.depth*ir):at=1,bt=0,It=0,ct=0}pe!==null?(Rt=pe.x,jt=pe.y,un=pe.z):(Rt=0,jt=0,un=0);const tn=Me.convert(ae.format),Wt=Me.convert(ae.type);let Bn;ae.isData3DTexture?(At.setTexture3D(ae,0),Bn=J.TEXTURE_3D):ae.isDataArrayTexture||ae.isCompressedArrayTexture?(At.setTexture2DArray(ae,0),Bn=J.TEXTURE_2D_ARRAY):(At.setTexture2D(ae,0),Bn=J.TEXTURE_2D),J.pixelStorei(J.UNPACK_FLIP_Y_WEBGL,ae.flipY),J.pixelStorei(J.UNPACK_PREMULTIPLY_ALPHA_WEBGL,ae.premultiplyAlpha),J.pixelStorei(J.UNPACK_ALIGNMENT,ae.unpackAlignment);const pn=J.getParameter(J.UNPACK_ROW_LENGTH),_n=J.getParameter(J.UNPACK_IMAGE_HEIGHT),Ar=J.getParameter(J.UNPACK_SKIP_PIXELS),Sn=J.getParameter(J.UNPACK_SKIP_ROWS),Un=J.getParameter(J.UNPACK_SKIP_IMAGES);J.pixelStorei(J.UNPACK_ROW_LENGTH,Kt.width),J.pixelStorei(J.UNPACK_IMAGE_HEIGHT,Kt.height),J.pixelStorei(J.UNPACK_SKIP_PIXELS,bt),J.pixelStorei(J.UNPACK_SKIP_ROWS,It),J.pixelStorei(J.UNPACK_SKIP_IMAGES,ct);const fn=G.isDataArrayTexture||G.isData3DTexture,Dr=ae.isDataArrayTexture||ae.isData3DTexture;if(G.isDepthTexture){const ir=Je.get(G),gr=Je.get(ae),si=Je.get(ir.__renderTarget),Ko=Je.get(gr.__renderTarget);Ue.bindFramebuffer(J.READ_FRAMEBUFFER,si.__webglFramebuffer),Ue.bindFramebuffer(J.DRAW_FRAMEBUFFER,Ko.__webglFramebuffer);for(let ps=0;ps<at;ps++)fn&&(J.framebufferTextureLayer(J.READ_FRAMEBUFFER,J.COLOR_ATTACHMENT0,Je.get(G).__webglTexture,_e,ct+ps),J.framebufferTextureLayer(J.DRAW_FRAMEBUFFER,J.COLOR_ATTACHMENT0,Je.get(ae).__webglTexture,Fe,un+ps)),J.blitFramebuffer(bt,It,je,ot,Rt,jt,je,ot,J.DEPTH_BUFFER_BIT,J.NEAREST);Ue.bindFramebuffer(J.READ_FRAMEBUFFER,null),Ue.bindFramebuffer(J.DRAW_FRAMEBUFFER,null)}else if(_e!==0||G.isRenderTargetTexture||Je.has(G)){const ir=Je.get(G),gr=Je.get(ae);Ue.bindFramebuffer(J.READ_FRAMEBUFFER,gt),Ue.bindFramebuffer(J.DRAW_FRAMEBUFFER,dt);for(let si=0;si<at;si++)fn?J.framebufferTextureLayer(J.READ_FRAMEBUFFER,J.COLOR_ATTACHMENT0,ir.__webglTexture,_e,ct+si):J.framebufferTexture2D(J.READ_FRAMEBUFFER,J.COLOR_ATTACHMENT0,J.TEXTURE_2D,ir.__webglTexture,_e),Dr?J.framebufferTextureLayer(J.DRAW_FRAMEBUFFER,J.COLOR_ATTACHMENT0,gr.__webglTexture,Fe,un+si):J.framebufferTexture2D(J.DRAW_FRAMEBUFFER,J.COLOR_ATTACHMENT0,J.TEXTURE_2D,gr.__webglTexture,Fe),_e!==0?J.blitFramebuffer(bt,It,je,ot,Rt,jt,je,ot,J.COLOR_BUFFER_BIT,J.NEAREST):Dr?J.copyTexSubImage3D(Bn,Fe,Rt,jt,un+si,bt,It,je,ot):J.copyTexSubImage2D(Bn,Fe,Rt,jt,bt,It,je,ot);Ue.bindFramebuffer(J.READ_FRAMEBUFFER,null),Ue.bindFramebuffer(J.DRAW_FRAMEBUFFER,null)}else Dr?G.isDataTexture||G.isData3DTexture?J.texSubImage3D(Bn,Fe,Rt,jt,un,je,ot,at,tn,Wt,Kt.data):ae.isCompressedArrayTexture?J.compressedTexSubImage3D(Bn,Fe,Rt,jt,un,je,ot,at,tn,Kt.data):J.texSubImage3D(Bn,Fe,Rt,jt,un,je,ot,at,tn,Wt,Kt):G.isDataTexture?J.texSubImage2D(J.TEXTURE_2D,Fe,Rt,jt,je,ot,tn,Wt,Kt.data):G.isCompressedTexture?J.compressedTexSubImage2D(J.TEXTURE_2D,Fe,Rt,jt,Kt.width,Kt.height,tn,Kt.data):J.texSubImage2D(J.TEXTURE_2D,Fe,Rt,jt,je,ot,tn,Wt,Kt);J.pixelStorei(J.UNPACK_ROW_LENGTH,pn),J.pixelStorei(J.UNPACK_IMAGE_HEIGHT,_n),J.pixelStorei(J.UNPACK_SKIP_PIXELS,Ar),J.pixelStorei(J.UNPACK_SKIP_ROWS,Sn),J.pixelStorei(J.UNPACK_SKIP_IMAGES,Un),Fe===0&&ae.generateMipmaps&&J.generateMipmap(Bn),Ue.unbindTexture()},this.copyTextureToTexture3D=function(G,ae,me=null,pe=null,_e=0){return gy('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),this.copyTextureToTexture(G,ae,me,pe,_e)},this.initRenderTarget=function(G){Je.get(G).__webglFramebuffer===void 0&&At.setupRenderTarget(G)},this.initTexture=function(G){G.isCubeTexture?At.setTextureCube(G,0):G.isData3DTexture?At.setTexture3D(G,0):G.isDataArrayTexture||G.isCompressedArrayTexture?At.setTexture2DArray(G,0):At.setTexture2D(G,0),Ue.unbindTexture()},this.resetState=function(){E=0,C=0,T=null,Ue.reset(),it.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Oo}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const n=this.getContext();n.drawingBufferColorSpace=Qn._getDrawingBufferColorSpace(e),n.unpackColorSpace=Qn._getUnpackColorSpace()}}const Lge=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:gP,AddEquation:nd,AddOperation:Hj,AdditiveAnimationBlendMode:_P,AdditiveBlending:OR,AgXToneMapping:Kj,AlphaFormat:vP,AlwaysCompare:c9,AlwaysDepth:OE,AlwaysStencilFunc:zR,AmbientLight:JT,AnimationAction:nX,AnimationClip:Gy,AnimationLoader:tde,AnimationMixer:Ide,AnimationObjectGroup:Ade,AnimationUtils:Yce,ArcCurve:_9,ArrayCamera:Q9,ArrowHelper:Xde,AttachedBindMode:$R,Audio:eX,AudioAnalyser:fde,AudioContext:e3,AudioListener:dde,AudioLoader:lde,AxesHelper:Kde,BackSide:sa,BasicDepthPacking:t9,BasicShadowMap:Sj,BatchedMesh:x9,Bone:FT,BooleanKeyframeTrack:wf,Box2:Fde,Box3:ds,Box3Helper:Vde,BoxGeometry:bf,BoxHelper:Wde,BufferAttribute:Ln,BufferGeometry:An,BufferGeometryLoader:Y9,ByteType:_T,Cache:Ku,Camera:W1,CameraHelper:Hde,CanvasTexture:bce,CapsuleGeometry:LT,CatmullRomCurve3:S9,CineonToneMapping:jj,CircleGeometry:OT,ClampToEdgeWrapping:jr,Clock:t3,Color:Ct,ColorKeyframeTrack:qP,ColorManagement:Qn,CompressedArrayTexture:vce,CompressedCubeTexture:xce,CompressedTexture:Tp,CompressedTextureLoader:nde,ConeGeometry:q1,ConstantAlphaFactor:$j,ConstantColorFactor:Bj,Controls:Jde,CubeCamera:m9,CubeReflectionMapping:uu,CubeRefractionMapping:Md,CubeTexture:V1,CubeTextureLoader:V9,CubeUVReflectionMapping:p0,CubicBezierCurve:UP,CubicBezierCurve3:A9,CubicInterpolant:z9,CullFaceBack:LR,CullFaceFront:_j,CullFaceFrontBack:Rle,CullFaceNone:wj,Curve:Cl,CurvePath:I9,CustomBlending:Aj,CustomToneMapping:Xj,CylinderGeometry:K1,Cylindrical:Rde,Data3DTexture:kT,DataArrayTexture:MT,DataTexture:yl,DataTextureLoader:JP,DataUtils:mp,DecrementStencilOp:Gle,DecrementWrapStencilOp:Wle,DefaultLoadingManager:W9,DepthFormat:Oy,DepthStencilFormat:By,DepthTexture:OP,DetachedBindMode:Jj,DirectionalLight:Q1,DirectionalLightHelper:Gde,DiscreteInterpolant:G9,DodecahedronGeometry:BT,DoubleSide:ta,DstAlphaFactor:Fj,DstColorFactor:Pj,DynamicCopyUsage:sue,DynamicDrawUsage:Qle,DynamicReadUsage:nue,EdgesGeometry:w9,EllipseCurve:UT,EqualCompare:a9,EqualDepth:UE,EqualStencilFunc:Kle,EquirectangularReflectionMapping:Dy,EquirectangularRefractionMapping:e1,Euler:Ba,EventDispatcher:gu,ExtrudeGeometry:$T,FileLoader:vs,Float16BufferAttribute:Yue,Float32BufferAttribute:Jt,FloatType:ti,Fog:RT,FogExp2:NT,FramebufferTexture:yce,FrontSide:lu,Frustum:f0,FrustumArray:DT,GLBufferAttribute:Nde,GLSL1:oue,GLSL3:GR,GreaterCompare:o9,GreaterDepth:zE,GreaterEqualCompare:u9,GreaterEqualDepth:$E,GreaterEqualStencilFunc:Zle,GreaterStencilFunc:Jle,GridHelper:$de,Group:Xu,HalfFloatType:Wi,HemisphereLight:j9,HemisphereLightHelper:Ude,IcosahedronGeometry:J1,ImageBitmapLoader:Z9,ImageLoader:u1,ImageUtils:IP,IncrementStencilOp:zle,IncrementWrapStencilOp:Hle,InstancedBufferAttribute:Gp,InstancedBufferGeometry:J9,InstancedInterleavedBuffer:kde,InstancedMesh:DP,Int16BufferAttribute:que,Int32BufferAttribute:Jue,Int8BufferAttribute:jue,IntType:z1,InterleavedBuffer:j1,InterleavedBufferAttribute:kd,Interpolant:m0,InterpolateDiscrete:$p,InterpolateLinear:zp,InterpolateSmooth:XA,InterpolationSamplingMode:cue,InterpolationSamplingType:uue,InvertStencilOp:Vle,KeepStencilOp:Jh,KeyframeTrack:Wo,LOD:v9,LatheGeometry:zT,Layers:Ip,LessCompare:s9,LessDepth:BE,LessEqualCompare:AP,LessEqualDepth:Bp,LessEqualStencilFunc:qle,LessStencilFunc:Xle,Light:Qd,LightProbe:q9,Line:lc,Line3:Dde,LineBasicMaterial:Ws,LineCurve:$P,LineCurve3:E9,LineDashedMaterial:B9,LineLoop:PP,LineSegments:Tl,LinearFilter:er,LinearInterpolant:KP,LinearMipMapLinearFilter:HE,LinearMipMapNearestFilter:Ple,LinearMipmapLinearFilter:Ma,LinearMipmapNearestFilter:Ap,LinearSRGBColorSpace:du,LinearToneMapping:Wj,LinearTransfer:n1,Loader:_s,LoaderUtils:_d,LoadingManager:KT,LoopOnce:Yj,LoopPingPong:Qj,LoopRepeat:Zj,MOUSE:Kh,Material:Ki,MaterialLoader:YT,MathUtils:Ju,Matrix2:a3,Matrix3:Mn,Matrix4:ln,MaxEquation:Cj,Mesh:Cr,MeshBasicMaterial:ka,MeshDepthMaterial:VP,MeshDistanceMaterial:jP,MeshLambertMaterial:WP,MeshMatcapMaterial:O9,MeshNormalMaterial:L9,MeshPhongMaterial:D9,MeshPhysicalMaterial:Ho,MeshStandardMaterial:Zd,MeshToonMaterial:P9,MinEquation:Tj,MirroredRepeatWrapping:Up,MixOperation:Gj,MultiplyBlending:UR,MultiplyOperation:U1,NearestFilter:yi,NearestMipMapLinearFilter:Dle,NearestMipMapNearestFilter:Fle,NearestMipmapLinearFilter:od,NearestMipmapNearestFilter:$1,NeutralToneMapping:qj,NeverCompare:i9,NeverDepth:LE,NeverStencilFunc:jle,NoBlending:nu,NoColorSpace:Jl,NoToneMapping:ru,NormalAnimationBlendMode:CT,NormalBlending:Sp,NotEqualCompare:l9,NotEqualDepth:GE,NotEqualStencilFunc:Yle,NumberKeyframeTrack:Wp,Object3D:Yn,ObjectLoader:ade,ObjectSpaceNormalMap:r9,OctahedronGeometry:Y1,OneFactor:kj,OneMinusConstantAlphaFactor:zj,OneMinusConstantColorFactor:Uj,OneMinusDstAlphaFactor:Dj,OneMinusDstColorFactor:Lj,OneMinusSrcAlphaFactor:PE,OneMinusSrcColorFactor:Rj,OrthographicCamera:iu,PCFShadowMap:wT,PCFSoftShadowMap:vb,PMREMGenerator:qR,Path:bI,PerspectiveCamera:Qr,Plane:Bu,PlaneGeometry:yu,PlaneHelper:jde,PointLight:QP,PointLightHelper:Ode,Points:LP,PointsMaterial:PT,PolarGridHelper:zde,PolyhedronGeometry:Yd,PositionalAudio:pde,PropertyBinding:Hn,PropertyMixer:tX,QuadraticBezierCurve:zP,QuadraticBezierCurve3:GP,Quaternion:Kr,QuaternionKeyframeTrack:Vp,QuaternionLinearInterpolant:H9,RED_GREEN_RGTC2_Format:fI,RED_RGTC1_Format:wP,REVISION:vf,RGBADepthPacking:n9,RGBAFormat:ui,RGBAIntegerFormat:TT,RGBA_ASTC_10x10_Format:lI,RGBA_ASTC_10x5_Format:sI,RGBA_ASTC_10x6_Format:aI,RGBA_ASTC_10x8_Format:oI,RGBA_ASTC_12x10_Format:uI,RGBA_ASTC_12x12_Format:cI,RGBA_ASTC_4x4_Format:YE,RGBA_ASTC_5x4_Format:ZE,RGBA_ASTC_5x5_Format:QE,RGBA_ASTC_6x5_Format:eI,RGBA_ASTC_6x6_Format:tI,RGBA_ASTC_8x5_Format:nI,RGBA_ASTC_8x6_Format:rI,RGBA_ASTC_8x8_Format:iI,RGBA_BPTC_Format:Sb,RGBA_ETC2_EAC_Format:JE,RGBA_PVRTC_2BPPV1_Format:XE,RGBA_PVRTC_4BPPV1_Format:jE,RGBA_S3TC_DXT1_Format:bb,RGBA_S3TC_DXT3_Format:wb,RGBA_S3TC_DXT5_Format:_b,RGBDepthPacking:Ole,RGBFormat:xP,RGBIntegerFormat:Lle,RGB_BPTC_SIGNED_Format:dI,RGB_BPTC_UNSIGNED_Format:hI,RGB_ETC1_Format:KE,RGB_ETC2_Format:qE,RGB_PVRTC_2BPPV1_Format:VE,RGB_PVRTC_4BPPV1_Format:WE,RGB_S3TC_DXT1_Format:xb,RGDepthPacking:Ble,RGFormat:bP,RGIntegerFormat:IT,RawShaderMaterial:F9,Ray:xf,Raycaster:s3,RectAreaLight:X9,RedFormat:G1,RedIntegerFormat:H1,ReinhardToneMapping:Vj,RenderTarget:TP,RenderTarget3D:Tde,RepeatWrapping:ac,ReplaceStencilOp:$le,ReverseSubtractEquation:Ij,RingGeometry:GT,SIGNED_RED_GREEN_RGTC2_Format:mI,SIGNED_RED_RGTC1_Format:pI,SRGBColorSpace:Ui,SRGBTransfer:yr,Scene:oc,ShaderChunk:Dn,ShaderLib:hl,ShaderMaterial:ua,ShadowMaterial:R9,Shape:Cp,ShapeGeometry:HT,ShapePath:qde,ShapeUtils:fl,ShortType:ST,Skeleton:X1,SkeletonHelper:Lde,SkinnedMesh:FP,Source:ju,Sphere:Xi,SphereGeometry:Z1,Spherical:wI,SphericalHarmonics3:K9,SplineCurve:HP,SpotLight:ZP,SpotLightHelper:Pde,Sprite:y9,SpriteMaterial:RP,SrcAlphaFactor:DE,SrcAlphaSaturateFactor:Oj,SrcColorFactor:Nj,StaticCopyUsage:iue,StaticDrawUsage:r1,StaticReadUsage:tue,StereoCamera:ude,StreamCopyUsage:aue,StreamDrawUsage:eue,StreamReadUsage:rue,StringKeyframeTrack:_f,SubtractEquation:Ej,SubtractiveBlending:BR,TOUCH:qh,TangentSpaceNormalMap:Jd,TetrahedronGeometry:WT,Texture:hr,TextureLoader:qT,TextureUtils:the,TimestampQuery:lue,TorusGeometry:VT,TorusKnotGeometry:jT,Triangle:Ia,TriangleFanDrawMode:gI,TriangleStripDrawMode:SP,TrianglesDrawMode:e9,TubeGeometry:XT,UVMapping:Cd,Uint16BufferAttribute:CP,Uint32BufferAttribute:MP,Uint8BufferAttribute:Xue,Uint8ClampedBufferAttribute:Kue,Uniform:i3,UniformsGroup:Mde,UniformsLib:Bt,UniformsUtils:kP,UnsignedByteType:la,UnsignedInt248Type:Ly,UnsignedInt5999Type:yP,UnsignedIntType:cu,UnsignedShort4444Type:AT,UnsignedShort5551Type:ET,UnsignedShortType:Py,VSMShadowMap:ul,Vector2:Qe,Vector3:Z,Vector4:Xn,VectorKeyframeTrack:jp,VideoFrameTexture:gce,VideoTexture:b9,WebGL3DRenderTarget:Pue,WebGLArrayRenderTarget:Due,WebGLCoordinateSystem:Oo,WebGLCubeRenderTarget:NP,WebGLRenderTarget:Oa,WebGLRenderer:l3,WebGLUtils:uX,WebGPUCoordinateSystem:i1,WebXRController:KA,WireframeGeometry:N9,WrapAroundEnding:t1,ZeroCurvatureEnding:pp,ZeroFactor:Mj,ZeroSlopeEnding:fp,ZeroStencilOp:Ule,createCanvasElement:h9},Symbol.toStringTag,{value:"Module"}));var cX={exports:{}},Sf={};/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */Sf.ConcurrentRoot=1;Sf.ContinuousEventPriority=4;Sf.DefaultEventPriority=16;Sf.DiscreteEventPriority=1;Sf.IdleEventPriority=536870912;Sf.LegacyRoot=0;cX.exports=Sf;var ly=cX.exports;function Oge(t){let e;const n=new Set,r=(u,c)=>{const d=typeof u=="function"?u(e):u;if(d!==e){const h=e;e=c?d:Object.assign({},e,d),n.forEach(p=>p(e,h))}},i=()=>e,s=(u,c=i,d=Object.is)=>{console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");let h=c(e);function p(){const f=c(e);if(!d(h,f)){const g=h;u(h=f,g)}}return n.add(p),()=>n.delete(p)},l={setState:r,getState:i,subscribe:(u,c,d)=>c||d?s(u,c,d):(n.add(u),()=>n.delete(u)),destroy:()=>n.clear()};return e=t(r,i,l),l}const Bge=typeof window>"u"||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent),TH=Bge?ne.useEffect:ne.useLayoutEffect;function dX(t){const e=typeof t=="function"?Oge(t):t,n=(r=e.getState,i=Object.is)=>{const[,s]=ne.useReducer(y=>y+1,0),a=e.getState(),o=ne.useRef(a),l=ne.useRef(r),u=ne.useRef(i),c=ne.useRef(!1),d=ne.useRef();d.current===void 0&&(d.current=r(a));let h,p=!1;(o.current!==a||l.current!==r||u.current!==i||c.current)&&(h=r(a),p=!i(d.current,h)),TH(()=>{p&&(d.current=h),o.current=a,l.current=r,u.current=i,c.current=!1});const f=ne.useRef(a);TH(()=>{const y=()=>{try{const b=e.getState(),w=l.current(b);u.current(d.current,w)||(o.current=b,d.current=w,s())}catch{c.current=!0,s()}},m=e.subscribe(y);return e.getState()!==f.current&&y(),m},[]);const g=p?h:d.current;return ne.useDebugValue(g),g};return Object.assign(n,e),n[Symbol.iterator]=function(){console.warn("[useStore, api] = create() is deprecated and will be removed in v4");const r=[n,e];return{next(){const i=r.length<=0;return{value:r.shift(),done:i}}}},n}const Uge=t=>typeof t=="object"&&typeof t.then=="function",yp=[];function hX(t,e,n=(r,i)=>r===i){if(t===e)return!0;if(!t||!e)return!1;const r=t.length;if(e.length!==r)return!1;for(let i=0;i<r;i++)if(!n(t[i],e[i]))return!1;return!0}function pX(t,e=null,n=!1,r={}){e===null&&(e=[t]);for(const s of yp)if(hX(e,s.keys,s.equal)){if(n)return;if(Object.prototype.hasOwnProperty.call(s,"error"))throw s.error;if(Object.prototype.hasOwnProperty.call(s,"response"))return r.lifespan&&r.lifespan>0&&(s.timeout&&clearTimeout(s.timeout),s.timeout=setTimeout(s.remove,r.lifespan)),s.response;if(!n)throw s.promise}const i={keys:e,equal:r.equal,remove:()=>{const s=yp.indexOf(i);s!==-1&&yp.splice(s,1)},promise:(Uge(t)?t:t(...e)).then(s=>{i.response=s,r.lifespan&&r.lifespan>0&&(i.timeout=setTimeout(i.remove,r.lifespan))}).catch(s=>i.error=s)};if(yp.push(i),!n)throw i.promise}const $ge=(t,e,n)=>pX(t,e,!1,n),zge=(t,e,n)=>void pX(t,e,!0,n),Gge=t=>{if(t===void 0||t.length===0)yp.splice(0,yp.length);else{const e=yp.find(n=>hX(t,n.keys,n.equal));e&&e.remove()}};var fX={exports:{}},Jk={exports:{}},Yk={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var CH;function Hge(){return CH||(CH=1,function(t){function e(O,j){var X=O.length;O.push(j);e:for(;0<X;){var te=X-1>>>1,le=O[te];if(0<i(le,j))O[te]=j,O[X]=le,X=te;else break e}}function n(O){return O.length===0?null:O[0]}function r(O){if(O.length===0)return null;var j=O[0],X=O.pop();if(X!==j){O[0]=X;e:for(var te=0,le=O.length,ge=le>>>1;te<ge;){var ie=2*(te+1)-1,we=O[ie],Ce=ie+1,Re=O[Ce];if(0>i(we,X))Ce<le&&0>i(Re,we)?(O[te]=Re,O[Ce]=X,te=Ce):(O[te]=we,O[ie]=X,te=ie);else if(Ce<le&&0>i(Re,X))O[te]=Re,O[Ce]=X,te=Ce;else break e}}return j}function i(O,j){var X=O.sortIndex-j.sortIndex;return X!==0?X:O.id-j.id}if(typeof performance=="object"&&typeof performance.now=="function"){var s=performance;t.unstable_now=function(){return s.now()}}else{var a=Date,o=a.now();t.unstable_now=function(){return a.now()-o}}var l=[],u=[],c=1,d=null,h=3,p=!1,f=!1,g=!1,y=typeof setTimeout=="function"?setTimeout:null,m=typeof clearTimeout=="function"?clearTimeout:null,b=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function w(O){for(var j=n(u);j!==null;){if(j.callback===null)r(u);else if(j.startTime<=O)r(u),j.sortIndex=j.expirationTime,e(l,j);else break;j=n(u)}}function _(O){if(g=!1,w(O),!f)if(n(l)!==null)f=!0,K(S);else{var j=n(u);j!==null&&Q(_,j.startTime-O)}}function S(O,j){f=!1,g&&(g=!1,m(T),T=-1),p=!0;var X=h;try{for(w(j),d=n(l);d!==null&&(!(d.expirationTime>j)||O&&!R());){var te=d.callback;if(typeof te=="function"){d.callback=null,h=d.priorityLevel;var le=te(d.expirationTime<=j);j=t.unstable_now(),typeof le=="function"?d.callback=le:d===n(l)&&r(l),w(j)}else r(l);d=n(l)}if(d!==null)var ge=!0;else{var ie=n(u);ie!==null&&Q(_,ie.startTime-j),ge=!1}return ge}finally{d=null,h=X,p=!1}}var E=!1,C=null,T=-1,M=5,k=-1;function R(){return!(t.unstable_now()-k<M)}function N(){if(C!==null){var O=t.unstable_now();k=O;var j=!0;try{j=C(!0,O)}finally{j?B():(E=!1,C=null)}}else E=!1}var B;if(typeof b=="function")B=function(){b(N)};else if(typeof MessageChannel<"u"){var z=new MessageChannel,V=z.port2;z.port1.onmessage=N,B=function(){V.postMessage(null)}}else B=function(){y(N,0)};function K(O){C=O,E||(E=!0,B())}function Q(O,j){T=y(function(){O(t.unstable_now())},j)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(O){O.callback=null},t.unstable_continueExecution=function(){f||p||(f=!0,K(S))},t.unstable_forceFrameRate=function(O){0>O||125<O?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):M=0<O?Math.floor(1e3/O):5},t.unstable_getCurrentPriorityLevel=function(){return h},t.unstable_getFirstCallbackNode=function(){return n(l)},t.unstable_next=function(O){switch(h){case 1:case 2:case 3:var j=3;break;default:j=h}var X=h;h=j;try{return O()}finally{h=X}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(O,j){switch(O){case 1:case 2:case 3:case 4:case 5:break;default:O=3}var X=h;h=O;try{return j()}finally{h=X}},t.unstable_scheduleCallback=function(O,j,X){var te=t.unstable_now();switch(typeof X=="object"&&X!==null?(X=X.delay,X=typeof X=="number"&&0<X?te+X:te):X=te,O){case 1:var le=-1;break;case 2:le=250;break;case 5:le=1073741823;break;case 4:le=1e4;break;default:le=5e3}return le=X+le,O={id:c++,callback:j,priorityLevel:O,startTime:X,expirationTime:le,sortIndex:-1},X>te?(O.sortIndex=X,e(u,O),n(l)===null&&O===n(u)&&(g?(m(T),T=-1):g=!0,Q(_,X-te))):(O.sortIndex=le,e(l,O),f||p||(f=!0,K(S))),O},t.unstable_shouldYield=R,t.unstable_wrapCallback=function(O){var j=h;return function(){var X=h;h=j;try{return O.apply(this,arguments)}finally{h=X}}}}(Yk)),Yk}var MH;function Wge(){return MH||(MH=1,Jk.exports=Hge()),Jk.exports}/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Vge=function(e){var n={},r=ne,i=Wge(),s=Object.assign;function a(v){for(var x="https://reactjs.org/docs/error-decoder.html?invariant="+v,A=1;A<arguments.length;A++)x+="&args[]="+encodeURIComponent(arguments[A]);return"Minified React error #"+v+"; visit "+x+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var o=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,l=Symbol.for("react.element"),u=Symbol.for("react.portal"),c=Symbol.for("react.fragment"),d=Symbol.for("react.strict_mode"),h=Symbol.for("react.profiler"),p=Symbol.for("react.provider"),f=Symbol.for("react.context"),g=Symbol.for("react.forward_ref"),y=Symbol.for("react.suspense"),m=Symbol.for("react.suspense_list"),b=Symbol.for("react.memo"),w=Symbol.for("react.lazy"),_=Symbol.for("react.offscreen"),S=Symbol.iterator;function E(v){return v===null||typeof v!="object"?null:(v=S&&v[S]||v["@@iterator"],typeof v=="function"?v:null)}function C(v){if(v==null)return null;if(typeof v=="function")return v.displayName||v.name||null;if(typeof v=="string")return v;switch(v){case c:return"Fragment";case u:return"Portal";case h:return"Profiler";case d:return"StrictMode";case y:return"Suspense";case m:return"SuspenseList"}if(typeof v=="object")switch(v.$$typeof){case f:return(v.displayName||"Context")+".Consumer";case p:return(v._context.displayName||"Context")+".Provider";case g:var x=v.render;return v=v.displayName,v||(v=x.displayName||x.name||"",v=v!==""?"ForwardRef("+v+")":"ForwardRef"),v;case b:return x=v.displayName||null,x!==null?x:C(v.type)||"Memo";case w:x=v._payload,v=v._init;try{return C(v(x))}catch{}}return null}function T(v){var x=v.type;switch(v.tag){case 24:return"Cache";case 9:return(x.displayName||"Context")+".Consumer";case 10:return(x._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return v=x.render,v=v.displayName||v.name||"",x.displayName||(v!==""?"ForwardRef("+v+")":"ForwardRef");case 7:return"Fragment";case 5:return x;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return C(x);case 8:return x===d?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof x=="function")return x.displayName||x.name||null;if(typeof x=="string")return x}return null}function M(v){var x=v,A=v;if(v.alternate)for(;x.return;)x=x.return;else{v=x;do x=v,x.flags&4098&&(A=x.return),v=x.return;while(v)}return x.tag===3?A:null}function k(v){if(M(v)!==v)throw Error(a(188))}function R(v){var x=v.alternate;if(!x){if(x=M(v),x===null)throw Error(a(188));return x!==v?null:v}for(var A=v,I=x;;){var F=A.return;if(F===null)break;var U=F.alternate;if(U===null){if(I=F.return,I!==null){A=I;continue}break}if(F.child===U.child){for(U=F.child;U;){if(U===A)return k(F),v;if(U===I)return k(F),x;U=U.sibling}throw Error(a(188))}if(A.return!==I.return)A=F,I=U;else{for(var se=!1,Ae=F.child;Ae;){if(Ae===A){se=!0,A=F,I=U;break}if(Ae===I){se=!0,I=F,A=U;break}Ae=Ae.sibling}if(!se){for(Ae=U.child;Ae;){if(Ae===A){se=!0,A=U,I=F;break}if(Ae===I){se=!0,I=U,A=F;break}Ae=Ae.sibling}if(!se)throw Error(a(189))}}if(A.alternate!==I)throw Error(a(190))}if(A.tag!==3)throw Error(a(188));return A.stateNode.current===A?v:x}function N(v){return v=R(v),v!==null?B(v):null}function B(v){if(v.tag===5||v.tag===6)return v;for(v=v.child;v!==null;){var x=B(v);if(x!==null)return x;v=v.sibling}return null}function z(v){if(v.tag===5||v.tag===6)return v;for(v=v.child;v!==null;){if(v.tag!==4){var x=z(v);if(x!==null)return x}v=v.sibling}return null}var V=Array.isArray,K=e.getPublicInstance,Q=e.getRootHostContext,O=e.getChildHostContext,j=e.prepareForCommit,X=e.resetAfterCommit,te=e.createInstance,le=e.appendInitialChild,ge=e.finalizeInitialChildren,ie=e.prepareUpdate,we=e.shouldSetTextContent,Ce=e.createTextInstance,Re=e.scheduleTimeout,Le=e.cancelTimeout,lt=e.noTimeout,st=e.isPrimaryRenderer,Et=e.supportsMutation,Tt=e.supportsPersistence,xt=e.supportsHydration,J=e.getInstanceFromNode,Ye=e.preparePortalMount,Be=e.getCurrentEventPriority,tt=e.detachDeletedInstance,Ue=e.supportsMicrotasks,St=e.scheduleMicrotask,Je=e.supportsTestSelectors,At=e.findFiberRoot,Vt=e.getBoundingRect,re=e.getTextContent,H=e.isHiddenSubtree,Ee=e.matchAccessibilityRole,Oe=e.setFocusIfFocusable,Xe=e.setupIntersectionObserver,$e=e.appendChild,Lt=e.appendChildToContainer,wt=e.commitTextUpdate,Pt=e.commitMount,Ht=e.commitUpdate,et=e.insertBefore,mt=e.insertInContainerBefore,Ot=e.removeChild,he=e.removeChildFromContainer,Me=e.resetTextContent,it=e.hideInstance,de=e.hideTextInstance,Ne=e.unhideInstance,nt=e.unhideTextInstance,Mt=e.clearContainer,ut=e.cloneInstance,Ze=e.createContainerChildSet,kt=e.appendChildToContainerChildSet,Se=e.finalizeContainerChildren,qe=e.replaceContainerChildren,pt=e.cloneHiddenInstance,ht=e.cloneHiddenTextInstance,xn=e.canHydrateInstance,ar=e.canHydrateTextInstance,gn=e.canHydrateSuspenseInstance,sn=e.isSuspenseInstancePending,ur=e.isSuspenseInstanceFallback,$r=e.registerSuspenseInstanceRetry,zr=e.getNextHydratableSibling,yn=e.getFirstHydratableChild,Wa=e.getFirstHydratableChildWithinContainer,Va=e.getFirstHydratableChildWithinSuspenseInstance,$=e.hydrateInstance,Y=e.hydrateTextInstance,ye=e.hydrateSuspenseInstance,De=e.getNextHydratableInstanceAfterSuspenseInstance,He=e.commitHydratedContainer,Ve=e.commitHydratedSuspenseInstance,gt=e.clearSuspenseBoundary,dt=e.clearSuspenseBoundaryFromContainer,G=e.shouldDeleteUnhydratedTailInstances,ae=e.didNotMatchHydratedContainerTextInstance,me=e.didNotMatchHydratedTextInstance,pe;function _e(v){if(pe===void 0)try{throw Error()}catch(A){var x=A.stack.trim().match(/\n( *(at )?)/);pe=x&&x[1]||""}return`
`+pe+v}var Fe=!1;function je(v,x){if(!v||Fe)return"";Fe=!0;var A=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(x)if(x=function(){throw Error()},Object.defineProperty(x.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(x,[])}catch(_t){var I=_t}Reflect.construct(v,[],x)}else{try{x.call()}catch(_t){I=_t}v.call(x.prototype)}else{try{throw Error()}catch(_t){I=_t}v()}}catch(_t){if(_t&&I&&typeof _t.stack=="string"){for(var F=_t.stack.split(`
`),U=I.stack.split(`
`),se=F.length-1,Ae=U.length-1;1<=se&&0<=Ae&&F[se]!==U[Ae];)Ae--;for(;1<=se&&0<=Ae;se--,Ae--)if(F[se]!==U[Ae]){if(se!==1||Ae!==1)do if(se--,Ae--,0>Ae||F[se]!==U[Ae]){var Ke=`
`+F[se].replace(" at new "," at ");return v.displayName&&Ke.includes("<anonymous>")&&(Ke=Ke.replace("<anonymous>",v.displayName)),Ke}while(1<=se&&0<=Ae);break}}}finally{Fe=!1,Error.prepareStackTrace=A}return(v=v?v.displayName||v.name:"")?_e(v):""}var ot=Object.prototype.hasOwnProperty,at=[],bt=-1;function It(v){return{current:v}}function ct(v){0>bt||(v.current=at[bt],at[bt]=null,bt--)}function Rt(v,x){bt++,at[bt]=v.current,v.current=x}var jt={},un=It(jt),Kt=It(!1),tn=jt;function Wt(v,x){var A=v.type.contextTypes;if(!A)return jt;var I=v.stateNode;if(I&&I.__reactInternalMemoizedUnmaskedChildContext===x)return I.__reactInternalMemoizedMaskedChildContext;var F={},U;for(U in A)F[U]=x[U];return I&&(v=v.stateNode,v.__reactInternalMemoizedUnmaskedChildContext=x,v.__reactInternalMemoizedMaskedChildContext=F),F}function Bn(v){return v=v.childContextTypes,v!=null}function pn(){ct(Kt),ct(un)}function _n(v,x,A){if(un.current!==jt)throw Error(a(168));Rt(un,x),Rt(Kt,A)}function Ar(v,x,A){var I=v.stateNode;if(x=x.childContextTypes,typeof I.getChildContext!="function")return A;I=I.getChildContext();for(var F in I)if(!(F in x))throw Error(a(108,T(v)||"Unknown",F));return s({},A,I)}function Sn(v){return v=(v=v.stateNode)&&v.__reactInternalMemoizedMergedChildContext||jt,tn=un.current,Rt(un,v),Rt(Kt,Kt.current),!0}function Un(v,x,A){var I=v.stateNode;if(!I)throw Error(a(169));A?(v=Ar(v,x,tn),I.__reactInternalMemoizedMergedChildContext=v,ct(Kt),ct(un),Rt(un,v)):ct(Kt),Rt(Kt,A)}var fn=Math.clz32?Math.clz32:gr,Dr=Math.log,ir=Math.LN2;function gr(v){return v>>>=0,v===0?32:31-(Dr(v)/ir|0)|0}var si=64,Ko=4194304;function ps(v){switch(v&-v){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return v&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return v&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return v}}function yh(v,x){var A=v.pendingLanes;if(A===0)return 0;var I=0,F=v.suspendedLanes,U=v.pingedLanes,se=A&268435455;if(se!==0){var Ae=se&~F;Ae!==0?I=ps(Ae):(U&=se,U!==0&&(I=ps(U)))}else se=A&~F,se!==0?I=ps(se):U!==0&&(I=ps(U));if(I===0)return 0;if(x!==0&&x!==I&&!(x&F)&&(F=I&-I,U=x&-x,F>=U||F===16&&(U&4194240)!==0))return x;if(I&4&&(I|=A&16),x=v.entangledLanes,x!==0)for(v=v.entanglements,x&=I;0<x;)A=31-fn(x),F=1<<A,I|=v[A],x&=~F;return I}function o_(v,x){switch(v){case 1:case 2:case 4:return x+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return x+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Gv(v,x){for(var A=v.suspendedLanes,I=v.pingedLanes,F=v.expirationTimes,U=v.pendingLanes;0<U;){var se=31-fn(U),Ae=1<<se,Ke=F[se];Ke===-1?(!(Ae&A)||Ae&I)&&(F[se]=o_(Ae,x)):Ke<=x&&(v.expiredLanes|=Ae),U&=~Ae}}function wc(v){return v=v.pendingLanes&-1073741825,v!==0?v:v&1073741824?1073741824:0}function _c(v){for(var x=[],A=0;31>A;A++)x.push(v);return x}function Nl(v,x,A){v.pendingLanes|=x,x!==536870912&&(v.suspendedLanes=0,v.pingedLanes=0),v=v.eventTimes,x=31-fn(x),v[x]=A}function l_(v,x){var A=v.pendingLanes&~x;v.pendingLanes=x,v.suspendedLanes=0,v.pingedLanes=0,v.expiredLanes&=x,v.mutableReadLanes&=x,v.entangledLanes&=x,x=v.entanglements;var I=v.eventTimes;for(v=v.expirationTimes;0<A;){var F=31-fn(A),U=1<<F;x[F]=0,I[F]=-1,v[F]=-1,A&=~U}}function Sc(v,x){var A=v.entangledLanes|=x;for(v=v.entanglements;A;){var I=31-fn(A),F=1<<I;F&x|v[I]&x&&(v[I]|=x),A&=~F}}var Wn=0;function u_(v){return v&=-v,1<v?4<v?v&268435455?16:536870912:4:1}var oe=i.unstable_scheduleCallback,ke=i.unstable_cancelCallback,vt=i.unstable_shouldYield,cn=i.unstable_requestPaint,en=i.unstable_now,vn=i.unstable_ImmediatePriority,$t=i.unstable_UserBlockingPriority,nn=i.unstable_NormalPriority,Nr=i.unstable_IdlePriority,ts=null,Si=null;function c_(v){if(Si&&typeof Si.onCommitFiberRoot=="function")try{Si.onCommitFiberRoot(ts,v,void 0,(v.current.flags&128)===128)}catch{}}function Hv(v,x){return v===x&&(v!==0||1/v===1/x)||v!==v&&x!==x}var go=typeof Object.is=="function"?Object.is:Hv,Jr=null,qo=!1,ng=!1;function WU(v){Jr===null?Jr=[v]:Jr.push(v)}function hre(v){qo=!0,WU(v)}function Rl(){if(!ng&&Jr!==null){ng=!0;var v=0,x=Wn;try{var A=Jr;for(Wn=1;v<A.length;v++){var I=A[v];do I=I(!0);while(I!==null)}Jr=null,qo=!1}catch(F){throw Jr!==null&&(Jr=Jr.slice(v+1)),oe(vn,Rl),F}finally{Wn=x,ng=!1}}return null}var pre=o.ReactCurrentBatchConfig;function d_(v,x){if(go(v,x))return!0;if(typeof v!="object"||v===null||typeof x!="object"||x===null)return!1;var A=Object.keys(v),I=Object.keys(x);if(A.length!==I.length)return!1;for(I=0;I<A.length;I++){var F=A[I];if(!ot.call(x,F)||!go(v[F],x[F]))return!1}return!0}function fre(v){switch(v.tag){case 5:return _e(v.type);case 16:return _e("Lazy");case 13:return _e("Suspense");case 19:return _e("SuspenseList");case 0:case 2:case 15:return v=je(v.type,!1),v;case 11:return v=je(v.type.render,!1),v;case 1:return v=je(v.type,!0),v;default:return""}}function Jo(v,x){if(v&&v.defaultProps){x=s({},x),v=v.defaultProps;for(var A in v)x[A]===void 0&&(x[A]=v[A]);return x}return x}var h_=It(null),p_=null,rg=null,kM=null;function NM(){kM=rg=p_=null}function VU(v,x,A){st?(Rt(h_,x._currentValue),x._currentValue=A):(Rt(h_,x._currentValue2),x._currentValue2=A)}function RM(v){var x=h_.current;ct(h_),st?v._currentValue=x:v._currentValue2=x}function FM(v,x,A){for(;v!==null;){var I=v.alternate;if((v.childLanes&x)!==x?(v.childLanes|=x,I!==null&&(I.childLanes|=x)):I!==null&&(I.childLanes&x)!==x&&(I.childLanes|=x),v===A)break;v=v.return}}function ig(v,x){p_=v,kM=rg=null,v=v.dependencies,v!==null&&v.firstContext!==null&&(v.lanes&x&&(Ka=!0),v.firstContext=null)}function yo(v){var x=st?v._currentValue:v._currentValue2;if(kM!==v)if(v={context:v,memoizedValue:x,next:null},rg===null){if(p_===null)throw Error(a(308));rg=v,p_.dependencies={lanes:0,firstContext:v}}else rg=rg.next=v;return x}var Fl=null,Ac=!1;function DM(v){v.updateQueue={baseState:v.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function jU(v,x){v=v.updateQueue,x.updateQueue===v&&(x.updateQueue={baseState:v.baseState,firstBaseUpdate:v.firstBaseUpdate,lastBaseUpdate:v.lastBaseUpdate,shared:v.shared,effects:v.effects})}function _u(v,x){return{eventTime:v,lane:x,tag:0,payload:null,callback:null,next:null}}function Ec(v,x){var A=v.updateQueue;A!==null&&(A=A.shared,Ai!==null&&v.mode&1&&!(zn&2)?(v=A.interleaved,v===null?(x.next=x,Fl===null?Fl=[A]:Fl.push(A)):(x.next=v.next,v.next=x),A.interleaved=x):(v=A.pending,v===null?x.next=x:(x.next=v.next,v.next=x),A.pending=x))}function f_(v,x,A){if(x=x.updateQueue,x!==null&&(x=x.shared,(A&4194240)!==0)){var I=x.lanes;I&=v.pendingLanes,A|=I,x.lanes=A,Sc(v,A)}}function XU(v,x){var A=v.updateQueue,I=v.alternate;if(I!==null&&(I=I.updateQueue,A===I)){var F=null,U=null;if(A=A.firstBaseUpdate,A!==null){do{var se={eventTime:A.eventTime,lane:A.lane,tag:A.tag,payload:A.payload,callback:A.callback,next:null};U===null?F=U=se:U=U.next=se,A=A.next}while(A!==null);U===null?F=U=x:U=U.next=x}else F=U=x;A={baseState:I.baseState,firstBaseUpdate:F,lastBaseUpdate:U,shared:I.shared,effects:I.effects},v.updateQueue=A;return}v=A.lastBaseUpdate,v===null?A.firstBaseUpdate=x:v.next=x,A.lastBaseUpdate=x}function m_(v,x,A,I){var F=v.updateQueue;Ac=!1;var U=F.firstBaseUpdate,se=F.lastBaseUpdate,Ae=F.shared.pending;if(Ae!==null){F.shared.pending=null;var Ke=Ae,_t=Ke.next;Ke.next=null,se===null?U=_t:se.next=_t,se=Ke;var Yt=v.alternate;Yt!==null&&(Yt=Yt.updateQueue,Ae=Yt.lastBaseUpdate,Ae!==se&&(Ae===null?Yt.firstBaseUpdate=_t:Ae.next=_t,Yt.lastBaseUpdate=Ke))}if(U!==null){var Tn=F.baseState;se=0,Yt=_t=Ke=null,Ae=U;do{var dn=Ae.lane,Ir=Ae.eventTime;if((I&dn)===dn){Yt!==null&&(Yt=Yt.next={eventTime:Ir,lane:0,tag:Ae.tag,payload:Ae.payload,callback:Ae.callback,next:null});e:{var on=v,Cs=Ae;switch(dn=x,Ir=A,Cs.tag){case 1:if(on=Cs.payload,typeof on=="function"){Tn=on.call(Ir,Tn,dn);break e}Tn=on;break e;case 3:on.flags=on.flags&-65537|128;case 0:if(on=Cs.payload,dn=typeof on=="function"?on.call(Ir,Tn,dn):on,dn==null)break e;Tn=s({},Tn,dn);break e;case 2:Ac=!0}}Ae.callback!==null&&Ae.lane!==0&&(v.flags|=64,dn=F.effects,dn===null?F.effects=[Ae]:dn.push(Ae))}else Ir={eventTime:Ir,lane:dn,tag:Ae.tag,payload:Ae.payload,callback:Ae.callback,next:null},Yt===null?(_t=Yt=Ir,Ke=Tn):Yt=Yt.next=Ir,se|=dn;if(Ae=Ae.next,Ae===null){if(Ae=F.shared.pending,Ae===null)break;dn=Ae,Ae=dn.next,dn.next=null,F.lastBaseUpdate=dn,F.shared.pending=null}}while(!0);if(Yt===null&&(Ke=Tn),F.baseState=Ke,F.firstBaseUpdate=_t,F.lastBaseUpdate=Yt,x=F.shared.interleaved,x!==null){F=x;do se|=F.lane,F=F.next;while(F!==x)}else U===null&&(F.shared.lanes=0);pg|=se,v.lanes=se,v.memoizedState=Tn}}function KU(v,x,A){if(v=x.effects,x.effects=null,v!==null)for(x=0;x<v.length;x++){var I=v[x],F=I.callback;if(F!==null){if(I.callback=null,I=A,typeof F!="function")throw Error(a(191,F));F.call(I)}}}var qU=new r.Component().refs;function PM(v,x,A,I){x=v.memoizedState,A=A(I,x),A=A==null?x:s({},x,A),v.memoizedState=A,v.lanes===0&&(v.updateQueue.baseState=A)}var g_={isMounted:function(v){return(v=v._reactInternals)?M(v)===v:!1},enqueueSetState:function(v,x,A){v=v._reactInternals;var I=Js(),F=Cc(v),U=_u(I,F);U.payload=x,A!=null&&(U.callback=A),Ec(v,U),x=_o(v,F,I),x!==null&&f_(x,v,F)},enqueueReplaceState:function(v,x,A){v=v._reactInternals;var I=Js(),F=Cc(v),U=_u(I,F);U.tag=1,U.payload=x,A!=null&&(U.callback=A),Ec(v,U),x=_o(v,F,I),x!==null&&f_(x,v,F)},enqueueForceUpdate:function(v,x){v=v._reactInternals;var A=Js(),I=Cc(v),F=_u(A,I);F.tag=2,x!=null&&(F.callback=x),Ec(v,F),x=_o(v,I,A),x!==null&&f_(x,v,I)}};function JU(v,x,A,I,F,U,se){return v=v.stateNode,typeof v.shouldComponentUpdate=="function"?v.shouldComponentUpdate(I,U,se):x.prototype&&x.prototype.isPureReactComponent?!d_(A,I)||!d_(F,U):!0}function YU(v,x,A){var I=!1,F=jt,U=x.contextType;return typeof U=="object"&&U!==null?U=yo(U):(F=Bn(x)?tn:un.current,I=x.contextTypes,U=(I=I!=null)?Wt(v,F):jt),x=new x(A,U),v.memoizedState=x.state!==null&&x.state!==void 0?x.state:null,x.updater=g_,v.stateNode=x,x._reactInternals=v,I&&(v=v.stateNode,v.__reactInternalMemoizedUnmaskedChildContext=F,v.__reactInternalMemoizedMaskedChildContext=U),x}function ZU(v,x,A,I){v=x.state,typeof x.componentWillReceiveProps=="function"&&x.componentWillReceiveProps(A,I),typeof x.UNSAFE_componentWillReceiveProps=="function"&&x.UNSAFE_componentWillReceiveProps(A,I),x.state!==v&&g_.enqueueReplaceState(x,x.state,null)}function LM(v,x,A,I){var F=v.stateNode;F.props=A,F.state=v.memoizedState,F.refs=qU,DM(v);var U=x.contextType;typeof U=="object"&&U!==null?F.context=yo(U):(U=Bn(x)?tn:un.current,F.context=Wt(v,U)),F.state=v.memoizedState,U=x.getDerivedStateFromProps,typeof U=="function"&&(PM(v,x,U,A),F.state=v.memoizedState),typeof x.getDerivedStateFromProps=="function"||typeof F.getSnapshotBeforeUpdate=="function"||typeof F.UNSAFE_componentWillMount!="function"&&typeof F.componentWillMount!="function"||(x=F.state,typeof F.componentWillMount=="function"&&F.componentWillMount(),typeof F.UNSAFE_componentWillMount=="function"&&F.UNSAFE_componentWillMount(),x!==F.state&&g_.enqueueReplaceState(F,F.state,null),m_(v,A,F,I),F.state=v.memoizedState),typeof F.componentDidMount=="function"&&(v.flags|=4194308)}var sg=[],ag=0,y_=null,v_=0,vo=[],xo=0,vh=null,Su=1,Au="";function xh(v,x){sg[ag++]=v_,sg[ag++]=y_,y_=v,v_=x}function QU(v,x,A){vo[xo++]=Su,vo[xo++]=Au,vo[xo++]=vh,vh=v;var I=Su;v=Au;var F=32-fn(I)-1;I&=~(1<<F),A+=1;var U=32-fn(x)+F;if(30<U){var se=F-F%5;U=(I&(1<<se)-1).toString(32),I>>=se,F-=se,Su=1<<32-fn(x)+F|A<<F|I,Au=U+v}else Su=1<<U|A<<F|I,Au=v}function OM(v){v.return!==null&&(xh(v,1),QU(v,1,0))}function BM(v){for(;v===y_;)y_=sg[--ag],sg[ag]=null,v_=sg[--ag],sg[ag]=null;for(;v===vh;)vh=vo[--xo],vo[xo]=null,Au=vo[--xo],vo[xo]=null,Su=vo[--xo],vo[xo]=null}var ja=null,Xa=null,Gr=!1,Wv=!1,Yo=null;function e$(v,x){var A=So(5,null,null,0);A.elementType="DELETED",A.stateNode=x,A.return=v,x=v.deletions,x===null?(v.deletions=[A],v.flags|=16):x.push(A)}function t$(v,x){switch(v.tag){case 5:return x=xn(x,v.type,v.pendingProps),x!==null?(v.stateNode=x,ja=v,Xa=yn(x),!0):!1;case 6:return x=ar(x,v.pendingProps),x!==null?(v.stateNode=x,ja=v,Xa=null,!0):!1;case 13:if(x=gn(x),x!==null){var A=vh!==null?{id:Su,overflow:Au}:null;return v.memoizedState={dehydrated:x,treeContext:A,retryLane:1073741824},A=So(18,null,null,0),A.stateNode=x,A.return=v,v.child=A,ja=v,Xa=null,!0}return!1;default:return!1}}function UM(v){return(v.mode&1)!==0&&(v.flags&128)===0}function $M(v){if(Gr){var x=Xa;if(x){var A=x;if(!t$(v,x)){if(UM(v))throw Error(a(418));x=zr(A);var I=ja;x&&t$(v,x)?e$(I,A):(v.flags=v.flags&-4097|2,Gr=!1,ja=v)}}else{if(UM(v))throw Error(a(418));v.flags=v.flags&-4097|2,Gr=!1,ja=v}}}function n$(v){for(v=v.return;v!==null&&v.tag!==5&&v.tag!==3&&v.tag!==13;)v=v.return;ja=v}function Vv(v){if(!xt||v!==ja)return!1;if(!Gr)return n$(v),Gr=!0,!1;if(v.tag!==3&&(v.tag!==5||G(v.type)&&!we(v.type,v.memoizedProps))){var x=Xa;if(x){if(UM(v)){for(v=Xa;v;)v=zr(v);throw Error(a(418))}for(;x;)e$(v,x),x=zr(x)}}if(n$(v),v.tag===13){if(!xt)throw Error(a(316));if(v=v.memoizedState,v=v!==null?v.dehydrated:null,!v)throw Error(a(317));Xa=De(v)}else Xa=ja?zr(v.stateNode):null;return!0}function og(){xt&&(Xa=ja=null,Wv=Gr=!1)}function zM(v){Yo===null?Yo=[v]:Yo.push(v)}function jv(v,x,A){if(v=A.ref,v!==null&&typeof v!="function"&&typeof v!="object"){if(A._owner){if(A=A._owner,A){if(A.tag!==1)throw Error(a(309));var I=A.stateNode}if(!I)throw Error(a(147,v));var F=I,U=""+v;return x!==null&&x.ref!==null&&typeof x.ref=="function"&&x.ref._stringRef===U?x.ref:(x=function(se){var Ae=F.refs;Ae===qU&&(Ae=F.refs={}),se===null?delete Ae[U]:Ae[U]=se},x._stringRef=U,x)}if(typeof v!="string")throw Error(a(284));if(!A._owner)throw Error(a(290,v))}return v}function x_(v,x){throw v=Object.prototype.toString.call(x),Error(a(31,v==="[object Object]"?"object with keys {"+Object.keys(x).join(", ")+"}":v))}function r$(v){var x=v._init;return x(v._payload)}function i$(v){function x(Pe,Te){if(v){var We=Pe.deletions;We===null?(Pe.deletions=[Te],Pe.flags|=16):We.push(Te)}}function A(Pe,Te){if(!v)return null;for(;Te!==null;)x(Pe,Te),Te=Te.sibling;return null}function I(Pe,Te){for(Pe=new Map;Te!==null;)Te.key!==null?Pe.set(Te.key,Te):Pe.set(Te.index,Te),Te=Te.sibling;return Pe}function F(Pe,Te){return Pe=kc(Pe,Te),Pe.index=0,Pe.sibling=null,Pe}function U(Pe,Te,We){return Pe.index=We,v?(We=Pe.alternate,We!==null?(We=We.index,We<Te?(Pe.flags|=2,Te):We):(Pe.flags|=2,Te)):(Pe.flags|=1048576,Te)}function se(Pe){return v&&Pe.alternate===null&&(Pe.flags|=2),Pe}function Ae(Pe,Te,We,Gt){return Te===null||Te.tag!==6?(Te=A2(We,Pe.mode,Gt),Te.return=Pe,Te):(Te=F(Te,We),Te.return=Pe,Te)}function Ke(Pe,Te,We,Gt){var an=We.type;return an===c?Yt(Pe,Te,We.props.children,Gt,We.key):Te!==null&&(Te.elementType===an||typeof an=="object"&&an!==null&&an.$$typeof===w&&r$(an)===Te.type)?(Gt=F(Te,We.props),Gt.ref=jv(Pe,Te,We),Gt.return=Pe,Gt):(Gt=J_(We.type,We.key,We.props,null,Pe.mode,Gt),Gt.ref=jv(Pe,Te,We),Gt.return=Pe,Gt)}function _t(Pe,Te,We,Gt){return Te===null||Te.tag!==4||Te.stateNode.containerInfo!==We.containerInfo||Te.stateNode.implementation!==We.implementation?(Te=E2(We,Pe.mode,Gt),Te.return=Pe,Te):(Te=F(Te,We.children||[]),Te.return=Pe,Te)}function Yt(Pe,Te,We,Gt,an){return Te===null||Te.tag!==7?(Te=Ih(We,Pe.mode,Gt,an),Te.return=Pe,Te):(Te=F(Te,We),Te.return=Pe,Te)}function Tn(Pe,Te,We){if(typeof Te=="string"&&Te!==""||typeof Te=="number")return Te=A2(""+Te,Pe.mode,We),Te.return=Pe,Te;if(typeof Te=="object"&&Te!==null){switch(Te.$$typeof){case l:return We=J_(Te.type,Te.key,Te.props,null,Pe.mode,We),We.ref=jv(Pe,null,Te),We.return=Pe,We;case u:return Te=E2(Te,Pe.mode,We),Te.return=Pe,Te;case w:var Gt=Te._init;return Tn(Pe,Gt(Te._payload),We)}if(V(Te)||E(Te))return Te=Ih(Te,Pe.mode,We,null),Te.return=Pe,Te;x_(Pe,Te)}return null}function dn(Pe,Te,We,Gt){var an=Te!==null?Te.key:null;if(typeof We=="string"&&We!==""||typeof We=="number")return an!==null?null:Ae(Pe,Te,""+We,Gt);if(typeof We=="object"&&We!==null){switch(We.$$typeof){case l:return We.key===an?Ke(Pe,Te,We,Gt):null;case u:return We.key===an?_t(Pe,Te,We,Gt):null;case w:return an=We._init,dn(Pe,Te,an(We._payload),Gt)}if(V(We)||E(We))return an!==null?null:Yt(Pe,Te,We,Gt,null);x_(Pe,We)}return null}function Ir(Pe,Te,We,Gt,an){if(typeof Gt=="string"&&Gt!==""||typeof Gt=="number")return Pe=Pe.get(We)||null,Ae(Te,Pe,""+Gt,an);if(typeof Gt=="object"&&Gt!==null){switch(Gt.$$typeof){case l:return Pe=Pe.get(Gt.key===null?We:Gt.key)||null,Ke(Te,Pe,Gt,an);case u:return Pe=Pe.get(Gt.key===null?We:Gt.key)||null,_t(Te,Pe,Gt,an);case w:var $n=Gt._init;return Ir(Pe,Te,We,$n(Gt._payload),an)}if(V(Gt)||E(Gt))return Pe=Pe.get(We)||null,Yt(Te,Pe,Gt,an,null);x_(Te,Gt)}return null}function on(Pe,Te,We,Gt){for(var an=null,$n=null,Cn=Te,or=Te=0,rs=null;Cn!==null&&or<We.length;or++){Cn.index>or?(rs=Cn,Cn=null):rs=Cn.sibling;var lr=dn(Pe,Cn,We[or],Gt);if(lr===null){Cn===null&&(Cn=rs);break}v&&Cn&&lr.alternate===null&&x(Pe,Cn),Te=U(lr,Te,or),$n===null?an=lr:$n.sibling=lr,$n=lr,Cn=rs}if(or===We.length)return A(Pe,Cn),Gr&&xh(Pe,or),an;if(Cn===null){for(;or<We.length;or++)Cn=Tn(Pe,We[or],Gt),Cn!==null&&(Te=U(Cn,Te,or),$n===null?an=Cn:$n.sibling=Cn,$n=Cn);return Gr&&xh(Pe,or),an}for(Cn=I(Pe,Cn);or<We.length;or++)rs=Ir(Cn,Pe,or,We[or],Gt),rs!==null&&(v&&rs.alternate!==null&&Cn.delete(rs.key===null?or:rs.key),Te=U(rs,Te,or),$n===null?an=rs:$n.sibling=rs,$n=rs);return v&&Cn.forEach(function(Nc){return x(Pe,Nc)}),Gr&&xh(Pe,or),an}function Cs(Pe,Te,We,Gt){var an=E(We);if(typeof an!="function")throw Error(a(150));if(We=an.call(We),We==null)throw Error(a(151));for(var $n=an=null,Cn=Te,or=Te=0,rs=null,lr=We.next();Cn!==null&&!lr.done;or++,lr=We.next()){Cn.index>or?(rs=Cn,Cn=null):rs=Cn.sibling;var Nc=dn(Pe,Cn,lr.value,Gt);if(Nc===null){Cn===null&&(Cn=rs);break}v&&Cn&&Nc.alternate===null&&x(Pe,Cn),Te=U(Nc,Te,or),$n===null?an=Nc:$n.sibling=Nc,$n=Nc,Cn=rs}if(lr.done)return A(Pe,Cn),Gr&&xh(Pe,or),an;if(Cn===null){for(;!lr.done;or++,lr=We.next())lr=Tn(Pe,lr.value,Gt),lr!==null&&(Te=U(lr,Te,or),$n===null?an=lr:$n.sibling=lr,$n=lr);return Gr&&xh(Pe,or),an}for(Cn=I(Pe,Cn);!lr.done;or++,lr=We.next())lr=Ir(Cn,Pe,or,lr.value,Gt),lr!==null&&(v&&lr.alternate!==null&&Cn.delete(lr.key===null?or:lr.key),Te=U(lr,Te,or),$n===null?an=lr:$n.sibling=lr,$n=lr);return v&&Cn.forEach(function(Wre){return x(Pe,Wre)}),Gr&&xh(Pe,or),an}function Ao(Pe,Te,We,Gt){if(typeof We=="object"&&We!==null&&We.type===c&&We.key===null&&(We=We.props.children),typeof We=="object"&&We!==null){switch(We.$$typeof){case l:e:{for(var an=We.key,$n=Te;$n!==null;){if($n.key===an){if(an=We.type,an===c){if($n.tag===7){A(Pe,$n.sibling),Te=F($n,We.props.children),Te.return=Pe,Pe=Te;break e}}else if($n.elementType===an||typeof an=="object"&&an!==null&&an.$$typeof===w&&r$(an)===$n.type){A(Pe,$n.sibling),Te=F($n,We.props),Te.ref=jv(Pe,$n,We),Te.return=Pe,Pe=Te;break e}A(Pe,$n);break}else x(Pe,$n);$n=$n.sibling}We.type===c?(Te=Ih(We.props.children,Pe.mode,Gt,We.key),Te.return=Pe,Pe=Te):(Gt=J_(We.type,We.key,We.props,null,Pe.mode,Gt),Gt.ref=jv(Pe,Te,We),Gt.return=Pe,Pe=Gt)}return se(Pe);case u:e:{for($n=We.key;Te!==null;){if(Te.key===$n)if(Te.tag===4&&Te.stateNode.containerInfo===We.containerInfo&&Te.stateNode.implementation===We.implementation){A(Pe,Te.sibling),Te=F(Te,We.children||[]),Te.return=Pe,Pe=Te;break e}else{A(Pe,Te);break}else x(Pe,Te);Te=Te.sibling}Te=E2(We,Pe.mode,Gt),Te.return=Pe,Pe=Te}return se(Pe);case w:return $n=We._init,Ao(Pe,Te,$n(We._payload),Gt)}if(V(We))return on(Pe,Te,We,Gt);if(E(We))return Cs(Pe,Te,We,Gt);x_(Pe,We)}return typeof We=="string"&&We!==""||typeof We=="number"?(We=""+We,Te!==null&&Te.tag===6?(A(Pe,Te.sibling),Te=F(Te,We),Te.return=Pe,Pe=Te):(A(Pe,Te),Te=A2(We,Pe.mode,Gt),Te.return=Pe,Pe=Te),se(Pe)):A(Pe,Te)}return Ao}var lg=i$(!0),s$=i$(!1),Xv={},bo=It(Xv),Kv=It(Xv),ug=It(Xv);function Dl(v){if(v===Xv)throw Error(a(174));return v}function GM(v,x){Rt(ug,x),Rt(Kv,v),Rt(bo,Xv),v=Q(x),ct(bo),Rt(bo,v)}function cg(){ct(bo),ct(Kv),ct(ug)}function a$(v){var x=Dl(ug.current),A=Dl(bo.current);x=O(A,v.type,x),A!==x&&(Rt(Kv,v),Rt(bo,x))}function HM(v){Kv.current===v&&(ct(bo),ct(Kv))}var Yr=It(0);function b_(v){for(var x=v;x!==null;){if(x.tag===13){var A=x.memoizedState;if(A!==null&&(A=A.dehydrated,A===null||sn(A)||ur(A)))return x}else if(x.tag===19&&x.memoizedProps.revealOrder!==void 0){if(x.flags&128)return x}else if(x.child!==null){x.child.return=x,x=x.child;continue}if(x===v)break;for(;x.sibling===null;){if(x.return===null||x.return===v)return null;x=x.return}x.sibling.return=x.return,x=x.sibling}return null}var WM=[];function VM(){for(var v=0;v<WM.length;v++){var x=WM[v];st?x._workInProgressVersionPrimary=null:x._workInProgressVersionSecondary=null}WM.length=0}var w_=o.ReactCurrentDispatcher,wo=o.ReactCurrentBatchConfig,dg=0,ai=null,Es=null,ns=null,__=!1,qv=!1,Jv=0,mre=0;function Is(){throw Error(a(321))}function jM(v,x){if(x===null)return!1;for(var A=0;A<x.length&&A<v.length;A++)if(!go(v[A],x[A]))return!1;return!0}function XM(v,x,A,I,F,U){if(dg=U,ai=x,x.memoizedState=null,x.updateQueue=null,x.lanes=0,w_.current=v===null||v.memoizedState===null?xre:bre,v=A(I,F),qv){U=0;do{if(qv=!1,Jv=0,25<=U)throw Error(a(301));U+=1,ns=Es=null,x.updateQueue=null,w_.current=wre,v=A(I,F)}while(qv)}if(w_.current=T_,x=Es!==null&&Es.next!==null,dg=0,ns=Es=ai=null,__=!1,x)throw Error(a(300));return v}function KM(){var v=Jv!==0;return Jv=0,v}function Eu(){var v={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return ns===null?ai.memoizedState=ns=v:ns=ns.next=v,ns}function Pl(){if(Es===null){var v=ai.alternate;v=v!==null?v.memoizedState:null}else v=Es.next;var x=ns===null?ai.memoizedState:ns.next;if(x!==null)ns=x,Es=v;else{if(v===null)throw Error(a(310));Es=v,v={memoizedState:Es.memoizedState,baseState:Es.baseState,baseQueue:Es.baseQueue,queue:Es.queue,next:null},ns===null?ai.memoizedState=ns=v:ns=ns.next=v}return ns}function bh(v,x){return typeof x=="function"?x(v):x}function S_(v){var x=Pl(),A=x.queue;if(A===null)throw Error(a(311));A.lastRenderedReducer=v;var I=Es,F=I.baseQueue,U=A.pending;if(U!==null){if(F!==null){var se=F.next;F.next=U.next,U.next=se}I.baseQueue=F=U,A.pending=null}if(F!==null){U=F.next,I=I.baseState;var Ae=se=null,Ke=null,_t=U;do{var Yt=_t.lane;if((dg&Yt)===Yt)Ke!==null&&(Ke=Ke.next={lane:0,action:_t.action,hasEagerState:_t.hasEagerState,eagerState:_t.eagerState,next:null}),I=_t.hasEagerState?_t.eagerState:v(I,_t.action);else{var Tn={lane:Yt,action:_t.action,hasEagerState:_t.hasEagerState,eagerState:_t.eagerState,next:null};Ke===null?(Ae=Ke=Tn,se=I):Ke=Ke.next=Tn,ai.lanes|=Yt,pg|=Yt}_t=_t.next}while(_t!==null&&_t!==U);Ke===null?se=I:Ke.next=Ae,go(I,x.memoizedState)||(Ka=!0),x.memoizedState=I,x.baseState=se,x.baseQueue=Ke,A.lastRenderedState=I}if(v=A.interleaved,v!==null){F=v;do U=F.lane,ai.lanes|=U,pg|=U,F=F.next;while(F!==v)}else F===null&&(A.lanes=0);return[x.memoizedState,A.dispatch]}function A_(v){var x=Pl(),A=x.queue;if(A===null)throw Error(a(311));A.lastRenderedReducer=v;var I=A.dispatch,F=A.pending,U=x.memoizedState;if(F!==null){A.pending=null;var se=F=F.next;do U=v(U,se.action),se=se.next;while(se!==F);go(U,x.memoizedState)||(Ka=!0),x.memoizedState=U,x.baseQueue===null&&(x.baseState=U),A.lastRenderedState=U}return[U,I]}function o$(){}function l$(v,x){var A=ai,I=Pl(),F=x(),U=!go(I.memoizedState,F);if(U&&(I.memoizedState=F,Ka=!0),I=I.queue,Zv(d$.bind(null,A,I,v),[v]),I.getSnapshot!==x||U||ns!==null&&ns.memoizedState.tag&1){if(A.flags|=2048,Yv(9,c$.bind(null,A,I,F,x),void 0,null),Ai===null)throw Error(a(349));dg&30||u$(A,x,F)}return F}function u$(v,x,A){v.flags|=16384,v={getSnapshot:x,value:A},x=ai.updateQueue,x===null?(x={lastEffect:null,stores:null},ai.updateQueue=x,x.stores=[v]):(A=x.stores,A===null?x.stores=[v]:A.push(v))}function c$(v,x,A,I){x.value=A,x.getSnapshot=I,h$(x)&&_o(v,1,-1)}function d$(v,x,A){return A(function(){h$(x)&&_o(v,1,-1)})}function h$(v){var x=v.getSnapshot;v=v.value;try{var A=x();return!go(v,A)}catch{return!0}}function qM(v){var x=Eu();return typeof v=="function"&&(v=v()),x.memoizedState=x.baseState=v,v={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:bh,lastRenderedState:v},x.queue=v,v=v.dispatch=vre.bind(null,ai,v),[x.memoizedState,v]}function Yv(v,x,A,I){return v={tag:v,create:x,destroy:A,deps:I,next:null},x=ai.updateQueue,x===null?(x={lastEffect:null,stores:null},ai.updateQueue=x,x.lastEffect=v.next=v):(A=x.lastEffect,A===null?x.lastEffect=v.next=v:(I=A.next,A.next=v,v.next=I,x.lastEffect=v)),v}function p$(){return Pl().memoizedState}function E_(v,x,A,I){var F=Eu();ai.flags|=v,F.memoizedState=Yv(1|x,A,void 0,I===void 0?null:I)}function I_(v,x,A,I){var F=Pl();I=I===void 0?null:I;var U=void 0;if(Es!==null){var se=Es.memoizedState;if(U=se.destroy,I!==null&&jM(I,se.deps)){F.memoizedState=Yv(x,A,U,I);return}}ai.flags|=v,F.memoizedState=Yv(1|x,A,U,I)}function JM(v,x){return E_(8390656,8,v,x)}function Zv(v,x){return I_(2048,8,v,x)}function f$(v,x){return I_(4,2,v,x)}function m$(v,x){return I_(4,4,v,x)}function g$(v,x){if(typeof x=="function")return v=v(),x(v),function(){x(null)};if(x!=null)return v=v(),x.current=v,function(){x.current=null}}function y$(v,x,A){return A=A!=null?A.concat([v]):null,I_(4,4,g$.bind(null,x,v),A)}function YM(){}function v$(v,x){var A=Pl();x=x===void 0?null:x;var I=A.memoizedState;return I!==null&&x!==null&&jM(x,I[1])?I[0]:(A.memoizedState=[v,x],v)}function x$(v,x){var A=Pl();x=x===void 0?null:x;var I=A.memoizedState;return I!==null&&x!==null&&jM(x,I[1])?I[0]:(v=v(),A.memoizedState=[v,x],v)}function gre(v,x){var A=Wn;Wn=A!==0&&4>A?A:4,v(!0);var I=wo.transition;wo.transition={};try{v(!1),x()}finally{Wn=A,wo.transition=I}}function b$(){return Pl().memoizedState}function yre(v,x,A){var I=Cc(v);A={lane:I,action:A,hasEagerState:!1,eagerState:null,next:null},w$(v)?_$(x,A):(S$(v,x,A),A=Js(),v=_o(v,I,A),v!==null&&A$(v,x,I))}function vre(v,x,A){var I=Cc(v),F={lane:I,action:A,hasEagerState:!1,eagerState:null,next:null};if(w$(v))_$(x,F);else{S$(v,x,F);var U=v.alternate;if(v.lanes===0&&(U===null||U.lanes===0)&&(U=x.lastRenderedReducer,U!==null))try{var se=x.lastRenderedState,Ae=U(se,A);if(F.hasEagerState=!0,F.eagerState=Ae,go(Ae,se))return}catch{}finally{}A=Js(),v=_o(v,I,A),v!==null&&A$(v,x,I)}}function w$(v){var x=v.alternate;return v===ai||x!==null&&x===ai}function _$(v,x){qv=__=!0;var A=v.pending;A===null?x.next=x:(x.next=A.next,A.next=x),v.pending=x}function S$(v,x,A){Ai!==null&&v.mode&1&&!(zn&2)?(v=x.interleaved,v===null?(A.next=A,Fl===null?Fl=[x]:Fl.push(x)):(A.next=v.next,v.next=A),x.interleaved=A):(v=x.pending,v===null?A.next=A:(A.next=v.next,v.next=A),x.pending=A)}function A$(v,x,A){if(A&4194240){var I=x.lanes;I&=v.pendingLanes,A|=I,x.lanes=A,Sc(v,A)}}var T_={readContext:yo,useCallback:Is,useContext:Is,useEffect:Is,useImperativeHandle:Is,useInsertionEffect:Is,useLayoutEffect:Is,useMemo:Is,useReducer:Is,useRef:Is,useState:Is,useDebugValue:Is,useDeferredValue:Is,useTransition:Is,useMutableSource:Is,useSyncExternalStore:Is,useId:Is,unstable_isNewReconciler:!1},xre={readContext:yo,useCallback:function(v,x){return Eu().memoizedState=[v,x===void 0?null:x],v},useContext:yo,useEffect:JM,useImperativeHandle:function(v,x,A){return A=A!=null?A.concat([v]):null,E_(4194308,4,g$.bind(null,x,v),A)},useLayoutEffect:function(v,x){return E_(4194308,4,v,x)},useInsertionEffect:function(v,x){return E_(4,2,v,x)},useMemo:function(v,x){var A=Eu();return x=x===void 0?null:x,v=v(),A.memoizedState=[v,x],v},useReducer:function(v,x,A){var I=Eu();return x=A!==void 0?A(x):x,I.memoizedState=I.baseState=x,v={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:v,lastRenderedState:x},I.queue=v,v=v.dispatch=yre.bind(null,ai,v),[I.memoizedState,v]},useRef:function(v){var x=Eu();return v={current:v},x.memoizedState=v},useState:qM,useDebugValue:YM,useDeferredValue:function(v){var x=qM(v),A=x[0],I=x[1];return JM(function(){var F=wo.transition;wo.transition={};try{I(v)}finally{wo.transition=F}},[v]),A},useTransition:function(){var v=qM(!1),x=v[0];return v=gre.bind(null,v[1]),Eu().memoizedState=v,[x,v]},useMutableSource:function(){},useSyncExternalStore:function(v,x,A){var I=ai,F=Eu();if(Gr){if(A===void 0)throw Error(a(407));A=A()}else{if(A=x(),Ai===null)throw Error(a(349));dg&30||u$(I,x,A)}F.memoizedState=A;var U={value:A,getSnapshot:x};return F.queue=U,JM(d$.bind(null,I,U,v),[v]),I.flags|=2048,Yv(9,c$.bind(null,I,U,A,x),void 0,null),A},useId:function(){var v=Eu(),x=Ai.identifierPrefix;if(Gr){var A=Au,I=Su;A=(I&~(1<<32-fn(I)-1)).toString(32)+A,x=":"+x+"R"+A,A=Jv++,0<A&&(x+="H"+A.toString(32)),x+=":"}else A=mre++,x=":"+x+"r"+A.toString(32)+":";return v.memoizedState=x},unstable_isNewReconciler:!1},bre={readContext:yo,useCallback:v$,useContext:yo,useEffect:Zv,useImperativeHandle:y$,useInsertionEffect:f$,useLayoutEffect:m$,useMemo:x$,useReducer:S_,useRef:p$,useState:function(){return S_(bh)},useDebugValue:YM,useDeferredValue:function(v){var x=S_(bh),A=x[0],I=x[1];return Zv(function(){var F=wo.transition;wo.transition={};try{I(v)}finally{wo.transition=F}},[v]),A},useTransition:function(){var v=S_(bh)[0],x=Pl().memoizedState;return[v,x]},useMutableSource:o$,useSyncExternalStore:l$,useId:b$,unstable_isNewReconciler:!1},wre={readContext:yo,useCallback:v$,useContext:yo,useEffect:Zv,useImperativeHandle:y$,useInsertionEffect:f$,useLayoutEffect:m$,useMemo:x$,useReducer:A_,useRef:p$,useState:function(){return A_(bh)},useDebugValue:YM,useDeferredValue:function(v){var x=A_(bh),A=x[0],I=x[1];return Zv(function(){var F=wo.transition;wo.transition={};try{I(v)}finally{wo.transition=F}},[v]),A},useTransition:function(){var v=A_(bh)[0],x=Pl().memoizedState;return[v,x]},useMutableSource:o$,useSyncExternalStore:l$,useId:b$,unstable_isNewReconciler:!1};function ZM(v,x){try{var A="",I=x;do A+=fre(I),I=I.return;while(I);var F=A}catch(U){F=`
Error generating stack: `+U.message+`
`+U.stack}return{value:v,source:x,stack:F}}function QM(v,x){try{console.error(x.value)}catch(A){setTimeout(function(){throw A})}}var _re=typeof WeakMap=="function"?WeakMap:Map;function E$(v,x,A){A=_u(-1,A),A.tag=3,A.payload={element:null};var I=x.value;return A.callback=function(){H_||(H_=!0,y2=I),QM(v,x)},A}function I$(v,x,A){A=_u(-1,A),A.tag=3;var I=v.type.getDerivedStateFromError;if(typeof I=="function"){var F=x.value;A.payload=function(){return I(F)},A.callback=function(){QM(v,x)}}var U=v.stateNode;return U!==null&&typeof U.componentDidCatch=="function"&&(A.callback=function(){QM(v,x),typeof I!="function"&&(Ic===null?Ic=new Set([this]):Ic.add(this));var se=x.stack;this.componentDidCatch(x.value,{componentStack:se!==null?se:""})}),A}function T$(v,x,A){var I=v.pingCache;if(I===null){I=v.pingCache=new _re;var F=new Set;I.set(x,F)}else F=I.get(x),F===void 0&&(F=new Set,I.set(x,F));F.has(A)||(F.add(A),v=Lre.bind(null,v,x,A),x.then(v,v))}function C$(v){do{var x;if((x=v.tag===13)&&(x=v.memoizedState,x=x!==null?x.dehydrated!==null:!0),x)return v;v=v.return}while(v!==null);return null}function M$(v,x,A,I,F){return v.mode&1?(v.flags|=65536,v.lanes=F,v):(v===x?v.flags|=65536:(v.flags|=128,A.flags|=131072,A.flags&=-52805,A.tag===1&&(A.alternate===null?A.tag=17:(x=_u(-1,1),x.tag=2,Ec(A,x))),A.lanes|=1),v)}function Ll(v){v.flags|=4}function k$(v,x){if(v!==null&&v.child===x.child)return!0;if(x.flags&16)return!1;for(v=x.child;v!==null;){if(v.flags&12854||v.subtreeFlags&12854)return!1;v=v.sibling}return!0}var Qv,ex,C_,M_;if(Et)Qv=function(v,x){for(var A=x.child;A!==null;){if(A.tag===5||A.tag===6)le(v,A.stateNode);else if(A.tag!==4&&A.child!==null){A.child.return=A,A=A.child;continue}if(A===x)break;for(;A.sibling===null;){if(A.return===null||A.return===x)return;A=A.return}A.sibling.return=A.return,A=A.sibling}},ex=function(){},C_=function(v,x,A,I,F){if(v=v.memoizedProps,v!==I){var U=x.stateNode,se=Dl(bo.current);A=ie(U,A,v,I,F,se),(x.updateQueue=A)&&Ll(x)}},M_=function(v,x,A,I){A!==I&&Ll(x)};else if(Tt){Qv=function(v,x,A,I){for(var F=x.child;F!==null;){if(F.tag===5){var U=F.stateNode;A&&I&&(U=pt(U,F.type,F.memoizedProps,F)),le(v,U)}else if(F.tag===6)U=F.stateNode,A&&I&&(U=ht(U,F.memoizedProps,F)),le(v,U);else if(F.tag!==4){if(F.tag===22&&F.memoizedState!==null)U=F.child,U!==null&&(U.return=F),Qv(v,F,!0,!0);else if(F.child!==null){F.child.return=F,F=F.child;continue}}if(F===x)break;for(;F.sibling===null;){if(F.return===null||F.return===x)return;F=F.return}F.sibling.return=F.return,F=F.sibling}};var N$=function(v,x,A,I){for(var F=x.child;F!==null;){if(F.tag===5){var U=F.stateNode;A&&I&&(U=pt(U,F.type,F.memoizedProps,F)),kt(v,U)}else if(F.tag===6)U=F.stateNode,A&&I&&(U=ht(U,F.memoizedProps,F)),kt(v,U);else if(F.tag!==4){if(F.tag===22&&F.memoizedState!==null)U=F.child,U!==null&&(U.return=F),N$(v,F,!0,!0);else if(F.child!==null){F.child.return=F,F=F.child;continue}}if(F===x)break;for(;F.sibling===null;){if(F.return===null||F.return===x)return;F=F.return}F.sibling.return=F.return,F=F.sibling}};ex=function(v,x){var A=x.stateNode;if(!k$(v,x)){v=A.containerInfo;var I=Ze(v);N$(I,x,!1,!1),A.pendingChildren=I,Ll(x),Se(v,I)}},C_=function(v,x,A,I,F){var U=v.stateNode,se=v.memoizedProps;if((v=k$(v,x))&&se===I)x.stateNode=U;else{var Ae=x.stateNode,Ke=Dl(bo.current),_t=null;se!==I&&(_t=ie(Ae,A,se,I,F,Ke)),v&&_t===null?x.stateNode=U:(U=ut(U,_t,A,se,I,x,v,Ae),ge(U,A,I,F,Ke)&&Ll(x),x.stateNode=U,v?Ll(x):Qv(U,x,!1,!1))}},M_=function(v,x,A,I){A!==I?(v=Dl(ug.current),A=Dl(bo.current),x.stateNode=Ce(I,v,A,x),Ll(x)):x.stateNode=v.stateNode}}else ex=function(){},C_=function(){},M_=function(){};function tx(v,x){if(!Gr)switch(v.tailMode){case"hidden":x=v.tail;for(var A=null;x!==null;)x.alternate!==null&&(A=x),x=x.sibling;A===null?v.tail=null:A.sibling=null;break;case"collapsed":A=v.tail;for(var I=null;A!==null;)A.alternate!==null&&(I=A),A=A.sibling;I===null?x||v.tail===null?v.tail=null:v.tail.sibling=null:I.sibling=null}}function Ts(v){var x=v.alternate!==null&&v.alternate.child===v.child,A=0,I=0;if(x)for(var F=v.child;F!==null;)A|=F.lanes|F.childLanes,I|=F.subtreeFlags&14680064,I|=F.flags&14680064,F.return=v,F=F.sibling;else for(F=v.child;F!==null;)A|=F.lanes|F.childLanes,I|=F.subtreeFlags,I|=F.flags,F.return=v,F=F.sibling;return v.subtreeFlags|=I,v.childLanes=A,x}function Sre(v,x,A){var I=x.pendingProps;switch(BM(x),x.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ts(x),null;case 1:return Bn(x.type)&&pn(),Ts(x),null;case 3:return I=x.stateNode,cg(),ct(Kt),ct(un),VM(),I.pendingContext&&(I.context=I.pendingContext,I.pendingContext=null),(v===null||v.child===null)&&(Vv(x)?Ll(x):v===null||v.memoizedState.isDehydrated&&!(x.flags&256)||(x.flags|=1024,Yo!==null&&(b2(Yo),Yo=null))),ex(v,x),Ts(x),null;case 5:HM(x),A=Dl(ug.current);var F=x.type;if(v!==null&&x.stateNode!=null)C_(v,x,F,I,A),v.ref!==x.ref&&(x.flags|=512,x.flags|=2097152);else{if(!I){if(x.stateNode===null)throw Error(a(166));return Ts(x),null}if(v=Dl(bo.current),Vv(x)){if(!xt)throw Error(a(175));v=$(x.stateNode,x.type,x.memoizedProps,A,v,x,!Wv),x.updateQueue=v,v!==null&&Ll(x)}else{var U=te(F,I,A,v,x);Qv(U,x,!1,!1),x.stateNode=U,ge(U,F,I,A,v)&&Ll(x)}x.ref!==null&&(x.flags|=512,x.flags|=2097152)}return Ts(x),null;case 6:if(v&&x.stateNode!=null)M_(v,x,v.memoizedProps,I);else{if(typeof I!="string"&&x.stateNode===null)throw Error(a(166));if(v=Dl(ug.current),A=Dl(bo.current),Vv(x)){if(!xt)throw Error(a(176));if(v=x.stateNode,I=x.memoizedProps,(A=Y(v,I,x,!Wv))&&(F=ja,F!==null))switch(U=(F.mode&1)!==0,F.tag){case 3:ae(F.stateNode.containerInfo,v,I,U);break;case 5:me(F.type,F.memoizedProps,F.stateNode,v,I,U)}A&&Ll(x)}else x.stateNode=Ce(I,v,A,x)}return Ts(x),null;case 13:if(ct(Yr),I=x.memoizedState,Gr&&Xa!==null&&x.mode&1&&!(x.flags&128)){for(v=Xa;v;)v=zr(v);return og(),x.flags|=98560,x}if(I!==null&&I.dehydrated!==null){if(I=Vv(x),v===null){if(!I)throw Error(a(318));if(!xt)throw Error(a(344));if(v=x.memoizedState,v=v!==null?v.dehydrated:null,!v)throw Error(a(317));ye(v,x)}else og(),!(x.flags&128)&&(x.memoizedState=null),x.flags|=4;return Ts(x),null}return Yo!==null&&(b2(Yo),Yo=null),x.flags&128?(x.lanes=A,x):(I=I!==null,A=!1,v===null?Vv(x):A=v.memoizedState!==null,I&&!A&&(x.child.flags|=8192,x.mode&1&&(v===null||Yr.current&1?Pi===0&&(Pi=3):_2())),x.updateQueue!==null&&(x.flags|=4),Ts(x),null);case 4:return cg(),ex(v,x),v===null&&Ye(x.stateNode.containerInfo),Ts(x),null;case 10:return RM(x.type._context),Ts(x),null;case 17:return Bn(x.type)&&pn(),Ts(x),null;case 19:if(ct(Yr),F=x.memoizedState,F===null)return Ts(x),null;if(I=(x.flags&128)!==0,U=F.rendering,U===null)if(I)tx(F,!1);else{if(Pi!==0||v!==null&&v.flags&128)for(v=x.child;v!==null;){if(U=b_(v),U!==null){for(x.flags|=128,tx(F,!1),v=U.updateQueue,v!==null&&(x.updateQueue=v,x.flags|=4),x.subtreeFlags=0,v=A,I=x.child;I!==null;)A=I,F=v,A.flags&=14680066,U=A.alternate,U===null?(A.childLanes=0,A.lanes=F,A.child=null,A.subtreeFlags=0,A.memoizedProps=null,A.memoizedState=null,A.updateQueue=null,A.dependencies=null,A.stateNode=null):(A.childLanes=U.childLanes,A.lanes=U.lanes,A.child=U.child,A.subtreeFlags=0,A.deletions=null,A.memoizedProps=U.memoizedProps,A.memoizedState=U.memoizedState,A.updateQueue=U.updateQueue,A.type=U.type,F=U.dependencies,A.dependencies=F===null?null:{lanes:F.lanes,firstContext:F.firstContext}),I=I.sibling;return Rt(Yr,Yr.current&1|2),x.child}v=v.sibling}F.tail!==null&&en()>g2&&(x.flags|=128,I=!0,tx(F,!1),x.lanes=4194304)}else{if(!I)if(v=b_(U),v!==null){if(x.flags|=128,I=!0,v=v.updateQueue,v!==null&&(x.updateQueue=v,x.flags|=4),tx(F,!0),F.tail===null&&F.tailMode==="hidden"&&!U.alternate&&!Gr)return Ts(x),null}else 2*en()-F.renderingStartTime>g2&&A!==1073741824&&(x.flags|=128,I=!0,tx(F,!1),x.lanes=4194304);F.isBackwards?(U.sibling=x.child,x.child=U):(v=F.last,v!==null?v.sibling=U:x.child=U,F.last=U)}return F.tail!==null?(x=F.tail,F.rendering=x,F.tail=x.sibling,F.renderingStartTime=en(),x.sibling=null,v=Yr.current,Rt(Yr,I?v&1|2:v&1),x):(Ts(x),null);case 22:case 23:return w2(),I=x.memoizedState!==null,v!==null&&v.memoizedState!==null!==I&&(x.flags|=8192),I&&x.mode&1?qa&1073741824&&(Ts(x),Et&&x.subtreeFlags&6&&(x.flags|=8192)):Ts(x),null;case 24:return null;case 25:return null}throw Error(a(156,x.tag))}var Are=o.ReactCurrentOwner,Ka=!1;function qs(v,x,A,I){x.child=v===null?s$(x,null,A,I):lg(x,v.child,A,I)}function R$(v,x,A,I,F){A=A.render;var U=x.ref;return ig(x,F),I=XM(v,x,A,I,U,F),A=KM(),v!==null&&!Ka?(x.updateQueue=v.updateQueue,x.flags&=-2053,v.lanes&=~F,Iu(v,x,F)):(Gr&&A&&OM(x),x.flags|=1,qs(v,x,I,F),x.child)}function F$(v,x,A,I,F){if(v===null){var U=A.type;return typeof U=="function"&&!S2(U)&&U.defaultProps===void 0&&A.compare===null&&A.defaultProps===void 0?(x.tag=15,x.type=U,D$(v,x,U,I,F)):(v=J_(A.type,null,I,x,x.mode,F),v.ref=x.ref,v.return=x,x.child=v)}if(U=v.child,!(v.lanes&F)){var se=U.memoizedProps;if(A=A.compare,A=A!==null?A:d_,A(se,I)&&v.ref===x.ref)return Iu(v,x,F)}return x.flags|=1,v=kc(U,I),v.ref=x.ref,v.return=x,x.child=v}function D$(v,x,A,I,F){if(v!==null&&d_(v.memoizedProps,I)&&v.ref===x.ref)if(Ka=!1,(v.lanes&F)!==0)v.flags&131072&&(Ka=!0);else return x.lanes=v.lanes,Iu(v,x,F);return e2(v,x,A,I,F)}function P$(v,x,A){var I=x.pendingProps,F=I.children,U=v!==null?v.memoizedState:null;if(I.mode==="hidden")if(!(x.mode&1))x.memoizedState={baseLanes:0,cachePool:null},Rt(hg,qa),qa|=A;else if(A&1073741824)x.memoizedState={baseLanes:0,cachePool:null},I=U!==null?U.baseLanes:A,Rt(hg,qa),qa|=I;else return v=U!==null?U.baseLanes|A:A,x.lanes=x.childLanes=1073741824,x.memoizedState={baseLanes:v,cachePool:null},x.updateQueue=null,Rt(hg,qa),qa|=v,null;else U!==null?(I=U.baseLanes|A,x.memoizedState=null):I=A,Rt(hg,qa),qa|=I;return qs(v,x,F,A),x.child}function L$(v,x){var A=x.ref;(v===null&&A!==null||v!==null&&v.ref!==A)&&(x.flags|=512,x.flags|=2097152)}function e2(v,x,A,I,F){var U=Bn(A)?tn:un.current;return U=Wt(x,U),ig(x,F),A=XM(v,x,A,I,U,F),I=KM(),v!==null&&!Ka?(x.updateQueue=v.updateQueue,x.flags&=-2053,v.lanes&=~F,Iu(v,x,F)):(Gr&&I&&OM(x),x.flags|=1,qs(v,x,A,F),x.child)}function O$(v,x,A,I,F){if(Bn(A)){var U=!0;Sn(x)}else U=!1;if(ig(x,F),x.stateNode===null)v!==null&&(v.alternate=null,x.alternate=null,x.flags|=2),YU(x,A,I),LM(x,A,I,F),I=!0;else if(v===null){var se=x.stateNode,Ae=x.memoizedProps;se.props=Ae;var Ke=se.context,_t=A.contextType;typeof _t=="object"&&_t!==null?_t=yo(_t):(_t=Bn(A)?tn:un.current,_t=Wt(x,_t));var Yt=A.getDerivedStateFromProps,Tn=typeof Yt=="function"||typeof se.getSnapshotBeforeUpdate=="function";Tn||typeof se.UNSAFE_componentWillReceiveProps!="function"&&typeof se.componentWillReceiveProps!="function"||(Ae!==I||Ke!==_t)&&ZU(x,se,I,_t),Ac=!1;var dn=x.memoizedState;se.state=dn,m_(x,I,se,F),Ke=x.memoizedState,Ae!==I||dn!==Ke||Kt.current||Ac?(typeof Yt=="function"&&(PM(x,A,Yt,I),Ke=x.memoizedState),(Ae=Ac||JU(x,A,Ae,I,dn,Ke,_t))?(Tn||typeof se.UNSAFE_componentWillMount!="function"&&typeof se.componentWillMount!="function"||(typeof se.componentWillMount=="function"&&se.componentWillMount(),typeof se.UNSAFE_componentWillMount=="function"&&se.UNSAFE_componentWillMount()),typeof se.componentDidMount=="function"&&(x.flags|=4194308)):(typeof se.componentDidMount=="function"&&(x.flags|=4194308),x.memoizedProps=I,x.memoizedState=Ke),se.props=I,se.state=Ke,se.context=_t,I=Ae):(typeof se.componentDidMount=="function"&&(x.flags|=4194308),I=!1)}else{se=x.stateNode,jU(v,x),Ae=x.memoizedProps,_t=x.type===x.elementType?Ae:Jo(x.type,Ae),se.props=_t,Tn=x.pendingProps,dn=se.context,Ke=A.contextType,typeof Ke=="object"&&Ke!==null?Ke=yo(Ke):(Ke=Bn(A)?tn:un.current,Ke=Wt(x,Ke));var Ir=A.getDerivedStateFromProps;(Yt=typeof Ir=="function"||typeof se.getSnapshotBeforeUpdate=="function")||typeof se.UNSAFE_componentWillReceiveProps!="function"&&typeof se.componentWillReceiveProps!="function"||(Ae!==Tn||dn!==Ke)&&ZU(x,se,I,Ke),Ac=!1,dn=x.memoizedState,se.state=dn,m_(x,I,se,F);var on=x.memoizedState;Ae!==Tn||dn!==on||Kt.current||Ac?(typeof Ir=="function"&&(PM(x,A,Ir,I),on=x.memoizedState),(_t=Ac||JU(x,A,_t,I,dn,on,Ke)||!1)?(Yt||typeof se.UNSAFE_componentWillUpdate!="function"&&typeof se.componentWillUpdate!="function"||(typeof se.componentWillUpdate=="function"&&se.componentWillUpdate(I,on,Ke),typeof se.UNSAFE_componentWillUpdate=="function"&&se.UNSAFE_componentWillUpdate(I,on,Ke)),typeof se.componentDidUpdate=="function"&&(x.flags|=4),typeof se.getSnapshotBeforeUpdate=="function"&&(x.flags|=1024)):(typeof se.componentDidUpdate!="function"||Ae===v.memoizedProps&&dn===v.memoizedState||(x.flags|=4),typeof se.getSnapshotBeforeUpdate!="function"||Ae===v.memoizedProps&&dn===v.memoizedState||(x.flags|=1024),x.memoizedProps=I,x.memoizedState=on),se.props=I,se.state=on,se.context=Ke,I=_t):(typeof se.componentDidUpdate!="function"||Ae===v.memoizedProps&&dn===v.memoizedState||(x.flags|=4),typeof se.getSnapshotBeforeUpdate!="function"||Ae===v.memoizedProps&&dn===v.memoizedState||(x.flags|=1024),I=!1)}return t2(v,x,A,I,U,F)}function t2(v,x,A,I,F,U){L$(v,x);var se=(x.flags&128)!==0;if(!I&&!se)return F&&Un(x,A,!1),Iu(v,x,U);I=x.stateNode,Are.current=x;var Ae=se&&typeof A.getDerivedStateFromError!="function"?null:I.render();return x.flags|=1,v!==null&&se?(x.child=lg(x,v.child,null,U),x.child=lg(x,null,Ae,U)):qs(v,x,Ae,U),x.memoizedState=I.state,F&&Un(x,A,!0),x.child}function B$(v){var x=v.stateNode;x.pendingContext?_n(v,x.pendingContext,x.pendingContext!==x.context):x.context&&_n(v,x.context,!1),GM(v,x.containerInfo)}function U$(v,x,A,I,F){return og(),zM(F),x.flags|=256,qs(v,x,A,I),x.child}var k_={dehydrated:null,treeContext:null,retryLane:0};function N_(v){return{baseLanes:v,cachePool:null}}function $$(v,x,A){var I=x.pendingProps,F=Yr.current,U=!1,se=(x.flags&128)!==0,Ae;if((Ae=se)||(Ae=v!==null&&v.memoizedState===null?!1:(F&2)!==0),Ae?(U=!0,x.flags&=-129):(v===null||v.memoizedState!==null)&&(F|=1),Rt(Yr,F&1),v===null)return $M(x),v=x.memoizedState,v!==null&&(v=v.dehydrated,v!==null)?(x.mode&1?ur(v)?x.lanes=8:x.lanes=1073741824:x.lanes=1,null):(F=I.children,v=I.fallback,U?(I=x.mode,U=x.child,F={mode:"hidden",children:F},!(I&1)&&U!==null?(U.childLanes=0,U.pendingProps=F):U=Y_(F,I,0,null),v=Ih(v,I,A,null),U.return=x,v.return=x,U.sibling=v,x.child=U,x.child.memoizedState=N_(A),x.memoizedState=k_,v):n2(x,F));if(F=v.memoizedState,F!==null){if(Ae=F.dehydrated,Ae!==null){if(se)return x.flags&256?(x.flags&=-257,R_(v,x,A,Error(a(422)))):x.memoizedState!==null?(x.child=v.child,x.flags|=128,null):(U=I.fallback,F=x.mode,I=Y_({mode:"visible",children:I.children},F,0,null),U=Ih(U,F,A,null),U.flags|=2,I.return=x,U.return=x,I.sibling=U,x.child=I,x.mode&1&&lg(x,v.child,null,A),x.child.memoizedState=N_(A),x.memoizedState=k_,U);if(!(x.mode&1))x=R_(v,x,A,null);else if(ur(Ae))x=R_(v,x,A,Error(a(419)));else if(I=(A&v.childLanes)!==0,Ka||I){if(I=Ai,I!==null){switch(A&-A){case 4:U=2;break;case 16:U=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:U=32;break;case 536870912:U=268435456;break;default:U=0}I=U&(I.suspendedLanes|A)?0:U,I!==0&&I!==F.retryLane&&(F.retryLane=I,_o(v,I,-1))}_2(),x=R_(v,x,A,Error(a(421)))}else sn(Ae)?(x.flags|=128,x.child=v.child,x=Ore.bind(null,v),$r(Ae,x),x=null):(A=F.treeContext,xt&&(Xa=Va(Ae),ja=x,Gr=!0,Yo=null,Wv=!1,A!==null&&(vo[xo++]=Su,vo[xo++]=Au,vo[xo++]=vh,Su=A.id,Au=A.overflow,vh=x)),x=n2(x,x.pendingProps.children),x.flags|=4096);return x}return U?(I=G$(v,x,I.children,I.fallback,A),U=x.child,F=v.child.memoizedState,U.memoizedState=F===null?N_(A):{baseLanes:F.baseLanes|A,cachePool:null},U.childLanes=v.childLanes&~A,x.memoizedState=k_,I):(A=z$(v,x,I.children,A),x.memoizedState=null,A)}return U?(I=G$(v,x,I.children,I.fallback,A),U=x.child,F=v.child.memoizedState,U.memoizedState=F===null?N_(A):{baseLanes:F.baseLanes|A,cachePool:null},U.childLanes=v.childLanes&~A,x.memoizedState=k_,I):(A=z$(v,x,I.children,A),x.memoizedState=null,A)}function n2(v,x){return x=Y_({mode:"visible",children:x},v.mode,0,null),x.return=v,v.child=x}function z$(v,x,A,I){var F=v.child;return v=F.sibling,A=kc(F,{mode:"visible",children:A}),!(x.mode&1)&&(A.lanes=I),A.return=x,A.sibling=null,v!==null&&(I=x.deletions,I===null?(x.deletions=[v],x.flags|=16):I.push(v)),x.child=A}function G$(v,x,A,I,F){var U=x.mode;v=v.child;var se=v.sibling,Ae={mode:"hidden",children:A};return!(U&1)&&x.child!==v?(A=x.child,A.childLanes=0,A.pendingProps=Ae,x.deletions=null):(A=kc(v,Ae),A.subtreeFlags=v.subtreeFlags&14680064),se!==null?I=kc(se,I):(I=Ih(I,U,F,null),I.flags|=2),I.return=x,A.return=x,A.sibling=I,x.child=A,I}function R_(v,x,A,I){return I!==null&&zM(I),lg(x,v.child,null,A),v=n2(x,x.pendingProps.children),v.flags|=2,x.memoizedState=null,v}function H$(v,x,A){v.lanes|=x;var I=v.alternate;I!==null&&(I.lanes|=x),FM(v.return,x,A)}function r2(v,x,A,I,F){var U=v.memoizedState;U===null?v.memoizedState={isBackwards:x,rendering:null,renderingStartTime:0,last:I,tail:A,tailMode:F}:(U.isBackwards=x,U.rendering=null,U.renderingStartTime=0,U.last=I,U.tail=A,U.tailMode=F)}function W$(v,x,A){var I=x.pendingProps,F=I.revealOrder,U=I.tail;if(qs(v,x,I.children,A),I=Yr.current,I&2)I=I&1|2,x.flags|=128;else{if(v!==null&&v.flags&128)e:for(v=x.child;v!==null;){if(v.tag===13)v.memoizedState!==null&&H$(v,A,x);else if(v.tag===19)H$(v,A,x);else if(v.child!==null){v.child.return=v,v=v.child;continue}if(v===x)break e;for(;v.sibling===null;){if(v.return===null||v.return===x)break e;v=v.return}v.sibling.return=v.return,v=v.sibling}I&=1}if(Rt(Yr,I),!(x.mode&1))x.memoizedState=null;else switch(F){case"forwards":for(A=x.child,F=null;A!==null;)v=A.alternate,v!==null&&b_(v)===null&&(F=A),A=A.sibling;A=F,A===null?(F=x.child,x.child=null):(F=A.sibling,A.sibling=null),r2(x,!1,F,A,U);break;case"backwards":for(A=null,F=x.child,x.child=null;F!==null;){if(v=F.alternate,v!==null&&b_(v)===null){x.child=F;break}v=F.sibling,F.sibling=A,A=F,F=v}r2(x,!0,A,null,U);break;case"together":r2(x,!1,null,null,void 0);break;default:x.memoizedState=null}return x.child}function Iu(v,x,A){if(v!==null&&(x.dependencies=v.dependencies),pg|=x.lanes,!(A&x.childLanes))return null;if(v!==null&&x.child!==v.child)throw Error(a(153));if(x.child!==null){for(v=x.child,A=kc(v,v.pendingProps),x.child=A,A.return=x;v.sibling!==null;)v=v.sibling,A=A.sibling=kc(v,v.pendingProps),A.return=x;A.sibling=null}return x.child}function Ere(v,x,A){switch(x.tag){case 3:B$(x),og();break;case 5:a$(x);break;case 1:Bn(x.type)&&Sn(x);break;case 4:GM(x,x.stateNode.containerInfo);break;case 10:VU(x,x.type._context,x.memoizedProps.value);break;case 13:var I=x.memoizedState;if(I!==null)return I.dehydrated!==null?(Rt(Yr,Yr.current&1),x.flags|=128,null):A&x.child.childLanes?$$(v,x,A):(Rt(Yr,Yr.current&1),v=Iu(v,x,A),v!==null?v.sibling:null);Rt(Yr,Yr.current&1);break;case 19:if(I=(A&x.childLanes)!==0,v.flags&128){if(I)return W$(v,x,A);x.flags|=128}var F=x.memoizedState;if(F!==null&&(F.rendering=null,F.tail=null,F.lastEffect=null),Rt(Yr,Yr.current),I)break;return null;case 22:case 23:return x.lanes=0,P$(v,x,A)}return Iu(v,x,A)}function Ire(v,x){switch(BM(x),x.tag){case 1:return Bn(x.type)&&pn(),v=x.flags,v&65536?(x.flags=v&-65537|128,x):null;case 3:return cg(),ct(Kt),ct(un),VM(),v=x.flags,v&65536&&!(v&128)?(x.flags=v&-65537|128,x):null;case 5:return HM(x),null;case 13:if(ct(Yr),v=x.memoizedState,v!==null&&v.dehydrated!==null){if(x.alternate===null)throw Error(a(340));og()}return v=x.flags,v&65536?(x.flags=v&-65537|128,x):null;case 19:return ct(Yr),null;case 4:return cg(),null;case 10:return RM(x.type._context),null;case 22:case 23:return w2(),null;case 24:return null;default:return null}}var F_=!1,wh=!1,Tre=typeof WeakSet=="function"?WeakSet:Set,Ut=null;function D_(v,x){var A=v.ref;if(A!==null)if(typeof A=="function")try{A(null)}catch(I){va(v,x,I)}else A.current=null}function i2(v,x,A){try{A()}catch(I){va(v,x,I)}}var V$=!1;function Cre(v,x){for(j(v.containerInfo),Ut=x;Ut!==null;)if(v=Ut,x=v.child,(v.subtreeFlags&1028)!==0&&x!==null)x.return=v,Ut=x;else for(;Ut!==null;){v=Ut;try{var A=v.alternate;if(v.flags&1024)switch(v.tag){case 0:case 11:case 15:break;case 1:if(A!==null){var I=A.memoizedProps,F=A.memoizedState,U=v.stateNode,se=U.getSnapshotBeforeUpdate(v.elementType===v.type?I:Jo(v.type,I),F);U.__reactInternalSnapshotBeforeUpdate=se}break;case 3:Et&&Mt(v.stateNode.containerInfo);break;case 5:case 6:case 4:case 17:break;default:throw Error(a(163))}}catch(Ae){va(v,v.return,Ae)}if(x=v.sibling,x!==null){x.return=v.return,Ut=x;break}Ut=v.return}return A=V$,V$=!1,A}function _h(v,x,A){var I=x.updateQueue;if(I=I!==null?I.lastEffect:null,I!==null){var F=I=I.next;do{if((F.tag&v)===v){var U=F.destroy;F.destroy=void 0,U!==void 0&&i2(x,A,U)}F=F.next}while(F!==I)}}function nx(v,x){if(x=x.updateQueue,x=x!==null?x.lastEffect:null,x!==null){var A=x=x.next;do{if((A.tag&v)===v){var I=A.create;A.destroy=I()}A=A.next}while(A!==x)}}function s2(v){var x=v.ref;if(x!==null){var A=v.stateNode;switch(v.tag){case 5:v=K(A);break;default:v=A}typeof x=="function"?x(v):x.current=v}}function j$(v,x,A){if(Si&&typeof Si.onCommitFiberUnmount=="function")try{Si.onCommitFiberUnmount(ts,x)}catch{}switch(x.tag){case 0:case 11:case 14:case 15:if(v=x.updateQueue,v!==null&&(v=v.lastEffect,v!==null)){var I=v=v.next;do{var F=I,U=F.destroy;F=F.tag,U!==void 0&&(F&2||F&4)&&i2(x,A,U),I=I.next}while(I!==v)}break;case 1:if(D_(x,A),v=x.stateNode,typeof v.componentWillUnmount=="function")try{v.props=x.memoizedProps,v.state=x.memoizedState,v.componentWillUnmount()}catch(se){va(x,A,se)}break;case 5:D_(x,A);break;case 4:Et?Z$(v,x,A):Tt&&Tt&&(x=x.stateNode.containerInfo,A=Ze(x),qe(x,A))}}function X$(v,x,A){for(var I=x;;)if(j$(v,I,A),I.child===null||Et&&I.tag===4){if(I===x)break;for(;I.sibling===null;){if(I.return===null||I.return===x)return;I=I.return}I.sibling.return=I.return,I=I.sibling}else I.child.return=I,I=I.child}function K$(v){var x=v.alternate;x!==null&&(v.alternate=null,K$(x)),v.child=null,v.deletions=null,v.sibling=null,v.tag===5&&(x=v.stateNode,x!==null&&tt(x)),v.stateNode=null,v.return=null,v.dependencies=null,v.memoizedProps=null,v.memoizedState=null,v.pendingProps=null,v.stateNode=null,v.updateQueue=null}function q$(v){return v.tag===5||v.tag===3||v.tag===4}function J$(v){e:for(;;){for(;v.sibling===null;){if(v.return===null||q$(v.return))return null;v=v.return}for(v.sibling.return=v.return,v=v.sibling;v.tag!==5&&v.tag!==6&&v.tag!==18;){if(v.flags&2||v.child===null||v.tag===4)continue e;v.child.return=v,v=v.child}if(!(v.flags&2))return v.stateNode}}function Y$(v){if(Et){e:{for(var x=v.return;x!==null;){if(q$(x))break e;x=x.return}throw Error(a(160))}var A=x;switch(A.tag){case 5:x=A.stateNode,A.flags&32&&(Me(x),A.flags&=-33),A=J$(v),o2(v,A,x);break;case 3:case 4:x=A.stateNode.containerInfo,A=J$(v),a2(v,A,x);break;default:throw Error(a(161))}}}function a2(v,x,A){var I=v.tag;if(I===5||I===6)v=v.stateNode,x?mt(A,v,x):Lt(A,v);else if(I!==4&&(v=v.child,v!==null))for(a2(v,x,A),v=v.sibling;v!==null;)a2(v,x,A),v=v.sibling}function o2(v,x,A){var I=v.tag;if(I===5||I===6)v=v.stateNode,x?et(A,v,x):$e(A,v);else if(I!==4&&(v=v.child,v!==null))for(o2(v,x,A),v=v.sibling;v!==null;)o2(v,x,A),v=v.sibling}function Z$(v,x,A){for(var I=x,F=!1,U,se;;){if(!F){F=I.return;e:for(;;){if(F===null)throw Error(a(160));switch(U=F.stateNode,F.tag){case 5:se=!1;break e;case 3:U=U.containerInfo,se=!0;break e;case 4:U=U.containerInfo,se=!0;break e}F=F.return}F=!0}if(I.tag===5||I.tag===6)X$(v,I,A),se?he(U,I.stateNode):Ot(U,I.stateNode);else if(I.tag===18)se?dt(U,I.stateNode):gt(U,I.stateNode);else if(I.tag===4){if(I.child!==null){U=I.stateNode.containerInfo,se=!0,I.child.return=I,I=I.child;continue}}else if(j$(v,I,A),I.child!==null){I.child.return=I,I=I.child;continue}if(I===x)break;for(;I.sibling===null;){if(I.return===null||I.return===x)return;I=I.return,I.tag===4&&(F=!1)}I.sibling.return=I.return,I=I.sibling}}function l2(v,x){if(Et){switch(x.tag){case 0:case 11:case 14:case 15:_h(3,x,x.return),nx(3,x),_h(5,x,x.return);return;case 1:return;case 5:var A=x.stateNode;if(A!=null){var I=x.memoizedProps;v=v!==null?v.memoizedProps:I;var F=x.type,U=x.updateQueue;x.updateQueue=null,U!==null&&Ht(A,U,F,v,I,x)}return;case 6:if(x.stateNode===null)throw Error(a(162));A=x.memoizedProps,wt(x.stateNode,v!==null?v.memoizedProps:A,A);return;case 3:xt&&v!==null&&v.memoizedState.isDehydrated&&He(x.stateNode.containerInfo);return;case 12:return;case 13:P_(x);return;case 19:P_(x);return;case 17:return}throw Error(a(163))}switch(x.tag){case 0:case 11:case 14:case 15:_h(3,x,x.return),nx(3,x),_h(5,x,x.return);return;case 12:return;case 13:P_(x);return;case 19:P_(x);return;case 3:xt&&v!==null&&v.memoizedState.isDehydrated&&He(x.stateNode.containerInfo);break;case 22:case 23:return}e:if(Tt){switch(x.tag){case 1:case 5:case 6:break e;case 3:case 4:x=x.stateNode,qe(x.containerInfo,x.pendingChildren);break e}throw Error(a(163))}}function P_(v){var x=v.updateQueue;if(x!==null){v.updateQueue=null;var A=v.stateNode;A===null&&(A=v.stateNode=new Tre),x.forEach(function(I){var F=Bre.bind(null,v,I);A.has(I)||(A.add(I),I.then(F,F))})}}function Mre(v,x){for(Ut=x;Ut!==null;){x=Ut;var A=x.deletions;if(A!==null)for(var I=0;I<A.length;I++){var F=A[I];try{var U=v;Et?Z$(U,F,x):X$(U,F,x);var se=F.alternate;se!==null&&(se.return=null),F.return=null}catch(an){va(F,x,an)}}if(A=x.child,x.subtreeFlags&12854&&A!==null)A.return=x,Ut=A;else for(;Ut!==null;){x=Ut;try{var Ae=x.flags;if(Ae&32&&Et&&Me(x.stateNode),Ae&512){var Ke=x.alternate;if(Ke!==null){var _t=Ke.ref;_t!==null&&(typeof _t=="function"?_t(null):_t.current=null)}}if(Ae&8192)switch(x.tag){case 13:if(x.memoizedState!==null){var Yt=x.alternate;(Yt===null||Yt.memoizedState===null)&&(m2=en())}break;case 22:var Tn=x.memoizedState!==null,dn=x.alternate,Ir=dn!==null&&dn.memoizedState!==null;if(A=x,Et){e:if(I=A,F=Tn,U=null,Et)for(var on=I;;){if(on.tag===5){if(U===null){U=on;var Cs=on.stateNode;F?it(Cs):Ne(on.stateNode,on.memoizedProps)}}else if(on.tag===6){if(U===null){var Ao=on.stateNode;F?de(Ao):nt(Ao,on.memoizedProps)}}else if((on.tag!==22&&on.tag!==23||on.memoizedState===null||on===I)&&on.child!==null){on.child.return=on,on=on.child;continue}if(on===I)break;for(;on.sibling===null;){if(on.return===null||on.return===I)break e;U===on&&(U=null),on=on.return}U===on&&(U=null),on.sibling.return=on.return,on=on.sibling}}if(Tn&&!Ir&&A.mode&1){Ut=A;for(var Pe=A.child;Pe!==null;){for(A=Ut=Pe;Ut!==null;){I=Ut;var Te=I.child;switch(I.tag){case 0:case 11:case 14:case 15:_h(4,I,I.return);break;case 1:D_(I,I.return);var We=I.stateNode;if(typeof We.componentWillUnmount=="function"){var Gt=I.return;try{We.props=I.memoizedProps,We.state=I.memoizedState,We.componentWillUnmount()}catch(an){va(I,Gt,an)}}break;case 5:D_(I,I.return);break;case 22:if(I.memoizedState!==null){tz(A);continue}}Te!==null?(Te.return=I,Ut=Te):tz(A)}Pe=Pe.sibling}}}switch(Ae&4102){case 2:Y$(x),x.flags&=-3;break;case 6:Y$(x),x.flags&=-3,l2(x.alternate,x);break;case 4096:x.flags&=-4097;break;case 4100:x.flags&=-4097,l2(x.alternate,x);break;case 4:l2(x.alternate,x)}}catch(an){va(x,x.return,an)}if(A=x.sibling,A!==null){A.return=x.return,Ut=A;break}Ut=x.return}}}function kre(v,x,A){Ut=v,Q$(v)}function Q$(v,x,A){for(var I=(v.mode&1)!==0;Ut!==null;){var F=Ut,U=F.child;if(F.tag===22&&I){var se=F.memoizedState!==null||F_;if(!se){var Ae=F.alternate,Ke=Ae!==null&&Ae.memoizedState!==null||wh;Ae=F_;var _t=wh;if(F_=se,(wh=Ke)&&!_t)for(Ut=F;Ut!==null;)se=Ut,Ke=se.child,se.tag===22&&se.memoizedState!==null?nz(F):Ke!==null?(Ke.return=se,Ut=Ke):nz(F);for(;U!==null;)Ut=U,Q$(U),U=U.sibling;Ut=F,F_=Ae,wh=_t}ez(v)}else F.subtreeFlags&8772&&U!==null?(U.return=F,Ut=U):ez(v)}}function ez(v){for(;Ut!==null;){var x=Ut;if(x.flags&8772){var A=x.alternate;try{if(x.flags&8772)switch(x.tag){case 0:case 11:case 15:wh||nx(5,x);break;case 1:var I=x.stateNode;if(x.flags&4&&!wh)if(A===null)I.componentDidMount();else{var F=x.elementType===x.type?A.memoizedProps:Jo(x.type,A.memoizedProps);I.componentDidUpdate(F,A.memoizedState,I.__reactInternalSnapshotBeforeUpdate)}var U=x.updateQueue;U!==null&&KU(x,U,I);break;case 3:var se=x.updateQueue;if(se!==null){if(A=null,x.child!==null)switch(x.child.tag){case 5:A=K(x.child.stateNode);break;case 1:A=x.child.stateNode}KU(x,se,A)}break;case 5:var Ae=x.stateNode;A===null&&x.flags&4&&Pt(Ae,x.type,x.memoizedProps,x);break;case 6:break;case 4:break;case 12:break;case 13:if(xt&&x.memoizedState===null){var Ke=x.alternate;if(Ke!==null){var _t=Ke.memoizedState;if(_t!==null){var Yt=_t.dehydrated;Yt!==null&&Ve(Yt)}}}break;case 19:case 17:case 21:case 22:case 23:break;default:throw Error(a(163))}wh||x.flags&512&&s2(x)}catch(Tn){va(x,x.return,Tn)}}if(x===v){Ut=null;break}if(A=x.sibling,A!==null){A.return=x.return,Ut=A;break}Ut=x.return}}function tz(v){for(;Ut!==null;){var x=Ut;if(x===v){Ut=null;break}var A=x.sibling;if(A!==null){A.return=x.return,Ut=A;break}Ut=x.return}}function nz(v){for(;Ut!==null;){var x=Ut;try{switch(x.tag){case 0:case 11:case 15:var A=x.return;try{nx(4,x)}catch(Ke){va(x,A,Ke)}break;case 1:var I=x.stateNode;if(typeof I.componentDidMount=="function"){var F=x.return;try{I.componentDidMount()}catch(Ke){va(x,F,Ke)}}var U=x.return;try{s2(x)}catch(Ke){va(x,U,Ke)}break;case 5:var se=x.return;try{s2(x)}catch(Ke){va(x,se,Ke)}}}catch(Ke){va(x,x.return,Ke)}if(x===v){Ut=null;break}var Ae=x.sibling;if(Ae!==null){Ae.return=x.return,Ut=Ae;break}Ut=x.return}}var L_=0,O_=1,B_=2,U_=3,$_=4;if(typeof Symbol=="function"&&Symbol.for){var rx=Symbol.for;L_=rx("selector.component"),O_=rx("selector.has_pseudo_class"),B_=rx("selector.role"),U_=rx("selector.test_id"),$_=rx("selector.text")}function u2(v){var x=J(v);if(x!=null){if(typeof x.memoizedProps["data-testname"]!="string")throw Error(a(364));return x}if(v=At(v),v===null)throw Error(a(362));return v.stateNode.current}function c2(v,x){switch(x.$$typeof){case L_:if(v.type===x.value)return!0;break;case O_:e:{x=x.value,v=[v,0];for(var A=0;A<v.length;){var I=v[A++],F=v[A++],U=x[F];if(I.tag!==5||!H(I)){for(;U!=null&&c2(I,U);)F++,U=x[F];if(F===x.length){x=!0;break e}else for(I=I.child;I!==null;)v.push(I,F),I=I.sibling}}x=!1}return x;case B_:if(v.tag===5&&Ee(v.stateNode,x.value))return!0;break;case $_:if((v.tag===5||v.tag===6)&&(v=re(v),v!==null&&0<=v.indexOf(x.value)))return!0;break;case U_:if(v.tag===5&&(v=v.memoizedProps["data-testname"],typeof v=="string"&&v.toLowerCase()===x.value.toLowerCase()))return!0;break;default:throw Error(a(365))}return!1}function d2(v){switch(v.$$typeof){case L_:return"<"+(C(v.value)||"Unknown")+">";case O_:return":has("+(d2(v)||"")+")";case B_:return'[role="'+v.value+'"]';case $_:return'"'+v.value+'"';case U_:return'[data-testname="'+v.value+'"]';default:throw Error(a(365))}}function rz(v,x){var A=[];v=[v,0];for(var I=0;I<v.length;){var F=v[I++],U=v[I++],se=x[U];if(F.tag!==5||!H(F)){for(;se!=null&&c2(F,se);)U++,se=x[U];if(U===x.length)A.push(F);else for(F=F.child;F!==null;)v.push(F,U),F=F.sibling}}return A}function h2(v,x){if(!Je)throw Error(a(363));v=u2(v),v=rz(v,x),x=[],v=Array.from(v);for(var A=0;A<v.length;){var I=v[A++];if(I.tag===5)H(I)||x.push(I.stateNode);else for(I=I.child;I!==null;)v.push(I),I=I.sibling}return x}var Nre=Math.ceil,z_=o.ReactCurrentDispatcher,p2=o.ReactCurrentOwner,hi=o.ReactCurrentBatchConfig,zn=0,Ai=null,Ei=null,fs=0,qa=0,hg=It(0),Pi=0,ix=null,pg=0,G_=0,f2=0,sx=null,ga=null,m2=0,g2=1/0;function fg(){g2=en()+500}var H_=!1,y2=null,Ic=null,W_=!1,Tc=null,V_=0,ax=0,v2=null,j_=-1,X_=0;function Js(){return zn&6?en():j_!==-1?j_:j_=en()}function Cc(v){return v.mode&1?zn&2&&fs!==0?fs&-fs:pre.transition!==null?(X_===0&&(v=si,si<<=1,!(si&4194240)&&(si=64),X_=v),X_):(v=Wn,v!==0?v:Be()):1}function _o(v,x,A){if(50<ax)throw ax=0,v2=null,Error(a(185));var I=K_(v,x);return I===null?null:(Nl(I,x,A),(!(zn&2)||I!==Ai)&&(I===Ai&&(!(zn&2)&&(G_|=x),Pi===4&&Mc(I,fs)),ya(I,A),x===1&&zn===0&&!(v.mode&1)&&(fg(),qo&&Rl())),I)}function K_(v,x){v.lanes|=x;var A=v.alternate;for(A!==null&&(A.lanes|=x),A=v,v=v.return;v!==null;)v.childLanes|=x,A=v.alternate,A!==null&&(A.childLanes|=x),A=v,v=v.return;return A.tag===3?A.stateNode:null}function ya(v,x){var A=v.callbackNode;Gv(v,x);var I=yh(v,v===Ai?fs:0);if(I===0)A!==null&&ke(A),v.callbackNode=null,v.callbackPriority=0;else if(x=I&-I,v.callbackPriority!==x){if(A!=null&&ke(A),x===1)v.tag===0?hre(sz.bind(null,v)):WU(sz.bind(null,v)),Ue?St(function(){zn===0&&Rl()}):oe(vn,Rl),A=null;else{switch(u_(I)){case 1:A=vn;break;case 4:A=$t;break;case 16:A=nn;break;case 536870912:A=Nr;break;default:A=nn}A=fz(A,iz.bind(null,v))}v.callbackPriority=x,v.callbackNode=A}}function iz(v,x){if(j_=-1,X_=0,zn&6)throw Error(a(327));var A=v.callbackNode;if(Eh()&&v.callbackNode!==A)return null;var I=yh(v,v===Ai?fs:0);if(I===0)return null;if(I&30||I&v.expiredLanes||x)x=q_(v,I);else{x=I;var F=zn;zn|=2;var U=lz();(Ai!==v||fs!==x)&&(fg(),Sh(v,x));do try{Dre();break}catch(Ae){oz(v,Ae)}while(!0);NM(),z_.current=U,zn=F,Ei!==null?x=0:(Ai=null,fs=0,x=Pi)}if(x!==0){if(x===2&&(F=wc(v),F!==0&&(I=F,x=x2(v,F))),x===1)throw A=ix,Sh(v,0),Mc(v,I),ya(v,en()),A;if(x===6)Mc(v,I);else{if(F=v.current.alternate,!(I&30)&&!Rre(F)&&(x=q_(v,I),x===2&&(U=wc(v),U!==0&&(I=U,x=x2(v,U))),x===1))throw A=ix,Sh(v,0),Mc(v,I),ya(v,en()),A;switch(v.finishedWork=F,v.finishedLanes=I,x){case 0:case 1:throw Error(a(345));case 2:Ah(v,ga);break;case 3:if(Mc(v,I),(I&130023424)===I&&(x=m2+500-en(),10<x)){if(yh(v,0)!==0)break;if(F=v.suspendedLanes,(F&I)!==I){Js(),v.pingedLanes|=v.suspendedLanes&F;break}v.timeoutHandle=Re(Ah.bind(null,v,ga),x);break}Ah(v,ga);break;case 4:if(Mc(v,I),(I&4194240)===I)break;for(x=v.eventTimes,F=-1;0<I;){var se=31-fn(I);U=1<<se,se=x[se],se>F&&(F=se),I&=~U}if(I=F,I=en()-I,I=(120>I?120:480>I?480:1080>I?1080:1920>I?1920:3e3>I?3e3:4320>I?4320:1960*Nre(I/1960))-I,10<I){v.timeoutHandle=Re(Ah.bind(null,v,ga),I);break}Ah(v,ga);break;case 5:Ah(v,ga);break;default:throw Error(a(329))}}}return ya(v,en()),v.callbackNode===A?iz.bind(null,v):null}function x2(v,x){var A=sx;return v.current.memoizedState.isDehydrated&&(Sh(v,x).flags|=256),v=q_(v,x),v!==2&&(x=ga,ga=A,x!==null&&b2(x)),v}function b2(v){ga===null?ga=v:ga.push.apply(ga,v)}function Rre(v){for(var x=v;;){if(x.flags&16384){var A=x.updateQueue;if(A!==null&&(A=A.stores,A!==null))for(var I=0;I<A.length;I++){var F=A[I],U=F.getSnapshot;F=F.value;try{if(!go(U(),F))return!1}catch{return!1}}}if(A=x.child,x.subtreeFlags&16384&&A!==null)A.return=x,x=A;else{if(x===v)break;for(;x.sibling===null;){if(x.return===null||x.return===v)return!0;x=x.return}x.sibling.return=x.return,x=x.sibling}}return!0}function Mc(v,x){for(x&=~f2,x&=~G_,v.suspendedLanes|=x,v.pingedLanes&=~x,v=v.expirationTimes;0<x;){var A=31-fn(x),I=1<<A;v[A]=-1,x&=~I}}function sz(v){if(zn&6)throw Error(a(327));Eh();var x=yh(v,0);if(!(x&1))return ya(v,en()),null;var A=q_(v,x);if(v.tag!==0&&A===2){var I=wc(v);I!==0&&(x=I,A=x2(v,I))}if(A===1)throw A=ix,Sh(v,0),Mc(v,x),ya(v,en()),A;if(A===6)throw Error(a(345));return v.finishedWork=v.current.alternate,v.finishedLanes=x,Ah(v,ga),ya(v,en()),null}function az(v){Tc!==null&&Tc.tag===0&&!(zn&6)&&Eh();var x=zn;zn|=1;var A=hi.transition,I=Wn;try{if(hi.transition=null,Wn=1,v)return v()}finally{Wn=I,hi.transition=A,zn=x,!(zn&6)&&Rl()}}function w2(){qa=hg.current,ct(hg)}function Sh(v,x){v.finishedWork=null,v.finishedLanes=0;var A=v.timeoutHandle;if(A!==lt&&(v.timeoutHandle=lt,Le(A)),Ei!==null)for(A=Ei.return;A!==null;){var I=A;switch(BM(I),I.tag){case 1:I=I.type.childContextTypes,I!=null&&pn();break;case 3:cg(),ct(Kt),ct(un),VM();break;case 5:HM(I);break;case 4:cg();break;case 13:ct(Yr);break;case 19:ct(Yr);break;case 10:RM(I.type._context);break;case 22:case 23:w2()}A=A.return}if(Ai=v,Ei=v=kc(v.current,null),fs=qa=x,Pi=0,ix=null,f2=G_=pg=0,ga=sx=null,Fl!==null){for(x=0;x<Fl.length;x++)if(A=Fl[x],I=A.interleaved,I!==null){A.interleaved=null;var F=I.next,U=A.pending;if(U!==null){var se=U.next;U.next=F,I.next=se}A.pending=I}Fl=null}return v}function oz(v,x){do{var A=Ei;try{if(NM(),w_.current=T_,__){for(var I=ai.memoizedState;I!==null;){var F=I.queue;F!==null&&(F.pending=null),I=I.next}__=!1}if(dg=0,ns=Es=ai=null,qv=!1,Jv=0,p2.current=null,A===null||A.return===null){Pi=1,ix=x,Ei=null;break}e:{var U=v,se=A.return,Ae=A,Ke=x;if(x=fs,Ae.flags|=32768,Ke!==null&&typeof Ke=="object"&&typeof Ke.then=="function"){var _t=Ke,Yt=Ae,Tn=Yt.tag;if(!(Yt.mode&1)&&(Tn===0||Tn===11||Tn===15)){var dn=Yt.alternate;dn?(Yt.updateQueue=dn.updateQueue,Yt.memoizedState=dn.memoizedState,Yt.lanes=dn.lanes):(Yt.updateQueue=null,Yt.memoizedState=null)}var Ir=C$(se);if(Ir!==null){Ir.flags&=-257,M$(Ir,se,Ae,U,x),Ir.mode&1&&T$(U,_t,x),x=Ir,Ke=_t;var on=x.updateQueue;if(on===null){var Cs=new Set;Cs.add(Ke),x.updateQueue=Cs}else on.add(Ke);break e}else{if(!(x&1)){T$(U,_t,x),_2();break e}Ke=Error(a(426))}}else if(Gr&&Ae.mode&1){var Ao=C$(se);if(Ao!==null){!(Ao.flags&65536)&&(Ao.flags|=256),M$(Ao,se,Ae,U,x),zM(Ke);break e}}U=Ke,Pi!==4&&(Pi=2),sx===null?sx=[U]:sx.push(U),Ke=ZM(Ke,Ae),Ae=se;do{switch(Ae.tag){case 3:Ae.flags|=65536,x&=-x,Ae.lanes|=x;var Pe=E$(Ae,Ke,x);XU(Ae,Pe);break e;case 1:U=Ke;var Te=Ae.type,We=Ae.stateNode;if(!(Ae.flags&128)&&(typeof Te.getDerivedStateFromError=="function"||We!==null&&typeof We.componentDidCatch=="function"&&(Ic===null||!Ic.has(We)))){Ae.flags|=65536,x&=-x,Ae.lanes|=x;var Gt=I$(Ae,U,x);XU(Ae,Gt);break e}}Ae=Ae.return}while(Ae!==null)}cz(A)}catch(an){x=an,Ei===A&&A!==null&&(Ei=A=A.return);continue}break}while(!0)}function lz(){var v=z_.current;return z_.current=T_,v===null?T_:v}function _2(){(Pi===0||Pi===3||Pi===2)&&(Pi=4),Ai===null||!(pg&268435455)&&!(G_&268435455)||Mc(Ai,fs)}function q_(v,x){var A=zn;zn|=2;var I=lz();Ai===v&&fs===x||Sh(v,x);do try{Fre();break}catch(F){oz(v,F)}while(!0);if(NM(),zn=A,z_.current=I,Ei!==null)throw Error(a(261));return Ai=null,fs=0,Pi}function Fre(){for(;Ei!==null;)uz(Ei)}function Dre(){for(;Ei!==null&&!vt();)uz(Ei)}function uz(v){var x=pz(v.alternate,v,qa);v.memoizedProps=v.pendingProps,x===null?cz(v):Ei=x,p2.current=null}function cz(v){var x=v;do{var A=x.alternate;if(v=x.return,x.flags&32768){if(A=Ire(A,x),A!==null){A.flags&=32767,Ei=A;return}if(v!==null)v.flags|=32768,v.subtreeFlags=0,v.deletions=null;else{Pi=6,Ei=null;return}}else if(A=Sre(A,x,qa),A!==null){Ei=A;return}if(x=x.sibling,x!==null){Ei=x;return}Ei=x=v}while(x!==null);Pi===0&&(Pi=5)}function Ah(v,x){var A=Wn,I=hi.transition;try{hi.transition=null,Wn=1,Pre(v,x,A)}finally{hi.transition=I,Wn=A}return null}function Pre(v,x,A){do Eh();while(Tc!==null);if(zn&6)throw Error(a(327));var I=v.finishedWork,F=v.finishedLanes;if(I===null)return null;if(v.finishedWork=null,v.finishedLanes=0,I===v.current)throw Error(a(177));v.callbackNode=null,v.callbackPriority=0;var U=I.lanes|I.childLanes;if(l_(v,U),v===Ai&&(Ei=Ai=null,fs=0),!(I.subtreeFlags&2064)&&!(I.flags&2064)||W_||(W_=!0,fz(nn,function(){return Eh(),null})),U=(I.flags&15990)!==0,I.subtreeFlags&15990||U){U=hi.transition,hi.transition=null;var se=Wn;Wn=1;var Ae=zn;zn|=4,p2.current=null,Cre(v,I),Mre(v,I),X(v.containerInfo),v.current=I,kre(I),cn(),zn=Ae,Wn=se,hi.transition=U}else v.current=I;if(W_&&(W_=!1,Tc=v,V_=F),U=v.pendingLanes,U===0&&(Ic=null),c_(I.stateNode),ya(v,en()),x!==null)for(A=v.onRecoverableError,I=0;I<x.length;I++)A(x[I]);if(H_)throw H_=!1,v=y2,y2=null,v;return V_&1&&v.tag!==0&&Eh(),U=v.pendingLanes,U&1?v===v2?ax++:(ax=0,v2=v):ax=0,Rl(),null}function Eh(){if(Tc!==null){var v=u_(V_),x=hi.transition,A=Wn;try{if(hi.transition=null,Wn=16>v?16:v,Tc===null)var I=!1;else{if(v=Tc,Tc=null,V_=0,zn&6)throw Error(a(331));var F=zn;for(zn|=4,Ut=v.current;Ut!==null;){var U=Ut,se=U.child;if(Ut.flags&16){var Ae=U.deletions;if(Ae!==null){for(var Ke=0;Ke<Ae.length;Ke++){var _t=Ae[Ke];for(Ut=_t;Ut!==null;){var Yt=Ut;switch(Yt.tag){case 0:case 11:case 15:_h(8,Yt,U)}var Tn=Yt.child;if(Tn!==null)Tn.return=Yt,Ut=Tn;else for(;Ut!==null;){Yt=Ut;var dn=Yt.sibling,Ir=Yt.return;if(K$(Yt),Yt===_t){Ut=null;break}if(dn!==null){dn.return=Ir,Ut=dn;break}Ut=Ir}}}var on=U.alternate;if(on!==null){var Cs=on.child;if(Cs!==null){on.child=null;do{var Ao=Cs.sibling;Cs.sibling=null,Cs=Ao}while(Cs!==null)}}Ut=U}}if(U.subtreeFlags&2064&&se!==null)se.return=U,Ut=se;else e:for(;Ut!==null;){if(U=Ut,U.flags&2048)switch(U.tag){case 0:case 11:case 15:_h(9,U,U.return)}var Pe=U.sibling;if(Pe!==null){Pe.return=U.return,Ut=Pe;break e}Ut=U.return}}var Te=v.current;for(Ut=Te;Ut!==null;){se=Ut;var We=se.child;if(se.subtreeFlags&2064&&We!==null)We.return=se,Ut=We;else e:for(se=Te;Ut!==null;){if(Ae=Ut,Ae.flags&2048)try{switch(Ae.tag){case 0:case 11:case 15:nx(9,Ae)}}catch(an){va(Ae,Ae.return,an)}if(Ae===se){Ut=null;break e}var Gt=Ae.sibling;if(Gt!==null){Gt.return=Ae.return,Ut=Gt;break e}Ut=Ae.return}}if(zn=F,Rl(),Si&&typeof Si.onPostCommitFiberRoot=="function")try{Si.onPostCommitFiberRoot(ts,v)}catch{}I=!0}return I}finally{Wn=A,hi.transition=x}}return!1}function dz(v,x,A){x=ZM(A,x),x=E$(v,x,1),Ec(v,x),x=Js(),v=K_(v,1),v!==null&&(Nl(v,1,x),ya(v,x))}function va(v,x,A){if(v.tag===3)dz(v,v,A);else for(;x!==null;){if(x.tag===3){dz(x,v,A);break}else if(x.tag===1){var I=x.stateNode;if(typeof x.type.getDerivedStateFromError=="function"||typeof I.componentDidCatch=="function"&&(Ic===null||!Ic.has(I))){v=ZM(A,v),v=I$(x,v,1),Ec(x,v),v=Js(),x=K_(x,1),x!==null&&(Nl(x,1,v),ya(x,v));break}}x=x.return}}function Lre(v,x,A){var I=v.pingCache;I!==null&&I.delete(x),x=Js(),v.pingedLanes|=v.suspendedLanes&A,Ai===v&&(fs&A)===A&&(Pi===4||Pi===3&&(fs&130023424)===fs&&500>en()-m2?Sh(v,0):f2|=A),ya(v,x)}function hz(v,x){x===0&&(v.mode&1?(x=Ko,Ko<<=1,!(Ko&130023424)&&(Ko=4194304)):x=1);var A=Js();v=K_(v,x),v!==null&&(Nl(v,x,A),ya(v,A))}function Ore(v){var x=v.memoizedState,A=0;x!==null&&(A=x.retryLane),hz(v,A)}function Bre(v,x){var A=0;switch(v.tag){case 13:var I=v.stateNode,F=v.memoizedState;F!==null&&(A=F.retryLane);break;case 19:I=v.stateNode;break;default:throw Error(a(314))}I!==null&&I.delete(x),hz(v,A)}var pz;pz=function(v,x,A){if(v!==null)if(v.memoizedProps!==x.pendingProps||Kt.current)Ka=!0;else{if(!(v.lanes&A)&&!(x.flags&128))return Ka=!1,Ere(v,x,A);Ka=!!(v.flags&131072)}else Ka=!1,Gr&&x.flags&1048576&&QU(x,v_,x.index);switch(x.lanes=0,x.tag){case 2:var I=x.type;v!==null&&(v.alternate=null,x.alternate=null,x.flags|=2),v=x.pendingProps;var F=Wt(x,un.current);ig(x,A),F=XM(null,x,I,v,F,A);var U=KM();return x.flags|=1,typeof F=="object"&&F!==null&&typeof F.render=="function"&&F.$$typeof===void 0?(x.tag=1,x.memoizedState=null,x.updateQueue=null,Bn(I)?(U=!0,Sn(x)):U=!1,x.memoizedState=F.state!==null&&F.state!==void 0?F.state:null,DM(x),F.updater=g_,x.stateNode=F,F._reactInternals=x,LM(x,I,v,A),x=t2(null,x,I,!0,U,A)):(x.tag=0,Gr&&U&&OM(x),qs(null,x,F,A),x=x.child),x;case 16:I=x.elementType;e:{switch(v!==null&&(v.alternate=null,x.alternate=null,x.flags|=2),v=x.pendingProps,F=I._init,I=F(I._payload),x.type=I,F=x.tag=$re(I),v=Jo(I,v),F){case 0:x=e2(null,x,I,v,A);break e;case 1:x=O$(null,x,I,v,A);break e;case 11:x=R$(null,x,I,v,A);break e;case 14:x=F$(null,x,I,Jo(I.type,v),A);break e}throw Error(a(306,I,""))}return x;case 0:return I=x.type,F=x.pendingProps,F=x.elementType===I?F:Jo(I,F),e2(v,x,I,F,A);case 1:return I=x.type,F=x.pendingProps,F=x.elementType===I?F:Jo(I,F),O$(v,x,I,F,A);case 3:e:{if(B$(x),v===null)throw Error(a(387));I=x.pendingProps,U=x.memoizedState,F=U.element,jU(v,x),m_(x,I,null,A);var se=x.memoizedState;if(I=se.element,xt&&U.isDehydrated)if(U={element:I,isDehydrated:!1,cache:se.cache,transitions:se.transitions},x.updateQueue.baseState=U,x.memoizedState=U,x.flags&256){F=Error(a(423)),x=U$(v,x,I,A,F);break e}else if(I!==F){F=Error(a(424)),x=U$(v,x,I,A,F);break e}else for(xt&&(Xa=Wa(x.stateNode.containerInfo),ja=x,Gr=!0,Yo=null,Wv=!1),A=s$(x,null,I,A),x.child=A;A;)A.flags=A.flags&-3|4096,A=A.sibling;else{if(og(),I===F){x=Iu(v,x,A);break e}qs(v,x,I,A)}x=x.child}return x;case 5:return a$(x),v===null&&$M(x),I=x.type,F=x.pendingProps,U=v!==null?v.memoizedProps:null,se=F.children,we(I,F)?se=null:U!==null&&we(I,U)&&(x.flags|=32),L$(v,x),qs(v,x,se,A),x.child;case 6:return v===null&&$M(x),null;case 13:return $$(v,x,A);case 4:return GM(x,x.stateNode.containerInfo),I=x.pendingProps,v===null?x.child=lg(x,null,I,A):qs(v,x,I,A),x.child;case 11:return I=x.type,F=x.pendingProps,F=x.elementType===I?F:Jo(I,F),R$(v,x,I,F,A);case 7:return qs(v,x,x.pendingProps,A),x.child;case 8:return qs(v,x,x.pendingProps.children,A),x.child;case 12:return qs(v,x,x.pendingProps.children,A),x.child;case 10:e:{if(I=x.type._context,F=x.pendingProps,U=x.memoizedProps,se=F.value,VU(x,I,se),U!==null)if(go(U.value,se)){if(U.children===F.children&&!Kt.current){x=Iu(v,x,A);break e}}else for(U=x.child,U!==null&&(U.return=x);U!==null;){var Ae=U.dependencies;if(Ae!==null){se=U.child;for(var Ke=Ae.firstContext;Ke!==null;){if(Ke.context===I){if(U.tag===1){Ke=_u(-1,A&-A),Ke.tag=2;var _t=U.updateQueue;if(_t!==null){_t=_t.shared;var Yt=_t.pending;Yt===null?Ke.next=Ke:(Ke.next=Yt.next,Yt.next=Ke),_t.pending=Ke}}U.lanes|=A,Ke=U.alternate,Ke!==null&&(Ke.lanes|=A),FM(U.return,A,x),Ae.lanes|=A;break}Ke=Ke.next}}else if(U.tag===10)se=U.type===x.type?null:U.child;else if(U.tag===18){if(se=U.return,se===null)throw Error(a(341));se.lanes|=A,Ae=se.alternate,Ae!==null&&(Ae.lanes|=A),FM(se,A,x),se=U.sibling}else se=U.child;if(se!==null)se.return=U;else for(se=U;se!==null;){if(se===x){se=null;break}if(U=se.sibling,U!==null){U.return=se.return,se=U;break}se=se.return}U=se}qs(v,x,F.children,A),x=x.child}return x;case 9:return F=x.type,I=x.pendingProps.children,ig(x,A),F=yo(F),I=I(F),x.flags|=1,qs(v,x,I,A),x.child;case 14:return I=x.type,F=Jo(I,x.pendingProps),F=Jo(I.type,F),F$(v,x,I,F,A);case 15:return D$(v,x,x.type,x.pendingProps,A);case 17:return I=x.type,F=x.pendingProps,F=x.elementType===I?F:Jo(I,F),v!==null&&(v.alternate=null,x.alternate=null,x.flags|=2),x.tag=1,Bn(I)?(v=!0,Sn(x)):v=!1,ig(x,A),YU(x,I,F),LM(x,I,F,A),t2(null,x,I,!0,v,A);case 19:return W$(v,x,A);case 22:return P$(v,x,A)}throw Error(a(156,x.tag))};function fz(v,x){return oe(v,x)}function Ure(v,x,A,I){this.tag=v,this.key=A,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=x,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=I,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function So(v,x,A,I){return new Ure(v,x,A,I)}function S2(v){return v=v.prototype,!(!v||!v.isReactComponent)}function $re(v){if(typeof v=="function")return S2(v)?1:0;if(v!=null){if(v=v.$$typeof,v===g)return 11;if(v===b)return 14}return 2}function kc(v,x){var A=v.alternate;return A===null?(A=So(v.tag,x,v.key,v.mode),A.elementType=v.elementType,A.type=v.type,A.stateNode=v.stateNode,A.alternate=v,v.alternate=A):(A.pendingProps=x,A.type=v.type,A.flags=0,A.subtreeFlags=0,A.deletions=null),A.flags=v.flags&14680064,A.childLanes=v.childLanes,A.lanes=v.lanes,A.child=v.child,A.memoizedProps=v.memoizedProps,A.memoizedState=v.memoizedState,A.updateQueue=v.updateQueue,x=v.dependencies,A.dependencies=x===null?null:{lanes:x.lanes,firstContext:x.firstContext},A.sibling=v.sibling,A.index=v.index,A.ref=v.ref,A}function J_(v,x,A,I,F,U){var se=2;if(I=v,typeof v=="function")S2(v)&&(se=1);else if(typeof v=="string")se=5;else e:switch(v){case c:return Ih(A.children,F,U,x);case d:se=8,F|=8;break;case h:return v=So(12,A,x,F|2),v.elementType=h,v.lanes=U,v;case y:return v=So(13,A,x,F),v.elementType=y,v.lanes=U,v;case m:return v=So(19,A,x,F),v.elementType=m,v.lanes=U,v;case _:return Y_(A,F,U,x);default:if(typeof v=="object"&&v!==null)switch(v.$$typeof){case p:se=10;break e;case f:se=9;break e;case g:se=11;break e;case b:se=14;break e;case w:se=16,I=null;break e}throw Error(a(130,v==null?v:typeof v,""))}return x=So(se,A,x,F),x.elementType=v,x.type=I,x.lanes=U,x}function Ih(v,x,A,I){return v=So(7,v,I,x),v.lanes=A,v}function Y_(v,x,A,I){return v=So(22,v,I,x),v.elementType=_,v.lanes=A,v.stateNode={},v}function A2(v,x,A){return v=So(6,v,null,x),v.lanes=A,v}function E2(v,x,A){return x=So(4,v.children!==null?v.children:[],v.key,x),x.lanes=A,x.stateNode={containerInfo:v.containerInfo,pendingChildren:null,implementation:v.implementation},x}function zre(v,x,A,I,F){this.tag=x,this.containerInfo=v,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=lt,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=_c(0),this.expirationTimes=_c(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=_c(0),this.identifierPrefix=I,this.onRecoverableError=F,xt&&(this.mutableSourceEagerHydrationData=null)}function mz(v,x,A,I,F,U,se,Ae,Ke){return v=new zre(v,x,A,Ae,Ke),x===1?(x=1,U===!0&&(x|=8)):x=0,U=So(3,null,null,x),v.current=U,U.stateNode=v,U.memoizedState={element:I,isDehydrated:A,cache:null,transitions:null},DM(U),v}function gz(v){if(!v)return jt;v=v._reactInternals;e:{if(M(v)!==v||v.tag!==1)throw Error(a(170));var x=v;do{switch(x.tag){case 3:x=x.stateNode.context;break e;case 1:if(Bn(x.type)){x=x.stateNode.__reactInternalMemoizedMergedChildContext;break e}}x=x.return}while(x!==null);throw Error(a(171))}if(v.tag===1){var A=v.type;if(Bn(A))return Ar(v,A,x)}return x}function yz(v){var x=v._reactInternals;if(x===void 0)throw typeof v.render=="function"?Error(a(188)):(v=Object.keys(v).join(","),Error(a(268,v)));return v=N(x),v===null?null:v.stateNode}function vz(v,x){if(v=v.memoizedState,v!==null&&v.dehydrated!==null){var A=v.retryLane;v.retryLane=A!==0&&A<x?A:x}}function I2(v,x){vz(v,x),(v=v.alternate)&&vz(v,x)}function Gre(v){return v=N(v),v===null?null:v.stateNode}function Hre(){return null}return n.attemptContinuousHydration=function(v){if(v.tag===13){var x=Js();_o(v,134217728,x),I2(v,134217728)}},n.attemptHydrationAtCurrentPriority=function(v){if(v.tag===13){var x=Js(),A=Cc(v);_o(v,A,x),I2(v,A)}},n.attemptSynchronousHydration=function(v){switch(v.tag){case 3:var x=v.stateNode;if(x.current.memoizedState.isDehydrated){var A=ps(x.pendingLanes);A!==0&&(Sc(x,A|1),ya(x,en()),!(zn&6)&&(fg(),Rl()))}break;case 13:var I=Js();az(function(){return _o(v,1,I)}),I2(v,1)}},n.batchedUpdates=function(v,x){var A=zn;zn|=1;try{return v(x)}finally{zn=A,zn===0&&(fg(),qo&&Rl())}},n.createComponentSelector=function(v){return{$$typeof:L_,value:v}},n.createContainer=function(v,x,A,I,F,U,se){return mz(v,x,!1,null,A,I,F,U,se)},n.createHasPseudoClassSelector=function(v){return{$$typeof:O_,value:v}},n.createHydrationContainer=function(v,x,A,I,F,U,se,Ae,Ke){return v=mz(A,I,!0,v,F,U,se,Ae,Ke),v.context=gz(null),A=v.current,I=Js(),F=Cc(A),U=_u(I,F),U.callback=x??null,Ec(A,U),v.current.lanes=F,Nl(v,F,I),ya(v,I),v},n.createPortal=function(v,x,A){var I=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:u,key:I==null?null:""+I,children:v,containerInfo:x,implementation:A}},n.createRoleSelector=function(v){return{$$typeof:B_,value:v}},n.createTestNameSelector=function(v){return{$$typeof:U_,value:v}},n.createTextSelector=function(v){return{$$typeof:$_,value:v}},n.deferredUpdates=function(v){var x=Wn,A=hi.transition;try{return hi.transition=null,Wn=16,v()}finally{Wn=x,hi.transition=A}},n.discreteUpdates=function(v,x,A,I,F){var U=Wn,se=hi.transition;try{return hi.transition=null,Wn=1,v(x,A,I,F)}finally{Wn=U,hi.transition=se,zn===0&&fg()}},n.findAllNodes=h2,n.findBoundingRects=function(v,x){if(!Je)throw Error(a(363));x=h2(v,x),v=[];for(var A=0;A<x.length;A++)v.push(Vt(x[A]));for(x=v.length-1;0<x;x--){A=v[x];for(var I=A.x,F=I+A.width,U=A.y,se=U+A.height,Ae=x-1;0<=Ae;Ae--)if(x!==Ae){var Ke=v[Ae],_t=Ke.x,Yt=_t+Ke.width,Tn=Ke.y,dn=Tn+Ke.height;if(I>=_t&&U>=Tn&&F<=Yt&&se<=dn){v.splice(x,1);break}else if(I!==_t||A.width!==Ke.width||dn<U||Tn>se){if(!(U!==Tn||A.height!==Ke.height||Yt<I||_t>F)){_t>I&&(Ke.width+=_t-I,Ke.x=I),Yt<F&&(Ke.width=F-_t),v.splice(x,1);break}}else{Tn>U&&(Ke.height+=Tn-U,Ke.y=U),dn<se&&(Ke.height=se-Tn),v.splice(x,1);break}}}return v},n.findHostInstance=yz,n.findHostInstanceWithNoPortals=function(v){return v=R(v),v=v!==null?z(v):null,v===null?null:v.stateNode},n.findHostInstanceWithWarning=function(v){return yz(v)},n.flushControlled=function(v){var x=zn;zn|=1;var A=hi.transition,I=Wn;try{hi.transition=null,Wn=1,v()}finally{Wn=I,hi.transition=A,zn=x,zn===0&&(fg(),Rl())}},n.flushPassiveEffects=Eh,n.flushSync=az,n.focusWithin=function(v,x){if(!Je)throw Error(a(363));for(v=u2(v),x=rz(v,x),x=Array.from(x),v=0;v<x.length;){var A=x[v++];if(!H(A)){if(A.tag===5&&Oe(A.stateNode))return!0;for(A=A.child;A!==null;)x.push(A),A=A.sibling}}return!1},n.getCurrentUpdatePriority=function(){return Wn},n.getFindAllNodesFailureDescription=function(v,x){if(!Je)throw Error(a(363));var A=0,I=[];v=[u2(v),0];for(var F=0;F<v.length;){var U=v[F++],se=v[F++],Ae=x[se];if((U.tag!==5||!H(U))&&(c2(U,Ae)&&(I.push(d2(Ae)),se++,se>A&&(A=se)),se<x.length))for(U=U.child;U!==null;)v.push(U,se),U=U.sibling}if(A<x.length){for(v=[];A<x.length;A++)v.push(d2(x[A]));return`findAllNodes was able to match part of the selector:
  `+(I.join(" > ")+`

No matching component was found for:
  `)+v.join(" > ")}return null},n.getPublicRootInstance=function(v){if(v=v.current,!v.child)return null;switch(v.child.tag){case 5:return K(v.child.stateNode);default:return v.child.stateNode}},n.injectIntoDevTools=function(v){if(v={bundleType:v.bundleType,version:v.version,rendererPackageName:v.rendererPackageName,rendererConfig:v.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:o.ReactCurrentDispatcher,findHostInstanceByFiber:Gre,findFiberByHostInstance:v.findFiberByHostInstance||Hre,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.0.0-fc46dba67-20220329"},typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")v=!1;else{var x=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(x.isDisabled||!x.supportsFiber)v=!0;else{try{ts=x.inject(v),Si=x}catch{}v=!!x.checkDCE}}return v},n.isAlreadyRendering=function(){return!1},n.observeVisibleRects=function(v,x,A,I){if(!Je)throw Error(a(363));v=h2(v,x);var F=Xe(v,A,I).disconnect;return{disconnect:function(){F()}}},n.registerMutableSourceForHydration=function(v,x){var A=x._getVersion;A=A(x._source),v.mutableSourceEagerHydrationData==null?v.mutableSourceEagerHydrationData=[x,A]:v.mutableSourceEagerHydrationData.push(x,A)},n.runWithPriority=function(v,x){var A=Wn;try{return Wn=v,x()}finally{Wn=A}},n.shouldError=function(){return null},n.shouldSuspend=function(){return!1},n.updateContainer=function(v,x,A,I){var F=x.current,U=Js(),se=Cc(F);return A=gz(A),x.context===null?x.context=A:x.pendingContext=A,x=_u(U,se),x.payload={element:v},I=I===void 0?null:I,I!==null&&(x.callback=I),Ec(F,x),v=_o(F,se,U),v!==null&&f_(v,F,se),se},n};fX.exports=Vge;var jge=fX.exports;const Xge=N5(jge);var mX={exports:{}},gX={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(t){function e(O,j){var X=O.length;O.push(j);e:for(;0<X;){var te=X-1>>>1,le=O[te];if(0<i(le,j))O[te]=j,O[X]=le,X=te;else break e}}function n(O){return O.length===0?null:O[0]}function r(O){if(O.length===0)return null;var j=O[0],X=O.pop();if(X!==j){O[0]=X;e:for(var te=0,le=O.length,ge=le>>>1;te<ge;){var ie=2*(te+1)-1,we=O[ie],Ce=ie+1,Re=O[Ce];if(0>i(we,X))Ce<le&&0>i(Re,we)?(O[te]=Re,O[Ce]=X,te=Ce):(O[te]=we,O[ie]=X,te=ie);else if(Ce<le&&0>i(Re,X))O[te]=Re,O[Ce]=X,te=Ce;else break e}}return j}function i(O,j){var X=O.sortIndex-j.sortIndex;return X!==0?X:O.id-j.id}if(typeof performance=="object"&&typeof performance.now=="function"){var s=performance;t.unstable_now=function(){return s.now()}}else{var a=Date,o=a.now();t.unstable_now=function(){return a.now()-o}}var l=[],u=[],c=1,d=null,h=3,p=!1,f=!1,g=!1,y=typeof setTimeout=="function"?setTimeout:null,m=typeof clearTimeout=="function"?clearTimeout:null,b=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function w(O){for(var j=n(u);j!==null;){if(j.callback===null)r(u);else if(j.startTime<=O)r(u),j.sortIndex=j.expirationTime,e(l,j);else break;j=n(u)}}function _(O){if(g=!1,w(O),!f)if(n(l)!==null)f=!0,K(S);else{var j=n(u);j!==null&&Q(_,j.startTime-O)}}function S(O,j){f=!1,g&&(g=!1,m(T),T=-1),p=!0;var X=h;try{for(w(j),d=n(l);d!==null&&(!(d.expirationTime>j)||O&&!R());){var te=d.callback;if(typeof te=="function"){d.callback=null,h=d.priorityLevel;var le=te(d.expirationTime<=j);j=t.unstable_now(),typeof le=="function"?d.callback=le:d===n(l)&&r(l),w(j)}else r(l);d=n(l)}if(d!==null)var ge=!0;else{var ie=n(u);ie!==null&&Q(_,ie.startTime-j),ge=!1}return ge}finally{d=null,h=X,p=!1}}var E=!1,C=null,T=-1,M=5,k=-1;function R(){return!(t.unstable_now()-k<M)}function N(){if(C!==null){var O=t.unstable_now();k=O;var j=!0;try{j=C(!0,O)}finally{j?B():(E=!1,C=null)}}else E=!1}var B;if(typeof b=="function")B=function(){b(N)};else if(typeof MessageChannel<"u"){var z=new MessageChannel,V=z.port2;z.port1.onmessage=N,B=function(){V.postMessage(null)}}else B=function(){y(N,0)};function K(O){C=O,E||(E=!0,B())}function Q(O,j){T=y(function(){O(t.unstable_now())},j)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(O){O.callback=null},t.unstable_continueExecution=function(){f||p||(f=!0,K(S))},t.unstable_forceFrameRate=function(O){0>O||125<O?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):M=0<O?Math.floor(1e3/O):5},t.unstable_getCurrentPriorityLevel=function(){return h},t.unstable_getFirstCallbackNode=function(){return n(l)},t.unstable_next=function(O){switch(h){case 1:case 2:case 3:var j=3;break;default:j=h}var X=h;h=j;try{return O()}finally{h=X}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(O,j){switch(O){case 1:case 2:case 3:case 4:case 5:break;default:O=3}var X=h;h=O;try{return j()}finally{h=X}},t.unstable_scheduleCallback=function(O,j,X){var te=t.unstable_now();switch(typeof X=="object"&&X!==null?(X=X.delay,X=typeof X=="number"&&0<X?te+X:te):X=te,O){case 1:var le=-1;break;case 2:le=250;break;case 5:le=1073741823;break;case 4:le=1e4;break;default:le=5e3}return le=X+le,O={id:c++,callback:j,priorityLevel:O,startTime:X,expirationTime:le,sortIndex:-1},X>te?(O.sortIndex=X,e(u,O),n(l)===null&&O===n(u)&&(g?(m(T),T=-1):g=!0,Q(_,X-te))):(O.sortIndex=le,e(l,O),f||p||(f=!0,K(S))),O},t.unstable_shouldYield=R,t.unstable_wrapCallback=function(O){var j=h;return function(){var X=h;h=j;try{return O.apply(this,arguments)}finally{h=X}}}})(gX);mX.exports=gX;var kH=mX.exports;const u3={},c3=t=>void Object.assign(u3,t);function Kge(t,e){function n(c,{args:d=[],attach:h,...p},f){let g=`${c[0].toUpperCase()}${c.slice(1)}`,y;if(c==="primitive"){if(p.object===void 0)throw new Error("R3F: Primitives without 'object' are invalid!");const m=p.object;y=Hg(m,{type:c,root:f,attach:h,primitive:!0})}else{const m=u3[g];if(!m)throw new Error(`R3F: ${g} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);if(!Array.isArray(d))throw new Error("R3F: The args prop must be an array!");y=Hg(new m(...d),{type:c,root:f,attach:h,memoizedProps:{args:d}})}return y.__r3f.attach===void 0&&(y.isBufferGeometry?y.__r3f.attach="geometry":y.isMaterial&&(y.__r3f.attach="material")),g!=="inject"&&eN(y,p),y}function r(c,d){let h=!1;if(d){var p,f;(p=d.__r3f)!=null&&p.attach?Qk(c,d,d.__r3f.attach):d.isObject3D&&c.isObject3D&&(c.add(d),h=!0),h||(f=c.__r3f)==null||f.objects.push(d),d.__r3f||Hg(d,{}),d.__r3f.parent=c,ZR(d),Wg(d)}}function i(c,d,h){let p=!1;if(d){var f,g;if((f=d.__r3f)!=null&&f.attach)Qk(c,d,d.__r3f.attach);else if(d.isObject3D&&c.isObject3D){d.parent=c,d.dispatchEvent({type:"added"}),c.dispatchEvent({type:"childadded",child:d});const y=c.children.filter(b=>b!==d),m=y.indexOf(h);c.children=[...y.slice(0,m),d,...y.slice(m)],p=!0}p||(g=c.__r3f)==null||g.objects.push(d),d.__r3f||Hg(d,{}),d.__r3f.parent=c,ZR(d),Wg(d)}}function s(c,d,h=!1){c&&[...c].forEach(p=>a(d,p,h))}function a(c,d,h){if(d){var p,f,g;if(d.__r3f&&(d.__r3f.parent=null),(p=c.__r3f)!=null&&p.objects&&(c.__r3f.objects=c.__r3f.objects.filter(_=>_!==d)),(f=d.__r3f)!=null&&f.attach)PH(c,d,d.__r3f.attach);else if(d.isObject3D&&c.isObject3D){var y;c.remove(d),(y=d.__r3f)!=null&&y.root&&nye(JA(d),d)}const b=(g=d.__r3f)==null?void 0:g.primitive,w=!b&&(h===void 0?d.dispose!==null:h);if(!b){var m;s((m=d.__r3f)==null?void 0:m.objects,d,w),s(d.children,d,w)}if(delete d.__r3f,w&&d.dispose&&d.type!=="Scene"){const _=()=>{try{d.dispose()}catch{}};typeof IS_REACT_ACT_ENVIRONMENT>"u"?kH.unstable_scheduleCallback(kH.unstable_IdlePriority,_):_()}Wg(c)}}function o(c,d,h,p){var f;const g=(f=c.__r3f)==null?void 0:f.parent;if(!g)return;const y=n(d,h,c.__r3f.root);if(c.children){for(const m of c.children)m.__r3f&&r(y,m);c.children=c.children.filter(m=>!m.__r3f)}c.__r3f.objects.forEach(m=>r(y,m)),c.__r3f.objects=[],c.__r3f.autoRemovedBeforeAppend||a(g,c),y.parent&&(y.__r3f.autoRemovedBeforeAppend=!0),r(g,y),y.raycast&&y.__r3f.eventCount&&JA(y).getState().internal.interaction.push(y),[p,p.alternate].forEach(m=>{m!==null&&(m.stateNode=y,m.ref&&(typeof m.ref=="function"?m.ref(y):m.ref.current=y))})}const l=()=>{};return{reconciler:Xge({createInstance:n,removeChild:a,appendChild:r,appendInitialChild:r,insertBefore:i,supportsMutation:!0,isPrimaryRenderer:!1,supportsPersistence:!1,supportsHydration:!1,noTimeout:-1,appendChildToContainer:(c,d)=>{if(!d)return;const h=c.getState().scene;h.__r3f&&(h.__r3f.root=c,r(h,d))},removeChildFromContainer:(c,d)=>{d&&a(c.getState().scene,d)},insertInContainerBefore:(c,d,h)=>{if(!d||!h)return;const p=c.getState().scene;p.__r3f&&i(p,d,h)},getRootHostContext:()=>null,getChildHostContext:c=>c,finalizeInitialChildren(c){var d;return!!((d=c==null?void 0:c.__r3f)!=null?d:{}).handlers},prepareUpdate(c,d,h,p){var f;if(((f=c==null?void 0:c.__r3f)!=null?f:{}).primitive&&p.object&&p.object!==c)return[!0];{const{args:y=[],children:m,...b}=p,{args:w=[],children:_,...S}=h;if(!Array.isArray(y))throw new Error("R3F: the args prop must be an array!");if(y.some((C,T)=>C!==w[T]))return[!0];const E=SX(c,b,S,!0);return E.changes.length?[!1,E]:null}},commitUpdate(c,[d,h],p,f,g,y){d?o(c,p,g,y):eN(c,h)},commitMount(c,d,h,p){var f;const g=(f=c.__r3f)!=null?f:{};c.raycast&&g.handlers&&g.eventCount&&JA(c).getState().internal.interaction.push(c)},getPublicInstance:c=>c,prepareForCommit:()=>null,preparePortalMount:c=>Hg(c.getState().scene),resetAfterCommit:()=>{},shouldSetTextContent:()=>!1,clearContainer:()=>!1,hideInstance(c){var d;const{attach:h,parent:p}=(d=c.__r3f)!=null?d:{};h&&p&&PH(p,c,h),c.isObject3D&&(c.visible=!1),Wg(c)},unhideInstance(c,d){var h;const{attach:p,parent:f}=(h=c.__r3f)!=null?h:{};p&&f&&Qk(f,c,p),(c.isObject3D&&d.visible==null||d.visible)&&(c.visible=!0),Wg(c)},createTextInstance:l,hideTextInstance:l,unhideTextInstance:l,getCurrentEventPriority:()=>e?e():ly.DefaultEventPriority,beforeActiveInstanceBlur:()=>{},afterActiveInstanceBlur:()=>{},detachDeletedInstance:()=>{},now:typeof performance<"u"&&Rr.fun(performance.now)?performance.now:Rr.fun(Date.now)?Date.now:()=>0,scheduleTimeout:Rr.fun(setTimeout)?setTimeout:void 0,cancelTimeout:Rr.fun(clearTimeout)?clearTimeout:void 0}),applyProps:eN}}var NH,RH;const Zk=t=>"colorSpace"in t||"outputColorSpace"in t,yX=()=>{var t;return(t=u3.ColorManagement)!=null?t:null},vX=t=>t&&t.isOrthographicCamera,qge=t=>t&&t.hasOwnProperty("current"),ew=typeof window<"u"&&((NH=window.document)!=null&&NH.createElement||((RH=window.navigator)==null?void 0:RH.product)==="ReactNative")?ne.useLayoutEffect:ne.useEffect;function xX(t){const e=ne.useRef(t);return ew(()=>void(e.current=t),[t]),e}function Jge({set:t}){return ew(()=>(t(new Promise(()=>null)),()=>t(!1)),[t]),null}class bX extends ne.Component{constructor(...e){super(...e),this.state={error:!1}}componentDidCatch(e){this.props.set(e)}render(){return this.state.error?null:this.props.children}}bX.getDerivedStateFromError=()=>({error:!0});const wX="__default",FH=new Map,Yge=t=>t&&!!t.memoized&&!!t.changes;function _X(t){var e;const n=typeof window<"u"?(e=window.devicePixelRatio)!=null?e:2:1;return Array.isArray(t)?Math.min(Math.max(t[0],n),t[1]):t}const Cx=t=>{var e;return(e=t.__r3f)==null?void 0:e.root.getState()};function JA(t){let e=t.__r3f.root;for(;e.getState().previousRoot;)e=e.getState().previousRoot;return e}const Rr={obj:t=>t===Object(t)&&!Rr.arr(t)&&typeof t!="function",fun:t=>typeof t=="function",str:t=>typeof t=="string",num:t=>typeof t=="number",boo:t=>typeof t=="boolean",und:t=>t===void 0,arr:t=>Array.isArray(t),equ(t,e,{arrays:n="shallow",objects:r="reference",strict:i=!0}={}){if(typeof t!=typeof e||!!t!=!!e)return!1;if(Rr.str(t)||Rr.num(t)||Rr.boo(t))return t===e;const s=Rr.obj(t);if(s&&r==="reference")return t===e;const a=Rr.arr(t);if(a&&n==="reference")return t===e;if((a||s)&&t===e)return!0;let o;for(o in t)if(!(o in e))return!1;if(s&&n==="shallow"&&r==="shallow"){for(o in i?e:t)if(!Rr.equ(t[o],e[o],{strict:i,objects:"reference"}))return!1}else for(o in i?e:t)if(t[o]!==e[o])return!1;if(Rr.und(o)){if(a&&t.length===0&&e.length===0||s&&Object.keys(t).length===0&&Object.keys(e).length===0)return!0;if(t!==e)return!1}return!0}};function Zge(t){const e={nodes:{},materials:{}};return t&&t.traverse(n=>{n.name&&(e.nodes[n.name]=n),n.material&&!e.materials[n.material.name]&&(e.materials[n.material.name]=n.material)}),e}function Qge(t){t.dispose&&t.type!=="Scene"&&t.dispose();for(const e in t)e.dispose==null||e.dispose(),delete t[e]}function Hg(t,e){const n=t;return n.__r3f={type:"",root:null,previousAttach:null,memoizedProps:{},eventCount:0,handlers:{},objects:[],parent:null,...e},t}function YR(t,e){let n=t;if(e.includes("-")){const r=e.split("-"),i=r.pop();return n=r.reduce((s,a)=>s[a],t),{target:n,key:i}}else return{target:n,key:e}}const DH=/-\d+$/;function Qk(t,e,n){if(Rr.str(n)){if(DH.test(n)){const s=n.replace(DH,""),{target:a,key:o}=YR(t,s);Array.isArray(a[o])||(a[o]=[])}const{target:r,key:i}=YR(t,n);e.__r3f.previousAttach=r[i],r[i]=e}else e.__r3f.previousAttach=n(t,e)}function PH(t,e,n){var r,i;if(Rr.str(n)){const{target:s,key:a}=YR(t,n),o=e.__r3f.previousAttach;o===void 0?delete s[a]:s[a]=o}else(r=e.__r3f)==null||r.previousAttach==null||r.previousAttach(t,e);(i=e.__r3f)==null||delete i.previousAttach}function SX(t,{children:e,key:n,ref:r,...i},{children:s,key:a,ref:o,...l}={},u=!1){const c=t.__r3f,d=Object.entries(i),h=[];if(u){const f=Object.keys(l);for(let g=0;g<f.length;g++)i.hasOwnProperty(f[g])||d.unshift([f[g],wX+"remove"])}d.forEach(([f,g])=>{var y;if((y=t.__r3f)!=null&&y.primitive&&f==="object"||Rr.equ(g,l[f]))return;if(/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(f))return h.push([f,g,!0,[]]);let m=[];f.includes("-")&&(m=f.split("-")),h.push([f,g,!1,m]);for(const b in i){const w=i[b];b.startsWith(`${f}-`)&&h.push([b,w,!1,b.split("-")])}});const p={...i};return c!=null&&c.memoizedProps&&c!=null&&c.memoizedProps.args&&(p.args=c.memoizedProps.args),c!=null&&c.memoizedProps&&c!=null&&c.memoizedProps.attach&&(p.attach=c.memoizedProps.attach),{memoized:p,changes:h}}const eye=typeof process<"u"&&!1;function eN(t,e){var n;const r=t.__r3f,i=r==null?void 0:r.root,s=i==null||i.getState==null?void 0:i.getState(),{memoized:a,changes:o}=Yge(e)?e:SX(t,e),l=r==null?void 0:r.eventCount;t.__r3f&&(t.__r3f.memoizedProps=a);for(let h=0;h<o.length;h++){let[p,f,g,y]=o[h];if(Zk(t)){const _="srgb",S="srgb-linear";p==="encoding"?(p="colorSpace",f=f===3001?_:S):p==="outputEncoding"&&(p="outputColorSpace",f=f===3001?_:S)}let m=t,b=m[p];if(y.length&&(b=y.reduce((w,_)=>w[_],t),!(b&&b.set))){const[w,..._]=y.reverse();m=_.reverse().reduce((S,E)=>S[E],t),p=w}if(f===wX+"remove")if(m.constructor){let w=FH.get(m.constructor);w||(w=new m.constructor,FH.set(m.constructor,w)),f=w[p]}else f=0;if(g&&r)f?r.handlers[p]=f:delete r.handlers[p],r.eventCount=Object.keys(r.handlers).length;else if(b&&b.set&&(b.copy||b instanceof Ip)){if(Array.isArray(f))b.fromArray?b.fromArray(f):b.set(...f);else if(b.copy&&f&&f.constructor&&(eye?b.constructor.name===f.constructor.name:b.constructor===f.constructor))b.copy(f);else if(f!==void 0){var u;const w=(u=b)==null?void 0:u.isColor;!w&&b.setScalar?b.setScalar(f):b instanceof Ip&&f instanceof Ip?b.mask=f.mask:b.set(f),!yX()&&s&&!s.linear&&w&&b.convertSRGBToLinear()}}else{var c;if(m[p]=f,(c=m[p])!=null&&c.isTexture&&m[p].format===ui&&m[p].type===la&&s){const w=m[p];Zk(w)&&Zk(s.gl)?w.colorSpace=s.gl.outputColorSpace:w.encoding=s.gl.outputEncoding}}Wg(t)}if(r&&r.parent&&t.raycast&&l!==r.eventCount){const h=JA(t).getState().internal,p=h.interaction.indexOf(t);p>-1&&h.interaction.splice(p,1),r.eventCount&&h.interaction.push(t)}return!(o.length===1&&o[0][0]==="onUpdate")&&o.length&&(n=t.__r3f)!=null&&n.parent&&ZR(t),t}function Wg(t){var e,n;const r=(e=t.__r3f)==null||(n=e.root)==null||n.getState==null?void 0:n.getState();r&&r.internal.frames===0&&r.invalidate()}function ZR(t){t.onUpdate==null||t.onUpdate(t)}function AX(t,e){t.manual||(vX(t)?(t.left=e.width/-2,t.right=e.width/2,t.top=e.height/2,t.bottom=e.height/-2):t.aspect=e.width/e.height,t.updateProjectionMatrix(),t.updateMatrixWorld())}function lA(t){return(t.eventObject||t.object).uuid+"/"+t.index+t.instanceId}function tye(){var t;const e=typeof self<"u"&&self||typeof window<"u"&&window;if(!e)return ly.DefaultEventPriority;switch((t=e.event)==null?void 0:t.type){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return ly.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return ly.ContinuousEventPriority;default:return ly.DefaultEventPriority}}function EX(t,e,n,r){const i=n.get(e);i&&(n.delete(e),n.size===0&&(t.delete(r),i.target.releasePointerCapture(r)))}function nye(t,e){const{internal:n}=t.getState();n.interaction=n.interaction.filter(r=>r!==e),n.initialHits=n.initialHits.filter(r=>r!==e),n.hovered.forEach((r,i)=>{(r.eventObject===e||r.object===e)&&n.hovered.delete(i)}),n.capturedMap.forEach((r,i)=>{EX(n.capturedMap,e,r,i)})}function rye(t){function e(l){const{internal:u}=t.getState(),c=l.offsetX-u.initialClick[0],d=l.offsetY-u.initialClick[1];return Math.round(Math.sqrt(c*c+d*d))}function n(l){return l.filter(u=>["Move","Over","Enter","Out","Leave"].some(c=>{var d;return(d=u.__r3f)==null?void 0:d.handlers["onPointer"+c]}))}function r(l,u){const c=t.getState(),d=new Set,h=[],p=u?u(c.internal.interaction):c.internal.interaction;for(let m=0;m<p.length;m++){const b=Cx(p[m]);b&&(b.raycaster.camera=void 0)}c.previousRoot||c.events.compute==null||c.events.compute(l,c);function f(m){const b=Cx(m);if(!b||!b.events.enabled||b.raycaster.camera===null)return[];if(b.raycaster.camera===void 0){var w;b.events.compute==null||b.events.compute(l,b,(w=b.previousRoot)==null?void 0:w.getState()),b.raycaster.camera===void 0&&(b.raycaster.camera=null)}return b.raycaster.camera?b.raycaster.intersectObject(m,!0):[]}let g=p.flatMap(f).sort((m,b)=>{const w=Cx(m.object),_=Cx(b.object);return!w||!_?m.distance-b.distance:_.events.priority-w.events.priority||m.distance-b.distance}).filter(m=>{const b=lA(m);return d.has(b)?!1:(d.add(b),!0)});c.events.filter&&(g=c.events.filter(g,c));for(const m of g){let b=m.object;for(;b;){var y;(y=b.__r3f)!=null&&y.eventCount&&h.push({...m,eventObject:b}),b=b.parent}}if("pointerId"in l&&c.internal.capturedMap.has(l.pointerId))for(let m of c.internal.capturedMap.get(l.pointerId).values())d.has(lA(m.intersection))||h.push(m.intersection);return h}function i(l,u,c,d){const h=t.getState();if(l.length){const p={stopped:!1};for(const f of l){const g=Cx(f.object)||h,{raycaster:y,pointer:m,camera:b,internal:w}=g,_=new Z(m.x,m.y,0).unproject(b),S=k=>{var R,N;return(R=(N=w.capturedMap.get(k))==null?void 0:N.has(f.eventObject))!=null?R:!1},E=k=>{const R={intersection:f,target:u.target};w.capturedMap.has(k)?w.capturedMap.get(k).set(f.eventObject,R):w.capturedMap.set(k,new Map([[f.eventObject,R]])),u.target.setPointerCapture(k)},C=k=>{const R=w.capturedMap.get(k);R&&EX(w.capturedMap,f.eventObject,R,k)};let T={};for(let k in u){let R=u[k];typeof R!="function"&&(T[k]=R)}let M={...f,...T,pointer:m,intersections:l,stopped:p.stopped,delta:c,unprojectedPoint:_,ray:y.ray,camera:b,stopPropagation(){const k="pointerId"in u&&w.capturedMap.get(u.pointerId);if((!k||k.has(f.eventObject))&&(M.stopped=p.stopped=!0,w.hovered.size&&Array.from(w.hovered.values()).find(R=>R.eventObject===f.eventObject))){const R=l.slice(0,l.indexOf(f));s([...R,f])}},target:{hasPointerCapture:S,setPointerCapture:E,releasePointerCapture:C},currentTarget:{hasPointerCapture:S,setPointerCapture:E,releasePointerCapture:C},nativeEvent:u};if(d(M),p.stopped===!0)break}}return l}function s(l){const{internal:u}=t.getState();for(const c of u.hovered.values())if(!l.length||!l.find(d=>d.object===c.object&&d.index===c.index&&d.instanceId===c.instanceId)){const h=c.eventObject.__r3f,p=h==null?void 0:h.handlers;if(u.hovered.delete(lA(c)),h!=null&&h.eventCount){const f={...c,intersections:l};p.onPointerOut==null||p.onPointerOut(f),p.onPointerLeave==null||p.onPointerLeave(f)}}}function a(l,u){for(let c=0;c<u.length;c++){const d=u[c].__r3f;d==null||d.handlers.onPointerMissed==null||d.handlers.onPointerMissed(l)}}function o(l){switch(l){case"onPointerLeave":case"onPointerCancel":return()=>s([]);case"onLostPointerCapture":return u=>{const{internal:c}=t.getState();"pointerId"in u&&c.capturedMap.has(u.pointerId)&&requestAnimationFrame(()=>{c.capturedMap.has(u.pointerId)&&(c.capturedMap.delete(u.pointerId),s([]))})}}return function(c){const{onPointerMissed:d,internal:h}=t.getState();h.lastEvent.current=c;const p=l==="onPointerMove",f=l==="onClick"||l==="onContextMenu"||l==="onDoubleClick",y=r(c,p?n:void 0),m=f?e(c):0;l==="onPointerDown"&&(h.initialClick=[c.offsetX,c.offsetY],h.initialHits=y.map(w=>w.eventObject)),f&&!y.length&&m<=2&&(a(c,h.interaction),d&&d(c)),p&&s(y);function b(w){const _=w.eventObject,S=_.__r3f,E=S==null?void 0:S.handlers;if(S!=null&&S.eventCount)if(p){if(E.onPointerOver||E.onPointerEnter||E.onPointerOut||E.onPointerLeave){const C=lA(w),T=h.hovered.get(C);T?T.stopped&&w.stopPropagation():(h.hovered.set(C,w),E.onPointerOver==null||E.onPointerOver(w),E.onPointerEnter==null||E.onPointerEnter(w))}E.onPointerMove==null||E.onPointerMove(w)}else{const C=E[l];C?(!f||h.initialHits.includes(_))&&(a(c,h.interaction.filter(T=>!h.initialHits.includes(T))),C(w)):f&&h.initialHits.includes(_)&&a(c,h.interaction.filter(T=>!h.initialHits.includes(T)))}}i(y,c,m,b)}}return{handlePointer:o}}const iye=["set","get","setSize","setFrameloop","setDpr","events","invalidate","advance","size","viewport"],IX=t=>!!(t!=null&&t.render),d3=ne.createContext(null),sye=(t,e)=>{const n=dX((o,l)=>{const u=new Z,c=new Z,d=new Z;function h(m=l().camera,b=c,w=l().size){const{width:_,height:S,top:E,left:C}=w,T=_/S;b.isVector3?d.copy(b):d.set(...b);const M=m.getWorldPosition(u).distanceTo(d);if(vX(m))return{width:_/m.zoom,height:S/m.zoom,top:E,left:C,factor:1,distance:M,aspect:T};{const k=m.fov*Math.PI/180,R=2*Math.tan(k/2)*M,N=R*(_/S);return{width:N,height:R,top:E,left:C,factor:_/N,distance:M,aspect:T}}}let p;const f=m=>o(b=>({performance:{...b.performance,current:m}})),g=new Qe;return{set:o,get:l,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},xr:null,scene:null,invalidate:(m=1)=>t(l(),m),advance:(m,b)=>e(m,b,l()),legacy:!1,linear:!1,flat:!1,controls:null,clock:new t3,pointer:g,mouse:g,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:()=>{const m=l();p&&clearTimeout(p),m.performance.current!==m.performance.min&&f(m.performance.min),p=setTimeout(()=>f(l().performance.max),m.performance.debounce)}},size:{width:0,height:0,top:0,left:0,updateStyle:!1},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:h},setEvents:m=>o(b=>({...b,events:{...b.events,...m}})),setSize:(m,b,w,_,S)=>{const E=l().camera,C={width:m,height:b,top:_||0,left:S||0,updateStyle:w};o(T=>({size:C,viewport:{...T.viewport,...h(E,c,C)}}))},setDpr:m=>o(b=>{const w=_X(m);return{viewport:{...b.viewport,dpr:w,initialDpr:b.viewport.initialDpr||w}}}),setFrameloop:(m="always")=>{const b=l().clock;b.stop(),b.elapsedTime=0,m!=="never"&&(b.start(),b.elapsedTime=0),o(()=>({frameloop:m}))},previousRoot:void 0,internal:{active:!1,priority:0,frames:0,lastEvent:ne.createRef(),interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,subscribe:(m,b,w)=>{const _=l().internal;return _.priority=_.priority+(b>0?1:0),_.subscribers.push({ref:m,priority:b,store:w}),_.subscribers=_.subscribers.sort((S,E)=>S.priority-E.priority),()=>{const S=l().internal;S!=null&&S.subscribers&&(S.priority=S.priority-(b>0?1:0),S.subscribers=S.subscribers.filter(E=>E.ref!==m))}}}}}),r=n.getState();let i=r.size,s=r.viewport.dpr,a=r.camera;return n.subscribe(()=>{const{camera:o,size:l,viewport:u,gl:c,set:d}=n.getState();if(l.width!==i.width||l.height!==i.height||u.dpr!==s){var h;i=l,s=u.dpr,AX(o,l),c.setPixelRatio(u.dpr);const p=(h=l.updateStyle)!=null?h:typeof HTMLCanvasElement<"u"&&c.domElement instanceof HTMLCanvasElement;c.setSize(l.width,l.height,p)}o!==a&&(a=o,d(p=>({viewport:{...p.viewport,...p.viewport.getCurrentViewport(o)}})))}),n.subscribe(o=>t(o)),n};let uA,aye=new Set,oye=new Set,lye=new Set;function tN(t,e){if(t.size)for(const{callback:n}of t.values())n(e)}function Mx(t,e){switch(t){case"before":return tN(aye,e);case"after":return tN(oye,e);case"tail":return tN(lye,e)}}let nN,rN;function iN(t,e,n){let r=e.clock.getDelta();for(e.frameloop==="never"&&typeof t=="number"&&(r=t-e.clock.elapsedTime,e.clock.oldTime=e.clock.elapsedTime,e.clock.elapsedTime=t),nN=e.internal.subscribers,uA=0;uA<nN.length;uA++)rN=nN[uA],rN.ref.current(rN.store.getState(),r,n);return!e.internal.priority&&e.gl.render&&e.gl.render(e.scene,e.camera),e.internal.frames=Math.max(0,e.internal.frames-1),e.frameloop==="always"?1:e.internal.frames}function uye(t){let e=!1,n=!1,r,i,s;function a(u){i=requestAnimationFrame(a),e=!0,r=0,Mx("before",u),n=!0;for(const d of t.values()){var c;s=d.store.getState(),s.internal.active&&(s.frameloop==="always"||s.internal.frames>0)&&!((c=s.gl.xr)!=null&&c.isPresenting)&&(r+=iN(u,s))}if(n=!1,Mx("after",u),r===0)return Mx("tail",u),e=!1,cancelAnimationFrame(i)}function o(u,c=1){var d;if(!u)return t.forEach(h=>o(h.store.getState(),c));(d=u.gl.xr)!=null&&d.isPresenting||!u.internal.active||u.frameloop==="never"||(c>1?u.internal.frames=Math.min(60,u.internal.frames+c):n?u.internal.frames=2:u.internal.frames=1,e||(e=!0,requestAnimationFrame(a)))}function l(u,c=!0,d,h){if(c&&Mx("before",u),d)iN(u,d,h);else for(const p of t.values())iN(u,p.store.getState());c&&Mx("after",u)}return{loop:a,invalidate:o,advance:l}}function h3(){const t=ne.useContext(d3);if(!t)throw new Error("R3F: Hooks can only be used within the Canvas component!");return t}function gs(t=n=>n,e){return h3()(t,e)}function y0(t,e=0){const n=h3(),r=n.getState().internal.subscribe,i=xX(t);return ew(()=>r(i,e,n),[e,r,n]),null}const LH=new WeakMap;function TX(t,e){return function(n,...r){let i=LH.get(n);return i||(i=new n,LH.set(n,i)),t&&t(i),Promise.all(r.map(s=>new Promise((a,o)=>i.load(s,l=>{l.scene&&Object.assign(l,Zge(l.scene)),a(l)},e,l=>o(new Error(`Could not load ${s}: ${l==null?void 0:l.message}`))))))}}function uc(t,e,n,r){const i=Array.isArray(e)?e:[e],s=$ge(TX(n,r),[t,...i],{equal:Rr.equ});return Array.isArray(e)?s:s[0]}uc.preload=function(t,e,n){const r=Array.isArray(e)?e:[e];return zge(TX(n),[t,...r])};uc.clear=function(t,e){const n=Array.isArray(e)?e:[e];return Gge([t,...n])};const Hy=new Map,{invalidate:OH,advance:BH}=uye(Hy),{reconciler:c1,applyProps:Yc}=Kge(Hy,tye),Lg={objects:"shallow",strict:!1},cye=(t,e)=>{const n=typeof t=="function"?t(e):t;return IX(n)?n:new l3({powerPreference:"high-performance",canvas:e,antialias:!0,alpha:!0,...t})};function dye(t,e){const n=typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement;if(e){const{width:r,height:i,top:s,left:a,updateStyle:o=n}=e;return{width:r,height:i,top:s,left:a,updateStyle:o}}else if(typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement&&t.parentElement){const{width:r,height:i,top:s,left:a}=t.parentElement.getBoundingClientRect();return{width:r,height:i,top:s,left:a,updateStyle:n}}else if(typeof OffscreenCanvas<"u"&&t instanceof OffscreenCanvas)return{width:t.width,height:t.height,top:0,left:0,updateStyle:n};return{width:0,height:0,top:0,left:0}}function hye(t){const e=Hy.get(t),n=e==null?void 0:e.fiber,r=e==null?void 0:e.store;e&&console.warn("R3F.createRoot should only be called once!");const i=typeof reportError=="function"?reportError:console.error,s=r||sye(OH,BH),a=n||c1.createContainer(s,ly.ConcurrentRoot,null,!1,null,"",i,null);e||Hy.set(t,{fiber:a,store:s});let o,l=!1,u;return{configure(c={}){let{gl:d,size:h,scene:p,events:f,onCreated:g,shadows:y=!1,linear:m=!1,flat:b=!1,legacy:w=!1,orthographic:_=!1,frameloop:S="always",dpr:E=[1,2],performance:C,raycaster:T,camera:M,onPointerMissed:k}=c,R=s.getState(),N=R.gl;R.gl||R.set({gl:N=cye(d,t)});let B=R.raycaster;B||R.set({raycaster:B=new s3});const{params:z,...V}=T||{};if(Rr.equ(V,B,Lg)||Yc(B,{...V}),Rr.equ(z,B.params,Lg)||Yc(B,{params:{...B.params,...z}}),!R.camera||R.camera===u&&!Rr.equ(u,M,Lg)){u=M;const X=M instanceof W1,te=X?M:_?new iu(0,0,0,0,.1,1e3):new Qr(75,0,.1,1e3);X||(te.position.z=5,M&&(Yc(te,M),("aspect"in M||"left"in M||"right"in M||"bottom"in M||"top"in M)&&(te.manual=!0,te.updateProjectionMatrix())),!R.camera&&!(M!=null&&M.rotation)&&te.lookAt(0,0,0)),R.set({camera:te}),B.camera=te}if(!R.scene){let X;p!=null&&p.isScene?X=p:(X=new oc,p&&Yc(X,p)),R.set({scene:Hg(X)})}if(!R.xr){var K;const X=(ge,ie)=>{const we=s.getState();we.frameloop!=="never"&&BH(ge,!0,we,ie)},te=()=>{const ge=s.getState();ge.gl.xr.enabled=ge.gl.xr.isPresenting,ge.gl.xr.setAnimationLoop(ge.gl.xr.isPresenting?X:null),ge.gl.xr.isPresenting||OH(ge)},le={connect(){const ge=s.getState().gl;ge.xr.addEventListener("sessionstart",te),ge.xr.addEventListener("sessionend",te)},disconnect(){const ge=s.getState().gl;ge.xr.removeEventListener("sessionstart",te),ge.xr.removeEventListener("sessionend",te)}};typeof((K=N.xr)==null?void 0:K.addEventListener)=="function"&&le.connect(),R.set({xr:le})}if(N.shadowMap){const X=N.shadowMap.enabled,te=N.shadowMap.type;if(N.shadowMap.enabled=!!y,Rr.boo(y))N.shadowMap.type=vb;else if(Rr.str(y)){var Q;const le={basic:Sj,percentage:wT,soft:vb,variance:ul};N.shadowMap.type=(Q=le[y])!=null?Q:vb}else Rr.obj(y)&&Object.assign(N.shadowMap,y);(X!==N.shadowMap.enabled||te!==N.shadowMap.type)&&(N.shadowMap.needsUpdate=!0)}const O=yX();O&&("enabled"in O?O.enabled=!w:"legacyMode"in O&&(O.legacyMode=w)),l||Yc(N,{outputEncoding:m?3e3:3001,toneMapping:b?ru:gP}),R.legacy!==w&&R.set(()=>({legacy:w})),R.linear!==m&&R.set(()=>({linear:m})),R.flat!==b&&R.set(()=>({flat:b})),d&&!Rr.fun(d)&&!IX(d)&&!Rr.equ(d,N,Lg)&&Yc(N,d),f&&!R.events.handlers&&R.set({events:f(s)});const j=dye(t,h);return Rr.equ(j,R.size,Lg)||R.setSize(j.width,j.height,j.updateStyle,j.top,j.left),E&&R.viewport.dpr!==_X(E)&&R.setDpr(E),R.frameloop!==S&&R.setFrameloop(S),R.onPointerMissed||R.set({onPointerMissed:k}),C&&!Rr.equ(C,R.performance,Lg)&&R.set(X=>({performance:{...X.performance,...C}})),o=g,l=!0,this},render(c){return l||this.configure(),c1.updateContainer(D.jsx(pye,{store:s,children:c,onCreated:o,rootElement:t}),a,null,()=>{}),s},unmount(){CX(t)}}}function pye({store:t,children:e,onCreated:n,rootElement:r}){return ew(()=>{const i=t.getState();i.set(s=>({internal:{...s.internal,active:!0}})),n&&n(i),t.getState().events.connected||i.events.connect==null||i.events.connect(r)},[]),D.jsx(d3.Provider,{value:t,children:e})}function CX(t,e){const n=Hy.get(t),r=n==null?void 0:n.fiber;if(r){const i=n==null?void 0:n.store.getState();i&&(i.internal.active=!1),c1.updateContainer(null,r,null,()=>{i&&setTimeout(()=>{try{var s,a,o,l;i.events.disconnect==null||i.events.disconnect(),(s=i.gl)==null||(a=s.renderLists)==null||a.dispose==null||a.dispose(),(o=i.gl)==null||o.forceContextLoss==null||o.forceContextLoss(),(l=i.gl)!=null&&l.xr&&i.xr.disconnect(),Qge(i),Hy.delete(t)}catch{}},500)})}}function fye(t,e,n){return D.jsx(mye,{children:t,container:e,state:n},e.uuid)}function mye({state:t={},children:e,container:n}){const{events:r,size:i,...s}=t,a=h3(),[o]=ne.useState(()=>new s3),[l]=ne.useState(()=>new Qe),u=ne.useCallback((d,h)=>{const p={...d};Object.keys(d).forEach(g=>{(iye.includes(g)||d[g]!==h[g]&&h[g])&&delete p[g]});let f;if(h&&i){const g=h.camera;f=d.viewport.getCurrentViewport(g,new Z,i),g!==d.camera&&AX(g,i)}return{...p,scene:n,raycaster:o,pointer:l,mouse:l,previousRoot:a,events:{...d.events,...h==null?void 0:h.events,...r},size:{...d.size,...i},viewport:{...d.viewport,...f},...s}},[t]),[c]=ne.useState(()=>{const d=a.getState();return dX((p,f)=>({...d,scene:n,raycaster:o,pointer:l,mouse:l,previousRoot:a,events:{...d.events,...r},size:{...d.size,...i},...s,set:p,get:f,setEvents:g=>p(y=>({...y,events:{...y.events,...g}}))}))});return ne.useEffect(()=>{const d=a.subscribe(h=>c.setState(p=>u(h,p)));return()=>{d()}},[u]),ne.useEffect(()=>{c.setState(d=>u(a.getState(),d))},[u]),ne.useEffect(()=>()=>{c.destroy()},[]),D.jsx(D.Fragment,{children:c1.createPortal(D.jsx(d3.Provider,{value:c,children:e}),c,null)})}c1.injectIntoDevTools({bundleType:0,rendererPackageName:"@react-three/fiber",version:ne.version});const sN={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function gye(t){const{handlePointer:e}=rye(t);return{priority:1,enabled:!0,compute(n,r,i){r.pointer.set(n.offsetX/r.size.width*2-1,-(n.offsetY/r.size.height)*2+1),r.raycaster.setFromCamera(r.pointer,r.camera)},connected:void 0,handlers:Object.keys(sN).reduce((n,r)=>({...n,[r]:e(r)}),{}),update:()=>{var n;const{events:r,internal:i}=t.getState();(n=i.lastEvent)!=null&&n.current&&r.handlers&&r.handlers.onPointerMove(i.lastEvent.current)},connect:n=>{var r;const{set:i,events:s}=t.getState();s.disconnect==null||s.disconnect(),i(a=>({events:{...a.events,connected:n}})),Object.entries((r=s.handlers)!=null?r:[]).forEach(([a,o])=>{const[l,u]=sN[a];n.addEventListener(l,o,{passive:u})})},disconnect:()=>{const{set:n,events:r}=t.getState();if(r.connected){var i;Object.entries((i=r.handlers)!=null?i:[]).forEach(([s,a])=>{if(r&&r.connected instanceof HTMLElement){const[o]=sN[s];r.connected.removeEventListener(o,a)}}),n(s=>({events:{...s.events,connected:void 0}}))}}}}function UH(t,e){let n;return(...r)=>{window.clearTimeout(n),n=window.setTimeout(()=>t(...r),e)}}function yye({debounce:t,scroll:e,polyfill:n,offsetSize:r}={debounce:0,scroll:!1,offsetSize:!1}){const i=n||(typeof window>"u"?class{}:window.ResizeObserver);if(!i)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");const[s,a]=ne.useState({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),o=ne.useRef({element:null,scrollContainers:null,resizeObserver:null,lastBounds:s,orientationHandler:null}),l=t?typeof t=="number"?t:t.scroll:null,u=t?typeof t=="number"?t:t.resize:null,c=ne.useRef(!1);ne.useEffect(()=>(c.current=!0,()=>void(c.current=!1)));const[d,h,p]=ne.useMemo(()=>{const m=()=>{if(!o.current.element)return;const{left:b,top:w,width:_,height:S,bottom:E,right:C,x:T,y:M}=o.current.element.getBoundingClientRect(),k={left:b,top:w,width:_,height:S,bottom:E,right:C,x:T,y:M};o.current.element instanceof HTMLElement&&r&&(k.height=o.current.element.offsetHeight,k.width=o.current.element.offsetWidth),Object.freeze(k),c.current&&!wye(o.current.lastBounds,k)&&a(o.current.lastBounds=k)};return[m,u?UH(m,u):m,l?UH(m,l):m]},[a,r,l,u]);function f(){o.current.scrollContainers&&(o.current.scrollContainers.forEach(m=>m.removeEventListener("scroll",p,!0)),o.current.scrollContainers=null),o.current.resizeObserver&&(o.current.resizeObserver.disconnect(),o.current.resizeObserver=null),o.current.orientationHandler&&("orientation"in screen&&"removeEventListener"in screen.orientation?screen.orientation.removeEventListener("change",o.current.orientationHandler):"onorientationchange"in window&&window.removeEventListener("orientationchange",o.current.orientationHandler))}function g(){o.current.element&&(o.current.resizeObserver=new i(p),o.current.resizeObserver.observe(o.current.element),e&&o.current.scrollContainers&&o.current.scrollContainers.forEach(m=>m.addEventListener("scroll",p,{capture:!0,passive:!0})),o.current.orientationHandler=()=>{p()},"orientation"in screen&&"addEventListener"in screen.orientation?screen.orientation.addEventListener("change",o.current.orientationHandler):"onorientationchange"in window&&window.addEventListener("orientationchange",o.current.orientationHandler))}const y=m=>{!m||m===o.current.element||(f(),o.current.element=m,o.current.scrollContainers=MX(m),g())};return xye(p,!!e),vye(h),ne.useEffect(()=>{f(),g()},[e,p,h]),ne.useEffect(()=>f,[]),[y,s,d]}function vye(t){ne.useEffect(()=>{const e=t;return window.addEventListener("resize",e),()=>void window.removeEventListener("resize",e)},[t])}function xye(t,e){ne.useEffect(()=>{if(e){const n=t;return window.addEventListener("scroll",n,{capture:!0,passive:!0}),()=>void window.removeEventListener("scroll",n,!0)}},[t,e])}function MX(t){const e=[];if(!t||t===document.body)return e;const{overflow:n,overflowX:r,overflowY:i}=window.getComputedStyle(t);return[n,r,i].some(s=>s==="auto"||s==="scroll")&&e.push(t),[...e,...MX(t.parentElement)]}const bye=["x","y","top","bottom","left","right","width","height"],wye=(t,e)=>bye.every(n=>t[n]===e[n]);var _ye=Object.defineProperty,Sye=Object.defineProperties,Aye=Object.getOwnPropertyDescriptors,$H=Object.getOwnPropertySymbols,Eye=Object.prototype.hasOwnProperty,Iye=Object.prototype.propertyIsEnumerable,zH=(t,e,n)=>e in t?_ye(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,GH=(t,e)=>{for(var n in e||(e={}))Eye.call(e,n)&&zH(t,n,e[n]);if($H)for(var n of $H(e))Iye.call(e,n)&&zH(t,n,e[n]);return t},Tye=(t,e)=>Sye(t,Aye(e)),HH,WH;typeof window<"u"&&((HH=window.document)!=null&&HH.createElement||((WH=window.navigator)==null?void 0:WH.product)==="ReactNative")?ne.useLayoutEffect:ne.useEffect;function kX(t,e,n){if(!t)return;if(n(t)===!0)return t;let r=t.child;for(;r;){const i=kX(r,e,n);if(i)return i;r=r.sibling}}function NX(t){try{return Object.defineProperties(t,{_currentRenderer:{get(){return null},set(){}},_currentRenderer2:{get(){return null},set(){}}})}catch{return t}}const VH=console.error;console.error=function(){const t=[...arguments].join("");if(t!=null&&t.startsWith("Warning:")&&t.includes("useContext")){console.error=VH;return}return VH.apply(this,arguments)};const p3=NX(ne.createContext(null));class RX extends ne.Component{render(){return ne.createElement(p3.Provider,{value:this._reactInternals},this.props.children)}}function Cye(){const t=ne.useContext(p3);if(t===null)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");const e=ne.useId();return ne.useMemo(()=>{for(const r of[t,t==null?void 0:t.alternate]){if(!r)continue;const i=kX(r,!1,s=>{let a=s.memoizedState;for(;a;){if(a.memoizedState===e)return!0;a=a.next}});if(i)return i}},[t,e])}function Mye(){const t=Cye(),[e]=ne.useState(()=>new Map);e.clear();let n=t;for(;n;){if(n.type&&typeof n.type=="object"){const i=n.type._context===void 0&&n.type.Provider===n.type?n.type:n.type._context;i&&i!==p3&&!e.has(i)&&e.set(i,ne.useContext(NX(i)))}n=n.return}return e}function kye(){const t=Mye();return ne.useMemo(()=>Array.from(t.keys()).reduce((e,n)=>r=>ne.createElement(e,null,ne.createElement(n.Provider,Tye(GH({},r),{value:t.get(n)}))),e=>ne.createElement(RX,GH({},e))),[t])}const Nye=ne.forwardRef(function({children:e,fallback:n,resize:r,style:i,gl:s,events:a=gye,eventSource:o,eventPrefix:l,shadows:u,linear:c,flat:d,legacy:h,orthographic:p,frameloop:f,dpr:g,performance:y,raycaster:m,camera:b,scene:w,onPointerMissed:_,onCreated:S,...E},C){ne.useMemo(()=>c3(Lge),[]);const T=kye(),[M,k]=yye({scroll:!0,debounce:{scroll:50,resize:0},...r}),R=ne.useRef(null),N=ne.useRef(null);ne.useImperativeHandle(C,()=>R.current);const B=xX(_),[z,V]=ne.useState(!1),[K,Q]=ne.useState(!1);if(z)throw z;if(K)throw K;const O=ne.useRef(null);ew(()=>{const X=R.current;k.width>0&&k.height>0&&X&&(O.current||(O.current=hye(X)),O.current.configure({gl:s,events:a,shadows:u,linear:c,flat:d,legacy:h,orthographic:p,frameloop:f,dpr:g,performance:y,raycaster:m,camera:b,scene:w,size:k,onPointerMissed:(...te)=>B.current==null?void 0:B.current(...te),onCreated:te=>{te.events.connect==null||te.events.connect(o?qge(o)?o.current:o:N.current),l&&te.setEvents({compute:(le,ge)=>{const ie=le[l+"X"],we=le[l+"Y"];ge.pointer.set(ie/ge.size.width*2-1,-(we/ge.size.height)*2+1),ge.raycaster.setFromCamera(ge.pointer,ge.camera)}}),S==null||S(te)}}),O.current.render(D.jsx(T,{children:D.jsx(bX,{set:Q,children:D.jsx(ne.Suspense,{fallback:D.jsx(Jge,{set:V}),children:e??null})})})))}),ne.useEffect(()=>{const X=R.current;if(X)return()=>CX(X)},[]);const j=o?"none":"auto";return D.jsx("div",{ref:N,style:{position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:j,...i},...E,children:D.jsx("div",{ref:M,style:{width:"100%",height:"100%"},children:D.jsx("canvas",{ref:R,style:{display:"block"},children:n})})})}),Rye=ne.forwardRef(function(e,n){return D.jsx(RX,{children:D.jsx(Nye,{...e,ref:n})})});function Wy(){return Wy=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)({}).hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},Wy.apply(null,arguments)}function Tb(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function QR(t,e){(e==null||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}function Fye(t,e){if(t){if(typeof t=="string")return QR(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);if(n==="Object"&&t.constructor&&(n=t.constructor.name),n==="Map"||n==="Set")return Array.from(t);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return QR(t,e)}}function Dye(t){if(Array.isArray(t))return QR(t)}function Pye(t){if(typeof Symbol<"u"&&t[Symbol.iterator]!=null||t["@@iterator"]!=null)return Array.from(t)}function Lye(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function Oye(t){return Dye(t)||Pye(t)||Fye(t)||Lye()}new Qe;new Qe;function Bye(t,e,n){return Math.max(e,Math.min(n,t))}function Uye(t,e){return Bye(t-Math.floor(t/e)*e,0,e)}function $ye(t,e){var n=Uye(e-t,Math.PI*2);return n>Math.PI&&(n-=Math.PI*2),n}function FX(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var Io=function t(e,n,r){var i=this;FX(this,t),Tb(this,"dot2",function(s,a){return i.x*s+i.y*a}),Tb(this,"dot3",function(s,a,o){return i.x*s+i.y*a+i.z*o}),this.x=e,this.y=n,this.z=r},zye=[new Io(1,1,0),new Io(-1,1,0),new Io(1,-1,0),new Io(-1,-1,0),new Io(1,0,1),new Io(-1,0,1),new Io(1,0,-1),new Io(-1,0,-1),new Io(0,1,1),new Io(0,-1,1),new Io(0,1,-1),new Io(0,-1,-1)],jH=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],XH=new Array(512),KH=new Array(512),Gye=function(e){e>0&&e<1&&(e*=65536),e=Math.floor(e),e<256&&(e|=e<<8);for(var n=0;n<256;n++){var r;n&1?r=jH[n]^e&255:r=jH[n]^e>>8&255,XH[n]=XH[n+256]=r,KH[n]=KH[n+256]=zye[r%12]}};Gye(0);function Hye(t){if(typeof t=="number")t=Math.abs(t);else if(typeof t=="string"){var e=t;t=0;for(var n=0;n<e.length;n++)t=(t+(n+1)*(e.charCodeAt(n)%96))%2147483647}return t===0&&(t=311),t}function qH(t){var e=Hye(t);return function(){var n=e*48271%2147483647;return e=n,n/2147483647}}var Wye=function t(e){var n=this;FX(this,t),Tb(this,"seed",0),Tb(this,"init",function(r){n.seed=r,n.value=qH(r)}),Tb(this,"value",qH(this.seed)),this.init(e)};new Wye(Math.random());var Vye=function(e){var n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:.01,r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:1,i=arguments.length>3&&arguments[3]!==void 0?arguments[3]:1/(2*Math.PI);return r/Math.atan(1/n)*Math.atan(Math.sin(2*Math.PI*e*i)/n)},DX=function(e){return 1/(1+e+.48*e*e+.235*e*e*e)},jye=function(e){return e},Xye={in:function(e){return 1-Math.cos(e*Math.PI/2)},out:function(e){return Math.sin(e*Math.PI/2)},inOut:function(e){return-(Math.cos(Math.PI*e)-1)/2}},Kye={in:function(e){return e*e*e},out:function(e){return 1-Math.pow(1-e,3)},inOut:function(e){return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}},qye={in:function(e){return e*e*e*e*e},out:function(e){return 1-Math.pow(1-e,5)},inOut:function(e){return e<.5?16*e*e*e*e*e:1-Math.pow(-2*e+2,5)/2}},Jye={in:function(e){return 1-Math.sqrt(1-Math.pow(e,2))},out:function(e){return Math.sqrt(1-Math.pow(e-1,2))},inOut:function(e){return e<.5?(1-Math.sqrt(1-Math.pow(2*e,2)))/2:(Math.sqrt(1-Math.pow(-2*e+2,2))+1)/2}},Yye={in:function(e){return e*e*e*e},out:function(e){return 1- --e*e*e*e},inOut:function(e){return e<.5?8*e*e*e*e:1-8*--e*e*e*e}},Zye={in:function(e){return e===0?0:Math.pow(2,10*e-10)},out:function(e){return e===1?1:1-Math.pow(2,-10*e)},inOut:function(e){return e===0?0:e===1?1:e<.5?Math.pow(2,20*e-10)/2:(2-Math.pow(2,-20*e+10))/2}};function Vi(t,e,n){var r=arguments.length>3&&arguments[3]!==void 0?arguments[3]:.25,i=arguments.length>4&&arguments[4]!==void 0?arguments[4]:.01,s=arguments.length>5&&arguments[5]!==void 0?arguments[5]:1/0,a=arguments.length>6&&arguments[6]!==void 0?arguments[6]:DX,o=arguments.length>7&&arguments[7]!==void 0?arguments[7]:.001,l="velocity_"+e;if(t.__damp===void 0&&(t.__damp={}),t.__damp[l]===void 0&&(t.__damp[l]=0),Math.abs(t[e]-n)<=o)return t[e]=n,!1;r=Math.max(1e-4,r);var u=2/r,c=a(u*i),d=t[e]-n,h=n,p=s*r;d=Math.min(Math.max(d,-p),p),n=t[e]-d;var f=(t.__damp[l]+u*d)*i;t.__damp[l]=(t.__damp[l]-u*f)*c;var g=n+(d+f)*c;return h-t[e]>0==g>h&&(g=h,t.__damp[l]=(g-h)/i),t[e]=g,!0}var Qye=function(e){return e&&e.isCamera},e0e=function(e){return e&&e.isLight},kx=new Z,JH=new Kr,YH=new Kr,Nx=new ln,aN=new Z;function t0e(t,e,n,r,i,s,a){typeof e=="number"?kx.setScalar(e):Array.isArray(e)?kx.set(e[0],e[1],e[2]):kx.copy(e);var o=t.parent;t.updateWorldMatrix(!0,!1),aN.setFromMatrixPosition(t.matrixWorld),Qye(t)||e0e(t)?Nx.lookAt(aN,kx,t.up):Nx.lookAt(kx,aN,t.up),_I(t.quaternion,YH.setFromRotationMatrix(Nx),n,r,i,s,a),o&&(Nx.extractRotation(o.matrixWorld),JH.setFromRotationMatrix(Nx),_I(t.quaternion,YH.copy(t.quaternion).premultiply(JH.invert()),n,r,i,s,a))}function vy(t,e,n,r,i,s,a,o){return Vi(t,e,t[e]+$ye(t[e],n),r,i,s,a,o)}var Rx=new Qe,ZH,QH;function n0e(t,e,n,r,i,s,a){return typeof e=="number"?Rx.setScalar(e):Array.isArray(e)?Rx.set(e[0],e[1]):Rx.copy(e),ZH=Vi(t,"x",Rx.x,n,r,i,s,a),QH=Vi(t,"y",Rx.y,n,r,i,s,a),ZH||QH}var Og=new Z,eW,tW,nW;function eF(t,e,n,r,i,s,a){return typeof e=="number"?Og.setScalar(e):Array.isArray(e)?Og.set(e[0],e[1],e[2]):Og.copy(e),eW=Vi(t,"x",Og.x,n,r,i,s,a),tW=Vi(t,"y",Og.y,n,r,i,s,a),nW=Vi(t,"z",Og.z,n,r,i,s,a),eW||tW||nW}var zh=new Xn,rW,iW,sW,aW;function r0e(t,e,n,r,i,s,a){return typeof e=="number"?zh.setScalar(e):Array.isArray(e)?zh.set(e[0],e[1],e[2],e[3]):zh.copy(e),rW=Vi(t,"x",zh.x,n,r,i,s,a),iW=Vi(t,"y",zh.y,n,r,i,s,a),sW=Vi(t,"z",zh.z,n,r,i,s,a),aW=Vi(t,"w",zh.w,n,r,i,s,a),rW||iW||sW||aW}var Fx=new Ba,oW,lW,uW;function i0e(t,e,n,r,i,s,a){return Array.isArray(e)?Fx.set(e[0],e[1],e[2],e[3]):Fx.copy(e),oW=vy(t,"x",Fx.x,n,r,i,s,a),lW=vy(t,"y",Fx.y,n,r,i,s,a),uW=vy(t,"z",Fx.z,n,r,i,s,a),oW||lW||uW}var Bg=new Ct,cW,dW,hW;function s0e(t,e,n,r,i,s,a){return e instanceof Ct?Bg.copy(e):Array.isArray(e)?Bg.setRGB(e[0],e[1],e[2]):Bg.set(e),cW=Vi(t,"r",Bg.r,n,r,i,s,a),dW=Vi(t,"g",Bg.g,n,r,i,s,a),hW=Vi(t,"b",Bg.b,n,r,i,s,a),cW||dW||hW}var rl=new Kr,Du=new Xn,pW=new Xn,Dx=new Xn,fW,mW,gW,yW;function _I(t,e,n,r,i,s,a){var o=t;Array.isArray(e)?rl.set(e[0],e[1],e[2],e[3]):rl.copy(e);var l=t.dot(rl)>0?1:-1;return rl.x*=l,rl.y*=l,rl.z*=l,rl.w*=l,fW=Vi(t,"x",rl.x,n,r,i,s,a),mW=Vi(t,"y",rl.y,n,r,i,s,a),gW=Vi(t,"z",rl.z,n,r,i,s,a),yW=Vi(t,"w",rl.w,n,r,i,s,a),Du.set(t.x,t.y,t.z,t.w).normalize(),pW.set(o.__damp.velocity_x,o.__damp.velocity_y,o.__damp.velocity_z,o.__damp.velocity_w),Dx.copy(Du).multiplyScalar(pW.dot(Du)/Du.dot(Du)),o.__damp.velocity_x-=Dx.x,o.__damp.velocity_y-=Dx.y,o.__damp.velocity_z-=Dx.z,o.__damp.velocity_w-=Dx.w,t.set(Du.x,Du.y,Du.z,Du.w),fW||mW||gW||yW}var Px=new wI,vW,xW,bW;function a0e(t,e,n,r,i,s,a){return Array.isArray(e)?Px.set(e[0],e[1],e[2]):Px.copy(e),vW=Vi(t,"radius",Px.radius,n,r,i,s,a),xW=vy(t,"phi",Px.phi,n,r,i,s,a),bW=vy(t,"theta",Px.theta,n,r,i,s,a),vW||xW||bW}var cA=new ln,wW=new Z,_W=new Kr,SW=new Z,AW,EW,IW;function o0e(t,e,n,r,i,s,a){var o=t;return o.__damp===void 0&&(o.__damp={position:new Z,rotation:new Kr,scale:new Z},t.decompose(o.__damp.position,o.__damp.rotation,o.__damp.scale)),Array.isArray(e)?cA.set.apply(cA,Oye(e)):cA.copy(e),cA.decompose(wW,_W,SW),AW=eF(o.__damp.position,wW,n,r,i,s,a),EW=_I(o.__damp.rotation,_W,n,r,i,s,a),IW=eF(o.__damp.scale,SW,n,r,i,s,a),t.compose(o.__damp.position,o.__damp.rotation,o.__damp.scale),AW||EW||IW}var SI=Object.freeze({__proto__:null,rsqw:Vye,exp:DX,linear:jye,sine:Xye,cubic:Kye,quint:qye,circ:Jye,quart:Yye,expo:Zye,damp:Vi,dampLookAt:t0e,dampAngle:vy,damp2:n0e,damp3:eF,damp4:r0e,dampE:i0e,dampC:s0e,dampQ:_I,dampS:a0e,dampM:o0e});const f3=parseInt(vf.replace(/\D+/g,""));function TW(t,e){if(e===e9)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),t;if(e===gI||e===SP){let n=t.getIndex();if(n===null){const a=[],o=t.getAttribute("position");if(o!==void 0){for(let l=0;l<o.count;l++)a.push(l);t.setIndex(a),n=t.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t}const r=n.count-2,i=[];if(n)if(e===gI)for(let a=1;a<=r;a++)i.push(n.getX(0)),i.push(n.getX(a)),i.push(n.getX(a+1));else for(let a=0;a<r;a++)a%2===0?(i.push(n.getX(a)),i.push(n.getX(a+1)),i.push(n.getX(a+2))):(i.push(n.getX(a+2)),i.push(n.getX(a+1)),i.push(n.getX(a)));i.length/3!==r&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=t.clone();return s.setIndex(i),s.clearGroups(),s}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),t}var Po=Uint8Array,ld=Uint16Array,tF=Uint32Array,PX=new Po([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),LX=new Po([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),l0e=new Po([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),OX=function(t,e){for(var n=new ld(31),r=0;r<31;++r)n[r]=e+=1<<t[r-1];for(var i=new tF(n[30]),r=1;r<30;++r)for(var s=n[r];s<n[r+1];++s)i[s]=s-n[r]<<5|r;return[n,i]},BX=OX(PX,2),UX=BX[0],u0e=BX[1];UX[28]=258,u0e[258]=28;var c0e=OX(LX,0),d0e=c0e[0],nF=new ld(32768);for(var Lr=0;Lr<32768;++Lr){var $c=(Lr&43690)>>>1|(Lr&21845)<<1;$c=($c&52428)>>>2|($c&13107)<<2,$c=($c&61680)>>>4|($c&3855)<<4,nF[Lr]=(($c&65280)>>>8|($c&255)<<8)>>>1}var Cb=function(t,e,n){for(var r=t.length,i=0,s=new ld(e);i<r;++i)++s[t[i]-1];var a=new ld(e);for(i=0;i<e;++i)a[i]=a[i-1]+s[i-1]<<1;var o;if(n){o=new ld(1<<e);var l=15-e;for(i=0;i<r;++i)if(t[i])for(var u=i<<4|t[i],c=e-t[i],d=a[t[i]-1]++<<c,h=d|(1<<c)-1;d<=h;++d)o[nF[d]>>>l]=u}else for(o=new ld(r),i=0;i<r;++i)t[i]&&(o[i]=nF[a[t[i]-1]++]>>>15-t[i]);return o},tw=new Po(288);for(var Lr=0;Lr<144;++Lr)tw[Lr]=8;for(var Lr=144;Lr<256;++Lr)tw[Lr]=9;for(var Lr=256;Lr<280;++Lr)tw[Lr]=7;for(var Lr=280;Lr<288;++Lr)tw[Lr]=8;var $X=new Po(32);for(var Lr=0;Lr<32;++Lr)$X[Lr]=5;var h0e=Cb(tw,9,1),p0e=Cb($X,5,1),oN=function(t){for(var e=t[0],n=1;n<t.length;++n)t[n]>e&&(e=t[n]);return e},il=function(t,e,n){var r=e/8|0;return(t[r]|t[r+1]<<8)>>(e&7)&n},lN=function(t,e){var n=e/8|0;return(t[n]|t[n+1]<<8|t[n+2]<<16)>>(e&7)},f0e=function(t){return(t/8|0)+(t&7&&1)},m0e=function(t,e,n){(n==null||n>t.length)&&(n=t.length);var r=new(t instanceof ld?ld:t instanceof tF?tF:Po)(n-e);return r.set(t.subarray(e,n)),r},g0e=function(t,e,n){var r=t.length;if(!r||n&&!n.l&&r<5)return e||new Po(0);var i=!e||n,s=!n||n.i;n||(n={}),e||(e=new Po(r*3));var a=function(Ce){var Re=e.length;if(Ce>Re){var Le=new Po(Math.max(Re*2,Ce));Le.set(e),e=Le}},o=n.f||0,l=n.p||0,u=n.b||0,c=n.l,d=n.d,h=n.m,p=n.n,f=r*8;do{if(!c){n.f=o=il(t,l,1);var g=il(t,l+1,3);if(l+=3,g)if(g==1)c=h0e,d=p0e,h=9,p=5;else if(g==2){var w=il(t,l,31)+257,_=il(t,l+10,15)+4,S=w+il(t,l+5,31)+1;l+=14;for(var E=new Po(S),C=new Po(19),T=0;T<_;++T)C[l0e[T]]=il(t,l+T*3,7);l+=_*3;for(var M=oN(C),k=(1<<M)-1,R=Cb(C,M,1),T=0;T<S;){var N=R[il(t,l,k)];l+=N&15;var y=N>>>4;if(y<16)E[T++]=y;else{var B=0,z=0;for(y==16?(z=3+il(t,l,3),l+=2,B=E[T-1]):y==17?(z=3+il(t,l,7),l+=3):y==18&&(z=11+il(t,l,127),l+=7);z--;)E[T++]=B}}var V=E.subarray(0,w),K=E.subarray(w);h=oN(V),p=oN(K),c=Cb(V,h,1),d=Cb(K,p,1)}else throw"invalid block type";else{var y=f0e(l)+4,m=t[y-4]|t[y-3]<<8,b=y+m;if(b>r){if(s)throw"unexpected EOF";break}i&&a(u+m),e.set(t.subarray(y,b),u),n.b=u+=m,n.p=l=b*8;continue}if(l>f){if(s)throw"unexpected EOF";break}}i&&a(u+131072);for(var Q=(1<<h)-1,O=(1<<p)-1,j=l;;j=l){var B=c[lN(t,l)&Q],X=B>>>4;if(l+=B&15,l>f){if(s)throw"unexpected EOF";break}if(!B)throw"invalid length/literal";if(X<256)e[u++]=X;else if(X==256){j=l,c=null;break}else{var te=X-254;if(X>264){var T=X-257,le=PX[T];te=il(t,l,(1<<le)-1)+UX[T],l+=le}var ge=d[lN(t,l)&O],ie=ge>>>4;if(!ge)throw"invalid distance";l+=ge&15;var K=d0e[ie];if(ie>3){var le=LX[ie];K+=lN(t,l)&(1<<le)-1,l+=le}if(l>f){if(s)throw"unexpected EOF";break}i&&a(u+131072);for(var we=u+te;u<we;u+=4)e[u]=e[u-K],e[u+1]=e[u+1-K],e[u+2]=e[u+2-K],e[u+3]=e[u+3-K];u=we}}n.l=c,n.p=j,n.b=u,c&&(o=1,n.m=h,n.d=d,n.n=p)}while(!o);return u==e.length?e:m0e(e,0,u)},y0e=new Po(0),v0e=function(t){if((t[0]&15)!=8||t[0]>>>4>7||(t[0]<<8|t[1])%31)throw"invalid zlib data";if(t[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function dA(t,e){return g0e((v0e(t),t.subarray(2,-4)),e)}var x0e=typeof TextDecoder<"u"&&new TextDecoder,b0e=0;try{x0e.decode(y0e,{stream:!0}),b0e=1}catch{}const w0e=t=>t&&t.isCubeTexture;class _0e extends Cr{constructor(e,n){var r,i;const s=w0e(e),o=((i=s?(r=e.image[0])==null?void 0:r.width:e.image.width)!=null?i:1024)/4,l=Math.floor(Math.log2(o)),u=Math.pow(2,l),c=3*Math.max(u,16*7),d=4*u,h=[s?"#define ENVMAP_TYPE_CUBE":"",`#define CUBEUV_TEXEL_WIDTH ${1/c}`,`#define CUBEUV_TEXEL_HEIGHT ${1/d}`,`#define CUBEUV_MAX_MIP ${l}.0`],p=`
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,f=h.join(`
`)+`
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${f3>=154?"colorspace_fragment":"encodings_fragment"}>
        }
        `,g={map:{value:e},height:{value:(n==null?void 0:n.height)||15},radius:{value:(n==null?void 0:n.radius)||100}},y=new J1(1,16),m=new ua({uniforms:g,fragmentShader:f,vertexShader:p,side:ta});super(y,m)}set radius(e){this.material.uniforms.radius.value=e}get radius(){return this.material.uniforms.radius.value}set height(e){this.material.uniforms.height.value=e}get height(){return this.material.uniforms.height.value}}var S0e=Object.defineProperty,A0e=(t,e,n)=>e in t?S0e(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,E0e=(t,e,n)=>(A0e(t,e+"",n),n);class I0e{constructor(){E0e(this,"_listeners")}addEventListener(e,n){this._listeners===void 0&&(this._listeners={});const r=this._listeners;r[e]===void 0&&(r[e]=[]),r[e].indexOf(n)===-1&&r[e].push(n)}hasEventListener(e,n){if(this._listeners===void 0)return!1;const r=this._listeners;return r[e]!==void 0&&r[e].indexOf(n)!==-1}removeEventListener(e,n){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const s=i.indexOf(n);s!==-1&&i.splice(s,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const r=this._listeners[e.type];if(r!==void 0){e.target=this;const i=r.slice(0);for(let s=0,a=i.length;s<a;s++)i[s].call(this,e);e.target=null}}}var T0e=Object.defineProperty,C0e=(t,e,n)=>e in t?T0e(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,hn=(t,e,n)=>(C0e(t,typeof e!="symbol"?e+"":e,n),n);const hA=new xf,CW=new Bu,M0e=Math.cos(70*(Math.PI/180)),MW=(t,e)=>(t%e+e)%e;let k0e=class extends I0e{constructor(e,n){super(),hn(this,"object"),hn(this,"domElement"),hn(this,"enabled",!0),hn(this,"target",new Z),hn(this,"minDistance",0),hn(this,"maxDistance",1/0),hn(this,"minZoom",0),hn(this,"maxZoom",1/0),hn(this,"minPolarAngle",0),hn(this,"maxPolarAngle",Math.PI),hn(this,"minAzimuthAngle",-1/0),hn(this,"maxAzimuthAngle",1/0),hn(this,"enableDamping",!1),hn(this,"dampingFactor",.05),hn(this,"enableZoom",!0),hn(this,"zoomSpeed",1),hn(this,"enableRotate",!0),hn(this,"rotateSpeed",1),hn(this,"enablePan",!0),hn(this,"panSpeed",1),hn(this,"screenSpacePanning",!0),hn(this,"keyPanSpeed",7),hn(this,"zoomToCursor",!1),hn(this,"autoRotate",!1),hn(this,"autoRotateSpeed",2),hn(this,"reverseOrbit",!1),hn(this,"reverseHorizontalOrbit",!1),hn(this,"reverseVerticalOrbit",!1),hn(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),hn(this,"mouseButtons",{LEFT:Kh.ROTATE,MIDDLE:Kh.DOLLY,RIGHT:Kh.PAN}),hn(this,"touches",{ONE:qh.ROTATE,TWO:qh.DOLLY_PAN}),hn(this,"target0"),hn(this,"position0"),hn(this,"zoom0"),hn(this,"_domElementKeyEvents",null),hn(this,"getPolarAngle"),hn(this,"getAzimuthalAngle"),hn(this,"setPolarAngle"),hn(this,"setAzimuthalAngle"),hn(this,"getDistance"),hn(this,"getZoomScale"),hn(this,"listenToKeyEvents"),hn(this,"stopListenToKeyEvents"),hn(this,"saveState"),hn(this,"reset"),hn(this,"update"),hn(this,"connect"),hn(this,"dispose"),hn(this,"dollyIn"),hn(this,"dollyOut"),hn(this,"getScale"),hn(this,"setScale"),this.object=e,this.domElement=n,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>c.phi,this.getAzimuthalAngle=()=>c.theta,this.setPolarAngle=he=>{let Me=MW(he,2*Math.PI),it=c.phi;it<0&&(it+=2*Math.PI),Me<0&&(Me+=2*Math.PI);let de=Math.abs(Me-it);2*Math.PI-de<de&&(Me<it?Me+=2*Math.PI:it+=2*Math.PI),d.phi=Me-it,r.update()},this.setAzimuthalAngle=he=>{let Me=MW(he,2*Math.PI),it=c.theta;it<0&&(it+=2*Math.PI),Me<0&&(Me+=2*Math.PI);let de=Math.abs(Me-it);2*Math.PI-de<de&&(Me<it?Me+=2*Math.PI:it+=2*Math.PI),d.theta=Me-it,r.update()},this.getDistance=()=>r.object.position.distanceTo(r.target),this.listenToKeyEvents=he=>{he.addEventListener("keydown",$e),this._domElementKeyEvents=he},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",$e),this._domElementKeyEvents=null},this.saveState=()=>{r.target0.copy(r.target),r.position0.copy(r.object.position),r.zoom0=r.object.zoom},this.reset=()=>{r.target.copy(r.target0),r.object.position.copy(r.position0),r.object.zoom=r.zoom0,r.object.updateProjectionMatrix(),r.dispatchEvent(i),r.update(),l=o.NONE},this.update=(()=>{const he=new Z,Me=new Z(0,1,0),it=new Kr().setFromUnitVectors(e.up,Me),de=it.clone().invert(),Ne=new Z,nt=new Kr,Mt=2*Math.PI;return function(){const Ze=r.object.position;it.setFromUnitVectors(e.up,Me),de.copy(it).invert(),he.copy(Ze).sub(r.target),he.applyQuaternion(it),c.setFromVector3(he),r.autoRotate&&l===o.NONE&&z(N()),r.enableDamping?(c.theta+=d.theta*r.dampingFactor,c.phi+=d.phi*r.dampingFactor):(c.theta+=d.theta,c.phi+=d.phi);let kt=r.minAzimuthAngle,Se=r.maxAzimuthAngle;isFinite(kt)&&isFinite(Se)&&(kt<-Math.PI?kt+=Mt:kt>Math.PI&&(kt-=Mt),Se<-Math.PI?Se+=Mt:Se>Math.PI&&(Se-=Mt),kt<=Se?c.theta=Math.max(kt,Math.min(Se,c.theta)):c.theta=c.theta>(kt+Se)/2?Math.max(kt,c.theta):Math.min(Se,c.theta)),c.phi=Math.max(r.minPolarAngle,Math.min(r.maxPolarAngle,c.phi)),c.makeSafe(),r.enableDamping===!0?r.target.addScaledVector(p,r.dampingFactor):r.target.add(p),r.zoomToCursor&&M||r.object.isOrthographicCamera?c.radius=ge(c.radius):c.radius=ge(c.radius*h),he.setFromSpherical(c),he.applyQuaternion(de),Ze.copy(r.target).add(he),r.object.matrixAutoUpdate||r.object.updateMatrix(),r.object.lookAt(r.target),r.enableDamping===!0?(d.theta*=1-r.dampingFactor,d.phi*=1-r.dampingFactor,p.multiplyScalar(1-r.dampingFactor)):(d.set(0,0,0),p.set(0,0,0));let qe=!1;if(r.zoomToCursor&&M){let pt=null;if(r.object instanceof Qr&&r.object.isPerspectiveCamera){const ht=he.length();pt=ge(ht*h);const xn=ht-pt;r.object.position.addScaledVector(C,xn),r.object.updateMatrixWorld()}else if(r.object.isOrthographicCamera){const ht=new Z(T.x,T.y,0);ht.unproject(r.object),r.object.zoom=Math.max(r.minZoom,Math.min(r.maxZoom,r.object.zoom/h)),r.object.updateProjectionMatrix(),qe=!0;const xn=new Z(T.x,T.y,0);xn.unproject(r.object),r.object.position.sub(xn).add(ht),r.object.updateMatrixWorld(),pt=he.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),r.zoomToCursor=!1;pt!==null&&(r.screenSpacePanning?r.target.set(0,0,-1).transformDirection(r.object.matrix).multiplyScalar(pt).add(r.object.position):(hA.origin.copy(r.object.position),hA.direction.set(0,0,-1).transformDirection(r.object.matrix),Math.abs(r.object.up.dot(hA.direction))<M0e?e.lookAt(r.target):(CW.setFromNormalAndCoplanarPoint(r.object.up,r.target),hA.intersectPlane(CW,r.target))))}else r.object instanceof iu&&r.object.isOrthographicCamera&&(qe=h!==1,qe&&(r.object.zoom=Math.max(r.minZoom,Math.min(r.maxZoom,r.object.zoom/h)),r.object.updateProjectionMatrix()));return h=1,M=!1,qe||Ne.distanceToSquared(r.object.position)>u||8*(1-nt.dot(r.object.quaternion))>u?(r.dispatchEvent(i),Ne.copy(r.object.position),nt.copy(r.object.quaternion),qe=!1,!0):!1}})(),this.connect=he=>{r.domElement=he,r.domElement.style.touchAction="none",r.domElement.addEventListener("contextmenu",Pt),r.domElement.addEventListener("pointerdown",Vt),r.domElement.addEventListener("pointercancel",H),r.domElement.addEventListener("wheel",Xe)},this.dispose=()=>{var he,Me,it,de,Ne,nt;r.domElement&&(r.domElement.style.touchAction="auto"),(he=r.domElement)==null||he.removeEventListener("contextmenu",Pt),(Me=r.domElement)==null||Me.removeEventListener("pointerdown",Vt),(it=r.domElement)==null||it.removeEventListener("pointercancel",H),(de=r.domElement)==null||de.removeEventListener("wheel",Xe),(Ne=r.domElement)==null||Ne.ownerDocument.removeEventListener("pointermove",re),(nt=r.domElement)==null||nt.ownerDocument.removeEventListener("pointerup",H),r._domElementKeyEvents!==null&&r._domElementKeyEvents.removeEventListener("keydown",$e)};const r=this,i={type:"change"},s={type:"start"},a={type:"end"},o={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let l=o.NONE;const u=1e-6,c=new wI,d=new wI;let h=1;const p=new Z,f=new Qe,g=new Qe,y=new Qe,m=new Qe,b=new Qe,w=new Qe,_=new Qe,S=new Qe,E=new Qe,C=new Z,T=new Qe;let M=!1;const k=[],R={};function N(){return 2*Math.PI/60/60*r.autoRotateSpeed}function B(){return Math.pow(.95,r.zoomSpeed)}function z(he){r.reverseOrbit||r.reverseHorizontalOrbit?d.theta+=he:d.theta-=he}function V(he){r.reverseOrbit||r.reverseVerticalOrbit?d.phi+=he:d.phi-=he}const K=(()=>{const he=new Z;return function(it,de){he.setFromMatrixColumn(de,0),he.multiplyScalar(-it),p.add(he)}})(),Q=(()=>{const he=new Z;return function(it,de){r.screenSpacePanning===!0?he.setFromMatrixColumn(de,1):(he.setFromMatrixColumn(de,0),he.crossVectors(r.object.up,he)),he.multiplyScalar(it),p.add(he)}})(),O=(()=>{const he=new Z;return function(it,de){const Ne=r.domElement;if(Ne&&r.object instanceof Qr&&r.object.isPerspectiveCamera){const nt=r.object.position;he.copy(nt).sub(r.target);let Mt=he.length();Mt*=Math.tan(r.object.fov/2*Math.PI/180),K(2*it*Mt/Ne.clientHeight,r.object.matrix),Q(2*de*Mt/Ne.clientHeight,r.object.matrix)}else Ne&&r.object instanceof iu&&r.object.isOrthographicCamera?(K(it*(r.object.right-r.object.left)/r.object.zoom/Ne.clientWidth,r.object.matrix),Q(de*(r.object.top-r.object.bottom)/r.object.zoom/Ne.clientHeight,r.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),r.enablePan=!1)}})();function j(he){r.object instanceof Qr&&r.object.isPerspectiveCamera||r.object instanceof iu&&r.object.isOrthographicCamera?h=he:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),r.enableZoom=!1)}function X(he){j(h/he)}function te(he){j(h*he)}function le(he){if(!r.zoomToCursor||!r.domElement)return;M=!0;const Me=r.domElement.getBoundingClientRect(),it=he.clientX-Me.left,de=he.clientY-Me.top,Ne=Me.width,nt=Me.height;T.x=it/Ne*2-1,T.y=-(de/nt)*2+1,C.set(T.x,T.y,1).unproject(r.object).sub(r.object.position).normalize()}function ge(he){return Math.max(r.minDistance,Math.min(r.maxDistance,he))}function ie(he){f.set(he.clientX,he.clientY)}function we(he){le(he),_.set(he.clientX,he.clientY)}function Ce(he){m.set(he.clientX,he.clientY)}function Re(he){g.set(he.clientX,he.clientY),y.subVectors(g,f).multiplyScalar(r.rotateSpeed);const Me=r.domElement;Me&&(z(2*Math.PI*y.x/Me.clientHeight),V(2*Math.PI*y.y/Me.clientHeight)),f.copy(g),r.update()}function Le(he){S.set(he.clientX,he.clientY),E.subVectors(S,_),E.y>0?X(B()):E.y<0&&te(B()),_.copy(S),r.update()}function lt(he){b.set(he.clientX,he.clientY),w.subVectors(b,m).multiplyScalar(r.panSpeed),O(w.x,w.y),m.copy(b),r.update()}function st(he){le(he),he.deltaY<0?te(B()):he.deltaY>0&&X(B()),r.update()}function Et(he){let Me=!1;switch(he.code){case r.keys.UP:O(0,r.keyPanSpeed),Me=!0;break;case r.keys.BOTTOM:O(0,-r.keyPanSpeed),Me=!0;break;case r.keys.LEFT:O(r.keyPanSpeed,0),Me=!0;break;case r.keys.RIGHT:O(-r.keyPanSpeed,0),Me=!0;break}Me&&(he.preventDefault(),r.update())}function Tt(){if(k.length==1)f.set(k[0].pageX,k[0].pageY);else{const he=.5*(k[0].pageX+k[1].pageX),Me=.5*(k[0].pageY+k[1].pageY);f.set(he,Me)}}function xt(){if(k.length==1)m.set(k[0].pageX,k[0].pageY);else{const he=.5*(k[0].pageX+k[1].pageX),Me=.5*(k[0].pageY+k[1].pageY);m.set(he,Me)}}function J(){const he=k[0].pageX-k[1].pageX,Me=k[0].pageY-k[1].pageY,it=Math.sqrt(he*he+Me*Me);_.set(0,it)}function Ye(){r.enableZoom&&J(),r.enablePan&&xt()}function Be(){r.enableZoom&&J(),r.enableRotate&&Tt()}function tt(he){if(k.length==1)g.set(he.pageX,he.pageY);else{const it=Ot(he),de=.5*(he.pageX+it.x),Ne=.5*(he.pageY+it.y);g.set(de,Ne)}y.subVectors(g,f).multiplyScalar(r.rotateSpeed);const Me=r.domElement;Me&&(z(2*Math.PI*y.x/Me.clientHeight),V(2*Math.PI*y.y/Me.clientHeight)),f.copy(g)}function Ue(he){if(k.length==1)b.set(he.pageX,he.pageY);else{const Me=Ot(he),it=.5*(he.pageX+Me.x),de=.5*(he.pageY+Me.y);b.set(it,de)}w.subVectors(b,m).multiplyScalar(r.panSpeed),O(w.x,w.y),m.copy(b)}function St(he){const Me=Ot(he),it=he.pageX-Me.x,de=he.pageY-Me.y,Ne=Math.sqrt(it*it+de*de);S.set(0,Ne),E.set(0,Math.pow(S.y/_.y,r.zoomSpeed)),X(E.y),_.copy(S)}function Je(he){r.enableZoom&&St(he),r.enablePan&&Ue(he)}function At(he){r.enableZoom&&St(he),r.enableRotate&&tt(he)}function Vt(he){var Me,it;r.enabled!==!1&&(k.length===0&&((Me=r.domElement)==null||Me.ownerDocument.addEventListener("pointermove",re),(it=r.domElement)==null||it.ownerDocument.addEventListener("pointerup",H)),Ht(he),he.pointerType==="touch"?Lt(he):Ee(he))}function re(he){r.enabled!==!1&&(he.pointerType==="touch"?wt(he):Oe(he))}function H(he){var Me,it,de;et(he),k.length===0&&((Me=r.domElement)==null||Me.releasePointerCapture(he.pointerId),(it=r.domElement)==null||it.ownerDocument.removeEventListener("pointermove",re),(de=r.domElement)==null||de.ownerDocument.removeEventListener("pointerup",H)),r.dispatchEvent(a),l=o.NONE}function Ee(he){let Me;switch(he.button){case 0:Me=r.mouseButtons.LEFT;break;case 1:Me=r.mouseButtons.MIDDLE;break;case 2:Me=r.mouseButtons.RIGHT;break;default:Me=-1}switch(Me){case Kh.DOLLY:if(r.enableZoom===!1)return;we(he),l=o.DOLLY;break;case Kh.ROTATE:if(he.ctrlKey||he.metaKey||he.shiftKey){if(r.enablePan===!1)return;Ce(he),l=o.PAN}else{if(r.enableRotate===!1)return;ie(he),l=o.ROTATE}break;case Kh.PAN:if(he.ctrlKey||he.metaKey||he.shiftKey){if(r.enableRotate===!1)return;ie(he),l=o.ROTATE}else{if(r.enablePan===!1)return;Ce(he),l=o.PAN}break;default:l=o.NONE}l!==o.NONE&&r.dispatchEvent(s)}function Oe(he){if(r.enabled!==!1)switch(l){case o.ROTATE:if(r.enableRotate===!1)return;Re(he);break;case o.DOLLY:if(r.enableZoom===!1)return;Le(he);break;case o.PAN:if(r.enablePan===!1)return;lt(he);break}}function Xe(he){r.enabled===!1||r.enableZoom===!1||l!==o.NONE&&l!==o.ROTATE||(he.preventDefault(),r.dispatchEvent(s),st(he),r.dispatchEvent(a))}function $e(he){r.enabled===!1||r.enablePan===!1||Et(he)}function Lt(he){switch(mt(he),k.length){case 1:switch(r.touches.ONE){case qh.ROTATE:if(r.enableRotate===!1)return;Tt(),l=o.TOUCH_ROTATE;break;case qh.PAN:if(r.enablePan===!1)return;xt(),l=o.TOUCH_PAN;break;default:l=o.NONE}break;case 2:switch(r.touches.TWO){case qh.DOLLY_PAN:if(r.enableZoom===!1&&r.enablePan===!1)return;Ye(),l=o.TOUCH_DOLLY_PAN;break;case qh.DOLLY_ROTATE:if(r.enableZoom===!1&&r.enableRotate===!1)return;Be(),l=o.TOUCH_DOLLY_ROTATE;break;default:l=o.NONE}break;default:l=o.NONE}l!==o.NONE&&r.dispatchEvent(s)}function wt(he){switch(mt(he),l){case o.TOUCH_ROTATE:if(r.enableRotate===!1)return;tt(he),r.update();break;case o.TOUCH_PAN:if(r.enablePan===!1)return;Ue(he),r.update();break;case o.TOUCH_DOLLY_PAN:if(r.enableZoom===!1&&r.enablePan===!1)return;Je(he),r.update();break;case o.TOUCH_DOLLY_ROTATE:if(r.enableZoom===!1&&r.enableRotate===!1)return;At(he),r.update();break;default:l=o.NONE}}function Pt(he){r.enabled!==!1&&he.preventDefault()}function Ht(he){k.push(he)}function et(he){delete R[he.pointerId];for(let Me=0;Me<k.length;Me++)if(k[Me].pointerId==he.pointerId){k.splice(Me,1);return}}function mt(he){let Me=R[he.pointerId];Me===void 0&&(Me=new Qe,R[he.pointerId]=Me),Me.set(he.pageX,he.pageY)}function Ot(he){const Me=he.pointerId===k[0].pointerId?k[1]:k[0];return R[Me.pointerId]}this.dollyIn=(he=B())=>{te(he),r.update()},this.dollyOut=(he=B())=>{X(he),r.update()},this.getScale=()=>h,this.setScale=he=>{j(he),r.update()},this.getZoomScale=()=>B(),n!==void 0&&this.connect(n),this.update()}};function AI(t){if(typeof TextDecoder<"u")return new TextDecoder().decode(t);let e="";for(let n=0,r=t.length;n<r;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch{return e}}const vp="srgb",Zu="srgb-linear",kW=3001,N0e=3e3;class m3 extends _s{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(n){return new L0e(n)}),this.register(function(n){return new O0e(n)}),this.register(function(n){return new j0e(n)}),this.register(function(n){return new X0e(n)}),this.register(function(n){return new K0e(n)}),this.register(function(n){return new U0e(n)}),this.register(function(n){return new $0e(n)}),this.register(function(n){return new z0e(n)}),this.register(function(n){return new G0e(n)}),this.register(function(n){return new P0e(n)}),this.register(function(n){return new H0e(n)}),this.register(function(n){return new B0e(n)}),this.register(function(n){return new V0e(n)}),this.register(function(n){return new W0e(n)}),this.register(function(n){return new F0e(n)}),this.register(function(n){return new q0e(n)}),this.register(function(n){return new J0e(n)})}load(e,n,r,i){const s=this;let a;if(this.resourcePath!=="")a=this.resourcePath;else if(this.path!==""){const u=_d.extractUrlBase(e);a=_d.resolveURL(u,this.path)}else a=_d.extractUrlBase(e);this.manager.itemStart(e);const o=function(u){i?i(u):console.error(u),s.manager.itemError(e),s.manager.itemEnd(e)},l=new vs(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(u){try{s.parse(u,a,function(c){n(c),s.manager.itemEnd(e)},o)}catch(c){o(c)}},r,o)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,n,r,i){let s;const a={},o={};if(typeof e=="string")s=JSON.parse(e);else if(e instanceof ArrayBuffer)if(AI(new Uint8Array(e.slice(0,4)))===zX){try{a[jn.KHR_BINARY_GLTF]=new Y0e(e)}catch(c){i&&i(c);return}s=JSON.parse(a[jn.KHR_BINARY_GLTF].content)}else s=JSON.parse(AI(new Uint8Array(e)));else s=e;if(s.asset===void 0||s.asset.version[0]<2){i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const l=new cve(s,{path:n||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let u=0;u<this.pluginCallbacks.length;u++){const c=this.pluginCallbacks[u](l);c.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),o[c.name]=c,a[c.name]=!0}if(s.extensionsUsed)for(let u=0;u<s.extensionsUsed.length;++u){const c=s.extensionsUsed[u],d=s.extensionsRequired||[];switch(c){case jn.KHR_MATERIALS_UNLIT:a[c]=new D0e;break;case jn.KHR_DRACO_MESH_COMPRESSION:a[c]=new Z0e(s,this.dracoLoader);break;case jn.KHR_TEXTURE_TRANSFORM:a[c]=new Q0e;break;case jn.KHR_MESH_QUANTIZATION:a[c]=new eve;break;default:d.indexOf(c)>=0&&o[c]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+c+'".')}}l.setExtensions(a),l.setPlugins(o),l.parse(r,i)}parseAsync(e,n){const r=this;return new Promise(function(i,s){r.parse(e,n,i,s)})}}function R0e(){let t={};return{get:function(e){return t[e]},add:function(e,n){t[e]=n},remove:function(e){delete t[e]},removeAll:function(){t={}}}}const jn={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class F0e{constructor(e){this.parser=e,this.name=jn.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,n=this.parser.json.nodes||[];for(let r=0,i=n.length;r<i;r++){const s=n[r];s.extensions&&s.extensions[this.name]&&s.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,s.extensions[this.name].light)}}_loadLight(e){const n=this.parser,r="light:"+e;let i=n.cache.get(r);if(i)return i;const s=n.json,l=((s.extensions&&s.extensions[this.name]||{}).lights||[])[e];let u;const c=new Ct(16777215);l.color!==void 0&&c.setRGB(l.color[0],l.color[1],l.color[2],Zu);const d=l.range!==void 0?l.range:0;switch(l.type){case"directional":u=new Q1(c),u.target.position.set(0,0,-1),u.add(u.target);break;case"point":u=new QP(c),u.distance=d;break;case"spot":u=new ZP(c),u.distance=d,l.spot=l.spot||{},l.spot.innerConeAngle=l.spot.innerConeAngle!==void 0?l.spot.innerConeAngle:0,l.spot.outerConeAngle=l.spot.outerConeAngle!==void 0?l.spot.outerConeAngle:Math.PI/4,u.angle=l.spot.outerConeAngle,u.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,u.target.position.set(0,0,-1),u.add(u.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return u.position.set(0,0,0),u.decay=2,Lu(u,l),l.intensity!==void 0&&(u.intensity=l.intensity),u.name=n.createUniqueName(l.name||"light_"+e),i=Promise.resolve(u),n.cache.add(r,i),i}getDependency(e,n){if(e==="light")return this._loadLight(n)}createNodeAttachment(e){const n=this,r=this.parser,s=r.json.nodes[e],o=(s.extensions&&s.extensions[this.name]||{}).light;return o===void 0?null:this._loadLight(o).then(function(l){return r._getNodeRef(n.cache,o,l)})}}let D0e=class{constructor(){this.name=jn.KHR_MATERIALS_UNLIT}getMaterialType(){return ka}extendParams(e,n,r){const i=[];e.color=new Ct(1,1,1),e.opacity=1;const s=n.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){const a=s.baseColorFactor;e.color.setRGB(a[0],a[1],a[2],Zu),e.opacity=a[3]}s.baseColorTexture!==void 0&&i.push(r.assignTexture(e,"map",s.baseColorTexture,vp))}return Promise.all(i)}},P0e=class{constructor(e){this.parser=e,this.name=jn.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,n){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=i.extensions[this.name].emissiveStrength;return s!==void 0&&(n.emissiveIntensity=s),Promise.resolve()}},L0e=class{constructor(e){this.parser=e,this.name=jn.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Ho}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];if(a.clearcoatFactor!==void 0&&(n.clearcoat=a.clearcoatFactor),a.clearcoatTexture!==void 0&&s.push(r.assignTexture(n,"clearcoatMap",a.clearcoatTexture)),a.clearcoatRoughnessFactor!==void 0&&(n.clearcoatRoughness=a.clearcoatRoughnessFactor),a.clearcoatRoughnessTexture!==void 0&&s.push(r.assignTexture(n,"clearcoatRoughnessMap",a.clearcoatRoughnessTexture)),a.clearcoatNormalTexture!==void 0&&(s.push(r.assignTexture(n,"clearcoatNormalMap",a.clearcoatNormalTexture)),a.clearcoatNormalTexture.scale!==void 0)){const o=a.clearcoatNormalTexture.scale;n.clearcoatNormalScale=new Qe(o,o)}return Promise.all(s)}},O0e=class{constructor(e){this.parser=e,this.name=jn.KHR_MATERIALS_DISPERSION}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Ho}extendMaterialParams(e,n){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=i.extensions[this.name];return n.dispersion=s.dispersion!==void 0?s.dispersion:0,Promise.resolve()}},B0e=class{constructor(e){this.parser=e,this.name=jn.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Ho}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];return a.iridescenceFactor!==void 0&&(n.iridescence=a.iridescenceFactor),a.iridescenceTexture!==void 0&&s.push(r.assignTexture(n,"iridescenceMap",a.iridescenceTexture)),a.iridescenceIor!==void 0&&(n.iridescenceIOR=a.iridescenceIor),n.iridescenceThicknessRange===void 0&&(n.iridescenceThicknessRange=[100,400]),a.iridescenceThicknessMinimum!==void 0&&(n.iridescenceThicknessRange[0]=a.iridescenceThicknessMinimum),a.iridescenceThicknessMaximum!==void 0&&(n.iridescenceThicknessRange[1]=a.iridescenceThicknessMaximum),a.iridescenceThicknessTexture!==void 0&&s.push(r.assignTexture(n,"iridescenceThicknessMap",a.iridescenceThicknessTexture)),Promise.all(s)}},U0e=class{constructor(e){this.parser=e,this.name=jn.KHR_MATERIALS_SHEEN}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Ho}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[];n.sheenColor=new Ct(0,0,0),n.sheenRoughness=0,n.sheen=1;const a=i.extensions[this.name];if(a.sheenColorFactor!==void 0){const o=a.sheenColorFactor;n.sheenColor.setRGB(o[0],o[1],o[2],Zu)}return a.sheenRoughnessFactor!==void 0&&(n.sheenRoughness=a.sheenRoughnessFactor),a.sheenColorTexture!==void 0&&s.push(r.assignTexture(n,"sheenColorMap",a.sheenColorTexture,vp)),a.sheenRoughnessTexture!==void 0&&s.push(r.assignTexture(n,"sheenRoughnessMap",a.sheenRoughnessTexture)),Promise.all(s)}},$0e=class{constructor(e){this.parser=e,this.name=jn.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Ho}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];return a.transmissionFactor!==void 0&&(n.transmission=a.transmissionFactor),a.transmissionTexture!==void 0&&s.push(r.assignTexture(n,"transmissionMap",a.transmissionTexture)),Promise.all(s)}},z0e=class{constructor(e){this.parser=e,this.name=jn.KHR_MATERIALS_VOLUME}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Ho}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];n.thickness=a.thicknessFactor!==void 0?a.thicknessFactor:0,a.thicknessTexture!==void 0&&s.push(r.assignTexture(n,"thicknessMap",a.thicknessTexture)),n.attenuationDistance=a.attenuationDistance||1/0;const o=a.attenuationColor||[1,1,1];return n.attenuationColor=new Ct().setRGB(o[0],o[1],o[2],Zu),Promise.all(s)}},G0e=class{constructor(e){this.parser=e,this.name=jn.KHR_MATERIALS_IOR}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Ho}extendMaterialParams(e,n){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=i.extensions[this.name];return n.ior=s.ior!==void 0?s.ior:1.5,Promise.resolve()}},H0e=class{constructor(e){this.parser=e,this.name=jn.KHR_MATERIALS_SPECULAR}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Ho}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];n.specularIntensity=a.specularFactor!==void 0?a.specularFactor:1,a.specularTexture!==void 0&&s.push(r.assignTexture(n,"specularIntensityMap",a.specularTexture));const o=a.specularColorFactor||[1,1,1];return n.specularColor=new Ct().setRGB(o[0],o[1],o[2],Zu),a.specularColorTexture!==void 0&&s.push(r.assignTexture(n,"specularColorMap",a.specularColorTexture,vp)),Promise.all(s)}},W0e=class{constructor(e){this.parser=e,this.name=jn.EXT_MATERIALS_BUMP}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Ho}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];return n.bumpScale=a.bumpFactor!==void 0?a.bumpFactor:1,a.bumpTexture!==void 0&&s.push(r.assignTexture(n,"bumpMap",a.bumpTexture)),Promise.all(s)}},V0e=class{constructor(e){this.parser=e,this.name=jn.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Ho}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];return a.anisotropyStrength!==void 0&&(n.anisotropy=a.anisotropyStrength),a.anisotropyRotation!==void 0&&(n.anisotropyRotation=a.anisotropyRotation),a.anisotropyTexture!==void 0&&s.push(r.assignTexture(n,"anisotropyMap",a.anisotropyTexture)),Promise.all(s)}};class j0e{constructor(e){this.parser=e,this.name=jn.KHR_TEXTURE_BASISU}loadTexture(e){const n=this.parser,r=n.json,i=r.textures[e];if(!i.extensions||!i.extensions[this.name])return null;const s=i.extensions[this.name],a=n.options.ktx2Loader;if(!a){if(r.extensionsRequired&&r.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return n.loadTextureImage(e,s.source,a)}}class X0e{constructor(e){this.parser=e,this.name=jn.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const n=this.name,r=this.parser,i=r.json,s=i.textures[e];if(!s.extensions||!s.extensions[n])return null;const a=s.extensions[n],o=i.images[a.source];let l=r.textureLoader;if(o.uri){const u=r.options.manager.getHandler(o.uri);u!==null&&(l=u)}return this.detectSupport().then(function(u){if(u)return r.loadTextureImage(e,a.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(n)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return r.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const n=new Image;n.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",n.onload=n.onerror=function(){e(n.height===1)}})),this.isSupported}}class K0e{constructor(e){this.parser=e,this.name=jn.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const n=this.name,r=this.parser,i=r.json,s=i.textures[e];if(!s.extensions||!s.extensions[n])return null;const a=s.extensions[n],o=i.images[a.source];let l=r.textureLoader;if(o.uri){const u=r.options.manager.getHandler(o.uri);u!==null&&(l=u)}return this.detectSupport().then(function(u){if(u)return r.loadTextureImage(e,a.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(n)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return r.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const n=new Image;n.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",n.onload=n.onerror=function(){e(n.height===1)}})),this.isSupported}}class q0e{constructor(e){this.name=jn.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const n=this.parser.json,r=n.bufferViews[e];if(r.extensions&&r.extensions[this.name]){const i=r.extensions[this.name],s=this.parser.getDependency("buffer",i.buffer),a=this.parser.options.meshoptDecoder;if(!a||!a.supported){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return s.then(function(o){const l=i.byteOffset||0,u=i.byteLength||0,c=i.count,d=i.byteStride,h=new Uint8Array(o,l,u);return a.decodeGltfBufferAsync?a.decodeGltfBufferAsync(c,d,h,i.mode,i.filter).then(function(p){return p.buffer}):a.ready.then(function(){const p=new ArrayBuffer(c*d);return a.decodeGltfBuffer(new Uint8Array(p),c,d,h,i.mode,i.filter),p})})}else return null}}let J0e=class{constructor(e){this.name=jn.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const n=this.parser.json,r=n.nodes[e];if(!r.extensions||!r.extensions[this.name]||r.mesh===void 0)return null;const i=n.meshes[r.mesh];for(const u of i.primitives)if(u.mode!==ko.TRIANGLES&&u.mode!==ko.TRIANGLE_STRIP&&u.mode!==ko.TRIANGLE_FAN&&u.mode!==void 0)return null;const a=r.extensions[this.name].attributes,o=[],l={};for(const u in a)o.push(this.parser.getDependency("accessor",a[u]).then(c=>(l[u]=c,l[u])));return o.length<1?null:(o.push(this.parser.createNodeMesh(e)),Promise.all(o).then(u=>{const c=u.pop(),d=c.isGroup?c.children:[c],h=u[0].count,p=[];for(const f of d){const g=new ln,y=new Z,m=new Kr,b=new Z(1,1,1),w=new DP(f.geometry,f.material,h);for(let _=0;_<h;_++)l.TRANSLATION&&y.fromBufferAttribute(l.TRANSLATION,_),l.ROTATION&&m.fromBufferAttribute(l.ROTATION,_),l.SCALE&&b.fromBufferAttribute(l.SCALE,_),w.setMatrixAt(_,g.compose(y,m,b));for(const _ in l)if(_==="_COLOR_0"){const S=l[_];w.instanceColor=new Gp(S.array,S.itemSize,S.normalized)}else _!=="TRANSLATION"&&_!=="ROTATION"&&_!=="SCALE"&&f.geometry.setAttribute(_,l[_]);Yn.prototype.copy.call(w,f),this.parser.assignFinalMaterial(w),p.push(w)}return c.isGroup?(c.clear(),c.add(...p),c):p[0]}))}};const zX="glTF",Lx=12,NW={JSON:1313821514,BIN:5130562};class Y0e{constructor(e){this.name=jn.KHR_BINARY_GLTF,this.content=null,this.body=null;const n=new DataView(e,0,Lx);if(this.header={magic:AI(new Uint8Array(e.slice(0,4))),version:n.getUint32(4,!0),length:n.getUint32(8,!0)},this.header.magic!==zX)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const r=this.header.length-Lx,i=new DataView(e,Lx);let s=0;for(;s<r;){const a=i.getUint32(s,!0);s+=4;const o=i.getUint32(s,!0);if(s+=4,o===NW.JSON){const l=new Uint8Array(e,Lx+s,a);this.content=AI(l)}else if(o===NW.BIN){const l=Lx+s;this.body=e.slice(l,l+a)}s+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Z0e{constructor(e,n){if(!n)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=jn.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=n,this.dracoLoader.preload()}decodePrimitive(e,n){const r=this.json,i=this.dracoLoader,s=e.extensions[this.name].bufferView,a=e.extensions[this.name].attributes,o={},l={},u={};for(const c in a){const d=rF[c]||c.toLowerCase();o[d]=a[c]}for(const c in e.attributes){const d=rF[c]||c.toLowerCase();if(a[c]!==void 0){const h=r.accessors[e.attributes[c]],p=xy[h.componentType];u[d]=p.name,l[d]=h.normalized===!0}}return n.getDependency("bufferView",s).then(function(c){return new Promise(function(d,h){i.decodeDracoFile(c,function(p){for(const f in p.attributes){const g=p.attributes[f],y=l[f];y!==void 0&&(g.normalized=y)}d(p)},o,u,Zu,h)})})}}class Q0e{constructor(){this.name=jn.KHR_TEXTURE_TRANSFORM}extendTexture(e,n){return(n.texCoord===void 0||n.texCoord===e.channel)&&n.offset===void 0&&n.rotation===void 0&&n.scale===void 0||(e=e.clone(),n.texCoord!==void 0&&(e.channel=n.texCoord),n.offset!==void 0&&e.offset.fromArray(n.offset),n.rotation!==void 0&&(e.rotation=n.rotation),n.scale!==void 0&&e.repeat.fromArray(n.scale),e.needsUpdate=!0),e}}class eve{constructor(){this.name=jn.KHR_MESH_QUANTIZATION}}class GX extends m0{constructor(e,n,r,i){super(e,n,r,i)}copySampleValue_(e){const n=this.resultBuffer,r=this.sampleValues,i=this.valueSize,s=e*i*3+i;for(let a=0;a!==i;a++)n[a]=r[s+a];return n}interpolate_(e,n,r,i){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=o*2,u=o*3,c=i-n,d=(r-n)/c,h=d*d,p=h*d,f=e*u,g=f-u,y=-2*p+3*h,m=p-h,b=1-y,w=m-h+d;for(let _=0;_!==o;_++){const S=a[g+_+o],E=a[g+_+l]*c,C=a[f+_+o],T=a[f+_]*c;s[_]=b*S+w*E+y*C+m*T}return s}}const tve=new Kr;class nve extends GX{interpolate_(e,n,r,i){const s=super.interpolate_(e,n,r,i);return tve.fromArray(s).normalize().toArray(s),s}}const ko={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},xy={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},RW={9728:yi,9729:er,9984:$1,9985:Ap,9986:od,9987:Ma},FW={33071:jr,33648:Up,10497:ac},uN={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},rF={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",...f3>=152?{TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3"}:{TEXCOORD_0:"uv",TEXCOORD_1:"uv2"},COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},zc={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},rve={CUBICSPLINE:void 0,LINEAR:zp,STEP:$p},cN={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function ive(t){return t.DefaultMaterial===void 0&&(t.DefaultMaterial=new Zd({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:lu})),t.DefaultMaterial}function Gh(t,e,n){for(const r in n.extensions)t[r]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[r]=n.extensions[r])}function Lu(t,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(t.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function sve(t,e,n){let r=!1,i=!1,s=!1;for(let u=0,c=e.length;u<c;u++){const d=e[u];if(d.POSITION!==void 0&&(r=!0),d.NORMAL!==void 0&&(i=!0),d.COLOR_0!==void 0&&(s=!0),r&&i&&s)break}if(!r&&!i&&!s)return Promise.resolve(t);const a=[],o=[],l=[];for(let u=0,c=e.length;u<c;u++){const d=e[u];if(r){const h=d.POSITION!==void 0?n.getDependency("accessor",d.POSITION):t.attributes.position;a.push(h)}if(i){const h=d.NORMAL!==void 0?n.getDependency("accessor",d.NORMAL):t.attributes.normal;o.push(h)}if(s){const h=d.COLOR_0!==void 0?n.getDependency("accessor",d.COLOR_0):t.attributes.color;l.push(h)}}return Promise.all([Promise.all(a),Promise.all(o),Promise.all(l)]).then(function(u){const c=u[0],d=u[1],h=u[2];return r&&(t.morphAttributes.position=c),i&&(t.morphAttributes.normal=d),s&&(t.morphAttributes.color=h),t.morphTargetsRelative=!0,t})}function ave(t,e){if(t.updateMorphTargets(),e.weights!==void 0)for(let n=0,r=e.weights.length;n<r;n++)t.morphTargetInfluences[n]=e.weights[n];if(e.extras&&Array.isArray(e.extras.targetNames)){const n=e.extras.targetNames;if(t.morphTargetInfluences.length===n.length){t.morphTargetDictionary={};for(let r=0,i=n.length;r<i;r++)t.morphTargetDictionary[n[r]]=r}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function ove(t){let e;const n=t.extensions&&t.extensions[jn.KHR_DRACO_MESH_COMPRESSION];if(n?e="draco:"+n.bufferView+":"+n.indices+":"+dN(n.attributes):e=t.indices+":"+dN(t.attributes)+":"+t.mode,t.targets!==void 0)for(let r=0,i=t.targets.length;r<i;r++)e+=":"+dN(t.targets[r]);return e}function dN(t){let e="";const n=Object.keys(t).sort();for(let r=0,i=n.length;r<i;r++)e+=n[r]+":"+t[n[r]]+";";return e}function iF(t){switch(t){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function lve(t){return t.search(/\.jpe?g($|\?)/i)>0||t.search(/^data\:image\/jpeg/)===0?"image/jpeg":t.search(/\.webp($|\?)/i)>0||t.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const uve=new ln;class cve{constructor(e={},n={}){this.json=e,this.extensions={},this.plugins={},this.options=n,this.cache=new R0e,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let r=!1,i=!1,s=-1;typeof navigator<"u"&&typeof navigator.userAgent<"u"&&(r=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,i=navigator.userAgent.indexOf("Firefox")>-1,s=i?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||r||i&&s<98?this.textureLoader=new qT(this.options.manager):this.textureLoader=new Z9(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new vs(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,n){const r=this,i=this.json,s=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(a){return a._markDefs&&a._markDefs()}),Promise.all(this._invokeAll(function(a){return a.beforeRoot&&a.beforeRoot()})).then(function(){return Promise.all([r.getDependencies("scene"),r.getDependencies("animation"),r.getDependencies("camera")])}).then(function(a){const o={scene:a[0][i.scene||0],scenes:a[0],animations:a[1],cameras:a[2],asset:i.asset,parser:r,userData:{}};return Gh(s,o,i),Lu(o,i),Promise.all(r._invokeAll(function(l){return l.afterRoot&&l.afterRoot(o)})).then(function(){for(const l of o.scenes)l.updateMatrixWorld();e(o)})}).catch(n)}_markDefs(){const e=this.json.nodes||[],n=this.json.skins||[],r=this.json.meshes||[];for(let i=0,s=n.length;i<s;i++){const a=n[i].joints;for(let o=0,l=a.length;o<l;o++)e[a[o]].isBone=!0}for(let i=0,s=e.length;i<s;i++){const a=e[i];a.mesh!==void 0&&(this._addNodeRef(this.meshCache,a.mesh),a.skin!==void 0&&(r[a.mesh].isSkinnedMesh=!0)),a.camera!==void 0&&this._addNodeRef(this.cameraCache,a.camera)}}_addNodeRef(e,n){n!==void 0&&(e.refs[n]===void 0&&(e.refs[n]=e.uses[n]=0),e.refs[n]++)}_getNodeRef(e,n,r){if(e.refs[n]<=1)return r;const i=r.clone(),s=(a,o)=>{const l=this.associations.get(a);l!=null&&this.associations.set(o,l);for(const[u,c]of a.children.entries())s(c,o.children[u])};return s(r,i),i.name+="_instance_"+e.uses[n]++,i}_invokeOne(e){const n=Object.values(this.plugins);n.push(this);for(let r=0;r<n.length;r++){const i=e(n[r]);if(i)return i}return null}_invokeAll(e){const n=Object.values(this.plugins);n.unshift(this);const r=[];for(let i=0;i<n.length;i++){const s=e(n[i]);s&&r.push(s)}return r}getDependency(e,n){const r=e+":"+n;let i=this.cache.get(r);if(!i){switch(e){case"scene":i=this.loadScene(n);break;case"node":i=this._invokeOne(function(s){return s.loadNode&&s.loadNode(n)});break;case"mesh":i=this._invokeOne(function(s){return s.loadMesh&&s.loadMesh(n)});break;case"accessor":i=this.loadAccessor(n);break;case"bufferView":i=this._invokeOne(function(s){return s.loadBufferView&&s.loadBufferView(n)});break;case"buffer":i=this.loadBuffer(n);break;case"material":i=this._invokeOne(function(s){return s.loadMaterial&&s.loadMaterial(n)});break;case"texture":i=this._invokeOne(function(s){return s.loadTexture&&s.loadTexture(n)});break;case"skin":i=this.loadSkin(n);break;case"animation":i=this._invokeOne(function(s){return s.loadAnimation&&s.loadAnimation(n)});break;case"camera":i=this.loadCamera(n);break;default:if(i=this._invokeOne(function(s){return s!=this&&s.getDependency&&s.getDependency(e,n)}),!i)throw new Error("Unknown type: "+e);break}this.cache.add(r,i)}return i}getDependencies(e){let n=this.cache.get(e);if(!n){const r=this,i=this.json[e+(e==="mesh"?"es":"s")]||[];n=Promise.all(i.map(function(s,a){return r.getDependency(e,a)})),this.cache.add(e,n)}return n}loadBuffer(e){const n=this.json.buffers[e],r=this.fileLoader;if(n.type&&n.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+n.type+" buffer type is not supported.");if(n.uri===void 0&&e===0)return Promise.resolve(this.extensions[jn.KHR_BINARY_GLTF].body);const i=this.options;return new Promise(function(s,a){r.load(_d.resolveURL(n.uri,i.path),s,void 0,function(){a(new Error('THREE.GLTFLoader: Failed to load buffer "'+n.uri+'".'))})})}loadBufferView(e){const n=this.json.bufferViews[e];return this.getDependency("buffer",n.buffer).then(function(r){const i=n.byteLength||0,s=n.byteOffset||0;return r.slice(s,s+i)})}loadAccessor(e){const n=this,r=this.json,i=this.json.accessors[e];if(i.bufferView===void 0&&i.sparse===void 0){const a=uN[i.type],o=xy[i.componentType],l=i.normalized===!0,u=new o(i.count*a);return Promise.resolve(new Ln(u,a,l))}const s=[];return i.bufferView!==void 0?s.push(this.getDependency("bufferView",i.bufferView)):s.push(null),i.sparse!==void 0&&(s.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(s).then(function(a){const o=a[0],l=uN[i.type],u=xy[i.componentType],c=u.BYTES_PER_ELEMENT,d=c*l,h=i.byteOffset||0,p=i.bufferView!==void 0?r.bufferViews[i.bufferView].byteStride:void 0,f=i.normalized===!0;let g,y;if(p&&p!==d){const m=Math.floor(h/p),b="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+m+":"+i.count;let w=n.cache.get(b);w||(g=new u(o,m*p,i.count*p/c),w=new j1(g,p/c),n.cache.add(b,w)),y=new kd(w,l,h%p/c,f)}else o===null?g=new u(i.count*l):g=new u(o,h,i.count*l),y=new Ln(g,l,f);if(i.sparse!==void 0){const m=uN.SCALAR,b=xy[i.sparse.indices.componentType],w=i.sparse.indices.byteOffset||0,_=i.sparse.values.byteOffset||0,S=new b(a[1],w,i.sparse.count*m),E=new u(a[2],_,i.sparse.count*l);o!==null&&(y=new Ln(y.array.slice(),y.itemSize,y.normalized));for(let C=0,T=S.length;C<T;C++){const M=S[C];if(y.setX(M,E[C*l]),l>=2&&y.setY(M,E[C*l+1]),l>=3&&y.setZ(M,E[C*l+2]),l>=4&&y.setW(M,E[C*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return y})}loadTexture(e){const n=this.json,r=this.options,s=n.textures[e].source,a=n.images[s];let o=this.textureLoader;if(a.uri){const l=r.manager.getHandler(a.uri);l!==null&&(o=l)}return this.loadTextureImage(e,s,o)}loadTextureImage(e,n,r){const i=this,s=this.json,a=s.textures[e],o=s.images[n],l=(o.uri||o.bufferView)+":"+a.sampler;if(this.textureCache[l])return this.textureCache[l];const u=this.loadImageSource(n,r).then(function(c){c.flipY=!1,c.name=a.name||o.name||"",c.name===""&&typeof o.uri=="string"&&o.uri.startsWith("data:image/")===!1&&(c.name=o.uri);const h=(s.samplers||{})[a.sampler]||{};return c.magFilter=RW[h.magFilter]||er,c.minFilter=RW[h.minFilter]||Ma,c.wrapS=FW[h.wrapS]||ac,c.wrapT=FW[h.wrapT]||ac,i.associations.set(c,{textures:e}),c}).catch(function(){return null});return this.textureCache[l]=u,u}loadImageSource(e,n){const r=this,i=this.json,s=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(d=>d.clone());const a=i.images[e],o=self.URL||self.webkitURL;let l=a.uri||"",u=!1;if(a.bufferView!==void 0)l=r.getDependency("bufferView",a.bufferView).then(function(d){u=!0;const h=new Blob([d],{type:a.mimeType});return l=o.createObjectURL(h),l});else if(a.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const c=Promise.resolve(l).then(function(d){return new Promise(function(h,p){let f=h;n.isImageBitmapLoader===!0&&(f=function(g){const y=new hr(g);y.needsUpdate=!0,h(y)}),n.load(_d.resolveURL(d,s.path),f,void 0,p)})}).then(function(d){return u===!0&&o.revokeObjectURL(l),Lu(d,a),d.userData.mimeType=a.mimeType||lve(a.uri),d}).catch(function(d){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),d});return this.sourceCache[e]=c,c}assignTexture(e,n,r,i){const s=this;return this.getDependency("texture",r.index).then(function(a){if(!a)return null;if(r.texCoord!==void 0&&r.texCoord>0&&(a=a.clone(),a.channel=r.texCoord),s.extensions[jn.KHR_TEXTURE_TRANSFORM]){const o=r.extensions!==void 0?r.extensions[jn.KHR_TEXTURE_TRANSFORM]:void 0;if(o){const l=s.associations.get(a);a=s.extensions[jn.KHR_TEXTURE_TRANSFORM].extendTexture(a,o),s.associations.set(a,l)}}return i!==void 0&&(typeof i=="number"&&(i=i===kW?vp:Zu),"colorSpace"in a?a.colorSpace=i:a.encoding=i===vp?kW:N0e),e[n]=a,a})}assignFinalMaterial(e){const n=e.geometry;let r=e.material;const i=n.attributes.tangent===void 0,s=n.attributes.color!==void 0,a=n.attributes.normal===void 0;if(e.isPoints){const o="PointsMaterial:"+r.uuid;let l=this.cache.get(o);l||(l=new PT,Ki.prototype.copy.call(l,r),l.color.copy(r.color),l.map=r.map,l.sizeAttenuation=!1,this.cache.add(o,l)),r=l}else if(e.isLine){const o="LineBasicMaterial:"+r.uuid;let l=this.cache.get(o);l||(l=new Ws,Ki.prototype.copy.call(l,r),l.color.copy(r.color),l.map=r.map,this.cache.add(o,l)),r=l}if(i||s||a){let o="ClonedMaterial:"+r.uuid+":";i&&(o+="derivative-tangents:"),s&&(o+="vertex-colors:"),a&&(o+="flat-shading:");let l=this.cache.get(o);l||(l=r.clone(),s&&(l.vertexColors=!0),a&&(l.flatShading=!0),i&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(o,l),this.associations.set(l,this.associations.get(r))),r=l}e.material=r}getMaterialType(){return Zd}loadMaterial(e){const n=this,r=this.json,i=this.extensions,s=r.materials[e];let a;const o={},l=s.extensions||{},u=[];if(l[jn.KHR_MATERIALS_UNLIT]){const d=i[jn.KHR_MATERIALS_UNLIT];a=d.getMaterialType(),u.push(d.extendParams(o,s,n))}else{const d=s.pbrMetallicRoughness||{};if(o.color=new Ct(1,1,1),o.opacity=1,Array.isArray(d.baseColorFactor)){const h=d.baseColorFactor;o.color.setRGB(h[0],h[1],h[2],Zu),o.opacity=h[3]}d.baseColorTexture!==void 0&&u.push(n.assignTexture(o,"map",d.baseColorTexture,vp)),o.metalness=d.metallicFactor!==void 0?d.metallicFactor:1,o.roughness=d.roughnessFactor!==void 0?d.roughnessFactor:1,d.metallicRoughnessTexture!==void 0&&(u.push(n.assignTexture(o,"metalnessMap",d.metallicRoughnessTexture)),u.push(n.assignTexture(o,"roughnessMap",d.metallicRoughnessTexture))),a=this._invokeOne(function(h){return h.getMaterialType&&h.getMaterialType(e)}),u.push(Promise.all(this._invokeAll(function(h){return h.extendMaterialParams&&h.extendMaterialParams(e,o)})))}s.doubleSided===!0&&(o.side=ta);const c=s.alphaMode||cN.OPAQUE;if(c===cN.BLEND?(o.transparent=!0,o.depthWrite=!1):(o.transparent=!1,c===cN.MASK&&(o.alphaTest=s.alphaCutoff!==void 0?s.alphaCutoff:.5)),s.normalTexture!==void 0&&a!==ka&&(u.push(n.assignTexture(o,"normalMap",s.normalTexture)),o.normalScale=new Qe(1,1),s.normalTexture.scale!==void 0)){const d=s.normalTexture.scale;o.normalScale.set(d,d)}if(s.occlusionTexture!==void 0&&a!==ka&&(u.push(n.assignTexture(o,"aoMap",s.occlusionTexture)),s.occlusionTexture.strength!==void 0&&(o.aoMapIntensity=s.occlusionTexture.strength)),s.emissiveFactor!==void 0&&a!==ka){const d=s.emissiveFactor;o.emissive=new Ct().setRGB(d[0],d[1],d[2],Zu)}return s.emissiveTexture!==void 0&&a!==ka&&u.push(n.assignTexture(o,"emissiveMap",s.emissiveTexture,vp)),Promise.all(u).then(function(){const d=new a(o);return s.name&&(d.name=s.name),Lu(d,s),n.associations.set(d,{materials:e}),s.extensions&&Gh(i,d,s),d})}createUniqueName(e){const n=Hn.sanitizeNodeName(e||"");return n in this.nodeNamesUsed?n+"_"+ ++this.nodeNamesUsed[n]:(this.nodeNamesUsed[n]=0,n)}loadGeometries(e){const n=this,r=this.extensions,i=this.primitiveCache;function s(o){return r[jn.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o,n).then(function(l){return DW(l,o,n)})}const a=[];for(let o=0,l=e.length;o<l;o++){const u=e[o],c=ove(u),d=i[c];if(d)a.push(d.promise);else{let h;u.extensions&&u.extensions[jn.KHR_DRACO_MESH_COMPRESSION]?h=s(u):h=DW(new An,u,n),i[c]={primitive:u,promise:h},a.push(h)}}return Promise.all(a)}loadMesh(e){const n=this,r=this.json,i=this.extensions,s=r.meshes[e],a=s.primitives,o=[];for(let l=0,u=a.length;l<u;l++){const c=a[l].material===void 0?ive(this.cache):this.getDependency("material",a[l].material);o.push(c)}return o.push(n.loadGeometries(a)),Promise.all(o).then(function(l){const u=l.slice(0,l.length-1),c=l[l.length-1],d=[];for(let p=0,f=c.length;p<f;p++){const g=c[p],y=a[p];let m;const b=u[p];if(y.mode===ko.TRIANGLES||y.mode===ko.TRIANGLE_STRIP||y.mode===ko.TRIANGLE_FAN||y.mode===void 0)m=s.isSkinnedMesh===!0?new FP(g,b):new Cr(g,b),m.isSkinnedMesh===!0&&m.normalizeSkinWeights(),y.mode===ko.TRIANGLE_STRIP?m.geometry=TW(m.geometry,SP):y.mode===ko.TRIANGLE_FAN&&(m.geometry=TW(m.geometry,gI));else if(y.mode===ko.LINES)m=new Tl(g,b);else if(y.mode===ko.LINE_STRIP)m=new lc(g,b);else if(y.mode===ko.LINE_LOOP)m=new PP(g,b);else if(y.mode===ko.POINTS)m=new LP(g,b);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+y.mode);Object.keys(m.geometry.morphAttributes).length>0&&ave(m,s),m.name=n.createUniqueName(s.name||"mesh_"+e),Lu(m,s),y.extensions&&Gh(i,m,y),n.assignFinalMaterial(m),d.push(m)}for(let p=0,f=d.length;p<f;p++)n.associations.set(d[p],{meshes:e,primitives:p});if(d.length===1)return s.extensions&&Gh(i,d[0],s),d[0];const h=new Xu;s.extensions&&Gh(i,h,s),n.associations.set(h,{meshes:e});for(let p=0,f=d.length;p<f;p++)h.add(d[p]);return h})}loadCamera(e){let n;const r=this.json.cameras[e],i=r[r.type];if(!i){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return r.type==="perspective"?n=new Qr(Ju.radToDeg(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):r.type==="orthographic"&&(n=new iu(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),r.name&&(n.name=this.createUniqueName(r.name)),Lu(n,r),Promise.resolve(n)}loadSkin(e){const n=this.json.skins[e],r=[];for(let i=0,s=n.joints.length;i<s;i++)r.push(this._loadNodeShallow(n.joints[i]));return n.inverseBindMatrices!==void 0?r.push(this.getDependency("accessor",n.inverseBindMatrices)):r.push(null),Promise.all(r).then(function(i){const s=i.pop(),a=i,o=[],l=[];for(let u=0,c=a.length;u<c;u++){const d=a[u];if(d){o.push(d);const h=new ln;s!==null&&h.fromArray(s.array,u*16),l.push(h)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',n.joints[u])}return new X1(o,l)})}loadAnimation(e){const n=this.json,r=this,i=n.animations[e],s=i.name?i.name:"animation_"+e,a=[],o=[],l=[],u=[],c=[];for(let d=0,h=i.channels.length;d<h;d++){const p=i.channels[d],f=i.samplers[p.sampler],g=p.target,y=g.node,m=i.parameters!==void 0?i.parameters[f.input]:f.input,b=i.parameters!==void 0?i.parameters[f.output]:f.output;g.node!==void 0&&(a.push(this.getDependency("node",y)),o.push(this.getDependency("accessor",m)),l.push(this.getDependency("accessor",b)),u.push(f),c.push(g))}return Promise.all([Promise.all(a),Promise.all(o),Promise.all(l),Promise.all(u),Promise.all(c)]).then(function(d){const h=d[0],p=d[1],f=d[2],g=d[3],y=d[4],m=[];for(let b=0,w=h.length;b<w;b++){const _=h[b],S=p[b],E=f[b],C=g[b],T=y[b];if(_===void 0)continue;_.updateMatrix&&_.updateMatrix();const M=r._createAnimationTracks(_,S,E,C,T);if(M)for(let k=0;k<M.length;k++)m.push(M[k])}return new Gy(s,void 0,m)})}createNodeMesh(e){const n=this.json,r=this,i=n.nodes[e];return i.mesh===void 0?null:r.getDependency("mesh",i.mesh).then(function(s){const a=r._getNodeRef(r.meshCache,i.mesh,s);return i.weights!==void 0&&a.traverse(function(o){if(o.isMesh)for(let l=0,u=i.weights.length;l<u;l++)o.morphTargetInfluences[l]=i.weights[l]}),a})}loadNode(e){const n=this.json,r=this,i=n.nodes[e],s=r._loadNodeShallow(e),a=[],o=i.children||[];for(let u=0,c=o.length;u<c;u++)a.push(r.getDependency("node",o[u]));const l=i.skin===void 0?Promise.resolve(null):r.getDependency("skin",i.skin);return Promise.all([s,Promise.all(a),l]).then(function(u){const c=u[0],d=u[1],h=u[2];h!==null&&c.traverse(function(p){p.isSkinnedMesh&&p.bind(h,uve)});for(let p=0,f=d.length;p<f;p++)c.add(d[p]);return c})}_loadNodeShallow(e){const n=this.json,r=this.extensions,i=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const s=n.nodes[e],a=s.name?i.createUniqueName(s.name):"",o=[],l=i._invokeOne(function(u){return u.createNodeMesh&&u.createNodeMesh(e)});return l&&o.push(l),s.camera!==void 0&&o.push(i.getDependency("camera",s.camera).then(function(u){return i._getNodeRef(i.cameraCache,s.camera,u)})),i._invokeAll(function(u){return u.createNodeAttachment&&u.createNodeAttachment(e)}).forEach(function(u){o.push(u)}),this.nodeCache[e]=Promise.all(o).then(function(u){let c;if(s.isBone===!0?c=new FT:u.length>1?c=new Xu:u.length===1?c=u[0]:c=new Yn,c!==u[0])for(let d=0,h=u.length;d<h;d++)c.add(u[d]);if(s.name&&(c.userData.name=s.name,c.name=a),Lu(c,s),s.extensions&&Gh(r,c,s),s.matrix!==void 0){const d=new ln;d.fromArray(s.matrix),c.applyMatrix4(d)}else s.translation!==void 0&&c.position.fromArray(s.translation),s.rotation!==void 0&&c.quaternion.fromArray(s.rotation),s.scale!==void 0&&c.scale.fromArray(s.scale);return i.associations.has(c)||i.associations.set(c,{}),i.associations.get(c).nodes=e,c}),this.nodeCache[e]}loadScene(e){const n=this.extensions,r=this.json.scenes[e],i=this,s=new Xu;r.name&&(s.name=i.createUniqueName(r.name)),Lu(s,r),r.extensions&&Gh(n,s,r);const a=r.nodes||[],o=[];for(let l=0,u=a.length;l<u;l++)o.push(i.getDependency("node",a[l]));return Promise.all(o).then(function(l){for(let c=0,d=l.length;c<d;c++)s.add(l[c]);const u=c=>{const d=new Map;for(const[h,p]of i.associations)(h instanceof Ki||h instanceof hr)&&d.set(h,p);return c.traverse(h=>{const p=i.associations.get(h);p!=null&&d.set(h,p)}),d};return i.associations=u(s),s})}_createAnimationTracks(e,n,r,i,s){const a=[],o=e.name?e.name:e.uuid,l=[];zc[s.path]===zc.weights?e.traverse(function(h){h.morphTargetInfluences&&l.push(h.name?h.name:h.uuid)}):l.push(o);let u;switch(zc[s.path]){case zc.weights:u=Wp;break;case zc.rotation:u=Vp;break;case zc.position:case zc.scale:u=jp;break;default:switch(r.itemSize){case 1:u=Wp;break;case 2:case 3:default:u=jp;break}break}const c=i.interpolation!==void 0?rve[i.interpolation]:zp,d=this._getArrayFromAccessor(r);for(let h=0,p=l.length;h<p;h++){const f=new u(l[h]+"."+zc[s.path],n.array,d,c);i.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(f),a.push(f)}return a}_getArrayFromAccessor(e){let n=e.array;if(e.normalized){const r=iF(n.constructor),i=new Float32Array(n.length);for(let s=0,a=n.length;s<a;s++)i[s]=n[s]*r;n=i}return n}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(r){const i=this instanceof Vp?nve:GX;return new i(this.times,this.values,this.getValueSize()/3,r)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function dve(t,e,n){const r=e.attributes,i=new ds;if(r.POSITION!==void 0){const o=n.json.accessors[r.POSITION],l=o.min,u=o.max;if(l!==void 0&&u!==void 0){if(i.set(new Z(l[0],l[1],l[2]),new Z(u[0],u[1],u[2])),o.normalized){const c=iF(xy[o.componentType]);i.min.multiplyScalar(c),i.max.multiplyScalar(c)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const s=e.targets;if(s!==void 0){const o=new Z,l=new Z;for(let u=0,c=s.length;u<c;u++){const d=s[u];if(d.POSITION!==void 0){const h=n.json.accessors[d.POSITION],p=h.min,f=h.max;if(p!==void 0&&f!==void 0){if(l.setX(Math.max(Math.abs(p[0]),Math.abs(f[0]))),l.setY(Math.max(Math.abs(p[1]),Math.abs(f[1]))),l.setZ(Math.max(Math.abs(p[2]),Math.abs(f[2]))),h.normalized){const g=iF(xy[h.componentType]);l.multiplyScalar(g)}o.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(o)}t.boundingBox=i;const a=new Xi;i.getCenter(a.center),a.radius=i.min.distanceTo(i.max)/2,t.boundingSphere=a}function DW(t,e,n){const r=e.attributes,i=[];function s(a,o){return n.getDependency("accessor",a).then(function(l){t.setAttribute(o,l)})}for(const a in r){const o=rF[a]||a.toLowerCase();o in t.attributes||i.push(s(r[a],o))}if(e.indices!==void 0&&!t.index){const a=n.getDependency("accessor",e.indices).then(function(o){t.setIndex(o)});i.push(a)}return Lu(t,e),dve(t,e,n),Promise.all(i).then(function(){return e.targets!==void 0?sve(t,e.targets,n):t})}class hve extends JP{constructor(e){super(e),this.type=Wi}parse(e){const a=function(T,M){switch(T){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(M||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(M||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(M||""));default:case 4:throw new Error("THREE.RGBELoader: Memory Error: "+(M||""))}},c=`
`,d=function(T,M,k){M=M||1024;let N=T.pos,B=-1,z=0,V="",K=String.fromCharCode.apply(null,new Uint16Array(T.subarray(N,N+128)));for(;0>(B=K.indexOf(c))&&z<M&&N<T.byteLength;)V+=K,z+=K.length,N+=128,K+=String.fromCharCode.apply(null,new Uint16Array(T.subarray(N,N+128)));return-1<B?(T.pos+=z+B+1,V+K.slice(0,B)):!1},h=function(T){const M=/^#\?(\S+)/,k=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,R=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,N=/^\s*FORMAT=(\S+)\s*$/,B=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,z={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let V,K;for((T.pos>=T.byteLength||!(V=d(T)))&&a(1,"no header found"),(K=V.match(M))||a(3,"bad initial token"),z.valid|=1,z.programtype=K[1],z.string+=V+`
`;V=d(T),V!==!1;){if(z.string+=V+`
`,V.charAt(0)==="#"){z.comments+=V+`
`;continue}if((K=V.match(k))&&(z.gamma=parseFloat(K[1])),(K=V.match(R))&&(z.exposure=parseFloat(K[1])),(K=V.match(N))&&(z.valid|=2,z.format=K[1]),(K=V.match(B))&&(z.valid|=4,z.height=parseInt(K[1],10),z.width=parseInt(K[2],10)),z.valid&2&&z.valid&4)break}return z.valid&2||a(3,"missing format specifier"),z.valid&4||a(3,"missing image size specifier"),z},p=function(T,M,k){const R=M;if(R<8||R>32767||T[0]!==2||T[1]!==2||T[2]&128)return new Uint8Array(T);R!==(T[2]<<8|T[3])&&a(3,"wrong scanline width");const N=new Uint8Array(4*M*k);N.length||a(4,"unable to allocate buffer space");let B=0,z=0;const V=4*R,K=new Uint8Array(4),Q=new Uint8Array(V);let O=k;for(;O>0&&z<T.byteLength;){z+4>T.byteLength&&a(1),K[0]=T[z++],K[1]=T[z++],K[2]=T[z++],K[3]=T[z++],(K[0]!=2||K[1]!=2||(K[2]<<8|K[3])!=R)&&a(3,"bad rgbe scanline format");let j=0,X;for(;j<V&&z<T.byteLength;){X=T[z++];const le=X>128;if(le&&(X-=128),(X===0||j+X>V)&&a(3,"bad scanline data"),le){const ge=T[z++];for(let ie=0;ie<X;ie++)Q[j++]=ge}else Q.set(T.subarray(z,z+X),j),j+=X,z+=X}const te=R;for(let le=0;le<te;le++){let ge=0;N[B]=Q[le+ge],ge+=R,N[B+1]=Q[le+ge],ge+=R,N[B+2]=Q[le+ge],ge+=R,N[B+3]=Q[le+ge],B+=4}O--}return N},f=function(T,M,k,R){const N=T[M+3],B=Math.pow(2,N-128)/255;k[R+0]=T[M+0]*B,k[R+1]=T[M+1]*B,k[R+2]=T[M+2]*B,k[R+3]=1},g=function(T,M,k,R){const N=T[M+3],B=Math.pow(2,N-128)/255;k[R+0]=mp.toHalfFloat(Math.min(T[M+0]*B,65504)),k[R+1]=mp.toHalfFloat(Math.min(T[M+1]*B,65504)),k[R+2]=mp.toHalfFloat(Math.min(T[M+2]*B,65504)),k[R+3]=mp.toHalfFloat(1)},y=new Uint8Array(e);y.pos=0;const m=h(y),b=m.width,w=m.height,_=p(y.subarray(y.pos),b,w);let S,E,C;switch(this.type){case ti:C=_.length/4;const T=new Float32Array(C*4);for(let k=0;k<C;k++)f(_,k*4,T,k*4);S=T,E=ti;break;case Wi:C=_.length/4;const M=new Uint16Array(C*4);for(let k=0;k<C;k++)g(_,k*4,M,k*4);S=M,E=Wi;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:b,height:w,data:S,header:m.string,gamma:m.gamma,exposure:m.exposure,type:E}}setDataType(e){return this.type=e,this}load(e,n,r,i){function s(a,o){switch(a.type){case ti:case Wi:"colorSpace"in a?a.colorSpace="srgb-linear":a.encoding=3e3,a.minFilter=er,a.magFilter=er,a.generateMipmaps=!1,a.flipY=!0;break}n&&n(a,o)}return super.load(e,s,r,i)}}const Ox=f3>=152;class pve extends JP{constructor(e){super(e),this.type=Wi}parse(e){const M=Math.pow(2.7182818,2.2);function k($,Y){for(var ye=0,De=0;De<65536;++De)(De==0||$[De>>3]&1<<(De&7))&&(Y[ye++]=De);for(var He=ye-1;ye<65536;)Y[ye++]=0;return He}function R($){for(var Y=0;Y<16384;Y++)$[Y]={},$[Y].len=0,$[Y].lit=0,$[Y].p=null}const N={l:0,c:0,lc:0};function B($,Y,ye,De,He){for(;ye<$;)Y=Y<<8|Ot(De,He),ye+=8;ye-=$,N.l=Y>>ye&(1<<$)-1,N.c=Y,N.lc=ye}const z=new Array(59);function V($){for(var Y=0;Y<=58;++Y)z[Y]=0;for(var Y=0;Y<65537;++Y)z[$[Y]]+=1;for(var ye=0,Y=58;Y>0;--Y){var De=ye+z[Y]>>1;z[Y]=ye,ye=De}for(var Y=0;Y<65537;++Y){var He=$[Y];He>0&&($[Y]=He|z[He]++<<6)}}function K($,Y,ye,De,He,Ve,gt){for(var dt=ye,G=0,ae=0;He<=Ve;He++){if(dt.value-ye.value>De)return!1;B(6,G,ae,$,dt);var me=N.l;if(G=N.c,ae=N.lc,gt[He]=me,me==63){if(dt.value-ye.value>De)throw"Something wrong with hufUnpackEncTable";B(8,G,ae,$,dt);var pe=N.l+6;if(G=N.c,ae=N.lc,He+pe>Ve+1)throw"Something wrong with hufUnpackEncTable";for(;pe--;)gt[He++]=0;He--}else if(me>=59){var pe=me-59+2;if(He+pe>Ve+1)throw"Something wrong with hufUnpackEncTable";for(;pe--;)gt[He++]=0;He--}}V(gt)}function Q($){return $&63}function O($){return $>>6}function j($,Y,ye,De){for(;Y<=ye;Y++){var He=O($[Y]),Ve=Q($[Y]);if(He>>Ve)throw"Invalid table entry";if(Ve>14){var gt=De[He>>Ve-14];if(gt.len)throw"Invalid table entry";if(gt.lit++,gt.p){var dt=gt.p;gt.p=new Array(gt.lit);for(var G=0;G<gt.lit-1;++G)gt.p[G]=dt[G]}else gt.p=new Array(1);gt.p[gt.lit-1]=Y}else if(Ve)for(var ae=0,G=1<<14-Ve;G>0;G--){var gt=De[(He<<14-Ve)+ae];if(gt.len||gt.p)throw"Invalid table entry";gt.len=Ve,gt.lit=Y,ae++}}return!0}const X={c:0,lc:0};function te($,Y,ye,De){$=$<<8|Ot(ye,De),Y+=8,X.c=$,X.lc=Y}const le={c:0,lc:0};function ge($,Y,ye,De,He,Ve,gt,dt,G,ae){if($==Y){De<8&&(te(ye,De,He,gt),ye=X.c,De=X.lc),De-=8;var me=ye>>De,me=new Uint8Array([me])[0];if(G.value+me>ae)return!1;for(var pe=dt[G.value-1];me-- >0;)dt[G.value++]=pe}else if(G.value<ae)dt[G.value++]=$;else return!1;le.c=ye,le.lc=De}function ie($){return $&65535}function we($){var Y=ie($);return Y>32767?Y-65536:Y}const Ce={a:0,b:0};function Re($,Y){var ye=we($),De=we(Y),He=De,Ve=ye+(He&1)+(He>>1),gt=Ve,dt=Ve-He;Ce.a=gt,Ce.b=dt}function Le($,Y){var ye=ie($),De=ie(Y),He=ye-(De>>1)&65535,Ve=De+He-32768&65535;Ce.a=Ve,Ce.b=He}function lt($,Y,ye,De,He,Ve,gt){for(var dt=gt<16384,G=ye>He?He:ye,ae=1,me;ae<=G;)ae<<=1;for(ae>>=1,me=ae,ae>>=1;ae>=1;){for(var pe=0,_e=pe+Ve*(He-me),Fe=Ve*ae,je=Ve*me,ot=De*ae,at=De*me,bt,It,ct,Rt;pe<=_e;pe+=je){for(var jt=pe,un=pe+De*(ye-me);jt<=un;jt+=at){var Kt=jt+ot,tn=jt+Fe,Wt=tn+ot;dt?(Re($[jt+Y],$[tn+Y]),bt=Ce.a,ct=Ce.b,Re($[Kt+Y],$[Wt+Y]),It=Ce.a,Rt=Ce.b,Re(bt,It),$[jt+Y]=Ce.a,$[Kt+Y]=Ce.b,Re(ct,Rt),$[tn+Y]=Ce.a,$[Wt+Y]=Ce.b):(Le($[jt+Y],$[tn+Y]),bt=Ce.a,ct=Ce.b,Le($[Kt+Y],$[Wt+Y]),It=Ce.a,Rt=Ce.b,Le(bt,It),$[jt+Y]=Ce.a,$[Kt+Y]=Ce.b,Le(ct,Rt),$[tn+Y]=Ce.a,$[Wt+Y]=Ce.b)}if(ye&ae){var tn=jt+Fe;dt?Re($[jt+Y],$[tn+Y]):Le($[jt+Y],$[tn+Y]),bt=Ce.a,$[tn+Y]=Ce.b,$[jt+Y]=bt}}if(He&ae)for(var jt=pe,un=pe+De*(ye-me);jt<=un;jt+=at){var Kt=jt+ot;dt?Re($[jt+Y],$[Kt+Y]):Le($[jt+Y],$[Kt+Y]),bt=Ce.a,$[Kt+Y]=Ce.b,$[jt+Y]=bt}me=ae,ae>>=1}return pe}function st($,Y,ye,De,He,Ve,gt,dt,G,ae){for(var me=0,pe=0,_e=dt,Fe=Math.trunc(He.value+(Ve+7)/8);He.value<Fe;)for(te(me,pe,ye,He),me=X.c,pe=X.lc;pe>=14;){var je=me>>pe-14&16383,ot=Y[je];if(ot.len)pe-=ot.len,ge(ot.lit,gt,me,pe,ye,De,He,G,ae,_e),me=le.c,pe=le.lc;else{if(!ot.p)throw"hufDecode issues";var at;for(at=0;at<ot.lit;at++){for(var bt=Q($[ot.p[at]]);pe<bt&&He.value<Fe;)te(me,pe,ye,He),me=X.c,pe=X.lc;if(pe>=bt&&O($[ot.p[at]])==(me>>pe-bt&(1<<bt)-1)){pe-=bt,ge(ot.p[at],gt,me,pe,ye,De,He,G,ae,_e),me=le.c,pe=le.lc;break}}if(at==ot.lit)throw"hufDecode issues"}}var It=8-Ve&7;for(me>>=It,pe-=It;pe>0;){var ot=Y[me<<14-pe&16383];if(ot.len)pe-=ot.len,ge(ot.lit,gt,me,pe,ye,De,He,G,ae,_e),me=le.c,pe=le.lc;else throw"hufDecode issues"}return!0}function Et($,Y,ye,De,He,Ve){var gt={value:0},dt=ye.value,G=mt(Y,ye),ae=mt(Y,ye);ye.value+=4;var me=mt(Y,ye);if(ye.value+=4,G<0||G>=65537||ae<0||ae>=65537)throw"Something wrong with HUF_ENCSIZE";var pe=new Array(65537),_e=new Array(16384);R(_e);var Fe=De-(ye.value-dt);if(K($,Y,ye,Fe,G,ae,pe),me>8*(De-(ye.value-dt)))throw"Something wrong with hufUncompress";j(pe,G,ae,_e),st(pe,_e,$,Y,ye,me,ae,Ve,He,gt)}function Tt($,Y,ye){for(var De=0;De<ye;++De)Y[De]=$[Y[De]]}function xt($){for(var Y=1;Y<$.length;Y++){var ye=$[Y-1]+$[Y]-128;$[Y]=ye}}function J($,Y){for(var ye=0,De=Math.floor(($.length+1)/2),He=0,Ve=$.length-1;!(He>Ve||(Y[He++]=$[ye++],He>Ve));)Y[He++]=$[De++]}function Ye($){for(var Y=$.byteLength,ye=new Array,De=0,He=new DataView($);Y>0;){var Ve=He.getInt8(De++);if(Ve<0){var gt=-Ve;Y-=gt+1;for(var dt=0;dt<gt;dt++)ye.push(He.getUint8(De++))}else{var gt=Ve;Y-=2;for(var G=He.getUint8(De++),dt=0;dt<gt+1;dt++)ye.push(G)}}return ye}function Be($,Y,ye,De,He,Ve){var Kt=new DataView(Ve.buffer),gt=ye[$.idx[0]].width,dt=ye[$.idx[0]].height,G=3,ae=Math.floor(gt/8),me=Math.ceil(gt/8),pe=Math.ceil(dt/8),_e=gt-(me-1)*8,Fe=dt-(pe-1)*8,je={value:0},ot=new Array(G),at=new Array(G),bt=new Array(G),It=new Array(G),ct=new Array(G);for(let _n=0;_n<G;++_n)ct[_n]=Y[$.idx[_n]],ot[_n]=_n<1?0:ot[_n-1]+me*pe,at[_n]=new Float32Array(64),bt[_n]=new Uint16Array(64),It[_n]=new Uint16Array(me*64);for(let _n=0;_n<pe;++_n){var Rt=8;_n==pe-1&&(Rt=Fe);var jt=8;for(let Sn=0;Sn<me;++Sn){Sn==me-1&&(jt=_e);for(let Un=0;Un<G;++Un)bt[Un].fill(0),bt[Un][0]=He[ot[Un]++],tt(je,De,bt[Un]),Ue(bt[Un],at[Un]),St(at[Un]);Je(at);for(let Un=0;Un<G;++Un)At(at[Un],It[Un],Sn*64)}let Ar=0;for(let Sn=0;Sn<G;++Sn){const Un=ye[$.idx[Sn]].type;for(let fn=8*_n;fn<8*_n+Rt;++fn){Ar=ct[Sn][fn];for(let Dr=0;Dr<ae;++Dr){const ir=Dr*64+(fn&7)*8;Kt.setUint16(Ar+0*2*Un,It[Sn][ir+0],!0),Kt.setUint16(Ar+1*2*Un,It[Sn][ir+1],!0),Kt.setUint16(Ar+2*2*Un,It[Sn][ir+2],!0),Kt.setUint16(Ar+3*2*Un,It[Sn][ir+3],!0),Kt.setUint16(Ar+4*2*Un,It[Sn][ir+4],!0),Kt.setUint16(Ar+5*2*Un,It[Sn][ir+5],!0),Kt.setUint16(Ar+6*2*Un,It[Sn][ir+6],!0),Kt.setUint16(Ar+7*2*Un,It[Sn][ir+7],!0),Ar+=8*2*Un}}if(ae!=me)for(let fn=8*_n;fn<8*_n+Rt;++fn){const Dr=ct[Sn][fn]+8*ae*2*Un,ir=ae*64+(fn&7)*8;for(let gr=0;gr<jt;++gr)Kt.setUint16(Dr+gr*2*Un,It[Sn][ir+gr],!0)}}}for(var un=new Uint16Array(gt),Kt=new DataView(Ve.buffer),tn=0;tn<G;++tn){ye[$.idx[tn]].decoded=!0;var Wt=ye[$.idx[tn]].type;if(ye[tn].type==2)for(var Bn=0;Bn<dt;++Bn){const _n=ct[tn][Bn];for(var pn=0;pn<gt;++pn)un[pn]=Kt.getUint16(_n+pn*2*Wt,!0);for(var pn=0;pn<gt;++pn)Kt.setFloat32(_n+pn*2*Wt,Ne(un[pn]),!0)}}}function tt($,Y,ye){for(var De,He=1;He<64;)De=Y[$.value],De==65280?He=64:De>>8==255?He+=De&255:(ye[He]=De,He++),$.value++}function Ue($,Y){Y[0]=Ne($[0]),Y[1]=Ne($[1]),Y[2]=Ne($[5]),Y[3]=Ne($[6]),Y[4]=Ne($[14]),Y[5]=Ne($[15]),Y[6]=Ne($[27]),Y[7]=Ne($[28]),Y[8]=Ne($[2]),Y[9]=Ne($[4]),Y[10]=Ne($[7]),Y[11]=Ne($[13]),Y[12]=Ne($[16]),Y[13]=Ne($[26]),Y[14]=Ne($[29]),Y[15]=Ne($[42]),Y[16]=Ne($[3]),Y[17]=Ne($[8]),Y[18]=Ne($[12]),Y[19]=Ne($[17]),Y[20]=Ne($[25]),Y[21]=Ne($[30]),Y[22]=Ne($[41]),Y[23]=Ne($[43]),Y[24]=Ne($[9]),Y[25]=Ne($[11]),Y[26]=Ne($[18]),Y[27]=Ne($[24]),Y[28]=Ne($[31]),Y[29]=Ne($[40]),Y[30]=Ne($[44]),Y[31]=Ne($[53]),Y[32]=Ne($[10]),Y[33]=Ne($[19]),Y[34]=Ne($[23]),Y[35]=Ne($[32]),Y[36]=Ne($[39]),Y[37]=Ne($[45]),Y[38]=Ne($[52]),Y[39]=Ne($[54]),Y[40]=Ne($[20]),Y[41]=Ne($[22]),Y[42]=Ne($[33]),Y[43]=Ne($[38]),Y[44]=Ne($[46]),Y[45]=Ne($[51]),Y[46]=Ne($[55]),Y[47]=Ne($[60]),Y[48]=Ne($[21]),Y[49]=Ne($[34]),Y[50]=Ne($[37]),Y[51]=Ne($[47]),Y[52]=Ne($[50]),Y[53]=Ne($[56]),Y[54]=Ne($[59]),Y[55]=Ne($[61]),Y[56]=Ne($[35]),Y[57]=Ne($[36]),Y[58]=Ne($[48]),Y[59]=Ne($[49]),Y[60]=Ne($[57]),Y[61]=Ne($[58]),Y[62]=Ne($[62]),Y[63]=Ne($[63])}function St($){const Y=.5*Math.cos(.7853975),ye=.5*Math.cos(3.14159/16),De=.5*Math.cos(3.14159/8),He=.5*Math.cos(3*3.14159/16),Ve=.5*Math.cos(5*3.14159/16),gt=.5*Math.cos(3*3.14159/8),dt=.5*Math.cos(7*3.14159/16);for(var G=new Array(4),ae=new Array(4),me=new Array(4),pe=new Array(4),_e=0;_e<8;++_e){var Fe=_e*8;G[0]=De*$[Fe+2],G[1]=gt*$[Fe+2],G[2]=De*$[Fe+6],G[3]=gt*$[Fe+6],ae[0]=ye*$[Fe+1]+He*$[Fe+3]+Ve*$[Fe+5]+dt*$[Fe+7],ae[1]=He*$[Fe+1]-dt*$[Fe+3]-ye*$[Fe+5]-Ve*$[Fe+7],ae[2]=Ve*$[Fe+1]-ye*$[Fe+3]+dt*$[Fe+5]+He*$[Fe+7],ae[3]=dt*$[Fe+1]-Ve*$[Fe+3]+He*$[Fe+5]-ye*$[Fe+7],me[0]=Y*($[Fe+0]+$[Fe+4]),me[3]=Y*($[Fe+0]-$[Fe+4]),me[1]=G[0]+G[3],me[2]=G[1]-G[2],pe[0]=me[0]+me[1],pe[1]=me[3]+me[2],pe[2]=me[3]-me[2],pe[3]=me[0]-me[1],$[Fe+0]=pe[0]+ae[0],$[Fe+1]=pe[1]+ae[1],$[Fe+2]=pe[2]+ae[2],$[Fe+3]=pe[3]+ae[3],$[Fe+4]=pe[3]-ae[3],$[Fe+5]=pe[2]-ae[2],$[Fe+6]=pe[1]-ae[1],$[Fe+7]=pe[0]-ae[0]}for(var je=0;je<8;++je)G[0]=De*$[16+je],G[1]=gt*$[16+je],G[2]=De*$[48+je],G[3]=gt*$[48+je],ae[0]=ye*$[8+je]+He*$[24+je]+Ve*$[40+je]+dt*$[56+je],ae[1]=He*$[8+je]-dt*$[24+je]-ye*$[40+je]-Ve*$[56+je],ae[2]=Ve*$[8+je]-ye*$[24+je]+dt*$[40+je]+He*$[56+je],ae[3]=dt*$[8+je]-Ve*$[24+je]+He*$[40+je]-ye*$[56+je],me[0]=Y*($[je]+$[32+je]),me[3]=Y*($[je]-$[32+je]),me[1]=G[0]+G[3],me[2]=G[1]-G[2],pe[0]=me[0]+me[1],pe[1]=me[3]+me[2],pe[2]=me[3]-me[2],pe[3]=me[0]-me[1],$[0+je]=pe[0]+ae[0],$[8+je]=pe[1]+ae[1],$[16+je]=pe[2]+ae[2],$[24+je]=pe[3]+ae[3],$[32+je]=pe[3]-ae[3],$[40+je]=pe[2]-ae[2],$[48+je]=pe[1]-ae[1],$[56+je]=pe[0]-ae[0]}function Je($){for(var Y=0;Y<64;++Y){var ye=$[0][Y],De=$[1][Y],He=$[2][Y];$[0][Y]=ye+1.5747*He,$[1][Y]=ye-.1873*De-.4682*He,$[2][Y]=ye+1.8556*De}}function At($,Y,ye){for(var De=0;De<64;++De)Y[ye+De]=mp.toHalfFloat(Vt($[De]))}function Vt($){return $<=1?Math.sign($)*Math.pow(Math.abs($),2.2):Math.sign($)*Math.pow(M,Math.abs($)-1)}function re($){return new DataView($.array.buffer,$.offset.value,$.size)}function H($){var Y=$.viewer.buffer.slice($.offset.value,$.offset.value+$.size),ye=new Uint8Array(Ye(Y)),De=new Uint8Array(ye.length);return xt(ye),J(ye,De),new DataView(De.buffer)}function Ee($){var Y=$.array.slice($.offset.value,$.offset.value+$.size),ye=dA(Y),De=new Uint8Array(ye.length);return xt(ye),J(ye,De),new DataView(De.buffer)}function Oe($){for(var Y=$.viewer,ye={value:$.offset.value},De=new Uint16Array($.width*$.scanlineBlockSize*($.channels*$.type)),He=new Uint8Array(8192),Ve=0,gt=new Array($.channels),dt=0;dt<$.channels;dt++)gt[dt]={},gt[dt].start=Ve,gt[dt].end=gt[dt].start,gt[dt].nx=$.width,gt[dt].ny=$.lines,gt[dt].size=$.type,Ve+=gt[dt].nx*gt[dt].ny*gt[dt].size;var G=nt(Y,ye),ae=nt(Y,ye);if(ae>=8192)throw"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";if(G<=ae)for(var dt=0;dt<ae-G+1;dt++)He[dt+G]=he(Y,ye);var me=new Uint16Array(65536),pe=k(He,me),_e=mt(Y,ye);Et($.array,Y,ye,_e,De,Ve);for(var dt=0;dt<$.channels;++dt)for(var Fe=gt[dt],je=0;je<gt[dt].size;++je)lt(De,Fe.start+je,Fe.nx,Fe.size,Fe.ny,Fe.nx*Fe.size,pe);Tt(me,De,Ve);for(var ot=0,at=new Uint8Array(De.buffer.byteLength),bt=0;bt<$.lines;bt++)for(var It=0;It<$.channels;It++){var Fe=gt[It],ct=Fe.nx*Fe.size,Rt=new Uint8Array(De.buffer,Fe.end*2,ct*2);at.set(Rt,ot),ot+=ct*2,Fe.end+=ct}return new DataView(at.buffer)}function Xe($){var Y=$.array.slice($.offset.value,$.offset.value+$.size),ye=dA(Y);const De=$.lines*$.channels*$.width,He=$.type==1?new Uint16Array(De):new Uint32Array(De);let Ve=0,gt=0;const dt=new Array(4);for(let G=0;G<$.lines;G++)for(let ae=0;ae<$.channels;ae++){let me=0;switch($.type){case 1:dt[0]=Ve,dt[1]=dt[0]+$.width,Ve=dt[1]+$.width;for(let pe=0;pe<$.width;++pe){const _e=ye[dt[0]++]<<8|ye[dt[1]++];me+=_e,He[gt]=me,gt++}break;case 2:dt[0]=Ve,dt[1]=dt[0]+$.width,dt[2]=dt[1]+$.width,Ve=dt[2]+$.width;for(let pe=0;pe<$.width;++pe){const _e=ye[dt[0]++]<<24|ye[dt[1]++]<<16|ye[dt[2]++]<<8;me+=_e,He[gt]=me,gt++}break}}return new DataView(He.buffer)}function $e($){var Y=$.viewer,ye={value:$.offset.value},De=new Uint8Array($.width*$.lines*($.channels*$.type*2)),He={version:Me(Y,ye),unknownUncompressedSize:Me(Y,ye),unknownCompressedSize:Me(Y,ye),acCompressedSize:Me(Y,ye),dcCompressedSize:Me(Y,ye),rleCompressedSize:Me(Y,ye),rleUncompressedSize:Me(Y,ye),rleRawSize:Me(Y,ye),totalAcUncompressedCount:Me(Y,ye),totalDcUncompressedCount:Me(Y,ye),acCompression:Me(Y,ye)};if(He.version<2)throw"EXRLoader.parse: "+zr.compression+" version "+He.version+" is unsupported";for(var Ve=new Array,gt=nt(Y,ye)-2;gt>0;){var dt=Lt(Y.buffer,ye),G=he(Y,ye),ae=G>>2&3,me=(G>>4)-1,pe=new Int8Array([me])[0],_e=he(Y,ye);Ve.push({name:dt,index:pe,type:_e,compression:ae}),gt-=dt.length+3}for(var Fe=zr.channels,je=new Array($.channels),ot=0;ot<$.channels;++ot){var at=je[ot]={},bt=Fe[ot];at.name=bt.name,at.compression=0,at.decoded=!1,at.type=bt.pixelType,at.pLinear=bt.pLinear,at.width=$.width,at.height=$.lines}for(var It={idx:new Array(3)},ct=0;ct<$.channels;++ct)for(var at=je[ct],ot=0;ot<Ve.length;++ot){var Rt=Ve[ot];at.name==Rt.name&&(at.compression=Rt.compression,Rt.index>=0&&(It.idx[Rt.index]=ct),at.offset=ct)}if(He.acCompressedSize>0)switch(He.acCompression){case 0:var Kt=new Uint16Array(He.totalAcUncompressedCount);Et($.array,Y,ye,He.acCompressedSize,Kt,He.totalAcUncompressedCount);break;case 1:var jt=$.array.slice(ye.value,ye.value+He.totalAcUncompressedCount),un=dA(jt),Kt=new Uint16Array(un.buffer);ye.value+=He.totalAcUncompressedCount;break}if(He.dcCompressedSize>0){var tn={array:$.array,offset:ye,size:He.dcCompressedSize},Wt=new Uint16Array(Ee(tn).buffer);ye.value+=He.dcCompressedSize}if(He.rleRawSize>0){var jt=$.array.slice(ye.value,ye.value+He.rleCompressedSize),un=dA(jt),Bn=Ye(un.buffer);ye.value+=He.rleCompressedSize}for(var pn=0,_n=new Array(je.length),ot=0;ot<_n.length;++ot)_n[ot]=new Array;for(var Ar=0;Ar<$.lines;++Ar)for(var Sn=0;Sn<je.length;++Sn)_n[Sn].push(pn),pn+=je[Sn].width*$.type*2;Be(It,_n,je,Kt,Wt,De);for(var ot=0;ot<je.length;++ot){var at=je[ot];if(!at.decoded)switch(at.compression){case 2:for(var Un=0,fn=0,Ar=0;Ar<$.lines;++Ar){for(var Dr=_n[ot][Un],ir=0;ir<at.width;++ir){for(var gr=0;gr<2*at.type;++gr)De[Dr++]=Bn[fn+gr*at.width*at.height];fn++}Un++}break;case 1:default:throw"EXRLoader.parse: unsupported channel compression"}}return new DataView(De.buffer)}function Lt($,Y){for(var ye=new Uint8Array($),De=0;ye[Y.value+De]!=0;)De+=1;var He=new TextDecoder().decode(ye.slice(Y.value,Y.value+De));return Y.value=Y.value+De+1,He}function wt($,Y,ye){var De=new TextDecoder().decode(new Uint8Array($).slice(Y.value,Y.value+ye));return Y.value=Y.value+ye,De}function Pt($,Y){var ye=et($,Y),De=mt($,Y);return[ye,De]}function Ht($,Y){var ye=mt($,Y),De=mt($,Y);return[ye,De]}function et($,Y){var ye=$.getInt32(Y.value,!0);return Y.value=Y.value+4,ye}function mt($,Y){var ye=$.getUint32(Y.value,!0);return Y.value=Y.value+4,ye}function Ot($,Y){var ye=$[Y.value];return Y.value=Y.value+1,ye}function he($,Y){var ye=$.getUint8(Y.value);return Y.value=Y.value+1,ye}const Me=function($,Y){let ye;return"getBigInt64"in DataView.prototype?ye=Number($.getBigInt64(Y.value,!0)):ye=$.getUint32(Y.value+4,!0)+Number($.getUint32(Y.value,!0)<<32),Y.value+=8,ye};function it($,Y){var ye=$.getFloat32(Y.value,!0);return Y.value+=4,ye}function de($,Y){return mp.toHalfFloat(it($,Y))}function Ne($){var Y=($&31744)>>10,ye=$&1023;return($>>15?-1:1)*(Y?Y===31?ye?NaN:1/0:Math.pow(2,Y-15)*(1+ye/1024):6103515625e-14*(ye/1024))}function nt($,Y){var ye=$.getUint16(Y.value,!0);return Y.value+=2,ye}function Mt($,Y){return Ne(nt($,Y))}function ut($,Y,ye,De){for(var He=ye.value,Ve=[];ye.value<He+De-1;){var gt=Lt(Y,ye),dt=et($,ye),G=he($,ye);ye.value+=3;var ae=et($,ye),me=et($,ye);Ve.push({name:gt,pixelType:dt,pLinear:G,xSampling:ae,ySampling:me})}return ye.value+=1,Ve}function Ze($,Y){var ye=it($,Y),De=it($,Y),He=it($,Y),Ve=it($,Y),gt=it($,Y),dt=it($,Y),G=it($,Y),ae=it($,Y);return{redX:ye,redY:De,greenX:He,greenY:Ve,blueX:gt,blueY:dt,whiteX:G,whiteY:ae}}function kt($,Y){var ye=["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"],De=he($,Y);return ye[De]}function Se($,Y){var ye=mt($,Y),De=mt($,Y),He=mt($,Y),Ve=mt($,Y);return{xMin:ye,yMin:De,xMax:He,yMax:Ve}}function qe($,Y){var ye=["INCREASING_Y"],De=he($,Y);return ye[De]}function pt($,Y){var ye=it($,Y),De=it($,Y);return[ye,De]}function ht($,Y){var ye=it($,Y),De=it($,Y),He=it($,Y);return[ye,De,He]}function xn($,Y,ye,De,He){if(De==="string"||De==="stringvector"||De==="iccProfile")return wt(Y,ye,He);if(De==="chlist")return ut($,Y,ye,He);if(De==="chromaticities")return Ze($,ye);if(De==="compression")return kt($,ye);if(De==="box2i")return Se($,ye);if(De==="lineOrder")return qe($,ye);if(De==="float")return it($,ye);if(De==="v2f")return pt($,ye);if(De==="v3f")return ht($,ye);if(De==="int")return et($,ye);if(De==="rational")return Pt($,ye);if(De==="timecode")return Ht($,ye);if(De==="preview")return ye.value+=He,"skipped";ye.value+=He}function ar($,Y,ye){const De={};if($.getUint32(0,!0)!=20000630)throw"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";De.version=$.getUint8(4);const He=$.getUint8(5);De.spec={singleTile:!!(He&2),longName:!!(He&4),deepFormat:!!(He&8),multiPart:!!(He&16)},ye.value=8;for(var Ve=!0;Ve;){var gt=Lt(Y,ye);if(gt==0)Ve=!1;else{var dt=Lt(Y,ye),G=mt($,ye),ae=xn($,Y,ye,dt,G);ae===void 0?console.warn(`EXRLoader.parse: skipped unknown header attribute type '${dt}'.`):De[gt]=ae}}if(He&-5)throw console.error("EXRHeader:",De),"THREE.EXRLoader: provided file is currently unsupported.";return De}function gn($,Y,ye,De,He){const Ve={size:0,viewer:Y,array:ye,offset:De,width:$.dataWindow.xMax-$.dataWindow.xMin+1,height:$.dataWindow.yMax-$.dataWindow.yMin+1,channels:$.channels.length,bytesPerLine:null,lines:null,inputSize:null,type:$.channels[0].pixelType,uncompress:null,getter:null,format:null,[Ox?"colorSpace":"encoding"]:null};switch($.compression){case"NO_COMPRESSION":Ve.lines=1,Ve.uncompress=re;break;case"RLE_COMPRESSION":Ve.lines=1,Ve.uncompress=H;break;case"ZIPS_COMPRESSION":Ve.lines=1,Ve.uncompress=Ee;break;case"ZIP_COMPRESSION":Ve.lines=16,Ve.uncompress=Ee;break;case"PIZ_COMPRESSION":Ve.lines=32,Ve.uncompress=Oe;break;case"PXR24_COMPRESSION":Ve.lines=16,Ve.uncompress=Xe;break;case"DWAA_COMPRESSION":Ve.lines=32,Ve.uncompress=$e;break;case"DWAB_COMPRESSION":Ve.lines=256,Ve.uncompress=$e;break;default:throw"EXRLoader.parse: "+$.compression+" is unsupported"}if(Ve.scanlineBlockSize=Ve.lines,Ve.type==1)switch(He){case ti:Ve.getter=Mt,Ve.inputSize=2;break;case Wi:Ve.getter=nt,Ve.inputSize=2;break}else if(Ve.type==2)switch(He){case ti:Ve.getter=it,Ve.inputSize=4;break;case Wi:Ve.getter=de,Ve.inputSize=4}else throw"EXRLoader.parse: unsupported pixelType "+Ve.type+" for "+$.compression+".";Ve.blockCount=($.dataWindow.yMax+1)/Ve.scanlineBlockSize;for(var gt=0;gt<Ve.blockCount;gt++)Me(Y,De);Ve.outputChannels=Ve.channels==3?4:Ve.channels;const dt=Ve.width*Ve.height*Ve.outputChannels;switch(He){case ti:Ve.byteArray=new Float32Array(dt),Ve.channels<Ve.outputChannels&&Ve.byteArray.fill(1,0,dt);break;case Wi:Ve.byteArray=new Uint16Array(dt),Ve.channels<Ve.outputChannels&&Ve.byteArray.fill(15360,0,dt);break;default:console.error("THREE.EXRLoader: unsupported type: ",He);break}return Ve.bytesPerLine=Ve.width*Ve.inputSize*Ve.channels,Ve.outputChannels==4?Ve.format=ui:Ve.format=G1,Ox?Ve.colorSpace="srgb-linear":Ve.encoding=3e3,Ve}const sn=new DataView(e),ur=new Uint8Array(e),$r={value:0},zr=ar(sn,e,$r),yn=gn(zr,sn,ur,$r,this.type),Wa={value:0},Va={R:0,G:1,B:2,A:3,Y:0};for(let $=0;$<yn.height/yn.scanlineBlockSize;$++){const Y=mt(sn,$r);yn.size=mt(sn,$r),yn.lines=Y+yn.scanlineBlockSize>yn.height?yn.height-Y:yn.scanlineBlockSize;const De=yn.size<yn.lines*yn.bytesPerLine?yn.uncompress(yn):re(yn);$r.value+=yn.size;for(let He=0;He<yn.scanlineBlockSize;He++){const Ve=He+$*yn.scanlineBlockSize;if(Ve>=yn.height)break;for(let gt=0;gt<yn.channels;gt++){const dt=Va[zr.channels[gt].name];for(let G=0;G<yn.width;G++){Wa.value=(He*(yn.channels*yn.width)+gt*yn.width+G)*yn.inputSize;const ae=(yn.height-1-Ve)*(yn.width*yn.outputChannels)+G*yn.outputChannels+dt;yn.byteArray[ae]=yn.getter(De,Wa)}}}}return{header:zr,width:yn.width,height:yn.height,data:yn.byteArray,format:yn.format,[Ox?"colorSpace":"encoding"]:yn[Ox?"colorSpace":"encoding"],type:this.type}}setDataType(e){return this.type=e,this}load(e,n,r,i){function s(a,o){Ox?a.colorSpace=o.colorSpace:a.encoding=o.encoding,a.minFilter=er,a.magFilter=er,a.generateMipmaps=!1,a.flipY=!1,n&&n(a,o)}return super.load(e,s,r,i)}}const hN=new WeakMap;class fve extends _s{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,n,r,i){const s=new vs(this.manager);s.setPath(this.path),s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,a=>{const o={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(a,o).then(n).catch(i)},r,i)}decodeDracoFile(e,n,r,i){const s={attributeIDs:r||this.defaultAttributeIDs,attributeTypes:i||this.defaultAttributeTypes,useUniqueIDs:!!r};this.decodeGeometry(e,s).then(n)}decodeGeometry(e,n){for(const l in n.attributeTypes){const u=n.attributeTypes[l];u.BYTES_PER_ELEMENT!==void 0&&(n.attributeTypes[l]=u.name)}const r=JSON.stringify(n);if(hN.has(e)){const l=hN.get(e);if(l.key===r)return l.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let i;const s=this.workerNextTaskID++,a=e.byteLength,o=this._getWorker(s,a).then(l=>(i=l,new Promise((u,c)=>{i._callbacks[s]={resolve:u,reject:c},i.postMessage({type:"decode",id:s,taskConfig:n,buffer:e},[e])}))).then(l=>this._createGeometry(l.geometry));return o.catch(()=>!0).then(()=>{i&&s&&this._releaseTask(i,s)}),hN.set(e,{key:r,promise:o}),o}_createGeometry(e){const n=new An;e.index&&n.setIndex(new Ln(e.index.array,1));for(let r=0;r<e.attributes.length;r++){const i=e.attributes[r],s=i.name,a=i.array,o=i.itemSize;n.setAttribute(s,new Ln(a,o))}return n}_loadLibrary(e,n){const r=new vs(this.manager);return r.setPath(this.decoderPath),r.setResponseType(n),r.setWithCredentials(this.withCredentials),new Promise((i,s)=>{r.load(e,i,void 0,s)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",n=[];return e?n.push(this._loadLibrary("draco_decoder.js","text")):(n.push(this._loadLibrary("draco_wasm_wrapper.js","text")),n.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(n).then(r=>{const i=r[0];e||(this.decoderConfig.wasmBinary=r[1]);const s=mve.toString(),a=["/* draco decoder */",i,"","/* worker */",s.substring(s.indexOf("{")+1,s.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([a]))}),this.decoderPending}_getWorker(e,n){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const i=new Worker(this.workerSourceURL);i._callbacks={},i._taskCosts={},i._taskLoad=0,i.postMessage({type:"init",decoderConfig:this.decoderConfig}),i.onmessage=function(s){const a=s.data;switch(a.type){case"decode":i._callbacks[a.id].resolve(a);break;case"error":i._callbacks[a.id].reject(a);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+a.type+'"')}},this.workerPool.push(i)}else this.workerPool.sort(function(i,s){return i._taskLoad>s._taskLoad?-1:1});const r=this.workerPool[this.workerPool.length-1];return r._taskCosts[e]=n,r._taskLoad+=n,r})}_releaseTask(e,n){e._taskLoad-=e._taskCosts[n],delete e._callbacks[n],delete e._taskCosts[n]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function mve(){let t,e;onmessage=function(a){const o=a.data;switch(o.type){case"init":t=o.decoderConfig,e=new Promise(function(c){t.onModuleLoaded=function(d){c({draco:d})},DracoDecoderModule(t)});break;case"decode":const l=o.buffer,u=o.taskConfig;e.then(c=>{const d=c.draco,h=new d.Decoder,p=new d.DecoderBuffer;p.Init(new Int8Array(l),l.byteLength);try{const f=n(d,h,p,u),g=f.attributes.map(y=>y.array.buffer);f.index&&g.push(f.index.array.buffer),self.postMessage({type:"decode",id:o.id,geometry:f},g)}catch(f){console.error(f),self.postMessage({type:"error",id:o.id,error:f.message})}finally{d.destroy(p),d.destroy(h)}});break}};function n(a,o,l,u){const c=u.attributeIDs,d=u.attributeTypes;let h,p;const f=o.GetEncodedGeometryType(l);if(f===a.TRIANGULAR_MESH)h=new a.Mesh,p=o.DecodeBufferToMesh(l,h);else if(f===a.POINT_CLOUD)h=new a.PointCloud,p=o.DecodeBufferToPointCloud(l,h);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!p.ok()||h.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+p.error_msg());const g={index:null,attributes:[]};for(const y in c){const m=self[d[y]];let b,w;if(u.useUniqueIDs)w=c[y],b=o.GetAttributeByUniqueId(h,w);else{if(w=o.GetAttributeId(h,a[c[y]]),w===-1)continue;b=o.GetAttribute(h,w)}g.attributes.push(i(a,o,h,y,m,b))}return f===a.TRIANGULAR_MESH&&(g.index=r(a,o,h)),a.destroy(h),g}function r(a,o,l){const c=l.num_faces()*3,d=c*4,h=a._malloc(d);o.GetTrianglesUInt32Array(l,d,h);const p=new Uint32Array(a.HEAPF32.buffer,h,c).slice();return a._free(h),{array:p,itemSize:1}}function i(a,o,l,u,c,d){const h=d.num_components(),f=l.num_points()*h,g=f*c.BYTES_PER_ELEMENT,y=s(a,c),m=a._malloc(g);o.GetAttributeDataArrayForAllPoints(l,d,y,g,m);const b=new c(a.HEAPF32.buffer,m,f).slice();return a._free(m),{name:u,array:b,itemSize:h}}function s(a,o){switch(o){case Float32Array:return a.DT_FLOAT32;case Int8Array:return a.DT_INT8;case Int16Array:return a.DT_INT16;case Int32Array:return a.DT_INT32;case Uint8Array:return a.DT_UINT8;case Uint16Array:return a.DT_UINT16;case Uint32Array:return a.DT_UINT32}}}let pA;const pN=()=>{if(pA)return pA;const t="B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",e="B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",n=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]),r=new Uint8Array([32,0,65,253,3,1,2,34,4,106,6,5,11,8,7,20,13,33,12,16,128,9,116,64,19,113,127,15,10,21,22,14,255,66,24,54,136,107,18,23,192,26,114,118,132,17,77,101,130,144,27,87,131,44,45,74,156,154,70,167]);if(typeof WebAssembly!="object")return{supported:!1};let i=t;WebAssembly.validate(n)&&(i=e);let s;const a=WebAssembly.instantiate(o(i),{}).then(d=>{s=d.instance,s.exports.__wasm_call_ctors()});function o(d){const h=new Uint8Array(d.length);for(let f=0;f<d.length;++f){const g=d.charCodeAt(f);h[f]=g>96?g-71:g>64?g-65:g>47?g+4:g>46?63:62}let p=0;for(let f=0;f<d.length;++f)h[p++]=h[f]<60?r[h[f]]:(h[f]-60)*64+h[++f];return h.buffer.slice(0,p)}function l(d,h,p,f,g,y){const m=s.exports.sbrk,b=p+3&-4,w=m(b*f),_=m(g.length),S=new Uint8Array(s.exports.memory.buffer);S.set(g,_);const E=d(w,p,f,_,g.length);if(E===0&&y&&y(w,b,f),h.set(S.subarray(w,w+p*f)),m(w-m(0)),E!==0)throw new Error(`Malformed buffer data: ${E}`)}const u={0:"",1:"meshopt_decodeFilterOct",2:"meshopt_decodeFilterQuat",3:"meshopt_decodeFilterExp",NONE:"",OCTAHEDRAL:"meshopt_decodeFilterOct",QUATERNION:"meshopt_decodeFilterQuat",EXPONENTIAL:"meshopt_decodeFilterExp"},c={0:"meshopt_decodeVertexBuffer",1:"meshopt_decodeIndexBuffer",2:"meshopt_decodeIndexSequence",ATTRIBUTES:"meshopt_decodeVertexBuffer",TRIANGLES:"meshopt_decodeIndexBuffer",INDICES:"meshopt_decodeIndexSequence"};return pA={ready:a,supported:!0,decodeVertexBuffer(d,h,p,f,g){l(s.exports.meshopt_decodeVertexBuffer,d,h,p,f,s.exports[u[g]])},decodeIndexBuffer(d,h,p,f){l(s.exports.meshopt_decodeIndexBuffer,d,h,p,f)},decodeIndexSequence(d,h,p,f){l(s.exports.meshopt_decodeIndexSequence,d,h,p,f)},decodeGltfBuffer(d,h,p,f,g,y){l(s.exports[c[g]],d,h,p,f,s.exports[u[y]])}},pA};function HX(t,e,n,r){const i=class extends ua{constructor(a={}){const o=Object.entries(t);super({uniforms:o.reduce((l,[u,c])=>{const d=kP.clone({[u]:{value:c}});return{...l,...d}},{}),vertexShader:e,fragmentShader:n}),this.key="",o.forEach(([l])=>Object.defineProperty(this,l,{get:()=>this.uniforms[l].value,set:u=>this.uniforms[l].value=u})),Object.assign(this,a)}};return i.key=Ju.generateUUID(),i}const gve=()=>parseInt(vf.replace(/\D+/g,"")),WX=gve();let fA=null,VX="https://www.gstatic.com/draco/versioned/decoders/1.5.5/";function jX(t=!0,e=!0,n){return r=>{n&&n(r),t&&(fA||(fA=new fve),fA.setDecoderPath(typeof t=="string"?t:VX),r.setDRACOLoader(fA)),e&&r.setMeshoptDecoder(typeof pN=="function"?pN():pN)}}const Af=(t,e,n,r)=>uc(m3,t,jX(e,n,r));Af.preload=(t,e,n,r)=>uc.preload(m3,t,jX(e,n,r));Af.clear=t=>uc.clear(m3,t);Af.setDecoderPath=t=>{VX=t};const yve=ne.forwardRef(({makeDefault:t,camera:e,regress:n,domElement:r,enableDamping:i=!0,keyEvents:s=!1,onChange:a,onStart:o,onEnd:l,...u},c)=>{const d=gs(E=>E.invalidate),h=gs(E=>E.camera),p=gs(E=>E.gl),f=gs(E=>E.events),g=gs(E=>E.setEvents),y=gs(E=>E.set),m=gs(E=>E.get),b=gs(E=>E.performance),w=e||h,_=r||f.connected||p.domElement,S=ne.useMemo(()=>new k0e(w),[w]);return y0(()=>{S.enabled&&S.update()},-1),ne.useEffect(()=>(s&&S.connect(s===!0?_:s),S.connect(_),()=>void S.dispose()),[s,_,n,S,d]),ne.useEffect(()=>{const E=M=>{d(),n&&b.regress(),a&&a(M)},C=M=>{o&&o(M)},T=M=>{l&&l(M)};return S.addEventListener("change",E),S.addEventListener("start",C),S.addEventListener("end",T),()=>{S.removeEventListener("start",C),S.removeEventListener("end",T),S.removeEventListener("change",E)}},[a,o,l,S,d,g]),ne.useEffect(()=>{if(t){const E=m().controls;return y({controls:S}),()=>y({controls:E})}},[t,S]),ne.createElement("primitive",Wy({ref:c,object:S,enableDamping:i},u))}),vve=ne.forwardRef(function({children:e,disable:n,disableX:r,disableY:i,disableZ:s,left:a,right:o,top:l,bottom:u,front:c,back:d,onCentered:h,precise:p=!0,cacheKey:f=0,...g},y){const m=ne.useRef(null),b=ne.useRef(null),w=ne.useRef(null);return ne.useLayoutEffect(()=>{b.current.matrixWorld.identity();const _=new ds().setFromObject(w.current,p),S=new Z,E=new Xi,C=_.max.x-_.min.x,T=_.max.y-_.min.y,M=_.max.z-_.min.z;_.getCenter(S),_.getBoundingSphere(E);const k=l?T/2:u?-T/2:0,R=a?-C/2:o?C/2:0,N=c?M/2:d?-M/2:0;b.current.position.set(n||r?0:-S.x+R,n||i?0:-S.y+k,n||s?0:-S.z+N),typeof h<"u"&&h({parent:m.current.parent,container:m.current,width:C,height:T,depth:M,boundingBox:_,boundingSphere:E,center:S,verticalAlignment:k,horizontalAlignment:R,depthAlignment:N})},[f,h,l,a,c,n,r,i,s,p,o,u,d]),ne.useImperativeHandle(y,()=>m.current,[]),ne.createElement("group",Wy({ref:m},g),ne.createElement("group",{ref:b},ne.createElement("group",{ref:w},e)))}),xve=3e3,bve=3001,wve=HX({},"void main() { }","void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }"),XX=(t,e,n)=>{let r;switch(t){case la:r=new Uint8ClampedArray(e*n*4);break;case Wi:r=new Uint16Array(e*n*4);break;case cu:r=new Uint32Array(e*n*4);break;case _T:r=new Int8Array(e*n*4);break;case ST:r=new Int16Array(e*n*4);break;case z1:r=new Int32Array(e*n*4);break;case ti:r=new Float32Array(e*n*4);break;default:throw new Error("Unsupported data type")}return r};let mA;const _ve=(t,e,n,r)=>{if(mA!==void 0)return mA;const i=new Oa(1,1,r);e.setRenderTarget(i);const s=new Cr(new yu,new ka({color:16777215}));e.render(s,n),e.setRenderTarget(null);const a=XX(t,i.width,i.height);return e.readRenderTargetPixels(i,0,0,i.width,i.height,a),i.dispose(),s.geometry.dispose(),s.material.dispose(),mA=a[0]!==0,mA};class g3{constructor(e){var n,r,i,s,a,o,l,u,c,d,h,p,f,g,y,m;this._rendererIsDisposable=!1,this._supportsReadPixels=!0,this.render=()=>{this._renderer.setRenderTarget(this._renderTarget);try{this._renderer.render(this._scene,this._camera)}catch(w){throw this._renderer.setRenderTarget(null),w}this._renderer.setRenderTarget(null)},this._width=e.width,this._height=e.height,this._type=e.type,this._colorSpace=e.colorSpace;const b={format:ui,depthBuffer:!1,stencilBuffer:!1,type:this._type,colorSpace:this._colorSpace,anisotropy:((n=e.renderTargetOptions)===null||n===void 0?void 0:n.anisotropy)!==void 0?(r=e.renderTargetOptions)===null||r===void 0?void 0:r.anisotropy:1,generateMipmaps:((i=e.renderTargetOptions)===null||i===void 0?void 0:i.generateMipmaps)!==void 0?(s=e.renderTargetOptions)===null||s===void 0?void 0:s.generateMipmaps:!1,magFilter:((a=e.renderTargetOptions)===null||a===void 0?void 0:a.magFilter)!==void 0?(o=e.renderTargetOptions)===null||o===void 0?void 0:o.magFilter:er,minFilter:((l=e.renderTargetOptions)===null||l===void 0?void 0:l.minFilter)!==void 0?(u=e.renderTargetOptions)===null||u===void 0?void 0:u.minFilter:er,samples:((c=e.renderTargetOptions)===null||c===void 0?void 0:c.samples)!==void 0?(d=e.renderTargetOptions)===null||d===void 0?void 0:d.samples:void 0,wrapS:((h=e.renderTargetOptions)===null||h===void 0?void 0:h.wrapS)!==void 0?(p=e.renderTargetOptions)===null||p===void 0?void 0:p.wrapS:jr,wrapT:((f=e.renderTargetOptions)===null||f===void 0?void 0:f.wrapT)!==void 0?(g=e.renderTargetOptions)===null||g===void 0?void 0:g.wrapT:jr};if(this._material=e.material,e.renderer?this._renderer=e.renderer:(this._renderer=g3.instantiateRenderer(),this._rendererIsDisposable=!0),this._scene=new oc,this._camera=new iu,this._camera.position.set(0,0,10),this._camera.left=-.5,this._camera.right=.5,this._camera.top=.5,this._camera.bottom=-.5,this._camera.updateProjectionMatrix(),!_ve(this._type,this._renderer,this._camera,b)){let w;switch(this._type){case Wi:w=this._renderer.extensions.has("EXT_color_buffer_float")?ti:void 0;break}w!==void 0?(console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${ti}`),this._type=w):(this._supportsReadPixels=!1,console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"))}this._quad=new Cr(new yu,this._material),this._quad.geometry.computeBoundingBox(),this._scene.add(this._quad),this._renderTarget=new Oa(this.width,this.height,b),this._renderTarget.texture.mapping=((y=e.renderTargetOptions)===null||y===void 0?void 0:y.mapping)!==void 0?(m=e.renderTargetOptions)===null||m===void 0?void 0:m.mapping:Cd}static instantiateRenderer(){const e=new l3;return e.setSize(128,128),e}toArray(){if(!this._supportsReadPixels)throw new Error("Can't read pixels in this browser");const e=XX(this._type,this._width,this._height);return this._renderer.readRenderTargetPixels(this._renderTarget,0,0,this._width,this._height,e),e}toDataTexture(e){const n=new yl(this.toArray(),this.width,this.height,ui,this._type,(e==null?void 0:e.mapping)||Cd,(e==null?void 0:e.wrapS)||jr,(e==null?void 0:e.wrapT)||jr,(e==null?void 0:e.magFilter)||er,(e==null?void 0:e.minFilter)||er,(e==null?void 0:e.anisotropy)||1,du);return n.generateMipmaps=(e==null?void 0:e.generateMipmaps)!==void 0?e==null?void 0:e.generateMipmaps:!1,n}disposeOnDemandRenderer(){this._renderer.setRenderTarget(null),this._rendererIsDisposable&&(this._renderer.dispose(),this._renderer.forceContextLoss())}dispose(e){this.disposeOnDemandRenderer(),e&&this.renderTarget.dispose(),this.material instanceof ua&&Object.values(this.material.uniforms).forEach(n=>{n.value instanceof hr&&n.value.dispose()}),Object.values(this.material).forEach(n=>{n instanceof hr&&n.dispose()}),this.material.dispose(),this._quad.geometry.dispose()}get width(){return this._width}set width(e){this._width=e,this._renderTarget.setSize(this._width,this._height)}get height(){return this._height}set height(e){this._height=e,this._renderTarget.setSize(this._width,this._height)}get renderer(){return this._renderer}get renderTarget(){return this._renderTarget}set renderTarget(e){this._renderTarget=e,this._width=e.width,this._height=e.height}get material(){return this._material}get type(){return this._type}get colorSpace(){return this._colorSpace}}const Sve=`
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,Ave=`
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;class Eve extends ua{constructor({gamma:e,offsetHdr:n,offsetSdr:r,gainMapMin:i,gainMapMax:s,maxDisplayBoost:a,hdrCapacityMin:o,hdrCapacityMax:l,sdr:u,gainMap:c}){super({name:"GainMapDecoderMaterial",vertexShader:Sve,fragmentShader:Ave,uniforms:{sdr:{value:u},gainMap:{value:c},gamma:{value:new Z(1/e[0],1/e[1],1/e[2])},offsetHdr:{value:new Z().fromArray(n)},offsetSdr:{value:new Z().fromArray(r)},gainMapMin:{value:new Z().fromArray(i)},gainMapMax:{value:new Z().fromArray(s)},weightFactor:{value:(Math.log2(a)-o)/(l-o)}},blending:nu,depthTest:!1,depthWrite:!1}),this._maxDisplayBoost=a,this._hdrCapacityMin=o,this._hdrCapacityMax=l,this.needsUpdate=!0,this.uniformsNeedUpdate=!0}get sdr(){return this.uniforms.sdr.value}set sdr(e){this.uniforms.sdr.value=e}get gainMap(){return this.uniforms.gainMap.value}set gainMap(e){this.uniforms.gainMap.value=e}get offsetHdr(){return this.uniforms.offsetHdr.value.toArray()}set offsetHdr(e){this.uniforms.offsetHdr.value.fromArray(e)}get offsetSdr(){return this.uniforms.offsetSdr.value.toArray()}set offsetSdr(e){this.uniforms.offsetSdr.value.fromArray(e)}get gainMapMin(){return this.uniforms.gainMapMin.value.toArray()}set gainMapMin(e){this.uniforms.gainMapMin.value.fromArray(e)}get gainMapMax(){return this.uniforms.gainMapMax.value.toArray()}set gainMapMax(e){this.uniforms.gainMapMax.value.fromArray(e)}get gamma(){const e=this.uniforms.gamma.value;return[1/e.x,1/e.y,1/e.z]}set gamma(e){const n=this.uniforms.gamma.value;n.x=1/e[0],n.y=1/e[1],n.z=1/e[2]}get hdrCapacityMin(){return this._hdrCapacityMin}set hdrCapacityMin(e){this._hdrCapacityMin=e,this.calculateWeight()}get hdrCapacityMax(){return this._hdrCapacityMax}set hdrCapacityMax(e){this._hdrCapacityMax=e,this.calculateWeight()}get maxDisplayBoost(){return this._maxDisplayBoost}set maxDisplayBoost(e){this._maxDisplayBoost=Math.max(1,Math.min(65504,e)),this.calculateWeight()}calculateWeight(){const e=(Math.log2(this._maxDisplayBoost)-this._hdrCapacityMin)/(this._hdrCapacityMax-this._hdrCapacityMin);this.uniforms.weightFactor.value=Math.max(0,Math.min(1,e))}}class KX extends Error{}class qX extends Error{}const Bx=(t,e,n)=>{const r=new RegExp(`${e}="([^"]*)"`,"i").exec(t);if(r)return r[1];const i=new RegExp(`<${e}[^>]*>([\\s\\S]*?)</${e}>`,"i").exec(t);if(i){const s=i[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);return s&&s.length===3?s.map(a=>a.replace(/<\/?rdf:li>/g,"")):i[1].trim()}if(n!==void 0)return n;throw new Error(`Can't find ${e} in gainmap metadata`)},Ive=t=>{let e;typeof TextDecoder<"u"?e=new TextDecoder().decode(t):e=t.toString();let n=e.indexOf("<x:xmpmeta");for(;n!==-1;){const r=e.indexOf("x:xmpmeta>",n),i=e.slice(n,r+10);try{const s=Bx(i,"hdrgm:GainMapMin","0"),a=Bx(i,"hdrgm:GainMapMax"),o=Bx(i,"hdrgm:Gamma","1"),l=Bx(i,"hdrgm:OffsetSDR","0.015625"),u=Bx(i,"hdrgm:OffsetHDR","0.015625"),c=/hdrgm:HDRCapacityMin="([^"]*)"/.exec(i),d=c?c[1]:"0",h=/hdrgm:HDRCapacityMax="([^"]*)"/.exec(i);if(!h)throw new Error("Incomplete gainmap metadata");const p=h[1];return{gainMapMin:Array.isArray(s)?s.map(f=>parseFloat(f)):[parseFloat(s),parseFloat(s),parseFloat(s)],gainMapMax:Array.isArray(a)?a.map(f=>parseFloat(f)):[parseFloat(a),parseFloat(a),parseFloat(a)],gamma:Array.isArray(o)?o.map(f=>parseFloat(f)):[parseFloat(o),parseFloat(o),parseFloat(o)],offsetSdr:Array.isArray(l)?l.map(f=>parseFloat(f)):[parseFloat(l),parseFloat(l),parseFloat(l)],offsetHdr:Array.isArray(u)?u.map(f=>parseFloat(f)):[parseFloat(u),parseFloat(u),parseFloat(u)],hdrCapacityMin:parseFloat(d),hdrCapacityMax:parseFloat(p)}}catch{}n=e.indexOf("<x:xmpmeta",r)}};class Tve{constructor(e){this.options={debug:e&&e.debug!==void 0?e.debug:!1,extractFII:e&&e.extractFII!==void 0?e.extractFII:!0,extractNonFII:e&&e.extractNonFII!==void 0?e.extractNonFII:!0}}extract(e){return new Promise((n,r)=>{const i=this.options.debug,s=new DataView(e.buffer);if(s.getUint16(0)!==65496){r(new Error("Not a valid jpeg"));return}const a=s.byteLength;let o=2,l=0,u;for(;o<a;){if(++l>250){r(new Error(`Found no marker after ${l} loops `));return}if(s.getUint8(o)!==255){r(new Error(`Not a valid marker at offset 0x${o.toString(16)}, found: 0x${s.getUint8(o).toString(16)}`));return}if(u=s.getUint8(o+1),i&&console.log(`Marker: ${u.toString(16)}`),u===226){i&&console.log("Found APP2 marker (0xffe2)");const c=o+4;if(s.getUint32(c)===1297106432){const d=c+4;let h;if(s.getUint16(d)===18761)h=!1;else if(s.getUint16(d)===19789)h=!0;else{r(new Error("No valid endianness marker found in TIFF header"));return}if(s.getUint16(d+2,!h)!==42){r(new Error("Not valid TIFF data! (no 0x002A marker)"));return}const p=s.getUint32(d+4,!h);if(p<8){r(new Error("Not valid TIFF data! (First offset less than 8)"));return}const f=d+p,g=s.getUint16(f,!h),y=f+2;let m=0;for(let S=y;S<y+12*g;S+=12)s.getUint16(S,!h)===45057&&(m=s.getUint32(S+8,!h));const w=f+2+g*12+4,_=[];for(let S=w;S<w+m*16;S+=16){const E={MPType:s.getUint32(S,!h),size:s.getUint32(S+4,!h),dataOffset:s.getUint32(S+8,!h),dependantImages:s.getUint32(S+12,!h),start:-1,end:-1,isFII:!1};E.dataOffset?(E.start=d+E.dataOffset,E.isFII=!1):(E.start=0,E.isFII=!0),E.end=E.start+E.size,_.push(E)}if(this.options.extractNonFII&&_.length){const S=new Blob([s]),E=[];for(const C of _){if(C.isFII&&!this.options.extractFII)continue;const T=S.slice(C.start,C.end+1,"image/jpeg");E.push(T)}n(E)}}}o+=2+s.getUint16(o+2)}})}}const Cve=async t=>{const e=Ive(t);if(!e)throw new qX("Gain map XMP metadata not found");const r=await new Tve({extractFII:!0,extractNonFII:!0}).extract(t);if(r.length!==2)throw new KX("Gain map recovery image not found");return{sdr:new Uint8Array(await r[0].arrayBuffer()),gainMap:new Uint8Array(await r[1].arrayBuffer()),metadata:e}},PW=t=>new Promise((e,n)=>{const r=document.createElement("img");r.onload=()=>{e(r)},r.onerror=i=>{n(i)},r.src=URL.createObjectURL(t)});class JX extends _s{constructor(e,n){super(n),e&&(this._renderer=e),this._internalLoadingManager=new KT}setRenderer(e){return this._renderer=e,this}setRenderTargetOptions(e){return this._renderTargetOptions=e,this}prepareQuadRenderer(){this._renderer||console.warn("WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.");const e=new Eve({gainMapMax:[1,1,1],gainMapMin:[0,0,0],gamma:[1,1,1],offsetHdr:[1,1,1],offsetSdr:[1,1,1],hdrCapacityMax:1,hdrCapacityMin:0,maxDisplayBoost:1,gainMap:new hr,sdr:new hr});return new g3({width:16,height:16,type:Wi,colorSpace:du,material:e,renderer:this._renderer,renderTargetOptions:this._renderTargetOptions})}async render(e,n,r,i){const s=i?new Blob([i],{type:"image/jpeg"}):void 0,a=new Blob([r],{type:"image/jpeg"});let o,l,u=!1;if(typeof createImageBitmap>"u"){const h=await Promise.all([s?PW(s):Promise.resolve(void 0),PW(a)]);l=h[0],o=h[1],u=!0}else{const h=await Promise.all([s?createImageBitmap(s,{imageOrientation:"flipY"}):Promise.resolve(void 0),createImageBitmap(a,{imageOrientation:"flipY"})]);l=h[0],o=h[1]}const c=new hr(l||new ImageData(2,2),Cd,jr,jr,er,HE,ui,la,1,du);c.flipY=u,c.needsUpdate=!0;const d=new hr(o,Cd,jr,jr,er,HE,ui,la,1,Ui);d.flipY=u,d.needsUpdate=!0,e.width=o.width,e.height=o.height,e.material.gainMap=c,e.material.sdr=d,e.material.gainMapMin=n.gainMapMin,e.material.gainMapMax=n.gainMapMax,e.material.offsetHdr=n.offsetHdr,e.material.offsetSdr=n.offsetSdr,e.material.gamma=n.gamma,e.material.hdrCapacityMin=n.hdrCapacityMin,e.material.hdrCapacityMax=n.hdrCapacityMax,e.material.maxDisplayBoost=Math.pow(2,n.hdrCapacityMax),e.material.needsUpdate=!0,e.render()}}class Mve extends JX{load([e,n,r],i,s,a){const o=this.prepareQuadRenderer();let l,u,c;const d=async()=>{if(l&&u&&c){try{await this.render(o,c,l,u)}catch(M){this.manager.itemError(e),this.manager.itemError(n),this.manager.itemError(r),typeof a=="function"&&a(M),o.disposeOnDemandRenderer();return}typeof i=="function"&&i(o),this.manager.itemEnd(e),this.manager.itemEnd(n),this.manager.itemEnd(r),o.disposeOnDemandRenderer()}};let h=!0,p=0,f=0,g=!0,y=0,m=0,b=!0,w=0,_=0;const S=()=>{if(typeof s=="function"){const M=p+y+w,k=f+m+_,R=h&&g&&b;s(new ProgressEvent("progress",{lengthComputable:R,loaded:k,total:M}))}};this.manager.itemStart(e),this.manager.itemStart(n),this.manager.itemStart(r);const E=new vs(this._internalLoadingManager);E.setResponseType("arraybuffer"),E.setRequestHeader(this.requestHeader),E.setPath(this.path),E.setWithCredentials(this.withCredentials),E.load(e,async M=>{if(typeof M=="string")throw new Error("Invalid sdr buffer");l=M,await d()},M=>{h=M.lengthComputable,f=M.loaded,p=M.total,S()},M=>{this.manager.itemError(e),typeof a=="function"&&a(M)});const C=new vs(this._internalLoadingManager);C.setResponseType("arraybuffer"),C.setRequestHeader(this.requestHeader),C.setPath(this.path),C.setWithCredentials(this.withCredentials),C.load(n,async M=>{if(typeof M=="string")throw new Error("Invalid gainmap buffer");u=M,await d()},M=>{g=M.lengthComputable,m=M.loaded,y=M.total,S()},M=>{this.manager.itemError(n),typeof a=="function"&&a(M)});const T=new vs(this._internalLoadingManager);return T.setRequestHeader(this.requestHeader),T.setPath(this.path),T.setWithCredentials(this.withCredentials),T.load(r,async M=>{if(typeof M!="string")throw new Error("Invalid metadata string");c=JSON.parse(M),await d()},M=>{b=M.lengthComputable,_=M.loaded,w=M.total,S()},M=>{this.manager.itemError(r),typeof a=="function"&&a(M)}),o}}class kve extends JX{load(e,n,r,i){const s=this.prepareQuadRenderer(),a=new vs(this._internalLoadingManager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(this.withCredentials),this.manager.itemStart(e),a.load(e,async o=>{if(typeof o=="string")throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");const l=new Uint8Array(o);let u,c,d;try{const h=await Cve(l);u=h.sdr,c=h.gainMap,d=h.metadata}catch(h){if(h instanceof qX||h instanceof KX)console.warn(`Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`),d={gainMapMin:[0,0,0],gainMapMax:[1,1,1],gamma:[1,1,1],hdrCapacityMin:0,hdrCapacityMax:1,offsetHdr:[0,0,0],offsetSdr:[0,0,0]},u=l;else throw h}try{await this.render(s,d,u,c)}catch(h){this.manager.itemError(e),typeof i=="function"&&i(h),s.disposeOnDemandRenderer();return}typeof n=="function"&&n(s),this.manager.itemEnd(e),s.disposeOnDemandRenderer()},r,o=>{this.manager.itemError(e),typeof i=="function"&&i(o)}),s}}const d1={apartment:"lebombo_1k.hdr",city:"potsdamer_platz_1k.hdr",dawn:"kiara_1_dawn_1k.hdr",forest:"forest_slope_1k.hdr",lobby:"st_fagans_interior_1k.hdr",night:"dikhololo_night_1k.hdr",park:"rooitou_park_1k.hdr",studio:"studio_small_03_1k.hdr",sunset:"venice_sunset_1k.hdr",warehouse:"empty_warehouse_01_1k.hdr"},YX="https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",by=t=>Array.isArray(t),y3=["/px.png","/nx.png","/py.png","/ny.png","/pz.png","/nz.png"];function QT({files:t=y3,path:e="",preset:n=void 0,encoding:r=void 0,extensions:i}={}){let s=null,a=!1;n&&(v3(n),t=d1[n],e=YX),a=by(t);const{extension:o,isCubemap:l}=x3(t);if(s=b3(o),!s)throw new Error("useEnvironment: Unrecognized file extension: "+t);const u=gs(p=>p.gl);ne.useLayoutEffect(()=>{if(o!=="webp"&&o!=="jpg"&&o!=="jpeg")return;function p(){uc.clear(s,a?[t]:t)}u.domElement.addEventListener("webglcontextlost",p,{once:!0})},[t,u.domElement]);const c=uc(s,a?[t]:t,p=>{(o==="webp"||o==="jpg"||o==="jpeg")&&p.setRenderer(u),p.setPath==null||p.setPath(e),i&&i(p)});let d=a?c[0]:c;if(o==="jpg"||o==="jpeg"||o==="webp"){var h;d=(h=d.renderTarget)==null?void 0:h.texture}return d.mapping=l?uu:Dy,"colorSpace"in d?d.colorSpace=r??l?"srgb":"srgb-linear":d.encoding=r??l?bve:xve,d}const Nve={files:y3,path:"",preset:void 0,extensions:void 0};QT.preload=t=>{const e={...Nve,...t};let{files:n,path:r=""}=e;const{preset:i,extensions:s}=e;i&&(v3(i),n=d1[i],r=YX);const{extension:a}=x3(n);if(a==="webp"||a==="jpg"||a==="jpeg")throw new Error("useEnvironment: Preloading gainmaps is not supported");const o=b3(a);if(!o)throw new Error("useEnvironment: Unrecognized file extension: "+n);uc.preload(o,by(n)?[n]:n,l=>{l.setPath==null||l.setPath(r),s&&s(l)})};const Rve={files:y3,preset:void 0};QT.clear=t=>{const e={...Rve,...t};let{files:n}=e;const{preset:r}=e;r&&(v3(r),n=d1[r]);const{extension:i}=x3(n),s=b3(i);if(!s)throw new Error("useEnvironment: Unrecognized file extension: "+n);uc.clear(s,by(n)?[n]:n)};function v3(t){if(!(t in d1))throw new Error("Preset must be one of: "+Object.keys(d1).join(", "))}function x3(t){var e;const n=by(t)&&t.length===6,r=by(t)&&t.length===3&&t.some(a=>a.endsWith("json")),i=by(t)?t[0]:t;return{extension:n?"cube":r?"webp":i.startsWith("data:application/exr")?"exr":i.startsWith("data:application/hdr")?"hdr":i.startsWith("data:image/jpeg")?"jpg":(e=i.split(".").pop())==null||(e=e.split("?"))==null||(e=e.shift())==null?void 0:e.toLowerCase(),isCubemap:n,isGainmap:r}}function b3(t){return t==="cube"?V9:t==="hdr"?hve:t==="exr"?pve:t==="jpg"||t==="jpeg"?kve:t==="webp"?Mve:null}const Fve=t=>t.current&&t.current.isScene,Dve=t=>Fve(t)?t.current:t;function w3(t,e,n,r,i={}){var s,a,o,l;i={backgroundBlurriness:0,backgroundIntensity:1,backgroundRotation:[0,0,0],environmentIntensity:1,environmentRotation:[0,0,0],...i};const u=Dve(e||n),c=u.background,d=u.environment,h={backgroundBlurriness:u.backgroundBlurriness,backgroundIntensity:u.backgroundIntensity,backgroundRotation:(s=(a=u.backgroundRotation)==null||a.clone==null?void 0:a.clone())!==null&&s!==void 0?s:[0,0,0],environmentIntensity:u.environmentIntensity,environmentRotation:(o=(l=u.environmentRotation)==null||l.clone==null?void 0:l.clone())!==null&&o!==void 0?o:[0,0,0]};return t!=="only"&&(u.environment=r),t&&(u.background=r),Yc(u,i),()=>{t!=="only"&&(u.environment=d),t&&(u.background=c),Yc(u,h)}}function _3({scene:t,background:e=!1,map:n,...r}){const i=gs(s=>s.scene);return ne.useLayoutEffect(()=>{if(n)return w3(e,t,i,n,r)}),null}function ZX({background:t=!1,scene:e,blur:n,backgroundBlurriness:r,backgroundIntensity:i,backgroundRotation:s,environmentIntensity:a,environmentRotation:o,...l}){const u=QT(l),c=gs(d=>d.scene);return ne.useLayoutEffect(()=>w3(t,e,c,u,{backgroundBlurriness:n??r,backgroundIntensity:i,backgroundRotation:s,environmentIntensity:a,environmentRotation:o})),ne.useEffect(()=>()=>{u.dispose()},[u]),null}function Pve({children:t,near:e=.1,far:n=1e3,resolution:r=256,frames:i=1,map:s,background:a=!1,blur:o,backgroundBlurriness:l,backgroundIntensity:u,backgroundRotation:c,environmentIntensity:d,environmentRotation:h,scene:p,files:f,path:g,preset:y=void 0,extensions:m}){const b=gs(T=>T.gl),w=gs(T=>T.scene),_=ne.useRef(null),[S]=ne.useState(()=>new oc),E=ne.useMemo(()=>{const T=new NP(r);return T.texture.type=Wi,T},[r]);ne.useEffect(()=>()=>{E.dispose()},[E]),ne.useLayoutEffect(()=>{if(i===1){const T=b.autoClear;b.autoClear=!0,_.current.update(b,S),b.autoClear=T}return w3(a,p,w,E.texture,{backgroundBlurriness:o??l,backgroundIntensity:u,backgroundRotation:c,environmentIntensity:d,environmentRotation:h})},[t,S,E.texture,p,w,a,i,b]);let C=1;return y0(()=>{if(i===1/0||C<i){const T=b.autoClear;b.autoClear=!0,_.current.update(b,S),b.autoClear=T,C++}}),ne.createElement(ne.Fragment,null,fye(ne.createElement(ne.Fragment,null,t,ne.createElement("cubeCamera",{ref:_,args:[e,n,E]}),f||y?ne.createElement(ZX,{background:!0,files:f,preset:y,path:g,extensions:m}):s?ne.createElement(_3,{background:!0,map:s,extensions:m}):null),S))}function Lve(t){var e,n,r,i;const s=QT(t),a=t.map||s;ne.useMemo(()=>c3({GroundProjectedEnvImpl:_0e}),[]),ne.useEffect(()=>()=>{s.dispose()},[s]);const o=ne.useMemo(()=>[a],[a]),l=(e=t.ground)==null?void 0:e.height,u=(n=t.ground)==null?void 0:n.radius,c=(r=(i=t.ground)==null?void 0:i.scale)!==null&&r!==void 0?r:1e3;return ne.createElement(ne.Fragment,null,ne.createElement(_3,Wy({},t,{map:a})),ne.createElement("groundProjectedEnvImpl",{args:o,scale:c,height:l,radius:u}))}function Ove(t){return t.ground?ne.createElement(Lve,t):t.map?ne.createElement(_3,t):t.children?ne.createElement(Pve,t):ne.createElement(ZX,t)}function Bve(t){return t.isLight}function Uve(t){return!!t.geometry}const QX=ne.createContext(null),$ve=HX({color:new Ct,blend:2,alphaTest:.75,opacity:0,map:null},`varying vec2 vUv;
   void main() {
     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);
     vUv = uv;
   }`,`varying vec2 vUv;
   uniform sampler2D map;
   uniform vec3 color;
   uniform float opacity;
   uniform float alphaTest;
   uniform float blend;
   void main() {
     vec4 sampledDiffuseColor = texture2D(map, vUv);
     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);
     #include <tonemapping_fragment>
     #include <${WX>=154?"colorspace_fragment":"encodings_fragment"}>
   }`),zve=ne.forwardRef(({children:t,temporal:e,frames:n=40,limit:r=1/0,blend:i=20,scale:s=10,opacity:a=1,alphaTest:o=.75,color:l="black",colorBlend:u=2,resolution:c=1024,toneMapped:d=!0,...h},p)=>{c3({SoftShadowMaterial:$ve});const f=gs(E=>E.gl),g=gs(E=>E.scene),y=gs(E=>E.camera),m=gs(E=>E.invalidate),b=ne.useRef(null),w=ne.useRef(null),[_]=ne.useState(()=>new Gve(f,g,c));ne.useLayoutEffect(()=>{_.configure(b.current)},[]);const S=ne.useMemo(()=>({lights:new Map,temporal:!!e,frames:Math.max(2,n),blend:Math.max(2,n===1/0?i:n),count:0,getMesh:()=>b.current,reset:()=>{_.clear();const E=b.current.material;E.opacity=0,E.alphaTest=0,S.count=0},update:(E=1)=>{const C=b.current.material;S.temporal?(C.opacity=Math.min(a,C.opacity+a/S.blend),C.alphaTest=Math.min(o,C.alphaTest+o/S.blend)):(C.opacity=a,C.alphaTest=o),w.current.visible=!0,_.prepare();for(let T=0;T<E;T++)S.lights.forEach(M=>M.update()),_.update(y,S.blend);w.current.visible=!1,_.finish()}}),[_,y,g,e,n,i,a,o]);return ne.useLayoutEffect(()=>{S.reset(),!S.temporal&&S.frames!==1/0&&S.update(S.blend)}),ne.useImperativeHandle(p,()=>S,[S]),y0(()=>{(S.temporal||S.frames===1/0)&&S.count<S.frames&&S.count<r&&(m(),S.update(),S.count++)}),ne.createElement("group",h,ne.createElement("group",{traverse:()=>null,ref:w},ne.createElement(QX.Provider,{value:S},t)),ne.createElement("mesh",{receiveShadow:!0,ref:b,scale:s,rotation:[-Math.PI/2,0,0]},ne.createElement("planeGeometry",null),ne.createElement("softShadowMaterial",{transparent:!0,depthWrite:!1,toneMapped:d,color:l,blend:u,map:_.progressiveLightMap2.texture})))}),LW=ne.forwardRef(({castShadow:t=!0,bias:e=.001,mapSize:n=512,size:r=5,near:i=.5,far:s=500,frames:a=1,position:o=[0,0,0],radius:l=1,amount:u=8,intensity:c=WX>=155?Math.PI:1,ambient:d=.5,...h},p)=>{const f=ne.useRef(null),g=new Z(...o).length(),y=ne.useContext(QX),m=ne.useCallback(()=>{let w;if(f.current)for(let _=0;_<f.current.children.length;_++)if(w=f.current.children[_],Math.random()>d)w.position.set(o[0]+Ju.randFloatSpread(l),o[1]+Ju.randFloatSpread(l),o[2]+Ju.randFloatSpread(l));else{let S=Math.acos(2*Math.random()-1)-Math.PI/2,E=2*Math.PI*Math.random();w.position.set(Math.cos(S)*Math.cos(E)*g,Math.abs(Math.cos(S)*Math.sin(E)*g),Math.sin(S)*g)}},[l,d,g,...o]),b=ne.useMemo(()=>({update:m}),[m]);return ne.useImperativeHandle(p,()=>b,[b]),ne.useLayoutEffect(()=>{var w;const _=f.current;return y&&((w=y.lights)==null||w.set(_.uuid,b)),()=>{var S;return void(y==null||(S=y.lights)==null?void 0:S.delete(_.uuid))}},[y,b]),ne.createElement("group",Wy({ref:f},h),Array.from({length:u},(w,_)=>ne.createElement("directionalLight",{key:_,castShadow:t,"shadow-bias":e,"shadow-mapSize":[n,n],intensity:c/u},ne.createElement("orthographicCamera",{attach:"shadow-camera",args:[-r,r,r,-r,i,s]}))))});class Gve{constructor(e,n,r=1024){this.renderer=e,this.res=r,this.scene=n,this.buffer1Active=!1,this.lights=[],this.meshes=[],this.object=null,this.clearColor=new Ct,this.clearAlpha=0;const i={type:Wi,magFilter:yi,minFilter:yi};this.progressiveLightMap1=new Oa(this.res,this.res,i),this.progressiveLightMap2=new Oa(this.res,this.res,i),this.discardMat=new wve,this.targetMat=new WP({fog:!1}),this.previousShadowMap={value:this.progressiveLightMap1.texture},this.averagingWindow={value:100},this.targetMat.onBeforeCompile=s=>{s.vertexShader=`varying vec2 vUv;
`+s.vertexShader.slice(0,-1)+"vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }";const a=s.fragmentShader.indexOf("void main() {");s.fragmentShader=`varying vec2 vUv;
`+s.fragmentShader.slice(0,a)+`uniform sampler2D previousShadowMap;
	uniform float averagingWindow;
`+s.fragmentShader.slice(a-1,-1)+`
vec3 texelOld = texture2D(previousShadowMap, vUv).rgb;
        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);
      }`,s.uniforms.previousShadowMap=this.previousShadowMap,s.uniforms.averagingWindow=this.averagingWindow}}clear(){this.renderer.getClearColor(this.clearColor),this.clearAlpha=this.renderer.getClearAlpha(),this.renderer.setClearColor("black",1),this.renderer.setRenderTarget(this.progressiveLightMap1),this.renderer.clear(),this.renderer.setRenderTarget(this.progressiveLightMap2),this.renderer.clear(),this.renderer.setRenderTarget(null),this.renderer.setClearColor(this.clearColor,this.clearAlpha),this.lights=[],this.meshes=[],this.scene.traverse(e=>{Uve(e)?this.meshes.push({object:e,material:e.material}):Bve(e)&&this.lights.push({object:e,intensity:e.intensity})})}prepare(){this.lights.forEach(e=>e.object.intensity=0),this.meshes.forEach(e=>e.object.material=this.discardMat)}finish(){this.lights.forEach(e=>e.object.intensity=e.intensity),this.meshes.forEach(e=>e.object.material=e.material)}configure(e){this.object=e}update(e,n=100){if(!this.object)return;this.averagingWindow.value=n,this.object.material=this.targetMat;const r=this.buffer1Active?this.progressiveLightMap1:this.progressiveLightMap2,i=this.buffer1Active?this.progressiveLightMap2:this.progressiveLightMap1,s=this.scene.background;this.scene.background=null,this.renderer.setRenderTarget(r),this.previousShadowMap.value=i.texture,this.buffer1Active=!this.buffer1Active,this.renderer.render(this.scene,e),this.renderer.setRenderTarget(null),this.scene.background=s}}function Hve({color:t="#ffffff",modelType:e="T-shirt",zoom:n=1}){const r="/TexWeb/",[i,s]=ne.useState(a(e));function a(h){return console.log("Getting model path for type:",h),h==="Full Body"?`${r}man.glb`:`${r}shirt_baked_collapsed.glb`}ne.useEffect(()=>{console.log("Model type changed to:",e);const h=a(e);console.log("New model path:",h),s(h)},[e,r]);const{nodes:o}=Af(i),l=ne.useRef();if(y0((h,p)=>{l.current&&SI.dampC(l.current.color,new Ct(t),.2,p)}),!o)return console.log("Nodes not loaded yet"),null;const u=Object.values(o).find(h=>h instanceof Cr);if(!u)return console.log("No mesh found in model"),null;const c=new Zd({color:new Ct(t),roughness:.7,metalness:.1});l.current=c;const d=n;return console.log("Rendering model with zoom scale:",d),D.jsx("group",{dispose:null,children:D.jsx("mesh",{geometry:u.geometry,material:c,scale:d,castShadow:!0,receiveShadow:!0})})}const e7="/TexWeb/";Af.preload(`${e7}shirt_baked_collapsed.glb`);Af.preload(`${e7}man.glb`);function Wve(){const t=ne.useRef(null);return y0((e,n)=>{t.current&&SI.dampC(t.current.getMesh().material.color,"#ffffff",.25,n)}),D.jsxs(zve,{ref:t,temporal:!0,frames:60,alphaTest:.85,scale:5,resolution:2048,rotation:[Math.PI/2,0,0],position:[0,0,-.14],children:[D.jsx(LW,{amount:4,radius:9,intensity:.55*Math.PI,ambient:.25,position:[5,5,-10]}),D.jsx(LW,{amount:4,radius:5,intensity:.25*Math.PI,ambient:.55,position:[-5,5,-9]})]})}function Vve({children:t}){const e=ne.useRef(null);return y0((n,r)=>{SI.damp3(n.camera.position,[0,0,2],.25,r),SI.dampE(e.current.rotation,[n.pointer.y/10,-n.pointer.x/5,0],.25,r)}),D.jsx("group",{ref:e,children:t})}function jve(){const t=ne.useRef(null),e=ne.useRef(null);return ne.useEffect(()=>{t.current&&e.current&&(t.current.target=e.current)},[]),D.jsx("group",{children:D.jsx("directionalLight",{ref:t,position:[4,4,4],intensity:1.5,castShadow:!0,"shadow-mapSize":[1024,1024],children:D.jsx("object3D",{ref:e,position:[0,0,-1]})})})}function Xve({modelUrl:t,modelType:e="T-shirt",...n}){const r=ne.useRef(null),[i,s]=ne.useState(window.innerWidth<=768);ne.useEffect(()=>{const o=()=>{s(window.innerWidth<=768)};return window.addEventListener("resize",o),()=>window.removeEventListener("resize",o)},[]),ne.useEffect(()=>{r.current&&(r.current.target.set(0,0,0),i?(r.current.minDistance=1.5,r.current.maxDistance=4,r.current.enablePan=!1):(r.current.minDistance=2,r.current.maxDistance=5,r.current.enablePan=!0),r.current.update())},[i]);const a={color:n.color,zoom:n.zoom,modelType:e};return D.jsx("div",{className:"human-model-canvas-container",children:D.jsxs(Rye,{shadows:!0,camera:{position:[0,e==="Full Body"?1:0,i?2:2.5],fov:i?50:45,near:.1,far:1e3},gl:{preserveDrawingBuffer:!0,antialias:!0,alpha:!0,powerPreference:"high-performance"},dpr:[1,2],children:[D.jsx("color",{attach:"background",args:["#f9fafb"]}),D.jsx("fog",{attach:"fog",args:["#f9fafb",5,15]}),D.jsx("directionalLight",{intensity:.5,position:[0,1,0],color:"#ffffff"}),D.jsx("directionalLight",{intensity:.3,position:[-5,5,-5],color:"#ffffff"}),D.jsx(jve,{}),D.jsx(Ove,{preset:"studio",background:!1}),D.jsxs(Vve,{children:[D.jsx(Wve,{}),D.jsx(vve,{children:D.jsx(Hve,{modelUrl:t,...a})})]}),D.jsx(yve,{ref:r,enableDamping:!0,dampingFactor:.05,rotateSpeed:.8,enableZoom:!0,enableRotate:!0,minPolarAngle:Math.PI/4,maxPolarAngle:Math.PI*3/4})]})})}Af.preload(new URL("shirt_baked_collapsed.glb",window.location.origin+"/TexWeb/").href);const Gc={min:0,max:50},Kve={min:0,max:100},S3={XS:{neck:13.75,chest:35,waist:29,hips:35,shoulder:16,sleeveLength:24,inseam:30,thigh:20,height:64},S:{neck:14.25,chest:37,waist:31,hips:37,shoulder:16.5,sleeveLength:24.5,inseam:31,thigh:21,height:66},M:{neck:14.75,chest:39,waist:33,hips:39,shoulder:17.5,sleeveLength:25.5,inseam:32,thigh:22,height:68},L:{neck:15.25,chest:41,waist:35,hips:41,shoulder:18.5,sleeveLength:26,inseam:33,thigh:23,height:70},XL:{neck:15.75,chest:43,waist:37,hips:43,shoulder:19.5,sleeveLength:26.5,inseam:34,thigh:24,height:72},"2XL":{neck:16.25,chest:45,waist:39,hips:45,shoulder:20.5,sleeveLength:27,inseam:35,thigh:25,height:74}};function qve(t,e){const n=ne.useRef();return ne.useCallback((...i)=>{n.current&&clearTimeout(n.current),n.current=setTimeout(()=>{t(...i)},e)},[t,e])}const t7=ne.memo(function({value:e,onChange:n,min:r,max:i,step:s,label:a,unit:o="",showValue:l=!0,debounceMs:u=150}){const c=ne.useRef(null),d=ne.useRef(null),h=ne.useRef(),[p,f]=ne.useState(e),[g,y]=ne.useState(!1),m=ne.useRef(e);ne.useEffect(()=>{g||(f(e),m.current=e)},[e,g]);const b=qve(n,u),w=ne.useCallback(()=>{h.current&&cancelAnimationFrame(h.current),h.current=requestAnimationFrame(()=>{if(d.current){const T=(p-r)/(i-r)*100;d.current.style.width=`${T}%`}})},[p,r,i]);ne.useEffect(()=>(w(),()=>{h.current&&cancelAnimationFrame(h.current)}),[w]);const _=ne.useCallback(T=>{const M=Math.min(Math.max(T,r),i);f(M),g?(b(M),m.current=M):n(M)},[r,i,g,n,b]),S=ne.useCallback(()=>{y(!1),m.current!==p&&n(p)},[p,n]),E=ne.useCallback(T=>{T.preventDefault(),y(!0);const M=R=>{if(c.current){const N=c.current.getBoundingClientRect(),B=Math.min(Math.max((R.clientX-N.left)/N.width,0),1),z=r+(i-r)*B,V=Math.round(z/s)*s;_(V)}},k=()=>{S(),document.removeEventListener("mousemove",M),document.removeEventListener("mouseup",k)};document.addEventListener("mousemove",M,{passive:!0}),document.addEventListener("mouseup",k)},[r,i,s,_,S]),C=ne.useCallback(T=>{T.preventDefault(),y(!0);const M=R=>{if(c.current&&R.touches[0]){const N=c.current.getBoundingClientRect(),B=Math.min(Math.max((R.touches[0].clientX-N.left)/N.width,0),1),z=r+(i-r)*B,V=Math.round(z/s)*s;_(V)}},k=()=>{S(),document.removeEventListener("touchmove",M),document.removeEventListener("touchend",k)};document.addEventListener("touchmove",M,{passive:!1}),document.addEventListener("touchend",k)},[r,i,s,_,S]);return D.jsxs("div",{className:"flex flex-col space-y-1",children:[a&&D.jsxs("div",{className:"flex justify-between items-center text-xs text-gray-600",children:[D.jsx("span",{children:a}),l&&D.jsxs("span",{className:"tabular-nums font-medium",children:[p.toFixed(1),o]})]}),D.jsxs("div",{className:"range-container relative h-6 flex items-center cursor-pointer touch-none",onMouseDown:E,onTouchStart:C,children:[D.jsx("div",{className:"absolute inset-0 h-1 bg-gray-200 rounded-full",children:D.jsx("div",{ref:d,className:"absolute h-full bg-rose-600 rounded-full",style:{willChange:"width"}})}),D.jsx("input",{ref:c,type:"range",value:p,onChange:T=>_(parseFloat(T.target.value)),min:r,max:i,step:s,className:"absolute w-full h-full opacity-0 cursor-pointer touch-none"}),D.jsx("div",{className:"absolute w-4 h-4 bg-white border-2 border-rose-600 rounded-full shadow transform -translate-x-1/2 hover:scale-110 active:scale-95 transition-transform",style:{left:`${(p-r)/(i-r)*100}%`,willChange:"transform",transform:`translateX(-50%) ${g?"scale(1.1)":""}`,transition:g?"none":"all 0.1s ease"}})]})]})});function n7({title:t,defaultOpen:e=!0,children:n,onStateChange:r}){const[i,s]=ne.useState(e),a=ne.useRef(null),[o,l]=ne.useState("auto");ne.useEffect(()=>{if(a.current){const c=a.current.scrollHeight;l(`${c}px`)}},[n]);const u=()=>{const c=!i;s(c),r&&r(c)};return D.jsxs("div",{className:"settings-section",children:[D.jsxs("div",{className:"section-header",onClick:u,children:[D.jsx("h2",{className:"section-title",children:t}),D.jsx("span",{className:`section-toggle ${i?"open":""}`,children:""})]}),D.jsx("div",{ref:a,className:`section-content ${i?"":"closed"}`,style:{maxHeight:i?o:"0"},children:n})]})}function Jve({settings:t,onSettingsChange:e,onStateChange:n}){return D.jsx(n7,{title:"Basic",defaultOpen:!0,onStateChange:n,children:D.jsxs("div",{className:"setting-fields",children:[D.jsxs("div",{className:"setting-field",children:[D.jsx("label",{children:"Type"}),D.jsxs("select",{value:t.itemType,onChange:r=>e({...t,itemType:r.target.value}),className:"compact-input",children:[D.jsx("option",{value:"T-shirt",children:"T-Shirt"}),D.jsx("option",{value:"Pants",children:"Pants"}),D.jsx("option",{value:"Full Body",children:"Full Body"})]})]}),D.jsxs("div",{className:"setting-field",children:[D.jsx("label",{children:"Size"}),D.jsxs("select",{value:t.standardSize,onChange:r=>{const i=r.target.value;e({...t,standardSize:i,measurements:S3[i]})},className:"compact-input",children:[D.jsx("option",{value:"XS",children:"XS"}),D.jsx("option",{value:"S",children:"S"}),D.jsx("option",{value:"M",children:"M"}),D.jsx("option",{value:"L",children:"L"}),D.jsx("option",{value:"XL",children:"XL"}),D.jsx("option",{value:"2XL",children:"2XL"})]})]}),D.jsxs("div",{className:"setting-field",children:[D.jsx("label",{children:"Color"}),D.jsxs("div",{className:"flex items-center gap-1",children:[D.jsx("input",{type:"color",value:t.color,onChange:r=>e({...t,color:r.target.value}),className:"w-6 h-6 rounded cursor-pointer"}),D.jsx("span",{className:"text-xs text-gray-600",children:t.color.toUpperCase()})]})]}),D.jsxs("div",{className:"setting-field",children:[D.jsx("label",{children:"Zoom"}),D.jsx(t7,{value:t.zoom??1,min:.5,max:2,step:.1,onChange:r=>e({...t,zoom:r})}),"        "]})]})})}function Yve({measurements:t,itemType:e,onMeasurementChange:n,onStateChange:r}){const i=()=>{const s=[{key:"neck",label:"Neck (inches)",range:Gc},{key:"chest",label:"Chest (inches)",range:Gc},{key:"waist",label:"Waist (inches)",range:Gc},{key:"hips",label:"Hips (inches)",range:Gc}],a=[{key:"shoulder",label:"Shoulder Width (inches)",range:Gc},{key:"sleeveLength",label:"Sleeve Length (inches)",range:Gc}],o=[{key:"inseam",label:"Inseam Length (inches)",range:Gc},{key:"thigh",label:"Thigh Circumference (inches)",range:Gc}],l={key:"height",label:"Height (inches)",range:Kve};switch(e){case"Full Body":return[...s,...a,...o,l];case"T-shirt":return[...s,...a];case"Pants":return[...s,...o];default:return s}};return D.jsx(n7,{title:"Measurements",defaultOpen:!0,onStateChange:r,children:D.jsxs("div",{className:"setting-fields",children:[i().map(s=>{var a,o;return D.jsx("div",{className:"setting-field",children:D.jsx(t7,{value:t[s.key]||0,onChange:l=>n(s.key,l),min:((a=s.range)==null?void 0:a.min)||0,max:((o=s.range)==null?void 0:o.max)||50,step:.5,label:s.label,unit:" in",showValue:!0})},s.key)}),"      "]})})}const Zve=ne.memo(function({settings:e,isPanelOpen:n,onPanelToggle:r,onSettingsChange:i,onMeasurementChange:s}){const a=ne.useRef(null),o=ne.useRef(0),l=ne.useRef(0),[u,c]=ne.useState(!1),[d,h]=ne.useState({basic:!0,measurements:!0}),p=w=>_=>{h(S=>({...S,[w]:_}))},f=!d.basic&&!d.measurements,g=d.basic&&!d.measurements||!d.basic&&d.measurements,y=ne.useCallback(w=>{a.current&&(o.current=w.touches[0].clientY,l.current=a.current.getBoundingClientRect().top,c(!0))},[]),m=ne.useCallback(w=>{if(!u||!a.current)return;const _=w.touches[0].clientY-o.current;l.current+_,(n&&_>0||!n&&_<0)&&(a.current.style.transform=`translateY(${_}px)`,w.preventDefault())},[u,n]),b=ne.useCallback(w=>{if(!u||!a.current)return;const _=w.changedTouches[0].clientY-o.current;Math.abs(_)>75&&(n&&_>0||!n&&_<0)&&r(),a.current.style.transform="",c(!1)},[u,n,r]);return ne.useEffect(()=>{const w=a.current;if(w)return w.addEventListener("touchstart",y,{passive:!1}),document.addEventListener("touchmove",m,{passive:!1}),document.addEventListener("touchend",b),()=>{w.removeEventListener("touchstart",y),document.removeEventListener("touchmove",m),document.removeEventListener("touchend",b)}},[y,m,b]),D.jsxs("div",{ref:a,className:`design-settings ${n?"open":"closed"} ${f?"all-collapsed":g?"one-collapsed":""}`,style:{touchAction:u?"none":"pan-y",transition:u?"none":void 0},children:[D.jsxs("div",{className:"settings-header",children:[D.jsx("span",{className:"text-sm font-semibold text-gray-900",children:"Settings"}),D.jsx("button",{className:"toggle-button",onClick:r,"aria-label":n?"Hide Settings":"Show Settings",children:D.jsx("span",{className:"toggle-icon",children:n?"":""})})]}),D.jsxs("div",{className:`settings-content ${n?"":"invisible"}`,children:[D.jsx(Jve,{settings:e,onSettingsChange:i,onStateChange:p("basic")}),D.jsx(Yve,{measurements:e.measurements,itemType:e.itemType,onMeasurementChange:s,onStateChange:p("measurements")})]})]})}),OW={POSITION:["byte","byte normalized","unsigned byte","unsigned byte normalized","short","short normalized","unsigned short","unsigned short normalized"],NORMAL:["byte normalized","short normalized"],TANGENT:["byte normalized","short normalized"],TEXCOORD:["byte","byte normalized","unsigned byte","short","short normalized","unsigned short"]};class h1{constructor(){this.textureUtils=null,this.pluginCallbacks=[],this.register(function(e){return new uxe(e)}),this.register(function(e){return new cxe(e)}),this.register(function(e){return new fxe(e)}),this.register(function(e){return new mxe(e)}),this.register(function(e){return new gxe(e)}),this.register(function(e){return new yxe(e)}),this.register(function(e){return new dxe(e)}),this.register(function(e){return new hxe(e)}),this.register(function(e){return new pxe(e)}),this.register(function(e){return new vxe(e)}),this.register(function(e){return new xxe(e)}),this.register(function(e){return new bxe(e)}),this.register(function(e){return new wxe(e)}),this.register(function(e){return new _xe(e)})}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}setTextureUtils(e){return this.textureUtils=e,this}parse(e,n,r,i){const s=new lxe,a=[];for(let o=0,l=this.pluginCallbacks.length;o<l;o++)a.push(this.pluginCallbacks[o](s));s.setPlugins(a),s.setTextureUtils(this.textureUtils),s.writeAsync(e,n,i).catch(r)}parseAsync(e,n){const r=this;return new Promise(function(i,s){r.parse(e,i,s,n)})}}const Vn={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,BYTE:5120,UNSIGNED_BYTE:5121,SHORT:5122,UNSIGNED_SHORT:5123,INT:5124,UNSIGNED_INT:5125,FLOAT:5126,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},fN="KHR_mesh_quantization",eo={};eo[yi]=Vn.NEAREST;eo[$1]=Vn.NEAREST_MIPMAP_NEAREST;eo[od]=Vn.NEAREST_MIPMAP_LINEAR;eo[er]=Vn.LINEAR;eo[Ap]=Vn.LINEAR_MIPMAP_NEAREST;eo[Ma]=Vn.LINEAR_MIPMAP_LINEAR;eo[jr]=Vn.CLAMP_TO_EDGE;eo[ac]=Vn.REPEAT;eo[Up]=Vn.MIRRORED_REPEAT;const BW={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"},Qve=new Ct,UW=12,exe=1179937895,txe=2,$W=8,nxe=1313821514,rxe=5130562;function Zx(t,e){return t.length===e.length&&t.every(function(n,r){return n===e[r]})}function ixe(t){return new TextEncoder().encode(t).buffer}function sxe(t){return Zx(t.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function axe(t,e,n){const r={min:new Array(t.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(t.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let i=e;i<e+n;i++)for(let s=0;s<t.itemSize;s++){let a;t.itemSize>4?a=t.array[i*t.itemSize+s]:(s===0?a=t.getX(i):s===1?a=t.getY(i):s===2?a=t.getZ(i):s===3&&(a=t.getW(i)),t.normalized===!0&&(a=Ju.normalize(a,t.array))),r.min[s]=Math.min(r.min[s],a),r.max[s]=Math.max(r.max[s],a)}return r}function r7(t){return Math.ceil(t/4)*4}function mN(t,e=0){const n=r7(t.byteLength);if(n!==t.byteLength){const r=new Uint8Array(n);if(r.set(new Uint8Array(t)),e!==0)for(let i=t.byteLength;i<n;i++)r[i]=e;return r.buffer}return t}function zW(){return typeof document>"u"&&typeof OffscreenCanvas<"u"?new OffscreenCanvas(1,1):document.createElement("canvas")}function oxe(t,e){if(t.toBlob!==void 0)return new Promise(r=>t.toBlob(r,e));let n;return e==="image/jpeg"?n=.92:e==="image/webp"&&(n=.8),t.convertToBlob({type:e,quality:n})}class lxe{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.extensionsRequired={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter r"+vf}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map},this.textureUtils=null}setPlugins(e){this.plugins=e}setTextureUtils(e){this.textureUtils=e}async writeAsync(e,n,r={}){this.options=Object.assign({binary:!1,trs:!1,onlyVisible:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},r),this.options.animations.length>0&&(this.options.trs=!0),await this.processInputAsync(e),await Promise.all(this.pending);const i=this,s=i.buffers,a=i.json;r=i.options;const o=i.extensionsUsed,l=i.extensionsRequired,u=new Blob(s,{type:"application/octet-stream"}),c=Object.keys(o),d=Object.keys(l);if(c.length>0&&(a.extensionsUsed=c),d.length>0&&(a.extensionsRequired=d),a.buffers&&a.buffers.length>0&&(a.buffers[0].byteLength=u.size),r.binary===!0){const h=new FileReader;h.readAsArrayBuffer(u),h.onloadend=function(){const p=mN(h.result),f=new DataView(new ArrayBuffer($W));f.setUint32(0,p.byteLength,!0),f.setUint32(4,rxe,!0);const g=mN(ixe(JSON.stringify(a)),32),y=new DataView(new ArrayBuffer($W));y.setUint32(0,g.byteLength,!0),y.setUint32(4,nxe,!0);const m=new ArrayBuffer(UW),b=new DataView(m);b.setUint32(0,exe,!0),b.setUint32(4,txe,!0);const w=UW+y.byteLength+g.byteLength+f.byteLength+p.byteLength;b.setUint32(8,w,!0);const _=new Blob([m,y,g,f,p],{type:"application/octet-stream"}),S=new FileReader;S.readAsArrayBuffer(_),S.onloadend=function(){n(S.result)}}}else if(a.buffers&&a.buffers.length>0){const h=new FileReader;h.readAsDataURL(u),h.onloadend=function(){const p=h.result;a.buffers[0].uri=p,n(a)}}else n(a)}serializeUserData(e,n){if(Object.keys(e.userData).length===0)return;const r=this.options,i=this.extensionsUsed;try{const s=JSON.parse(JSON.stringify(e.userData));if(r.includeCustomExtensions&&s.gltfExtensions){n.extensions===void 0&&(n.extensions={});for(const a in s.gltfExtensions)n.extensions[a]=s.gltfExtensions[a],i[a]=!0;delete s.gltfExtensions}Object.keys(s).length>0&&(n.extras=s)}catch(s){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+s.message)}}getUID(e,n=!1){if(this.uids.has(e)===!1){const i=new Map;i.set(!0,this.uid++),i.set(!1,this.uid++),this.uids.set(e,i)}return this.uids.get(e).get(n)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const r=new Z;for(let i=0,s=e.count;i<s;i++)if(Math.abs(r.fromBufferAttribute(e,i).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const n=this.cache;if(n.attributesNormalized.has(e))return n.attributesNormalized.get(e);const r=e.clone(),i=new Z;for(let s=0,a=r.count;s<a;s++)i.fromBufferAttribute(r,s),i.x===0&&i.y===0&&i.z===0?i.setX(1):i.normalize(),r.setXYZ(s,i.x,i.y,i.z);return n.attributesNormalized.set(e,r),r}applyTextureTransform(e,n){let r=!1;const i={};(n.offset.x!==0||n.offset.y!==0)&&(i.offset=n.offset.toArray(),r=!0),n.rotation!==0&&(i.rotation=n.rotation,r=!0),(n.repeat.x!==1||n.repeat.y!==1)&&(i.scale=n.repeat.toArray(),r=!0),r&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=i,this.extensionsUsed.KHR_texture_transform=!0)}async buildMetalRoughTextureAsync(e,n){if(e===n)return e;function r(p){return p.colorSpace===Ui?function(g){return g<.04045?g*.0773993808:Math.pow(g*.9478672986+.0521327014,2.4)}:function(g){return g}}e instanceof Tp&&(e=await this.decompressTextureAsync(e)),n instanceof Tp&&(n=await this.decompressTextureAsync(n));const i=e?e.image:null,s=n?n.image:null,a=Math.max(i?i.width:0,s?s.width:0),o=Math.max(i?i.height:0,s?s.height:0),l=zW();l.width=a,l.height=o;const u=l.getContext("2d",{willReadFrequently:!0});u.fillStyle="#00ffff",u.fillRect(0,0,a,o);const c=u.getImageData(0,0,a,o);if(i){u.drawImage(i,0,0,a,o);const p=r(e),f=u.getImageData(0,0,a,o).data;for(let g=2;g<f.length;g+=4)c.data[g]=p(f[g]/256)*256}if(s){u.drawImage(s,0,0,a,o);const p=r(n),f=u.getImageData(0,0,a,o).data;for(let g=1;g<f.length;g+=4)c.data[g]=p(f[g]/256)*256}u.putImageData(c,0,0);const h=(e||n).clone();return h.source=new ju(l),h.colorSpace=Jl,h.channel=(e||n).channel,e&&n&&e.channel!==n.channel&&console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."),console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."),h}async decompressTextureAsync(e,n=1/0){if(this.textureUtils===null)throw new Error("THREE.GLTFExporter: setTextureUtils() must be called to process compressed textures.");return await this.textureUtils.decompress(e,n)}processBuffer(e){const n=this.json,r=this.buffers;return n.buffers||(n.buffers=[{byteLength:0}]),r.push(e),0}processBufferView(e,n,r,i,s){const a=this.json;a.bufferViews||(a.bufferViews=[]);let o;switch(n){case Vn.BYTE:case Vn.UNSIGNED_BYTE:o=1;break;case Vn.SHORT:case Vn.UNSIGNED_SHORT:o=2;break;default:o=4}let l=e.itemSize*o;s===Vn.ARRAY_BUFFER&&(l=Math.ceil(l/4)*4);const u=r7(i*l),c=new DataView(new ArrayBuffer(u));let d=0;for(let f=r;f<r+i;f++){for(let g=0;g<e.itemSize;g++){let y;e.itemSize>4?y=e.array[f*e.itemSize+g]:(g===0?y=e.getX(f):g===1?y=e.getY(f):g===2?y=e.getZ(f):g===3&&(y=e.getW(f)),e.normalized===!0&&(y=Ju.normalize(y,e.array))),n===Vn.FLOAT?c.setFloat32(d,y,!0):n===Vn.INT?c.setInt32(d,y,!0):n===Vn.UNSIGNED_INT?c.setUint32(d,y,!0):n===Vn.SHORT?c.setInt16(d,y,!0):n===Vn.UNSIGNED_SHORT?c.setUint16(d,y,!0):n===Vn.BYTE?c.setInt8(d,y):n===Vn.UNSIGNED_BYTE&&c.setUint8(d,y),d+=o}d%l!==0&&(d+=l-d%l)}const h={buffer:this.processBuffer(c.buffer),byteOffset:this.byteOffset,byteLength:u};return s!==void 0&&(h.target=s),s===Vn.ARRAY_BUFFER&&(h.byteStride=l),this.byteOffset+=u,a.bufferViews.push(h),{id:a.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const n=this,r=n.json;return r.bufferViews||(r.bufferViews=[]),new Promise(function(i){const s=new FileReader;s.readAsArrayBuffer(e),s.onloadend=function(){const a=mN(s.result),o={buffer:n.processBuffer(a),byteOffset:n.byteOffset,byteLength:a.byteLength};n.byteOffset+=a.byteLength,i(r.bufferViews.push(o)-1)}})}processAccessor(e,n,r,i){const s=this.json,a={1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",9:"MAT3",16:"MAT4"};let o;if(e.array.constructor===Float32Array)o=Vn.FLOAT;else if(e.array.constructor===Int32Array)o=Vn.INT;else if(e.array.constructor===Uint32Array)o=Vn.UNSIGNED_INT;else if(e.array.constructor===Int16Array)o=Vn.SHORT;else if(e.array.constructor===Uint16Array)o=Vn.UNSIGNED_SHORT;else if(e.array.constructor===Int8Array)o=Vn.BYTE;else if(e.array.constructor===Uint8Array)o=Vn.UNSIGNED_BYTE;else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: "+e.array.constructor.name);if(r===void 0&&(r=0),(i===void 0||i===1/0)&&(i=e.count),i===0)return null;const l=axe(e,r,i);let u;n!==void 0&&(u=e===n.index?Vn.ELEMENT_ARRAY_BUFFER:Vn.ARRAY_BUFFER);const c=this.processBufferView(e,o,r,i,u),d={bufferView:c.id,byteOffset:c.byteOffset,componentType:o,count:i,max:l.max,min:l.min,type:a[e.itemSize]};return e.normalized===!0&&(d.normalized=!0),s.accessors||(s.accessors=[]),s.accessors.push(d)-1}processImage(e,n,r,i="image/png"){if(e!==null){const s=this,a=s.cache,o=s.json,l=s.options,u=s.pending;a.images.has(e)||a.images.set(e,{});const c=a.images.get(e),d=i+":flipY/"+r.toString();if(c[d]!==void 0)return c[d];o.images||(o.images=[]);const h={mimeType:i},p=zW();p.width=Math.min(e.width,l.maxTextureSize),p.height=Math.min(e.height,l.maxTextureSize);const f=p.getContext("2d",{willReadFrequently:!0});if(r===!0&&(f.translate(0,p.height),f.scale(1,-1)),e.data!==void 0){n!==ui&&console.error("GLTFExporter: Only RGBAFormat is supported.",n),(e.width>l.maxTextureSize||e.height>l.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const y=new Uint8ClampedArray(e.height*e.width*4);for(let m=0;m<y.length;m+=4)y[m+0]=e.data[m+0],y[m+1]=e.data[m+1],y[m+2]=e.data[m+2],y[m+3]=e.data[m+3];f.putImageData(new ImageData(y,e.width,e.height),0,0)}else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap||typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas)f.drawImage(e,0,0,p.width,p.height);else throw new Error("THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.");l.binary===!0?u.push(oxe(p,i).then(y=>s.processBufferViewImage(y)).then(y=>{h.bufferView=y})):h.uri=IP.getDataURL(p,i);const g=o.images.push(h)-1;return c[d]=g,g}else throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")}processSampler(e){const n=this.json;n.samplers||(n.samplers=[]);const r={magFilter:eo[e.magFilter],minFilter:eo[e.minFilter],wrapS:eo[e.wrapS],wrapT:eo[e.wrapT]};return n.samplers.push(r)-1}async processTextureAsync(e){const r=this.options,i=this.cache,s=this.json;if(i.textures.has(e))return i.textures.get(e);s.textures||(s.textures=[]),e instanceof Tp&&(e=await this.decompressTextureAsync(e,r.maxTextureSize));let a=e.userData.mimeType;a==="image/webp"&&(a="image/png");const o={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY,a)};e.name&&(o.name=e.name),await this._invokeAllAsync(async function(u){u.writeTexture&&await u.writeTexture(e,o)});const l=s.textures.push(o)-1;return i.textures.set(e,l),l}async processMaterialAsync(e){const n=this.cache,r=this.json;if(n.materials.has(e))return n.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;r.materials||(r.materials=[]);const i={pbrMetallicRoughness:{}};e.isMeshStandardMaterial!==!0&&e.isMeshBasicMaterial!==!0&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const s=e.color.toArray().concat([e.opacity]);if(Zx(s,[1,1,1,1])||(i.pbrMetallicRoughness.baseColorFactor=s),e.isMeshStandardMaterial?(i.pbrMetallicRoughness.metallicFactor=e.metalness,i.pbrMetallicRoughness.roughnessFactor=e.roughness):(i.pbrMetallicRoughness.metallicFactor=0,i.pbrMetallicRoughness.roughnessFactor=1),e.metalnessMap||e.roughnessMap){const o=await this.buildMetalRoughTextureAsync(e.metalnessMap,e.roughnessMap),l={index:await this.processTextureAsync(o),texCoord:o.channel};this.applyTextureTransform(l,o),i.pbrMetallicRoughness.metallicRoughnessTexture=l}if(e.map){const o={index:await this.processTextureAsync(e.map),texCoord:e.map.channel};this.applyTextureTransform(o,e.map),i.pbrMetallicRoughness.baseColorTexture=o}if(e.emissive){const o=e.emissive;if(Math.max(o.r,o.g,o.b)>0&&(i.emissiveFactor=e.emissive.toArray()),e.emissiveMap){const u={index:await this.processTextureAsync(e.emissiveMap),texCoord:e.emissiveMap.channel};this.applyTextureTransform(u,e.emissiveMap),i.emissiveTexture=u}}if(e.normalMap){const o={index:await this.processTextureAsync(e.normalMap),texCoord:e.normalMap.channel};e.normalScale&&e.normalScale.x!==1&&(o.scale=e.normalScale.x),this.applyTextureTransform(o,e.normalMap),i.normalTexture=o}if(e.aoMap){const o={index:await this.processTextureAsync(e.aoMap),texCoord:e.aoMap.channel};e.aoMapIntensity!==1&&(o.strength=e.aoMapIntensity),this.applyTextureTransform(o,e.aoMap),i.occlusionTexture=o}e.transparent?i.alphaMode="BLEND":e.alphaTest>0&&(i.alphaMode="MASK",i.alphaCutoff=e.alphaTest),e.side===ta&&(i.doubleSided=!0),e.name!==""&&(i.name=e.name),this.serializeUserData(e,i),await this._invokeAllAsync(async function(o){o.writeMaterialAsync&&await o.writeMaterialAsync(e,i)});const a=r.materials.push(i)-1;return n.materials.set(e,a),a}async processMeshAsync(e){const n=this.cache,r=this.json,i=[e.geometry.uuid];if(Array.isArray(e.material))for(let _=0,S=e.material.length;_<S;_++)i.push(e.material[_].uuid);else i.push(e.material.uuid);const s=i.join(":");if(n.meshes.has(s))return n.meshes.get(s);const a=e.geometry;let o;e.isLineSegments?o=Vn.LINES:e.isLineLoop?o=Vn.LINE_LOOP:e.isLine?o=Vn.LINE_STRIP:e.isPoints?o=Vn.POINTS:o=e.material.wireframe?Vn.LINES:Vn.TRIANGLES;const l={},u={},c=[],d=[],h={uv:"TEXCOORD_0",uv1:"TEXCOORD_1",uv2:"TEXCOORD_2",uv3:"TEXCOORD_3",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},p=a.getAttribute("normal");p!==void 0&&!this.isNormalizedNormalAttribute(p)&&(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),a.setAttribute("normal",this.createNormalizedNormalAttribute(p)));let f=null;for(let _ in a.attributes){if(_.slice(0,5)==="morph")continue;const S=a.attributes[_];if(_=h[_]||_.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(_)||(_="_"+_),n.attributes.has(this.getUID(S))){u[_]=n.attributes.get(this.getUID(S));continue}f=null;const C=S.array;_==="JOINTS_0"&&!(C instanceof Uint16Array)&&!(C instanceof Uint8Array)?(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),f=new Ln(new Uint16Array(C),S.itemSize,S.normalized)):(C instanceof Uint32Array||C instanceof Int32Array)&&!_.startsWith("_")&&(console.warn(`GLTFExporter: Attribute "${_}" converted to type FLOAT.`),f=h1.Utils.toFloat32BufferAttribute(S));const T=this.processAccessor(f||S,a);T!==null&&(_.startsWith("_")||this.detectMeshQuantization(_,S),u[_]=T,n.attributes.set(this.getUID(S),T))}if(p!==void 0&&a.setAttribute("normal",p),Object.keys(u).length===0)return null;if(e.morphTargetInfluences!==void 0&&e.morphTargetInfluences.length>0){const _=[],S=[],E={};if(e.morphTargetDictionary!==void 0)for(const C in e.morphTargetDictionary)E[e.morphTargetDictionary[C]]=C;for(let C=0;C<e.morphTargetInfluences.length;++C){const T={};let M=!1;for(const k in a.morphAttributes){if(k!=="position"&&k!=="normal"){M||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),M=!0);continue}const R=a.morphAttributes[k][C],N=k.toUpperCase(),B=a.attributes[k];if(n.attributes.has(this.getUID(R,!0))){T[N]=n.attributes.get(this.getUID(R,!0));continue}const z=R.clone();if(!a.morphTargetsRelative)for(let V=0,K=R.count;V<K;V++)for(let Q=0;Q<R.itemSize;Q++)Q===0&&z.setX(V,R.getX(V)-B.getX(V)),Q===1&&z.setY(V,R.getY(V)-B.getY(V)),Q===2&&z.setZ(V,R.getZ(V)-B.getZ(V)),Q===3&&z.setW(V,R.getW(V)-B.getW(V));T[N]=this.processAccessor(z,a),n.attributes.set(this.getUID(B,!0),T[N])}d.push(T),_.push(e.morphTargetInfluences[C]),e.morphTargetDictionary!==void 0&&S.push(E[C])}l.weights=_,S.length>0&&(l.extras={},l.extras.targetNames=S)}const g=Array.isArray(e.material);if(g&&a.groups.length===0)return null;let y=!1;if(g&&a.index===null){const _=[];for(let S=0,E=a.attributes.position.count;S<E;S++)_[S]=S;a.setIndex(_),y=!0}const m=g?e.material:[e.material],b=g?a.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let _=0,S=b.length;_<S;_++){const E={mode:o,attributes:u};if(this.serializeUserData(a,E),d.length>0&&(E.targets=d),a.index!==null){let T=this.getUID(a.index);(b[_].start!==void 0||b[_].count!==void 0)&&(T+=":"+b[_].start+":"+b[_].count),n.attributes.has(T)?E.indices=n.attributes.get(T):(E.indices=this.processAccessor(a.index,a,b[_].start,b[_].count),n.attributes.set(T,E.indices)),E.indices===null&&delete E.indices}const C=await this.processMaterialAsync(m[b[_].materialIndex]);C!==null&&(E.material=C),c.push(E)}y===!0&&a.setIndex(null),l.primitives=c,r.meshes||(r.meshes=[]),await this._invokeAllAsync(function(_){_.writeMesh&&_.writeMesh(e,l)});const w=r.meshes.push(l)-1;return n.meshes.set(s,w),w}detectMeshQuantization(e,n){if(this.extensionsUsed[fN])return;let r;switch(n.array.constructor){case Int8Array:r="byte";break;case Uint8Array:r="unsigned byte";break;case Int16Array:r="short";break;case Uint16Array:r="unsigned short";break;default:return}n.normalized&&(r+=" normalized");const i=e.split("_",1)[0];OW[i]&&OW[i].includes(r)&&(this.extensionsUsed[fN]=!0,this.extensionsRequired[fN]=!0)}processCamera(e){const n=this.json;n.cameras||(n.cameras=[]);const r=e.isOrthographicCamera,i={type:r?"orthographic":"perspective"};return r?i.orthographic={xmag:e.right*2,ymag:e.top*2,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:i.perspective={aspectRatio:e.aspect,yfov:Ju.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},e.name!==""&&(i.name=e.type),n.cameras.push(i)-1}processAnimation(e,n){const r=this.json,i=this.nodeMap;r.animations||(r.animations=[]),e=h1.Utils.mergeMorphTargetTracks(e.clone(),n);const s=e.tracks,a=[],o=[];for(let l=0;l<s.length;++l){const u=s[l],c=Hn.parseTrackName(u.name);let d=Hn.findNode(n,c.nodeName);const h=BW[c.propertyName];if(c.objectName==="bones"&&(d.isSkinnedMesh===!0?d=d.skeleton.getBoneByName(c.objectIndex):d=void 0),!d||!h){console.warn('THREE.GLTFExporter: Could not export animation track "%s".',u.name);continue}const p=1;let f=u.values.length/u.times.length;h===BW.morphTargetInfluences&&(f/=d.morphTargetInfluences.length);let g;u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline===!0?(g="CUBICSPLINE",f/=3):u.getInterpolation()===$p?g="STEP":g="LINEAR",o.push({input:this.processAccessor(new Ln(u.times,p)),output:this.processAccessor(new Ln(u.values,f)),interpolation:g}),a.push({sampler:o.length-1,target:{node:i.get(d),path:h}})}return r.animations.push({name:e.name||"clip_"+r.animations.length,samplers:o,channels:a}),r.animations.length-1}processSkin(e){const n=this.json,r=this.nodeMap,i=n.nodes[r.get(e)],s=e.skeleton;if(s===void 0)return null;const a=e.skeleton.bones[0];if(a===void 0)return null;const o=[],l=new Float32Array(s.bones.length*16),u=new ln;for(let d=0;d<s.bones.length;++d)o.push(r.get(s.bones[d])),u.copy(s.boneInverses[d]),u.multiply(e.bindMatrix).toArray(l,d*16);return n.skins===void 0&&(n.skins=[]),n.skins.push({inverseBindMatrices:this.processAccessor(new Ln(l,16)),joints:o,skeleton:r.get(a)}),i.skin=n.skins.length-1}async processNodeAsync(e){const n=this.json,r=this.options,i=this.nodeMap;n.nodes||(n.nodes=[]);const s={};if(r.trs){const o=e.quaternion.toArray(),l=e.position.toArray(),u=e.scale.toArray();Zx(o,[0,0,0,1])||(s.rotation=o),Zx(l,[0,0,0])||(s.translation=l),Zx(u,[1,1,1])||(s.scale=u)}else e.matrixAutoUpdate&&e.updateMatrix(),sxe(e.matrix)===!1&&(s.matrix=e.matrix.elements);if(e.name!==""&&(s.name=String(e.name)),this.serializeUserData(e,s),e.isMesh||e.isLine||e.isPoints){const o=await this.processMeshAsync(e);o!==null&&(s.mesh=o)}else e.isCamera&&(s.camera=this.processCamera(e));e.isSkinnedMesh&&this.skins.push(e);const a=n.nodes.push(s)-1;if(i.set(e,a),e.children.length>0){const o=[];for(let l=0,u=e.children.length;l<u;l++){const c=e.children[l];if(c.visible||r.onlyVisible===!1){const d=await this.processNodeAsync(c);d!==null&&o.push(d)}}o.length>0&&(s.children=o)}return await this._invokeAllAsync(function(o){o.writeNode&&o.writeNode(e,s)}),a}async processSceneAsync(e){const n=this.json,r=this.options;n.scenes||(n.scenes=[],n.scene=0);const i={};e.name!==""&&(i.name=e.name),n.scenes.push(i);const s=[];for(let a=0,o=e.children.length;a<o;a++){const l=e.children[a];if(l.visible||r.onlyVisible===!1){const u=await this.processNodeAsync(l);u!==null&&s.push(u)}}s.length>0&&(i.nodes=s),this.serializeUserData(e,i)}async processObjectsAsync(e){const n=new oc;n.name="AuxScene";for(let r=0;r<e.length;r++)n.children.push(e[r]);await this.processSceneAsync(n)}async processInputAsync(e){const n=this.options;e=e instanceof Array?e:[e],await this._invokeAllAsync(function(i){i.beforeParse&&i.beforeParse(e)});const r=[];for(let i=0;i<e.length;i++)e[i]instanceof oc?await this.processSceneAsync(e[i]):r.push(e[i]);r.length>0&&await this.processObjectsAsync(r);for(let i=0;i<this.skins.length;++i)this.processSkin(this.skins[i]);for(let i=0;i<n.animations.length;++i)this.processAnimation(n.animations[i],e[0]);await this._invokeAllAsync(function(i){i.afterParse&&i.afterParse(e)})}async _invokeAllAsync(e){for(let n=0,r=this.plugins.length;n<r;n++)await e(this.plugins[n])}}class uxe{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,n){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight){console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);return}const r=this.writer,i=r.json,s=r.extensionsUsed,a={};e.name&&(a.name=e.name),a.color=e.color.toArray(),a.intensity=e.intensity,e.isDirectionalLight?a.type="directional":e.isPointLight?(a.type="point",e.distance>0&&(a.range=e.distance)):e.isSpotLight&&(a.type="spot",e.distance>0&&(a.range=e.distance),a.spot={},a.spot.innerConeAngle=(1-e.penumbra)*e.angle,a.spot.outerConeAngle=e.angle),e.decay!==void 0&&e.decay!==2&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),e.target&&(e.target.parent!==e||e.target.position.x!==0||e.target.position.y!==0||e.target.position.z!==-1)&&console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),s[this.name]||(i.extensions=i.extensions||{},i.extensions[this.name]={lights:[]},s[this.name]=!0);const o=i.extensions[this.name].lights;o.push(a),n.extensions=n.extensions||{},n.extensions[this.name]={light:o.length-1}}}class cxe{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}async writeMaterialAsync(e,n){if(!e.isMeshBasicMaterial)return;const i=this.writer.extensionsUsed;n.extensions=n.extensions||{},n.extensions[this.name]={},i[this.name]=!0,n.pbrMetallicRoughness.metallicFactor=0,n.pbrMetallicRoughness.roughnessFactor=.9}}class dxe{constructor(e){this.writer=e,this.name="KHR_materials_clearcoat"}async writeMaterialAsync(e,n){if(!e.isMeshPhysicalMaterial||e.clearcoat===0)return;const r=this.writer,i=r.extensionsUsed,s={};if(s.clearcoatFactor=e.clearcoat,e.clearcoatMap){const a={index:await r.processTextureAsync(e.clearcoatMap),texCoord:e.clearcoatMap.channel};r.applyTextureTransform(a,e.clearcoatMap),s.clearcoatTexture=a}if(s.clearcoatRoughnessFactor=e.clearcoatRoughness,e.clearcoatRoughnessMap){const a={index:await r.processTextureAsync(e.clearcoatRoughnessMap),texCoord:e.clearcoatRoughnessMap.channel};r.applyTextureTransform(a,e.clearcoatRoughnessMap),s.clearcoatRoughnessTexture=a}if(e.clearcoatNormalMap){const a={index:await r.processTextureAsync(e.clearcoatNormalMap),texCoord:e.clearcoatNormalMap.channel};e.clearcoatNormalScale.x!==1&&(a.scale=e.clearcoatNormalScale.x),r.applyTextureTransform(a,e.clearcoatNormalMap),s.clearcoatNormalTexture=a}n.extensions=n.extensions||{},n.extensions[this.name]=s,i[this.name]=!0}}class hxe{constructor(e){this.writer=e,this.name="KHR_materials_dispersion"}async writeMaterialAsync(e,n){if(!e.isMeshPhysicalMaterial||e.dispersion===0)return;const i=this.writer.extensionsUsed,s={};s.dispersion=e.dispersion,n.extensions=n.extensions||{},n.extensions[this.name]=s,i[this.name]=!0}}class pxe{constructor(e){this.writer=e,this.name="KHR_materials_iridescence"}async writeMaterialAsync(e,n){if(!e.isMeshPhysicalMaterial||e.iridescence===0)return;const r=this.writer,i=r.extensionsUsed,s={};if(s.iridescenceFactor=e.iridescence,e.iridescenceMap){const a={index:await r.processTextureAsync(e.iridescenceMap),texCoord:e.iridescenceMap.channel};r.applyTextureTransform(a,e.iridescenceMap),s.iridescenceTexture=a}if(s.iridescenceIor=e.iridescenceIOR,s.iridescenceThicknessMinimum=e.iridescenceThicknessRange[0],s.iridescenceThicknessMaximum=e.iridescenceThicknessRange[1],e.iridescenceThicknessMap){const a={index:await r.processTextureAsync(e.iridescenceThicknessMap),texCoord:e.iridescenceThicknessMap.channel};r.applyTextureTransform(a,e.iridescenceThicknessMap),s.iridescenceThicknessTexture=a}n.extensions=n.extensions||{},n.extensions[this.name]=s,i[this.name]=!0}}class fxe{constructor(e){this.writer=e,this.name="KHR_materials_transmission"}async writeMaterialAsync(e,n){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const r=this.writer,i=r.extensionsUsed,s={};if(s.transmissionFactor=e.transmission,e.transmissionMap){const a={index:await r.processTextureAsync(e.transmissionMap),texCoord:e.transmissionMap.channel};r.applyTextureTransform(a,e.transmissionMap),s.transmissionTexture=a}n.extensions=n.extensions||{},n.extensions[this.name]=s,i[this.name]=!0}}class mxe{constructor(e){this.writer=e,this.name="KHR_materials_volume"}async writeMaterialAsync(e,n){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const r=this.writer,i=r.extensionsUsed,s={};if(s.thicknessFactor=e.thickness,e.thicknessMap){const a={index:await r.processTextureAsync(e.thicknessMap),texCoord:e.thicknessMap.channel};r.applyTextureTransform(a,e.thicknessMap),s.thicknessTexture=a}e.attenuationDistance!==1/0&&(s.attenuationDistance=e.attenuationDistance),s.attenuationColor=e.attenuationColor.toArray(),n.extensions=n.extensions||{},n.extensions[this.name]=s,i[this.name]=!0}}class gxe{constructor(e){this.writer=e,this.name="KHR_materials_ior"}async writeMaterialAsync(e,n){if(!e.isMeshPhysicalMaterial||e.ior===1.5)return;const i=this.writer.extensionsUsed,s={};s.ior=e.ior,n.extensions=n.extensions||{},n.extensions[this.name]=s,i[this.name]=!0}}class yxe{constructor(e){this.writer=e,this.name="KHR_materials_specular"}async writeMaterialAsync(e,n){if(!e.isMeshPhysicalMaterial||e.specularIntensity===1&&e.specularColor.equals(Qve)&&!e.specularIntensityMap&&!e.specularColorMap)return;const r=this.writer,i=r.extensionsUsed,s={};if(e.specularIntensityMap){const a={index:await r.processTextureAsync(e.specularIntensityMap),texCoord:e.specularIntensityMap.channel};r.applyTextureTransform(a,e.specularIntensityMap),s.specularTexture=a}if(e.specularColorMap){const a={index:await r.processTextureAsync(e.specularColorMap),texCoord:e.specularColorMap.channel};r.applyTextureTransform(a,e.specularColorMap),s.specularColorTexture=a}s.specularFactor=e.specularIntensity,s.specularColorFactor=e.specularColor.toArray(),n.extensions=n.extensions||{},n.extensions[this.name]=s,i[this.name]=!0}}class vxe{constructor(e){this.writer=e,this.name="KHR_materials_sheen"}async writeMaterialAsync(e,n){if(!e.isMeshPhysicalMaterial||e.sheen==0)return;const r=this.writer,i=r.extensionsUsed,s={};if(e.sheenRoughnessMap){const a={index:await r.processTextureAsync(e.sheenRoughnessMap),texCoord:e.sheenRoughnessMap.channel};r.applyTextureTransform(a,e.sheenRoughnessMap),s.sheenRoughnessTexture=a}if(e.sheenColorMap){const a={index:await r.processTextureAsync(e.sheenColorMap),texCoord:e.sheenColorMap.channel};r.applyTextureTransform(a,e.sheenColorMap),s.sheenColorTexture=a}s.sheenRoughnessFactor=e.sheenRoughness,s.sheenColorFactor=e.sheenColor.toArray(),n.extensions=n.extensions||{},n.extensions[this.name]=s,i[this.name]=!0}}class xxe{constructor(e){this.writer=e,this.name="KHR_materials_anisotropy"}async writeMaterialAsync(e,n){if(!e.isMeshPhysicalMaterial||e.anisotropy==0)return;const r=this.writer,i=r.extensionsUsed,s={};if(e.anisotropyMap){const a={index:await r.processTextureAsync(e.anisotropyMap)};r.applyTextureTransform(a,e.anisotropyMap),s.anisotropyTexture=a}s.anisotropyStrength=e.anisotropy,s.anisotropyRotation=e.anisotropyRotation,n.extensions=n.extensions||{},n.extensions[this.name]=s,i[this.name]=!0}}class bxe{constructor(e){this.writer=e,this.name="KHR_materials_emissive_strength"}async writeMaterialAsync(e,n){if(!e.isMeshStandardMaterial||e.emissiveIntensity===1)return;const i=this.writer.extensionsUsed,s={};s.emissiveStrength=e.emissiveIntensity,n.extensions=n.extensions||{},n.extensions[this.name]=s,i[this.name]=!0}}class wxe{constructor(e){this.writer=e,this.name="EXT_materials_bump"}async writeMaterialAsync(e,n){if(!e.isMeshStandardMaterial||e.bumpScale===1&&!e.bumpMap)return;const r=this.writer,i=r.extensionsUsed,s={};if(e.bumpMap){const a={index:await r.processTextureAsync(e.bumpMap),texCoord:e.bumpMap.channel};r.applyTextureTransform(a,e.bumpMap),s.bumpTexture=a}s.bumpFactor=e.bumpScale,n.extensions=n.extensions||{},n.extensions[this.name]=s,i[this.name]=!0}}class _xe{constructor(e){this.writer=e,this.name="EXT_mesh_gpu_instancing"}writeNode(e,n){if(!e.isInstancedMesh)return;const r=this.writer,i=e,s=new Float32Array(i.count*3),a=new Float32Array(i.count*4),o=new Float32Array(i.count*3),l=new ln,u=new Z,c=new Kr,d=new Z;for(let p=0;p<i.count;p++)i.getMatrixAt(p,l),l.decompose(u,c,d),u.toArray(s,p*3),c.toArray(a,p*4),d.toArray(o,p*3);const h={TRANSLATION:r.processAccessor(new Ln(s,3)),ROTATION:r.processAccessor(new Ln(a,4)),SCALE:r.processAccessor(new Ln(o,3))};i.instanceColor&&(h._COLOR_0=r.processAccessor(i.instanceColor)),n.extensions=n.extensions||{},n.extensions[this.name]={attributes:h},r.extensionsUsed[this.name]=!0,r.extensionsRequired[this.name]=!0}}h1.Utils={insertKeyframe:function(t,e){const r=t.getValueSize(),i=new t.TimeBufferType(t.times.length+1),s=new t.ValueBufferType(t.values.length+r),a=t.createInterpolant(new t.ValueBufferType(r));let o;if(t.times.length===0){i[0]=e;for(let l=0;l<r;l++)s[l]=0;o=0}else if(e<t.times[0]){if(Math.abs(t.times[0]-e)<.001)return 0;i[0]=e,i.set(t.times,1),s.set(a.evaluate(e),0),s.set(t.values,r),o=0}else if(e>t.times[t.times.length-1]){if(Math.abs(t.times[t.times.length-1]-e)<.001)return t.times.length-1;i[i.length-1]=e,i.set(t.times,0),s.set(t.values,0),s.set(a.evaluate(e),t.values.length),o=i.length-1}else for(let l=0;l<t.times.length;l++){if(Math.abs(t.times[l]-e)<.001)return l;if(t.times[l]<e&&t.times[l+1]>e){i.set(t.times.slice(0,l+1),0),i[l+1]=e,i.set(t.times.slice(l+1),l+2),s.set(t.values.slice(0,(l+1)*r),0),s.set(a.evaluate(e),(l+1)*r),s.set(t.values.slice((l+1)*r),(l+2)*r),o=l+1;break}}return t.times=i,t.values=s,o},mergeMorphTargetTracks:function(t,e){const n=[],r={},i=t.tracks;for(let s=0;s<i.length;++s){let a=i[s];const o=Hn.parseTrackName(a.name),l=Hn.findNode(e,o.nodeName);if(o.propertyName!=="morphTargetInfluences"||o.propertyIndex===void 0){n.push(a);continue}if(a.createInterpolant!==a.InterpolantFactoryMethodDiscrete&&a.createInterpolant!==a.InterpolantFactoryMethodLinear){if(a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),a=a.clone(),a.setInterpolation(zp)}const u=l.morphTargetInfluences.length,c=l.morphTargetDictionary[o.propertyIndex];if(c===void 0)throw new Error("THREE.GLTFExporter: Morph target name not found: "+o.propertyIndex);let d;if(r[l.uuid]===void 0){d=a.clone();const p=new d.ValueBufferType(u*d.times.length);for(let f=0;f<d.times.length;f++)p[f*u+c]=d.values[f];d.name=(o.nodeName||"")+".morphTargetInfluences",d.values=p,r[l.uuid]=d,n.push(d);continue}const h=a.createInterpolant(new a.ValueBufferType(1));d=r[l.uuid];for(let p=0;p<d.times.length;p++)d.values[p*u+c]=h.evaluate(d.times[p]);for(let p=0;p<a.times.length;p++){const f=this.insertKeyframe(d,a.times[p]);d.values[f*u+c]=a.values[p]}}return t.tracks=n,t},toFloat32BufferAttribute:function(t){const e=new Ln(new Float32Array(t.count*t.itemSize),t.itemSize,!1);if(!t.normalized&&!t.isInterleavedBufferAttribute)return e.array.set(t.array),e;for(let n=0,r=t.count;n<r;n++)for(let i=0;i<t.itemSize;i++)e.setComponent(n,i,t.getComponent(n,i));return e}};class gN{static isValidImageFile(e){return e.type.startsWith("image/")}static async createMaterialFromImage(e){const n=URL.createObjectURL(e);try{const r=await new Promise((o,l)=>{const u=new Image;u.onload=()=>o(u),u.onerror=l,u.src=n}),i=r.width/r.height,s=await new Promise((o,l)=>{new qT().load(n,u=>{u.colorSpace=Ui,u.encoding=void 0,u.needsUpdate=!0,u.generateMipmaps=!0,u.minFilter=HE,u.magFilter=er,o(u)},void 0,l)});return{material:new Zd({map:s,transparent:!0,roughness:.5,metalness:0,side:ta,envMapIntensity:1,color:16777215}),aspectRatio:i}}finally{URL.revokeObjectURL(n)}}static async convertImageToTexture(e){try{const{material:n,aspectRatio:r}=await this.createMaterialFromImage(e),i=new yu(r,1),s=new Cr(i,n);s.name="ImagePlane";const a=new oc,o=new JT(16777215,.5);a.add(o);const l=new Q1(16777215,1);l.position.set(5,5,5),l.castShadow=!0,a.add(l),a.add(s);const u=new h1,c=await new Promise((d,h)=>{u.parse(a,p=>{p instanceof ArrayBuffer?d(new Blob([p],{type:"model/gltf-binary"})):h(new Error("Failed to export GLB"))},p=>h(p),{binary:!0,includeCustomExtensions:!0,embedImages:!0})});return new Promise((d,h)=>{const p=new FileReader;p.onload=()=>d(p.result),p.onerror=h,p.readAsDataURL(c)})}catch(n){return console.error("Error converting image to GLB:",n),null}}}var Sxe=Object.defineProperty,Axe=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,n)=>(typeof require<"u"?require:e)[n]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')}),A3=(t,e)=>{for(var n in e)Sxe(t,n,{get:e[n],enumerable:!0})},Vc={};A3(Vc,{Abs:()=>x0,Acos:()=>If,Acosh:()=>Tf,AdadeltaOptimizer:()=>WL,AdagradOptimizer:()=>VL,AdamOptimizer:()=>jL,AdamaxOptimizer:()=>XL,Add:()=>th,AddN:()=>Cf,All:()=>b0,Any:()=>w0,ArgMax:()=>_0,ArgMin:()=>S0,Asin:()=>Mf,Asinh:()=>kf,Atan:()=>Nf,Atan2:()=>Ff,Atanh:()=>Rf,AvgPool:()=>Df,AvgPool3D:()=>A0,AvgPool3DGrad:()=>sw,AvgPoolGrad:()=>iw,BackendWasm:()=>hne,BatchMatMul:()=>Pf,BatchToSpaceND:()=>E0,Bincount:()=>I0,BitwiseAnd:()=>T0,BroadcastArgs:()=>aw,BroadcastTo:()=>v7,Callback:()=>dY,CallbackList:()=>iJ,Cast:()=>Lf,Ceil:()=>Of,ClipByValue:()=>nh,Complex:()=>iC,ComplexAbs:()=>ow,Concat:()=>C0,Conv2D:()=>Bf,Conv2DBackpropFilter:()=>sC,Conv2DBackpropInput:()=>Uf,Conv3D:()=>$f,Conv3DBackpropFilterV2:()=>M0,Conv3DBackpropInputV2:()=>k0,Cos:()=>zf,Cosh:()=>Gf,CropAndResize:()=>R0,Cumprod:()=>N0,Cumsum:()=>Hf,CustomCallback:()=>aJ,DataStorage:()=>tC,DenseBincount:()=>lw,DepthToSpace:()=>F0,DepthwiseConv2dNative:()=>Wf,DepthwiseConv2dNativeBackpropFilter:()=>aC,DepthwiseConv2dNativeBackpropInput:()=>oC,Diag:()=>uw,Dilation2D:()=>Vf,Dilation2DBackpropFilter:()=>Xy,Dilation2DBackpropInput:()=>jy,Draw:()=>lC,ENV:()=>M3,EarlyStopping:()=>hY,Einsum:()=>uC,Elu:()=>Xf,EluGrad:()=>D0,Environment:()=>g7,Equal:()=>P0,Erf:()=>Kf,Exp:()=>qf,ExpandDims:()=>L0,Expm1:()=>Jf,FFT:()=>cC,Fill:()=>cw,FlipLeftRight:()=>O0,Floor:()=>Yf,FloorDiv:()=>Zf,FromPixels:()=>CI,FusedBatchNorm:()=>Qf,FusedConv2D:()=>Kp,FusedDepthwiseConv2D:()=>qp,GPGPUContext:()=>iE,GatherNd:()=>U0,GatherV2:()=>B0,GraphModel:()=>FB,Greater:()=>$0,GreaterEqual:()=>em,History:()=>sJ,IFFT:()=>dC,Identity:()=>tm,Imag:()=>hC,InputSpec:()=>gi,IsFinite:()=>nm,IsInf:()=>rm,IsNan:()=>im,KernelBackend:()=>nw,LRN:()=>lm,LRNGrad:()=>X0,LayerVariable:()=>Jq,LayersModel:()=>ec,LeakyRelu:()=>sm,Less:()=>z0,LessEqual:()=>G0,LinSpace:()=>H0,Log:()=>am,Log1p:()=>om,LogSoftmax:()=>b7,LogicalAnd:()=>W0,LogicalNot:()=>V0,LogicalOr:()=>j0,LogicalXor:()=>x7,LowerBound:()=>mbe,MathBackendCPU:()=>LB,MathBackendWebGL:()=>cU,MatrixBandPart:()=>gbe,Max:()=>um,MaxPool:()=>dm,MaxPool3D:()=>K0,MaxPool3DGrad:()=>hw,MaxPoolGrad:()=>dw,MaxPoolWithArgmax:()=>pw,Maximum:()=>cm,Mean:()=>hm,Min:()=>pm,Minimum:()=>fm,MirrorPad:()=>mm,Mod:()=>gm,MomentumOptimizer:()=>KL,Multinomial:()=>q0,Multiply:()=>ym,Neg:()=>J0,NonMaxSuppressionV3:()=>Z0,NonMaxSuppressionV4:()=>Q0,NonMaxSuppressionV5:()=>ev,NotEqual:()=>Y0,OP_SCOPE_SUFFIX:()=>D3,OneHot:()=>vm,OnesLike:()=>tv,Optimizer:()=>vc,OptimizerConstructors:()=>Mq,Pack:()=>nv,PadV2:()=>xm,Pool:()=>ybe,Pow:()=>bm,Prelu:()=>wm,Prod:()=>_m,RMSPropOptimizer:()=>qL,RNN:()=>xc,RaggedGather:()=>pC,RaggedRange:()=>fC,RaggedTensorToTensor:()=>mC,Range:()=>fw,Rank:()=>oF,Real:()=>gC,RealDiv:()=>jf,Reciprocal:()=>Sm,Reduction:()=>Os,Relu:()=>Am,Relu6:()=>Tm,Reshape:()=>rv,ResizeBilinear:()=>Im,ResizeBilinearGrad:()=>sv,ResizeNearestNeighbor:()=>Em,ResizeNearestNeighborGrad:()=>iv,Reverse:()=>Cm,RotateWithOffset:()=>bv,Round:()=>Mm,Rsqrt:()=>km,SGDOptimizer:()=>ZC,ScatterNd:()=>av,SearchSorted:()=>lv,Select:()=>uv,Selu:()=>Nm,Sequential:()=>dM,Sigmoid:()=>Pm,Sign:()=>Dm,Sin:()=>Rm,Sinh:()=>Fm,Slice:()=>cv,Softmax:()=>Um,Softplus:()=>Lm,SpaceToBatchND:()=>dv,SparseFillEmptyRows:()=>mw,SparseReshape:()=>pv,SparseSegmentMean:()=>gw,SparseSegmentSum:()=>yw,SparseToDense:()=>fv,SplitV:()=>hv,Sqrt:()=>Om,Square:()=>vw,SquaredDifference:()=>$m,StaticRegexReplace:()=>xw,Step:()=>ih,StridedSlice:()=>mv,StringNGrams:()=>bw,StringSplit:()=>ww,StringToHashBucketFast:()=>_w,Sub:()=>zm,Sum:()=>Bm,SymbolicTensor:()=>Al,Tan:()=>Gm,Tanh:()=>Hm,Tensor:()=>In,TensorBuffer:()=>vi,TensorScatterUpdate:()=>ov,Tile:()=>rh,TopK:()=>gv,Transform:()=>yv,Transpose:()=>Qu,Unique:()=>Sw,Unpack:()=>vv,UnsortedSegmentSum:()=>Aw,UpperBound:()=>vbe,Variable:()=>Jp,ZerosLike:()=>xv,_FusedMatMul:()=>Xp,abs:()=>fi,acos:()=>U3,acosh:()=>$3,add:()=>ze,addN:()=>K7,all:()=>wC,any:()=>v1,argMax:()=>ef,argMin:()=>z3,asin:()=>G3,asinh:()=>H3,atan:()=>W3,atan2:()=>V3,atanh:()=>j3,avgPool:()=>mc,avgPool3d:()=>K3,backend:()=>P3,backend_util:()=>W,basicLSTMCell:()=>Z7,batchNorm:()=>Wm,batchNorm2d:()=>q3,batchNorm3d:()=>J3,batchNorm4d:()=>Y3,batchToSpaceND:()=>Nw,bincount:()=>Z3,bitwiseAnd:()=>Q7,booleanMaskAsync:()=>GK,broadcastArgs:()=>eK,broadcastTo:()=>Mp,broadcast_util:()=>wv,browser:()=>Ww,buffer:()=>Rn,callbacks:()=>pFe,cast:()=>ft,ceil:()=>Q3,clipByValue:()=>bs,clone:()=>su,complex:()=>cc,concat:()=>wr,concat1d:()=>eL,concat2d:()=>tL,concat3d:()=>nL,concat4d:()=>rL,constraints:()=>eJ,conv1d:()=>_C,conv2d:()=>zs,conv2dTranspose:()=>SC,conv3d:()=>sL,conv3dTranspose:()=>aL,copyRegisteredKernels:()=>_be,cos:()=>Rw,cosh:()=>AC,cosineWindow:()=>XC,cumprod:()=>w1,cumsum:()=>EC,customGrad:()=>fu,data:()=>LY,denseBincount:()=>NI,deprecationWarn:()=>D7,depthToSpace:()=>oL,depthwiseConv2d:()=>Vm,deregisterOp:()=>gFe,device_util:()=>Cw,diag:()=>nK,dilation2d:()=>lL,disableDeprecationWarnings:()=>Zbe,dispose:()=>bn,disposeVariables:()=>Qbe,div:()=>zt,divNoNan:()=>uL,dot:()=>cL,dropout:()=>UL,einsum:()=>ip,elu:()=>_v,enableDebugMode:()=>Ybe,enableProdMode:()=>Jbe,enclosingPowerOfTwo:()=>$L,engine:()=>No,ensureShape:()=>iK,env:()=>Ie,equal:()=>Ua,erf:()=>IC,euclideanNorm:()=>pL,exp:()=>ws,expandDims:()=>Gi,expm1:()=>fL,eye:()=>TC,fft:()=>Gw,fill:()=>Pa,findBackend:()=>s1e,findBackendFactory:()=>a1e,floor:()=>Av,floorDiv:()=>bC,forceHalfFloat:()=>aee,fused:()=>t0,gather:()=>Ev,gatherND:()=>jK,gather_util:()=>ZL,getBackend:()=>P7,getGradient:()=>sF,getKernel:()=>m1,getKernelsForBackend:()=>MI,getThreadsCount:()=>bZe,gpgpu_util:()=>OQ,grad:()=>B_e,grads:()=>U_e,greater:()=>Xs,greaterEqual:()=>gc,ifft:()=>e0,imag:()=>Fw,image:()=>to,inTopKAsync:()=>XK,initializers:()=>tJ,input:()=>bJ,io:()=>us,irfft:()=>$C,isFinite:()=>mL,isInf:()=>gL,isNaN:()=>yL,keep:()=>Ci,kernel_impls:()=>bu,layers:()=>nJ,leakyRelu:()=>Dw,less:()=>Jy,lessEqual:()=>ah,linalg:()=>HL,linspace:()=>uK,loadGraphModel:()=>_De,loadGraphModelSync:()=>SDe,loadLayersModel:()=>lNe,localResponseNormalization:()=>vL,log:()=>$a,log1p:()=>Pw,logSigmoid:()=>xL,logSoftmax:()=>MC,logSumExp:()=>Lw,logicalAnd:()=>Go,logicalNot:()=>Ow,logicalOr:()=>kC,logicalXor:()=>bL,losses:()=>sq,lowerBound:()=>dK,matMul:()=>kn,math:()=>gq,max:()=>oo,maxPool:()=>Oi,maxPool3d:()=>wL,maxPoolWithArgmax:()=>hK,maximum:()=>xu,mean:()=>Wr,memory:()=>fF,meshgrid:()=>pK,metrics:()=>lY,min:()=>qy,minimum:()=>Od,mirrorPad:()=>_L,mod:()=>SL,model:()=>dNe,models:()=>uY,moments:()=>Bw,movingAverage:()=>HK,mul:()=>fe,multiRNNCell:()=>fK,multinomial:()=>mK,neg:()=>Mr,nextFrame:()=>QL,norm:()=>Sv,notEqual:()=>rf,oneHot:()=>Yy,ones:()=>ra,onesLike:()=>za,op:()=>ce,outerProduct:()=>gK,pad:()=>Ml,pad1d:()=>yK,pad2d:()=>vK,pad3d:()=>xK,pad4d:()=>bK,pool:()=>AL,pow:()=>pu,prelu:()=>$w,print:()=>B3,prod:()=>EL,profile:()=>e1e,raggedGather:()=>wK,raggedRange:()=>_K,raggedTensorToTensor:()=>SK,rand:()=>AK,randomGamma:()=>CK,randomNormal:()=>RC,randomStandardNormal:()=>MK,randomUniform:()=>oh,randomUniformInt:()=>kK,range:()=>sf,ready:()=>r1e,real:()=>Zy,reciprocal:()=>kL,registerBackend:()=>xC,registerCallbackConstructor:()=>pNe,registerGradient:()=>w7,registerKernel:()=>Ew,registerOp:()=>mFe,regularizers:()=>cY,relu:()=>pr,relu6:()=>FC,removeBackend:()=>i1e,reshape:()=>ve,reverse:()=>ho,reverse1d:()=>NK,reverse2d:()=>RK,reverse3d:()=>FK,reverse4d:()=>DK,rfft:()=>Hw,round:()=>DC,rsqrt:()=>PC,scalar:()=>rn,scatterND:()=>WK,scatter_util:()=>HC,searchSorted:()=>NC,selu:()=>LC,separableConv2d:()=>Iv,sequential:()=>hNe,serialization:()=>rt,setBackend:()=>n1e,setPlatform:()=>o1e,setThreadsCount:()=>xZe,setWasmPath:()=>yZe,setWasmPaths:()=>vZe,setWebGLContext:()=>oQ,setdiff1dAsync:()=>PK,shared:()=>OB,sigmoid:()=>Uo,sign:()=>NL,signal:()=>iq,sin:()=>OC,sinh:()=>BC,slice:()=>Gn,slice1d:()=>zw,slice2d:()=>UC,slice3d:()=>Tv,slice4d:()=>Qy,slice_util:()=>Ni,softmax:()=>lh,softplus:()=>jm,spaceToBatchND:()=>Uw,sparse:()=>aq,sparseToDense:()=>VK,spectral:()=>rq,split:()=>aa,sqrt:()=>Zi,square:()=>xr,squaredDifference:()=>zC,squeeze:()=>uh,stack:()=>xi,step:()=>Xm,stridedSlice:()=>RL,string:()=>oq,sub:()=>Dt,sum:()=>Xt,sumOutType:()=>vC,tan:()=>FL,tanh:()=>Ld,tensor:()=>Us,tensor1d:()=>cr,tensor2d:()=>au,tensor3d:()=>GC,tensor4d:()=>Bd,tensor5d:()=>LK,tensor6d:()=>OK,tensorScatterUpdate:()=>UK,tensor_util:()=>vl,test_util:()=>EK,tidy:()=>xe,tile:()=>Na,time:()=>t1e,topk:()=>PL,train:()=>Qh,transpose:()=>Nn,truncatedNormal:()=>VC,unique:()=>LL,unregisterGradient:()=>wbe,unregisterKernel:()=>bbe,unsortedSegmentSum:()=>jC,unstack:()=>ii,upcastType:()=>uo,upperBound:()=>$K,util:()=>P,valueAndGrad:()=>$_e,valueAndGrads:()=>z_e,variable:()=>OL,variableGrads:()=>cK,version:()=>TZe,version_converter:()=>EDe,version_core:()=>dTe,version_cpu:()=>I3e,version_layers:()=>_O,version_wasm:()=>wZe,version_webgl:()=>mGe,webgl:()=>gGe,webgl_util:()=>aQ,where:()=>qi,whereAsync:()=>BL,zeros:()=>Vr,zerosLike:()=>Kn});var Exe=Object.create,E3=Object.defineProperty,Ixe=Object.getOwnPropertyDescriptor,Txe=Object.getOwnPropertyNames,Cxe=Object.getPrototypeOf,Mxe=Object.prototype.hasOwnProperty,wi=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),wn=(t,e)=>{for(var n in e)E3(t,n,{get:e[n],enumerable:!0})},kxe=(t,e,n,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of Txe(e))!Mxe.call(t,i)&&i!==n&&E3(t,i,{get:()=>e[i],enumerable:!(r=Ixe(e,i))||r.enumerable});return t},eh=(t,e,n)=>(n=t!=null?Exe(Cxe(t)):{},kxe(!t||!t.__esModule?E3(n,"default",{value:t,enumerable:!0}):n,t)),Nxe=wi((t,e)=>{e.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function r(N,B,z){this.low=N|0,this.high=B|0,this.unsigned=!!z}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0});function i(N){return(N&&N.__isLong__)===!0}r.isLong=i;var s={},a={};function o(N,B){var z,V,K;return B?(N>>>=0,(K=0<=N&&N<256)&&(V=a[N],V)?V:(z=u(N,(N|0)<0?-1:0,!0),K&&(a[N]=z),z)):(N|=0,(K=-128<=N&&N<128)&&(V=s[N],V)?V:(z=u(N,N<0?-1:0,!1),K&&(s[N]=z),z))}r.fromInt=o;function l(N,B){if(isNaN(N))return B?_:w;if(B){if(N<0)return _;if(N>=y)return M}else{if(N<=-m)return k;if(N+1>=m)return T}return N<0?l(-N,B).neg():u(N%g|0,N/g|0,B)}r.fromNumber=l;function u(N,B,z){return new r(N,B,z)}r.fromBits=u;var c=Math.pow;function d(N,B,z){if(N.length===0)throw Error("empty string");if(N==="NaN"||N==="Infinity"||N==="+Infinity"||N==="-Infinity")return w;if(typeof B=="number"?(z=B,B=!1):B=!!B,z=z||10,z<2||36<z)throw RangeError("radix");var V;if((V=N.indexOf("-"))>0)throw Error("interior hyphen");if(V===0)return d(N.substring(1),B,z).neg();for(var K=l(c(z,8)),Q=w,O=0;O<N.length;O+=8){var j=Math.min(8,N.length-O),X=parseInt(N.substring(O,O+j),z);if(j<8){var te=l(c(z,j));Q=Q.mul(te).add(l(X))}else Q=Q.mul(K),Q=Q.add(l(X))}return Q.unsigned=B,Q}r.fromString=d;function h(N,B){return typeof N=="number"?l(N,B):typeof N=="string"?d(N,B):u(N.low,N.high,typeof B=="boolean"?B:N.unsigned)}r.fromValue=h;var p=65536,f=1<<24,g=p*p,y=g*g,m=y/2,b=o(f),w=o(0);r.ZERO=w;var _=o(0,!0);r.UZERO=_;var S=o(1);r.ONE=S;var E=o(1,!0);r.UONE=E;var C=o(-1);r.NEG_ONE=C;var T=u(-1,2147483647,!1);r.MAX_VALUE=T;var M=u(-1,-1,!0);r.MAX_UNSIGNED_VALUE=M;var k=u(0,-2147483648,!1);r.MIN_VALUE=k;var R=r.prototype;R.toInt=function(){return this.unsigned?this.low>>>0:this.low},R.toNumber=function(){return this.unsigned?(this.high>>>0)*g+(this.low>>>0):this.high*g+(this.low>>>0)},R.toString=function(N){if(N=N||10,N<2||36<N)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(k)){var B=l(N),z=this.div(B),V=z.mul(B).sub(this);return z.toString(N)+V.toInt().toString(N)}else return"-"+this.neg().toString(N);for(var K=l(c(N,6),this.unsigned),Q=this,O="";;){var j=Q.div(K),X=Q.sub(j.mul(K)).toInt()>>>0,te=X.toString(N);if(Q=j,Q.isZero())return te+O;for(;te.length<6;)te="0"+te;O=""+te+O}},R.getHighBits=function(){return this.high},R.getHighBitsUnsigned=function(){return this.high>>>0},R.getLowBits=function(){return this.low},R.getLowBitsUnsigned=function(){return this.low>>>0},R.getNumBitsAbs=function(){if(this.isNegative())return this.eq(k)?64:this.neg().getNumBitsAbs();for(var N=this.high!=0?this.high:this.low,B=31;B>0&&!(N&1<<B);B--);return this.high!=0?B+33:B+1},R.isZero=function(){return this.high===0&&this.low===0},R.eqz=R.isZero,R.isNegative=function(){return!this.unsigned&&this.high<0},R.isPositive=function(){return this.unsigned||this.high>=0},R.isOdd=function(){return(this.low&1)===1},R.isEven=function(){return(this.low&1)===0},R.equals=function(N){return i(N)||(N=h(N)),this.unsigned!==N.unsigned&&this.high>>>31===1&&N.high>>>31===1?!1:this.high===N.high&&this.low===N.low},R.eq=R.equals,R.notEquals=function(N){return!this.eq(N)},R.neq=R.notEquals,R.ne=R.notEquals,R.lessThan=function(N){return this.comp(N)<0},R.lt=R.lessThan,R.lessThanOrEqual=function(N){return this.comp(N)<=0},R.lte=R.lessThanOrEqual,R.le=R.lessThanOrEqual,R.greaterThan=function(N){return this.comp(N)>0},R.gt=R.greaterThan,R.greaterThanOrEqual=function(N){return this.comp(N)>=0},R.gte=R.greaterThanOrEqual,R.ge=R.greaterThanOrEqual,R.compare=function(N){if(i(N)||(N=h(N)),this.eq(N))return 0;var B=this.isNegative(),z=N.isNegative();return B&&!z?-1:!B&&z?1:this.unsigned?N.high>>>0>this.high>>>0||N.high===this.high&&N.low>>>0>this.low>>>0?-1:1:this.sub(N).isNegative()?-1:1},R.comp=R.compare,R.negate=function(){return!this.unsigned&&this.eq(k)?k:this.not().add(S)},R.neg=R.negate,R.add=function(N){i(N)||(N=h(N));var B=this.high>>>16,z=this.high&65535,V=this.low>>>16,K=this.low&65535,Q=N.high>>>16,O=N.high&65535,j=N.low>>>16,X=N.low&65535,te=0,le=0,ge=0,ie=0;return ie+=K+X,ge+=ie>>>16,ie&=65535,ge+=V+j,le+=ge>>>16,ge&=65535,le+=z+O,te+=le>>>16,le&=65535,te+=B+Q,te&=65535,u(ge<<16|ie,te<<16|le,this.unsigned)},R.subtract=function(N){return i(N)||(N=h(N)),this.add(N.neg())},R.sub=R.subtract,R.multiply=function(N){if(this.isZero())return w;if(i(N)||(N=h(N)),n){var B=n.mul(this.low,this.high,N.low,N.high);return u(B,n.get_high(),this.unsigned)}if(N.isZero())return w;if(this.eq(k))return N.isOdd()?k:w;if(N.eq(k))return this.isOdd()?k:w;if(this.isNegative())return N.isNegative()?this.neg().mul(N.neg()):this.neg().mul(N).neg();if(N.isNegative())return this.mul(N.neg()).neg();if(this.lt(b)&&N.lt(b))return l(this.toNumber()*N.toNumber(),this.unsigned);var z=this.high>>>16,V=this.high&65535,K=this.low>>>16,Q=this.low&65535,O=N.high>>>16,j=N.high&65535,X=N.low>>>16,te=N.low&65535,le=0,ge=0,ie=0,we=0;return we+=Q*te,ie+=we>>>16,we&=65535,ie+=K*te,ge+=ie>>>16,ie&=65535,ie+=Q*X,ge+=ie>>>16,ie&=65535,ge+=V*te,le+=ge>>>16,ge&=65535,ge+=K*X,le+=ge>>>16,ge&=65535,ge+=Q*j,le+=ge>>>16,ge&=65535,le+=z*te+V*X+K*j+Q*O,le&=65535,u(ie<<16|we,le<<16|ge,this.unsigned)},R.mul=R.multiply,R.divide=function(N){if(i(N)||(N=h(N)),N.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&N.low===-1&&N.high===-1)return this;var B=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,N.low,N.high);return u(B,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?_:w;var z,V,K;if(this.unsigned){if(N.unsigned||(N=N.toUnsigned()),N.gt(this))return _;if(N.gt(this.shru(1)))return E;K=_}else{if(this.eq(k)){if(N.eq(S)||N.eq(C))return k;if(N.eq(k))return S;var Q=this.shr(1);return z=Q.div(N).shl(1),z.eq(w)?N.isNegative()?S:C:(V=this.sub(N.mul(z)),K=z.add(V.div(N)),K)}else if(N.eq(k))return this.unsigned?_:w;if(this.isNegative())return N.isNegative()?this.neg().div(N.neg()):this.neg().div(N).neg();if(N.isNegative())return this.div(N.neg()).neg();K=w}for(V=this;V.gte(N);){z=Math.max(1,Math.floor(V.toNumber()/N.toNumber()));for(var O=Math.ceil(Math.log(z)/Math.LN2),j=O<=48?1:c(2,O-48),X=l(z),te=X.mul(N);te.isNegative()||te.gt(V);)z-=j,X=l(z,this.unsigned),te=X.mul(N);X.isZero()&&(X=S),K=K.add(X),V=V.sub(te)}return K},R.div=R.divide,R.modulo=function(N){if(i(N)||(N=h(N)),n){var B=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,N.low,N.high);return u(B,n.get_high(),this.unsigned)}return this.sub(this.div(N).mul(N))},R.mod=R.modulo,R.rem=R.modulo,R.not=function(){return u(~this.low,~this.high,this.unsigned)},R.and=function(N){return i(N)||(N=h(N)),u(this.low&N.low,this.high&N.high,this.unsigned)},R.or=function(N){return i(N)||(N=h(N)),u(this.low|N.low,this.high|N.high,this.unsigned)},R.xor=function(N){return i(N)||(N=h(N)),u(this.low^N.low,this.high^N.high,this.unsigned)},R.shiftLeft=function(N){return i(N)&&(N=N.toInt()),(N&=63)===0?this:N<32?u(this.low<<N,this.high<<N|this.low>>>32-N,this.unsigned):u(0,this.low<<N-32,this.unsigned)},R.shl=R.shiftLeft,R.shiftRight=function(N){return i(N)&&(N=N.toInt()),(N&=63)===0?this:N<32?u(this.low>>>N|this.high<<32-N,this.high>>N,this.unsigned):u(this.high>>N-32,this.high>=0?0:-1,this.unsigned)},R.shr=R.shiftRight,R.shiftRightUnsigned=function(N){if(i(N)&&(N=N.toInt()),N&=63,N===0)return this;var B=this.high;if(N<32){var z=this.low;return u(z>>>N|B<<32-N,B>>>N,this.unsigned)}else return N===32?u(B,0,this.unsigned):u(B>>>N-32,0,this.unsigned)},R.shru=R.shiftRightUnsigned,R.shr_u=R.shiftRightUnsigned,R.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},R.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},R.toBytes=function(N){return N?this.toBytesLE():this.toBytesBE()},R.toBytesLE=function(){var N=this.high,B=this.low;return[B&255,B>>>8&255,B>>>16&255,B>>>24,N&255,N>>>8&255,N>>>16&255,N>>>24]},R.toBytesBE=function(){var N=this.high,B=this.low;return[N>>>24,N>>>16&255,N>>>8&255,N&255,B>>>24,B>>>16&255,B>>>8&255,B&255]},r.fromBytes=function(N,B,z){return z?r.fromBytesLE(N,B):r.fromBytesBE(N,B)},r.fromBytesLE=function(N,B){return new r(N[0]|N[1]<<8|N[2]<<16|N[3]<<24,N[4]|N[5]<<8|N[6]<<16|N[7]<<24,B)},r.fromBytesBE=function(N,B){return new r(N[4]<<24|N[5]<<16|N[6]<<8|N[7],N[0]<<24|N[1]<<16|N[2]<<8|N[3],B)}}),Rxe=wi(()=>{}),Fxe=wi(()=>{}),Dxe=wi((t,e)=>{(function(n,r,i){function s(u){var c=this,d=l();c.next=function(){var h=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=h-(c.c=h|0)},c.c=1,c.s0=d(" "),c.s1=d(" "),c.s2=d(" "),c.s0-=d(u),c.s0<0&&(c.s0+=1),c.s1-=d(u),c.s1<0&&(c.s1+=1),c.s2-=d(u),c.s2<0&&(c.s2+=1),d=null}function a(u,c){return c.c=u.c,c.s0=u.s0,c.s1=u.s1,c.s2=u.s2,c}function o(u,c){var d=new s(u),h=c&&c.state,p=d.next;return p.int32=function(){return d.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,h&&(typeof h=="object"&&a(h,d),p.state=function(){return a(d,{})}),p}function l(){var u=4022871197,c=function(d){d=String(d);for(var h=0;h<d.length;h++){u+=d.charCodeAt(h);var p=.02519603282416938*u;u=p>>>0,p-=u,p*=u,u=p>>>0,p-=u,u+=p*4294967296}return(u>>>0)*23283064365386963e-26};return c}r&&r.exports?r.exports=o:i&&i.amd?i(function(){return o}):this.alea=o})(t,typeof e=="object"&&e,typeof define=="function"&&define)}),Pxe=wi((t,e)=>{(function(n,r,i){function s(l){var u=this,c="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var h=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^h^h>>>8},l===(l|0)?u.x=l:c+=l;for(var d=0;d<c.length+64;d++)u.x^=c.charCodeAt(d)|0,u.next()}function a(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u}function o(l,u){var c=new s(l),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,g=(p+f)/(1<<21);while(g===0);return g},h.int32=c.next,h.quick=h,d&&(typeof d=="object"&&a(d,c),h.state=function(){return a(c,{})}),h}r&&r.exports?r.exports=o:i&&i.amd?i(function(){return o}):this.xor128=o})(t,typeof e=="object"&&e,typeof define=="function"&&define)}),Lxe=wi((t,e)=>{(function(n,r,i){function s(l){var u=this,c="";u.next=function(){var h=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(h^h<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,l===(l|0)?u.x=l:c+=l;for(var d=0;d<c.length+64;d++)u.x^=c.charCodeAt(d)|0,d==c.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function a(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u.v=l.v,u.d=l.d,u}function o(l,u){var c=new s(l),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,g=(p+f)/(1<<21);while(g===0);return g},h.int32=c.next,h.quick=h,d&&(typeof d=="object"&&a(d,c),h.state=function(){return a(c,{})}),h}r&&r.exports?r.exports=o:i&&i.amd?i(function(){return o}):this.xorwow=o})(t,typeof e=="object"&&e,typeof define=="function"&&define)}),Oxe=wi((t,e)=>{(function(n,r,i){function s(l){var u=this;u.next=function(){var d=u.x,h=u.i,p,f;return p=d[h],p^=p>>>7,f=p^p<<24,p=d[h+1&7],f^=p^p>>>10,p=d[h+3&7],f^=p^p>>>3,p=d[h+4&7],f^=p^p<<7,p=d[h+7&7],p=p^p<<13,f^=p^p<<9,d[h]=f,u.i=h+1&7,f};function c(d,h){var p,f=[];if(h===(h|0))f[0]=h;else for(h=""+h,p=0;p<h.length;++p)f[p&7]=f[p&7]<<15^h.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?f[7]=-1:f[p],d.x=f,d.i=0,p=256;p>0;--p)d.next()}c(u,l)}function a(l,u){return u.x=l.x.slice(),u.i=l.i,u}function o(l,u){l==null&&(l=+new Date);var c=new s(l),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,g=(p+f)/(1<<21);while(g===0);return g},h.int32=c.next,h.quick=h,d&&(d.x&&a(d,c),h.state=function(){return a(c,{})}),h}r&&r.exports?r.exports=o:i&&i.amd?i(function(){return o}):this.xorshift7=o})(t,typeof e=="object"&&e,typeof define=="function"&&define)}),Bxe=wi((t,e)=>{(function(n,r,i){function s(l){var u=this;u.next=function(){var d=u.w,h=u.X,p=u.i,f,g;return u.w=d=d+1640531527|0,g=h[p+34&127],f=h[p=p+1&127],g^=g<<13,f^=f<<17,g^=g>>>15,f^=f>>>12,g=h[p]=g^f,u.i=p,g+(d^d>>>16)|0};function c(d,h){var p,f,g,y,m,b=[],w=128;for(h===(h|0)?(f=h,h=null):(h=h+"\0",f=0,w=Math.max(w,h.length)),g=0,y=-32;y<w;++y)h&&(f^=h.charCodeAt((y+32)%h.length)),y===0&&(m=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,y>=0&&(m=m+1640531527|0,p=b[y&127]^=f+m,g=p==0?g+1:0);for(g>=128&&(b[(h&&h.length||0)&127]=-1),g=127,y=4*128;y>0;--y)f=b[g+34&127],p=b[g=g+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,b[g]=f^p;d.w=m,d.X=b,d.i=g}c(u,l)}function a(l,u){return u.i=l.i,u.w=l.w,u.X=l.X.slice(),u}function o(l,u){l==null&&(l=+new Date);var c=new s(l),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,g=(p+f)/(1<<21);while(g===0);return g},h.int32=c.next,h.quick=h,d&&(d.X&&a(d,c),h.state=function(){return a(c,{})}),h}r&&r.exports?r.exports=o:i&&i.amd?i(function(){return o}):this.xor4096=o})(t,typeof e=="object"&&e,typeof define=="function"&&define)}),Uxe=wi((t,e)=>{(function(n,r,i){function s(l){var u=this,c="";u.next=function(){var h=u.b,p=u.c,f=u.d,g=u.a;return h=h<<25^h>>>7^p,p=p-f|0,f=f<<24^f>>>8^g,g=g-h|0,u.b=h=h<<20^h>>>12^p,u.c=p=p-f|0,u.d=f<<16^p>>>16^g,u.a=g-h|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,l===Math.floor(l)?(u.a=l/4294967296|0,u.b=l|0):c+=l;for(var d=0;d<c.length+20;d++)u.b^=c.charCodeAt(d)|0,u.next()}function a(l,u){return u.a=l.a,u.b=l.b,u.c=l.c,u.d=l.d,u}function o(l,u){var c=new s(l),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,g=(p+f)/(1<<21);while(g===0);return g},h.int32=c.next,h.quick=h,d&&(typeof d=="object"&&a(d,c),h.state=function(){return a(c,{})}),h}r&&r.exports?r.exports=o:i&&i.amd?i(function(){return o}):this.tychei=o})(t,typeof e=="object"&&e,typeof define=="function"&&define)}),$xe=wi(()=>{}),zxe=wi((t,e)=>{(function(n,r,i){var s=256,a=6,o=52,l="random",u=i.pow(s,a),c=i.pow(2,o),d=c*2,h=s-1,p;function f(S,E,C){var T=[];E=E==!0?{entropy:!0}:E||{};var M=b(m(E.entropy?[S,_(r)]:S??w(),3),T),k=new g(T),R=function(){for(var N=k.g(a),B=u,z=0;N<c;)N=(N+z)*s,B*=s,z=k.g(1);for(;N>=d;)N/=2,B/=2,z>>>=1;return(N+z)/B};return R.int32=function(){return k.g(4)|0},R.quick=function(){return k.g(4)/4294967296},R.double=R,b(_(k.S),r),(E.pass||C||function(N,B,z,V){return V&&(V.S&&y(V,k),N.state=function(){return y(k,{})}),z?(i[l]=N,B):N})(R,M,"global"in E?E.global:this==i,E.state)}function g(S){var E,C=S.length,T=this,M=0,k=T.i=T.j=0,R=T.S=[];for(C||(S=[C++]);M<s;)R[M]=M++;for(M=0;M<s;M++)R[M]=R[k=h&k+S[M%C]+(E=R[M])],R[k]=E;(T.g=function(N){for(var B,z=0,V=T.i,K=T.j,Q=T.S;N--;)B=Q[V=h&V+1],z=z*s+Q[h&(Q[V]=Q[K=h&K+B])+(Q[K]=B)];return T.i=V,T.j=K,z})(s)}function y(S,E){return E.i=S.i,E.j=S.j,E.S=S.S.slice(),E}function m(S,E){var C=[],T=typeof S,M;if(E&&T=="object")for(M in S)try{C.push(m(S[M],E-1))}catch{}return C.length?C:T=="string"?S:S+"\0"}function b(S,E){for(var C=S+"",T,M=0;M<C.length;)E[h&M]=h&(T^=E[h&M]*19)+C.charCodeAt(M++);return _(E)}function w(){try{var S;return p&&(S=p.randomBytes)?S=S(s):(S=new Uint8Array(s),(n.crypto||n.msCrypto).getRandomValues(S)),_(S)}catch{var E=n.navigator,C=E&&E.plugins;return[+new Date,n,C,n.screen,_(r)]}}function _(S){return String.fromCharCode.apply(0,S)}if(b(i.random(),r),typeof e=="object"&&e.exports){e.exports=f;try{p=$xe()}catch{}}else typeof define=="function"&&define.amd?define(function(){return f}):i["seed"+l]=f})(typeof self<"u"?self:t,[],Math)}),eC=wi((t,e)=>{var n=Dxe(),r=Pxe(),i=Lxe(),s=Oxe(),a=Bxe(),o=Uxe(),l=zxe();l.alea=n,l.xor128=r,l.xorwow=i,l.xorshift7=s,l.xor4096=a,l.tychei=o,e.exports=l}),i7=wi(()=>{}),I3=wi(()=>{}),s7=wi(()=>{}),Gxe=wi(()=>{}),Hxe=wi(()=>{}),Wxe=wi(()=>{}),Vxe=wi((t,e)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(i){i=i||{};function s(){return O.buffer!=Le&&J(O.buffer),lt}function a(){return O.buffer!=Le&&J(O.buffer),st}function o(){return O.buffer!=Le&&J(O.buffer),Et}function l(){return O.buffer!=Le&&J(O.buffer),Tt}function u(){return O.buffer!=Le&&J(O.buffer),xt}var c=typeof i<"u"?i:{},d,h;c.ready=new Promise(function(oe,ke){d=oe,h=ke});var p;typeof process<"u"&&process.listeners&&(p={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f=Object.assign({},c),g=(oe,ke)=>{throw ke},y=typeof window=="object",m=typeof importScripts=="function",b=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",w=c.ENVIRONMENT_IS_PTHREAD||!1,_="";function S(oe){return c.locateFile?c.locateFile(oe,_):_+oe}var E,C,T;function M(oe){oe instanceof Ne||V("exiting due to exception: "+oe)}if(b){var k=I3(),R=s7();m?_=R.dirname(_)+"/":_=__dirname+"/",E=(ke,vt)=>(ke=mt(ke)?new URL(ke):R.normalize(ke),k.readFileSync(ke,vt?void 0:"utf8")),T=ke=>{var vt=E(ke,!0);return vt.buffer||(vt=new Uint8Array(vt)),vt},C=(ke,vt,cn)=>{ke=mt(ke)?new URL(ke):R.normalize(ke),k.readFile(ke,function(en,vn){en?cn(en):vt(vn.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(ke){if(!(ke instanceof Ne))throw ke}),process.on("unhandledRejection",function(ke){throw ke}),g=(ke,vt)=>{if(Je())throw process.exitCode=ke,vt;M(vt),process.exit(ke)},c.inspect=function(){return"[Emscripten Module object]"};let oe;try{oe=Gxe()}catch(ke){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),ke}global.Worker=oe.Worker}else(y||m)&&(m?_=self.location.href:typeof document<"u"&&document.currentScript&&(_=document.currentScript.src),typeof r<"u"&&r&&(_=r),_.indexOf("blob:")!==0?_=_.substr(0,_.replace(/[?#].*/,"").lastIndexOf("/")+1):_="",b||(E=oe=>{var ke=new XMLHttpRequest;return ke.open("GET",oe,!1),ke.send(null),ke.responseText},m&&(T=oe=>{var ke=new XMLHttpRequest;return ke.open("GET",oe,!1),ke.responseType="arraybuffer",ke.send(null),new Uint8Array(ke.response)}),C=(oe,ke,vt)=>{var cn=new XMLHttpRequest;cn.open("GET",oe,!0),cn.responseType="arraybuffer",cn.onload=()=>{if(cn.status==200||cn.status==0&&cn.response){ke(cn.response);return}vt()},cn.onerror=vt,cn.send(null)}));b&&typeof performance>"u"&&(global.performance=Hxe().performance);var N=console.log.bind(console),B=console.warn.bind(console);b&&(N=oe=>k.writeSync(1,oe+`
`),B=oe=>k.writeSync(2,oe+`
`));var z=c.print||N,V=c.printErr||B;Object.assign(c,f),f=null,c.arguments&&c.arguments,c.thisProgram&&c.thisProgram,c.quit&&(g=c.quit);var K;c.wasmBinary&&(K=c.wasmBinary);var Q=c.noExitRuntime||!0;typeof WebAssembly!="object"&&Pt("no native wasm support detected");var O,j,X=!1,te;function le(oe,ke){oe||Pt(ke)}var ge=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function ie(oe,ke,vt){ke>>>=0;for(var cn=ke+vt,en=ke;oe[en]&&!(en>=cn);)++en;if(en-ke>16&&oe.buffer&&ge)return ge.decode(oe.buffer instanceof SharedArrayBuffer?oe.slice(ke,en):oe.subarray(ke,en));for(var vn="";ke<en;){var $t=oe[ke++];if(!($t&128)){vn+=String.fromCharCode($t);continue}var nn=oe[ke++]&63;if(($t&224)==192){vn+=String.fromCharCode(($t&31)<<6|nn);continue}var Nr=oe[ke++]&63;if(($t&240)==224?$t=($t&15)<<12|nn<<6|Nr:$t=($t&7)<<18|nn<<12|Nr<<6|oe[ke++]&63,$t<65536)vn+=String.fromCharCode($t);else{var ts=$t-65536;vn+=String.fromCharCode(55296|ts>>10,56320|ts&1023)}}return vn}function we(oe,ke){return oe>>>=0,oe?ie(a(),oe,ke):""}function Ce(oe,ke,vt,cn){if(vt>>>=0,!(cn>0))return 0;for(var en=vt,vn=vt+cn-1,$t=0;$t<oe.length;++$t){var nn=oe.charCodeAt($t);if(nn>=55296&&nn<=57343){var Nr=oe.charCodeAt(++$t);nn=65536+((nn&1023)<<10)|Nr&1023}if(nn<=127){if(vt>=vn)break;ke[vt++>>>0]=nn}else if(nn<=2047){if(vt+1>=vn)break;ke[vt++>>>0]=192|nn>>6,ke[vt++>>>0]=128|nn&63}else if(nn<=65535){if(vt+2>=vn)break;ke[vt++>>>0]=224|nn>>12,ke[vt++>>>0]=128|nn>>6&63,ke[vt++>>>0]=128|nn&63}else{if(vt+3>=vn)break;ke[vt++>>>0]=240|nn>>18,ke[vt++>>>0]=128|nn>>12&63,ke[vt++>>>0]=128|nn>>6&63,ke[vt++>>>0]=128|nn&63}}return ke[vt>>>0]=0,vt-en}function Re(oe,ke,vt){return Ce(oe,a(),ke,vt)}var Le,lt,st,Et,Tt,xt;w&&(Le=c.buffer);function J(oe){Le=oe,c.HEAP8=lt=new Int8Array(oe),c.HEAP16=new Int16Array(oe),c.HEAP32=Et=new Int32Array(oe),c.HEAPU8=st=new Uint8Array(oe),c.HEAPU16=new Uint16Array(oe),c.HEAPU32=Tt=new Uint32Array(oe),c.HEAPF32=new Float32Array(oe),c.HEAPF64=xt=new Float64Array(oe)}var Ye=c.INITIAL_MEMORY||16777216;if(w)O=c.wasmMemory,Le=c.buffer;else if(c.wasmMemory)O=c.wasmMemory;else if(O=new WebAssembly.Memory({initial:Ye/65536,maximum:65536,shared:!0}),!(O.buffer instanceof SharedArrayBuffer))throw V("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),b&&V("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");O&&(Le=O.buffer),Ye=Le.byteLength,J(Le);var Be,tt=[],Ue=[],St=[];function Je(){return Q}function At(){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;)H(c.preRun.shift());xn(tt)}function Vt(){!w&&xn(Ue)}function re(){if(!w){if(c.postRun)for(typeof c.postRun=="function"&&(c.postRun=[c.postRun]);c.postRun.length;)Oe(c.postRun.shift());xn(St)}}function H(oe){tt.unshift(oe)}function Ee(oe){Ue.unshift(oe)}function Oe(oe){St.unshift(oe)}var Xe=0,$e=null;function Lt(oe){Xe++,c.monitorRunDependencies&&c.monitorRunDependencies(Xe)}function wt(oe){if(Xe--,c.monitorRunDependencies&&c.monitorRunDependencies(Xe),Xe==0&&$e){var ke=$e;$e=null,ke()}}function Pt(oe){c.onAbort&&c.onAbort(oe),oe="Aborted("+oe+")",V(oe),X=!0,te=1,oe+=". Build with -sASSERTIONS for more info.";var ke=new WebAssembly.RuntimeError(oe);throw h(ke),ke}var Ht="data:application/octet-stream;base64,";function et(oe){return oe.startsWith(Ht)}function mt(oe){return oe.startsWith("file://")}var Ot;Ot="tfjs-backend-wasm-threaded-simd.wasm",et(Ot)||(Ot=S(Ot));function he(oe){try{if(oe==Ot&&K)return new Uint8Array(K);if(T)return T(oe);throw"both async and sync fetching of the wasm failed"}catch(ke){Pt(ke)}}function Me(){if(!K&&(y||m)){if(typeof fetch=="function"&&!mt(Ot))return fetch(Ot,{credentials:"same-origin"}).then(function(oe){if(!oe.ok)throw"failed to load wasm binary file at '"+Ot+"'";return oe.arrayBuffer()}).catch(function(){return he(Ot)});if(C)return new Promise(function(oe,ke){C(Ot,function(vt){oe(new Uint8Array(vt))},ke)})}return Promise.resolve().then(function(){return he(Ot)})}function it(){var oe={env:Dr,wasi_snapshot_preview1:Dr};function ke($t,nn){var Nr=$t.exports;if(c.asm=Nr,zr(c.asm._emscripten_tls_init),Be=c.asm.__indirect_function_table,Ee(c.asm.__wasm_call_ctors),j=nn,!w){var ts=ht.unusedWorkers.length;ht.unusedWorkers.forEach(function(Si){ht.loadWasmModuleToWorker(Si,function(){--ts||wt()})})}}w||Lt();function vt($t){ke($t.instance,$t.module)}function cn($t){return Me().then(function(nn){return WebAssembly.instantiate(nn,oe)}).then(function(nn){return nn}).then($t,function(nn){V("failed to asynchronously prepare wasm: "+nn),Pt(nn)})}function en(){return!K&&typeof WebAssembly.instantiateStreaming=="function"&&!et(Ot)&&!mt(Ot)&&!b&&typeof fetch=="function"?fetch(Ot,{credentials:"same-origin"}).then(function($t){var nn=WebAssembly.instantiateStreaming($t,oe);return nn.then(vt,function(Nr){return V("wasm streaming compile failed: "+Nr),V("falling back to ArrayBuffer instantiation"),cn(vt)})}):cn(vt)}if(c.instantiateWasm)try{var vn=c.instantiateWasm(oe,ke);return vn}catch($t){V("Module.instantiateWasm callback failed with error: "+$t),h($t)}return en().catch(h),{}}var de={};function Ne(oe){this.name="ExitStatus",this.message="Program terminated with exit("+oe+")",this.status=oe}function nt(oe){var ke=ht.pthreads[oe];delete ht.pthreads[oe],ke.terminate(),ps(oe),ht.runningWorkers.splice(ht.runningWorkers.indexOf(ke),1),ke.pthread_ptr=0}function Mt(oe){var ke=ht.pthreads[oe];ke.postMessage({cmd:"cancel"})}function ut(oe){var ke=ht.pthreads[oe];le(ke),ht.returnWorkerToPool(ke)}function Ze(oe){var ke=ht.getNewWorker();if(!ke)return 6;ht.runningWorkers.push(ke),ht.pthreads[oe.pthread_ptr]=ke,ke.pthread_ptr=oe.pthread_ptr;var vt={cmd:"run",start_routine:oe.startRoutine,arg:oe.arg,pthread_ptr:oe.pthread_ptr};return ke.runPthread=()=>{b&&ke.ref(),ke.postMessage(vt,oe.transferList),delete ke.runPthread},ke.loaded&&ke.runPthread(),0}function kt(oe){if(w)return bt(1,1,oe);te=oe,Je()||(ht.terminateAllThreads(),c.onExit&&c.onExit(oe),X=!0),g(oe,new Ne(oe))}function Se(oe,ke){if(te=oe,!ke&&w)throw gn(oe),"unwind";kt(oe)}var qe=Se;function pt(oe){if(oe instanceof Ne||oe=="unwind")return te;g(1,oe)}var ht={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){w?ht.initWorker():ht.initMainThread()},initMainThread:function(){for(var oe=8;oe--;)ht.allocateUnusedWorker()},initWorker:function(){Q=!1},setExitStatus:function(oe){te=oe},terminateAllThreads:function(){for(var oe of Object.values(ht.pthreads))ht.returnWorkerToPool(oe);for(var oe of ht.unusedWorkers)oe.terminate();ht.unusedWorkers=[]},returnWorkerToPool:function(oe){var ke=oe.pthread_ptr;delete ht.pthreads[ke],ht.unusedWorkers.push(oe),ht.runningWorkers.splice(ht.runningWorkers.indexOf(oe),1),oe.pthread_ptr=0,b&&oe.unref(),ps(ke)},receiveObjectTransfer:function(oe){},threadInitTLS:function(){ht.tlsInitFunctions.forEach(oe=>oe())},loadWasmModuleToWorker:function(oe,ke){oe.onmessage=vn=>{var $t=vn.data,nn=$t.cmd;if(oe.pthread_ptr&&(ht.currentProxiedOperationCallerThread=oe.pthread_ptr),$t.targetThread&&$t.targetThread!=ir()){var Nr=ht.pthreads[$t.targetThread];Nr?Nr.postMessage($t,$t.transferList):V('Internal error! Worker sent a message "'+nn+'" to target pthread '+$t.targetThread+", but that thread no longer exists!"),ht.currentProxiedOperationCallerThread=void 0;return}nn==="processProxyingQueue"?He($t.queue):nn==="spawnThread"?Ze($t):nn==="cleanupThread"?ut($t.thread):nn==="killThread"?nt($t.thread):nn==="cancelThread"?Mt($t.thread):nn==="loaded"?(oe.loaded=!0,b&&oe.unref(),ke&&ke(oe),oe.runPthread&&oe.runPthread()):nn==="print"?z("Thread "+$t.threadId+": "+$t.text):nn==="printErr"?V("Thread "+$t.threadId+": "+$t.text):nn==="alert"?alert("Thread "+$t.threadId+": "+$t.text):$t.target==="setimmediate"?oe.postMessage($t):nn==="callHandler"?c[$t.handler](...$t.args):nn&&V("worker sent an unknown command "+nn),ht.currentProxiedOperationCallerThread=void 0},oe.onerror=vn=>{var $t="worker sent an error!";throw V($t+" "+vn.filename+":"+vn.lineno+": "+vn.message),vn},b&&(oe.on("message",function(vn){oe.onmessage({data:vn})}),oe.on("error",function(vn){oe.onerror(vn)}),oe.on("detachedExit",function(){}));var vt=[],cn=["onExit","onAbort","print","printErr"];for(var en of cn)c.hasOwnProperty(en)&&vt.push(en);oe.postMessage({cmd:"load",handlers:vt,urlOrBlob:c.mainScriptUrlOrBlob||r,wasmMemory:O,wasmModule:j})},allocateUnusedWorker:function(){var oe,ke=S("tfjs-backend-wasm-threaded-simd.worker.js");oe=new Worker(ke),ht.unusedWorkers.push(oe)},getNewWorker:function(){return ht.unusedWorkers.length==0&&(ht.allocateUnusedWorker(),ht.loadWasmModuleToWorker(ht.unusedWorkers[0])),ht.unusedWorkers.pop()}};c.PThread=ht;function xn(oe){for(;oe.length>0;)oe.shift()(c)}function ar(){var oe=ir(),ke=o()[oe+52>>>2],vt=o()[oe+56>>>2],cn=ke-vt;o_(ke,cn),wc(ke)}c.establishStackSpace=ar;function gn(oe){if(w)return bt(2,0,oe);try{qe(oe)}catch(ke){pt(ke)}}var sn=[];function ur(oe){var ke=sn[oe];return ke||(oe>=sn.length&&(sn.length=oe+1),sn[oe]=ke=Be.get(oe)),ke}function $r(oe,ke){var vt=ur(oe)(ke);Je()?ht.setExitStatus(vt):yh(vt)}c.invokeEntryPoint=$r;function zr(oe){ht.tlsInitFunctions.push(oe)}function yn(oe){gr(oe,!m,1,!y),ht.threadInitTLS()}function Wa(oe){w?postMessage({cmd:"cleanupThread",thread:oe}):ut(oe)}function Va(oe,ke,vt,cn){return w?bt(3,1,oe,ke,vt,cn):$(oe,ke,vt,cn)}function $(oe,ke,vt,cn){if(typeof SharedArrayBuffer>"u")return V("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var en=[],vn=0;if(w&&(en.length===0||vn))return Va(oe,ke,vt,cn);var $t={startRoutine:vt,pthread_ptr:oe,arg:cn,transferList:en};return w?($t.cmd="spawnThread",postMessage($t,en),0):Ze($t)}function Y(){return 65536}var ye=!0;function De(){return ye}function He(oe){Atomics.store(o(),oe>>2,1),ir()&&Ko(oe),Atomics.compareExchange(o(),oe>>2,1,0)}c.executeNotifiedProxyingQueue=He;function Ve(oe,ke,vt,cn){if(oe==ke)setTimeout(()=>He(cn));else if(w)postMessage({targetThread:oe,cmd:"processProxyingQueue",queue:cn});else{var en=ht.pthreads[oe];if(!en)return;en.postMessage({cmd:"processProxyingQueue",queue:cn})}return 1}function gt(oe,ke,vt){return-1}function dt(){Pt("")}function G(oe){G.shown||(G.shown={}),G.shown[oe]||(G.shown[oe]=1,b&&(oe="warning: "+oe),V(oe))}function ae(){b||m||G("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function me(){return Date.now()}function pe(){return 4294901760}function _e(){return pe()}var Fe;b?Fe=()=>{var oe=process.hrtime();return oe[0]*1e3+oe[1]/1e6}:Fe=()=>performance.timeOrigin+performance.now();function je(oe,ke,vt){a().copyWithin(oe>>>0,ke>>>0,ke+vt>>>0)}function ot(){return b?Wxe().cpus().length:navigator.hardwareConcurrency}function at(oe){var ke=Gv(),vt=oe();return wc(ke),vt}function bt(oe,ke){var vt=arguments.length-2,cn=arguments;return at(()=>{for(var en=vt,vn=_c(en*8),$t=vn>>3,nn=0;nn<vt;nn++){var Nr=cn[2+nn];u()[$t+nn>>>0]=Nr}return si(oe,en,vn,ke)})}var It=[];function ct(oe,ke,vt){It.length=ke;for(var cn=vt>>3,en=0;en<ke;en++)It[en]=u()[cn+en>>>0];var vn=oe<0,$t=vn?de[-oe-1]:fn[oe];return $t.apply(null,It)}function Rt(oe){try{return O.grow(oe-Le.byteLength+65535>>>16),J(O.buffer),1}catch{}}function jt(oe){var ke=a().length;if(oe=oe>>>0,oe<=ke)return!1;var vt=pe();if(oe>vt)return!1;let cn=(Nr,ts)=>Nr+(ts-Nr%ts)%ts;for(var en=1;en<=4;en*=2){var vn=ke*(1+.2/en);vn=Math.min(vn,oe+100663296);var $t=Math.min(vt,cn(Math.max(oe,vn),65536)),nn=Rt($t);if(nn)return!0}return!1}function un(){throw"unwind"}function Kt(oe){return w?bt(4,1,oe):52}function tn(oe,ke,vt,cn,en){return w?bt(5,1,oe,ke,vt,cn,en):70}var Wt=[null,[],[]];function Bn(oe,ke){var vt=Wt[oe];ke===0||ke===10?((oe===1?z:V)(ie(vt,0)),vt.length=0):vt.push(ke)}function pn(oe,ke,vt,cn){if(w)return bt(6,1,oe,ke,vt,cn);for(var en=0,vn=0;vn<vt;vn++){var $t=l()[ke>>>2],nn=l()[ke+4>>>2];ke+=8;for(var Nr=0;Nr<nn;Nr++)Bn(oe,a()[$t+Nr>>>0]);en+=nn}return l()[cn>>>2]=en,0}function _n(oe){var ke=c["_"+oe];return ke}function Ar(oe,ke){s().set(oe,ke>>>0)}function Sn(oe,ke,vt,cn,en){var vn={string:Jr=>{var qo=0;if(Jr!=null&&Jr!==0){var ng=(Jr.length<<2)+1;qo=_c(ng),Re(Jr,qo,ng)}return qo},array:Jr=>{var qo=_c(Jr.length);return Ar(Jr,qo),qo}};function $t(Jr){return ke==="string"?we(Jr):ke==="boolean"?!!Jr:Jr}var nn=_n(oe),Nr=[],ts=0;if(cn)for(var Si=0;Si<cn.length;Si++){var c_=vn[vt[Si]];c_?(ts===0&&(ts=Gv()),Nr[Si]=c_(cn[Si])):Nr[Si]=cn[Si]}var Hv=nn.apply(null,Nr);function go(Jr){return ts!==0&&wc(ts),$t(Jr)}return Hv=go(Hv),Hv}function Un(oe,ke,vt,cn){vt=vt||[];var en=vt.every($t=>$t==="number"||$t==="boolean"),vn=ke!=="string";return vn&&en&&!cn?_n(oe):function(){return Sn(oe,ke,vt,arguments)}}ht.init();var fn=[null,kt,gn,Va,Kt,tn,pn],Dr={__emscripten_init_main_thread_js:yn,__emscripten_thread_cleanup:Wa,__pthread_create_js:$,_emscripten_default_pthread_stack_size:Y,_emscripten_get_now_is_monotonic:De,_emscripten_notify_task_queue:Ve,_emscripten_set_offscreencanvas_size:gt,abort:dt,emscripten_check_blocking_allowed:ae,emscripten_date_now:me,emscripten_get_heap_max:_e,emscripten_get_now:Fe,emscripten_memcpy_big:je,emscripten_num_logical_cores:ot,emscripten_receive_on_main_thread_js:ct,emscripten_resize_heap:jt,emscripten_unwind_to_js_event_loop:un,exit:qe,fd_close:Kt,fd_seek:tn,fd_write:pn,memory:O||c.wasmMemory};it(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.__wasm_call_ctors).apply(null,arguments)},c._init=function(){return(c._init=c.asm.init).apply(null,arguments)},c._init_with_threads_count=function(){return(c._init_with_threads_count=c.asm.init_with_threads_count).apply(null,arguments)},c._get_threads_count=function(){return(c._get_threads_count=c.asm.get_threads_count).apply(null,arguments)},c._register_tensor=function(){return(c._register_tensor=c.asm.register_tensor).apply(null,arguments)},c._dispose_data=function(){return(c._dispose_data=c.asm.dispose_data).apply(null,arguments)},c._dispose=function(){return(c._dispose=c.asm.dispose).apply(null,arguments)},c._Abs=function(){return(c._Abs=c.asm.Abs).apply(null,arguments)},c._Acos=function(){return(c._Acos=c.asm.Acos).apply(null,arguments)},c._Acosh=function(){return(c._Acosh=c.asm.Acosh).apply(null,arguments)},c._Add=function(){return(c._Add=c.asm.Add).apply(null,arguments)},c._AddN=function(){return(c._AddN=c.asm.AddN).apply(null,arguments)},c._All=function(){return(c._All=c.asm.All).apply(null,arguments)},c._Any=function(){return(c._Any=c.asm.Any).apply(null,arguments)},c._ArgMax=function(){return(c._ArgMax=c.asm.ArgMax).apply(null,arguments)},c._ArgMin=function(){return(c._ArgMin=c.asm.ArgMin).apply(null,arguments)},c._Asin=function(){return(c._Asin=c.asm.Asin).apply(null,arguments)},c._Asinh=function(){return(c._Asinh=c.asm.Asinh).apply(null,arguments)},c._Atan=function(){return(c._Atan=c.asm.Atan).apply(null,arguments)},c._Atan2=function(){return(c._Atan2=c.asm.Atan2).apply(null,arguments)},c._Atanh=function(){return(c._Atanh=c.asm.Atanh).apply(null,arguments)},c._AvgPool=function(){return(c._AvgPool=c.asm.AvgPool).apply(null,arguments)},c._AvgPool3D=function(){return(c._AvgPool3D=c.asm.AvgPool3D).apply(null,arguments)},c._AvgPool3DGrad=function(){return(c._AvgPool3DGrad=c.asm.AvgPool3DGrad).apply(null,arguments)},c._AvgPoolGrad=function(){return(c._AvgPoolGrad=c.asm.AvgPoolGrad).apply(null,arguments)},c._BatchMatMul=function(){return(c._BatchMatMul=c.asm.BatchMatMul).apply(null,arguments)},c._Bincount=function(){return(c._Bincount=c.asm.Bincount).apply(null,arguments)},c._BitwiseAnd=function(){return(c._BitwiseAnd=c.asm.BitwiseAnd).apply(null,arguments)},c._Ceil=function(){return(c._Ceil=c.asm.Ceil).apply(null,arguments)},c._ClipByValue=function(){return(c._ClipByValue=c.asm.ClipByValue).apply(null,arguments)},c._Conv2D=function(){return(c._Conv2D=c.asm.Conv2D).apply(null,arguments)},c._Conv2DBackpropInput=function(){return(c._Conv2DBackpropInput=c.asm.Conv2DBackpropInput).apply(null,arguments)},c._Conv3D=function(){return(c._Conv3D=c.asm.Conv3D).apply(null,arguments)},c._Conv3DBackpropFilterV2=function(){return(c._Conv3DBackpropFilterV2=c.asm.Conv3DBackpropFilterV2).apply(null,arguments)},c._Conv3DBackpropInputV2=function(){return(c._Conv3DBackpropInputV2=c.asm.Conv3DBackpropInputV2).apply(null,arguments)},c._Cos=function(){return(c._Cos=c.asm.Cos).apply(null,arguments)},c._Cosh=function(){return(c._Cosh=c.asm.Cosh).apply(null,arguments)},c._CropAndResize=function(){return(c._CropAndResize=c.asm.CropAndResize).apply(null,arguments)},c._Cumprod=function(){return(c._Cumprod=c.asm.Cumprod).apply(null,arguments)},c._Cumsum=function(){return(c._Cumsum=c.asm.Cumsum).apply(null,arguments)},c._DenseBincount=function(){return(c._DenseBincount=c.asm.DenseBincount).apply(null,arguments)},c._DepthToSpace=function(){return(c._DepthToSpace=c.asm.DepthToSpace).apply(null,arguments)},c._DepthwiseConv2dNative=function(){return(c._DepthwiseConv2dNative=c.asm.DepthwiseConv2dNative).apply(null,arguments)},c._Diag=function(){return(c._Diag=c.asm.Diag).apply(null,arguments)},c._Dilation2D=function(){return(c._Dilation2D=c.asm.Dilation2D).apply(null,arguments)},c._Dilation2DBackpropFilter=function(){return(c._Dilation2DBackpropFilter=c.asm.Dilation2DBackpropFilter).apply(null,arguments)},c._Dilation2DBackpropInput=function(){return(c._Dilation2DBackpropInput=c.asm.Dilation2DBackpropInput).apply(null,arguments)},c._Elu=function(){return(c._Elu=c.asm.Elu).apply(null,arguments)},c._EluGrad=function(){return(c._EluGrad=c.asm.EluGrad).apply(null,arguments)},c._Equal=function(){return(c._Equal=c.asm.Equal).apply(null,arguments)},c._Erf=function(){return(c._Erf=c.asm.Erf).apply(null,arguments)},c._Exp=function(){return(c._Exp=c.asm.Exp).apply(null,arguments)},c._Expm1=function(){return(c._Expm1=c.asm.Expm1).apply(null,arguments)},c._FlipLeftRight=function(){return(c._FlipLeftRight=c.asm.FlipLeftRight).apply(null,arguments)},c._Floor=function(){return(c._Floor=c.asm.Floor).apply(null,arguments)},c._FloorDiv=function(){return(c._FloorDiv=c.asm.FloorDiv).apply(null,arguments)},c._FusedBatchNorm=function(){return(c._FusedBatchNorm=c.asm.FusedBatchNorm).apply(null,arguments)},c._FusedConv2D=function(){return(c._FusedConv2D=c.asm.FusedConv2D).apply(null,arguments)},c._FusedDepthwiseConv2D=function(){return(c._FusedDepthwiseConv2D=c.asm.FusedDepthwiseConv2D).apply(null,arguments)},c._Gather=function(){return(c._Gather=c.asm.Gather).apply(null,arguments)},c._GatherNd=function(){return(c._GatherNd=c.asm.GatherNd).apply(null,arguments)},c._Greater=function(){return(c._Greater=c.asm.Greater).apply(null,arguments)},c._GreaterEqual=function(){return(c._GreaterEqual=c.asm.GreaterEqual).apply(null,arguments)},c._IsFinite=function(){return(c._IsFinite=c.asm.IsFinite).apply(null,arguments)},c._IsInf=function(){return(c._IsInf=c.asm.IsInf).apply(null,arguments)},c._IsNan=function(){return(c._IsNan=c.asm.IsNan).apply(null,arguments)},c._LRN=function(){return(c._LRN=c.asm.LRN).apply(null,arguments)},c._LRNGrad=function(){return(c._LRNGrad=c.asm.LRNGrad).apply(null,arguments)},c._LeakyRelu=function(){return(c._LeakyRelu=c.asm.LeakyRelu).apply(null,arguments)},c._Less=function(){return(c._Less=c.asm.Less).apply(null,arguments)},c._LessEqual=function(){return(c._LessEqual=c.asm.LessEqual).apply(null,arguments)},c._LinSpace=function(){return(c._LinSpace=c.asm.LinSpace).apply(null,arguments)},c._Log=function(){return(c._Log=c.asm.Log).apply(null,arguments)},c._Log1p=function(){return(c._Log1p=c.asm.Log1p).apply(null,arguments)},c._LogicalAnd=function(){return(c._LogicalAnd=c.asm.LogicalAnd).apply(null,arguments)},c._LogicalNot=function(){return(c._LogicalNot=c.asm.LogicalNot).apply(null,arguments)},c._LogicalOr=function(){return(c._LogicalOr=c.asm.LogicalOr).apply(null,arguments)},c._LogicalXor=function(){return(c._LogicalXor=c.asm.LogicalXor).apply(null,arguments)},c._Max=function(){return(c._Max=c.asm.Max).apply(null,arguments)},c._MaxPool=function(){return(c._MaxPool=c.asm.MaxPool).apply(null,arguments)},c._MaxPool3D=function(){return(c._MaxPool3D=c.asm.MaxPool3D).apply(null,arguments)},c._MaxPool3DGrad=function(){return(c._MaxPool3DGrad=c.asm.MaxPool3DGrad).apply(null,arguments)},c._MaxPoolGrad=function(){return(c._MaxPoolGrad=c.asm.MaxPoolGrad).apply(null,arguments)},c._MaxPoolWithArgmax=function(){return(c._MaxPoolWithArgmax=c.asm.MaxPoolWithArgmax).apply(null,arguments)},c._Maximum=function(){return(c._Maximum=c.asm.Maximum).apply(null,arguments)},c._Mean=function(){return(c._Mean=c.asm.Mean).apply(null,arguments)},c._Min=function(){return(c._Min=c.asm.Min).apply(null,arguments)},c._Minimum=function(){return(c._Minimum=c.asm.Minimum).apply(null,arguments)},c._MirrorPad=function(){return(c._MirrorPad=c.asm.MirrorPad).apply(null,arguments)},c._Mod=function(){return(c._Mod=c.asm.Mod).apply(null,arguments)},c._Multinomial=function(){return(c._Multinomial=c.asm.Multinomial).apply(null,arguments)},c._Multiply=function(){return(c._Multiply=c.asm.Multiply).apply(null,arguments)},c._Neg=function(){return(c._Neg=c.asm.Neg).apply(null,arguments)},c._NonMaxSuppressionV3=function(){return(c._NonMaxSuppressionV3=c.asm.NonMaxSuppressionV3).apply(null,arguments)},c._NonMaxSuppressionV4=function(){return(c._NonMaxSuppressionV4=c.asm.NonMaxSuppressionV4).apply(null,arguments)},c._NonMaxSuppressionV5=function(){return(c._NonMaxSuppressionV5=c.asm.NonMaxSuppressionV5).apply(null,arguments)},c._NotEqual=function(){return(c._NotEqual=c.asm.NotEqual).apply(null,arguments)},c._OneHot=function(){return(c._OneHot=c.asm.OneHot).apply(null,arguments)},c._PadV2=function(){return(c._PadV2=c.asm.PadV2).apply(null,arguments)},c._Pow=function(){return(c._Pow=c.asm.Pow).apply(null,arguments)},c._Prelu=function(){return(c._Prelu=c.asm.Prelu).apply(null,arguments)},c._Prod=function(){return(c._Prod=c.asm.Prod).apply(null,arguments)},c._RealDiv=function(){return(c._RealDiv=c.asm.RealDiv).apply(null,arguments)},c._Reciprocal=function(){return(c._Reciprocal=c.asm.Reciprocal).apply(null,arguments)},c._Relu=function(){return(c._Relu=c.asm.Relu).apply(null,arguments)},c._Relu6=function(){return(c._Relu6=c.asm.Relu6).apply(null,arguments)},c._ResizeBilinear=function(){return(c._ResizeBilinear=c.asm.ResizeBilinear).apply(null,arguments)},c._ResizeBilinearGrad=function(){return(c._ResizeBilinearGrad=c.asm.ResizeBilinearGrad).apply(null,arguments)},c._ResizeNearestNeighbor=function(){return(c._ResizeNearestNeighbor=c.asm.ResizeNearestNeighbor).apply(null,arguments)},c._ResizeNearestNeighborGrad=function(){return(c._ResizeNearestNeighborGrad=c.asm.ResizeNearestNeighborGrad).apply(null,arguments)},c._Reverse=function(){return(c._Reverse=c.asm.Reverse).apply(null,arguments)},c._RotateWithOffset=function(){return(c._RotateWithOffset=c.asm.RotateWithOffset).apply(null,arguments)},c._Round=function(){return(c._Round=c.asm.Round).apply(null,arguments)},c._Rsqrt=function(){return(c._Rsqrt=c.asm.Rsqrt).apply(null,arguments)},c._ScatterNd=function(){return(c._ScatterNd=c.asm.ScatterNd).apply(null,arguments)},c._SearchSorted=function(){return(c._SearchSorted=c.asm.SearchSorted).apply(null,arguments)},c._SelectV2=function(){return(c._SelectV2=c.asm.SelectV2).apply(null,arguments)},c._Selu=function(){return(c._Selu=c.asm.Selu).apply(null,arguments)},c._Sigmoid=function(){return(c._Sigmoid=c.asm.Sigmoid).apply(null,arguments)},c._Sign=function(){return(c._Sign=c.asm.Sign).apply(null,arguments)},c._Sin=function(){return(c._Sin=c.asm.Sin).apply(null,arguments)},c._Sinh=function(){return(c._Sinh=c.asm.Sinh).apply(null,arguments)},c._Softmax=function(){return(c._Softmax=c.asm.Softmax).apply(null,arguments)},c._Softplus=function(){return(c._Softplus=c.asm.Softplus).apply(null,arguments)},c._SparseFillEmptyRows=function(){return(c._SparseFillEmptyRows=c.asm.SparseFillEmptyRows).apply(null,arguments)},c._SparseReshape=function(){return(c._SparseReshape=c.asm.SparseReshape).apply(null,arguments)},c._SparseSegmentReduction=function(){return(c._SparseSegmentReduction=c.asm.SparseSegmentReduction).apply(null,arguments)},c._SparseToDense=function(){return(c._SparseToDense=c.asm.SparseToDense).apply(null,arguments)},c._Sqrt=function(){return(c._Sqrt=c.asm.Sqrt).apply(null,arguments)},c._Square=function(){return(c._Square=c.asm.Square).apply(null,arguments)},c._SquaredDifference=function(){return(c._SquaredDifference=c.asm.SquaredDifference).apply(null,arguments)},c._Step=function(){return(c._Step=c.asm.Step).apply(null,arguments)},c._StridedSlice=function(){return(c._StridedSlice=c.asm.StridedSlice).apply(null,arguments)},c._Sub=function(){return(c._Sub=c.asm.Sub).apply(null,arguments)},c._Sum=function(){return(c._Sum=c.asm.Sum).apply(null,arguments)},c._Tan=function(){return(c._Tan=c.asm.Tan).apply(null,arguments)},c._Tanh=function(){return(c._Tanh=c.asm.Tanh).apply(null,arguments)},c._TensorScatterUpdate=function(){return(c._TensorScatterUpdate=c.asm.TensorScatterUpdate).apply(null,arguments)},c._Tile=function(){return(c._Tile=c.asm.Tile).apply(null,arguments)},c._TopK=function(){return(c._TopK=c.asm.TopK).apply(null,arguments)},c._Transform=function(){return(c._Transform=c.asm.Transform).apply(null,arguments)},c._Transpose=function(){return(c._Transpose=c.asm.Transpose).apply(null,arguments)},c.__FusedMatMul=function(){return(c.__FusedMatMul=c.asm._FusedMatMul).apply(null,arguments)},c._malloc=function(){return(c._malloc=c.asm.malloc).apply(null,arguments)},c._free=function(){return(c._free=c.asm.free).apply(null,arguments)},c.__emscripten_tls_init=function(){return(c.__emscripten_tls_init=c.asm._emscripten_tls_init).apply(null,arguments)};var ir=c._pthread_self=function(){return(ir=c._pthread_self=c.asm.pthread_self).apply(null,arguments)};c.___errno_location=function(){return(c.___errno_location=c.asm.__errno_location).apply(null,arguments)};var gr=c.__emscripten_thread_init=function(){return(gr=c.__emscripten_thread_init=c.asm._emscripten_thread_init).apply(null,arguments)};c.__emscripten_thread_crashed=function(){return(c.__emscripten_thread_crashed=c.asm._emscripten_thread_crashed).apply(null,arguments)},c._emscripten_main_thread_process_queued_calls=function(){return(c._emscripten_main_thread_process_queued_calls=c.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},c._emscripten_main_browser_thread_id=function(){return(c._emscripten_main_browser_thread_id=c.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var si=c._emscripten_run_in_main_runtime_thread_js=function(){return(si=c._emscripten_run_in_main_runtime_thread_js=c.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};c._emscripten_dispatch_to_thread_=function(){return(c._emscripten_dispatch_to_thread_=c.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var Ko=c.__emscripten_proxy_execute_task_queue=function(){return(Ko=c.__emscripten_proxy_execute_task_queue=c.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},ps=c.__emscripten_thread_free_data=function(){return(ps=c.__emscripten_thread_free_data=c.asm._emscripten_thread_free_data).apply(null,arguments)},yh=c.__emscripten_thread_exit=function(){return(yh=c.__emscripten_thread_exit=c.asm._emscripten_thread_exit).apply(null,arguments)},o_=c._emscripten_stack_set_limits=function(){return(o_=c._emscripten_stack_set_limits=c.asm.emscripten_stack_set_limits).apply(null,arguments)},Gv=c.stackSave=function(){return(Gv=c.stackSave=c.asm.stackSave).apply(null,arguments)},wc=c.stackRestore=function(){return(wc=c.stackRestore=c.asm.stackRestore).apply(null,arguments)},_c=c.stackAlloc=function(){return(_c=c.stackAlloc=c.asm.stackAlloc).apply(null,arguments)};c.dynCall_iijjiiii=function(){return(c.dynCall_iijjiiii=c.asm.dynCall_iijjiiii).apply(null,arguments)},c.dynCall_jiji=function(){return(c.dynCall_jiji=c.asm.dynCall_jiji).apply(null,arguments)},c.keepRuntimeAlive=Je,c.wasmMemory=O,c.cwrap=Un,c.ExitStatus=Ne,c.PThread=ht;var Nl;$e=function oe(){Nl||l_(),Nl||($e=oe)};function l_(oe){if(Xe>0)return;if(w){d(c),Vt(),startWorker(c);return}if(At(),Xe>0)return;function ke(){Nl||(Nl=!0,c.calledRun=!0,!X&&(Vt(),d(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),re()))}c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),ke()},1)):ke()}if(c.preInit)for(typeof c.preInit=="function"&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();l_();var Sc;p&&(Sc={uncaughtException:process.listeners("uncaughtException").filter(function(oe){return!p.uncaughtException.indexOf(oe)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(oe){return!p.unhandledRejection.indexOf(oe)>-1})});var Wn;if(typeof WasmBackendModule<"u")Wn=WasmBackendModule;else if(typeof i<"u")Wn=i;else throw new Error("Could not find wasm module in post.js");if(Sc){var u_=Wn._dispose;Wn._dispose=function(){u_(),Sc.uncaughtException.forEach(function(oe){process.removeListener("uncaughtException",oe)}),Sc.unhandledRejection.forEach(function(oe){process.removeListener("unhandledRejection",oe)})}}return i.ready}})();typeof t=="object"&&typeof e=="object"?e.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof t=="object"&&(t.WasmBackendModuleThreadedSimd=n)}),jxe=wi((t,e)=>{e.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`}),Xxe=wi((t,e)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(i){i=i||{};var s=typeof i<"u"?i:{},a,o;s.ready=new Promise(function(Se,qe){a=Se,o=qe});var l;typeof process<"u"&&process.listeners&&(l={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var u=Object.assign({},s),c=typeof window=="object",d=typeof importScripts=="function",h=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",p="";function f(Se){return s.locateFile?s.locateFile(Se,p):p+Se}var g,y,m;if(h){var b=I3(),w=s7();d?p=w.dirname(p)+"/":p=__dirname+"/",g=(Se,qe)=>(Se=Ye(Se)?new URL(Se):w.normalize(Se),b.readFileSync(Se,qe?void 0:"utf8")),m=Se=>{var qe=g(Se,!0);return qe.buffer||(qe=new Uint8Array(qe)),qe},y=(Se,qe,pt)=>{Se=Ye(Se)?new URL(Se):w.normalize(Se),b.readFile(Se,function(ht,xn){ht?pt(ht):qe(xn.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(Se){if(!(Se instanceof Je))throw Se}),process.on("unhandledRejection",function(Se){throw Se}),s.inspect=function(){return"[Emscripten Module object]"}}else(c||d)&&(d?p=self.location.href:typeof document<"u"&&document.currentScript&&(p=document.currentScript.src),r&&(p=r),p.indexOf("blob:")!==0?p=p.substr(0,p.replace(/[?#].*/,"").lastIndexOf("/")+1):p="",g=Se=>{var qe=new XMLHttpRequest;return qe.open("GET",Se,!1),qe.send(null),qe.responseText},d&&(m=Se=>{var qe=new XMLHttpRequest;return qe.open("GET",Se,!1),qe.responseType="arraybuffer",qe.send(null),new Uint8Array(qe.response)}),y=(Se,qe,pt)=>{var ht=new XMLHttpRequest;ht.open("GET",Se,!0),ht.responseType="arraybuffer",ht.onload=()=>{if(ht.status==200||ht.status==0&&ht.response){qe(ht.response);return}pt()},ht.onerror=pt,ht.send(null)});var _=s.print||console.log.bind(console),S=s.printErr||console.warn.bind(console);Object.assign(s,u),u=null,s.arguments&&s.arguments,s.thisProgram&&s.thisProgram,s.quit&&s.quit;var E;s.wasmBinary&&(E=s.wasmBinary),s.noExitRuntime,typeof WebAssembly!="object"&&Tt("no native wasm support detected");var C,T=!1,M=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function k(Se,qe,pt){qe>>>=0;for(var ht=qe+pt,xn=qe;Se[xn]&&!(xn>=ht);)++xn;if(xn-qe>16&&Se.buffer&&M)return M.decode(Se.subarray(qe,xn));for(var ar="";qe<xn;){var gn=Se[qe++];if(!(gn&128)){ar+=String.fromCharCode(gn);continue}var sn=Se[qe++]&63;if((gn&224)==192){ar+=String.fromCharCode((gn&31)<<6|sn);continue}var ur=Se[qe++]&63;if((gn&240)==224?gn=(gn&15)<<12|sn<<6|ur:gn=(gn&7)<<18|sn<<12|ur<<6|Se[qe++]&63,gn<65536)ar+=String.fromCharCode(gn);else{var $r=gn-65536;ar+=String.fromCharCode(55296|$r>>10,56320|$r&1023)}}return ar}function R(Se,qe){return Se>>>=0,Se?k(K,Se,qe):""}function N(Se,qe,pt,ht){if(pt>>>=0,!(ht>0))return 0;for(var xn=pt,ar=pt+ht-1,gn=0;gn<Se.length;++gn){var sn=Se.charCodeAt(gn);if(sn>=55296&&sn<=57343){var ur=Se.charCodeAt(++gn);sn=65536+((sn&1023)<<10)|ur&1023}if(sn<=127){if(pt>=ar)break;qe[pt++>>>0]=sn}else if(sn<=2047){if(pt+1>=ar)break;qe[pt++>>>0]=192|sn>>6,qe[pt++>>>0]=128|sn&63}else if(sn<=65535){if(pt+2>=ar)break;qe[pt++>>>0]=224|sn>>12,qe[pt++>>>0]=128|sn>>6&63,qe[pt++>>>0]=128|sn&63}else{if(pt+3>=ar)break;qe[pt++>>>0]=240|sn>>18,qe[pt++>>>0]=128|sn>>12&63,qe[pt++>>>0]=128|sn>>6&63,qe[pt++>>>0]=128|sn&63}}return qe[pt>>>0]=0,pt-xn}function B(Se,qe,pt){return N(Se,K,qe,pt)}var z,V,K,Q;function O(Se){z=Se,s.HEAP8=V=new Int8Array(Se),s.HEAP16=new Int16Array(Se),s.HEAP32=new Int32Array(Se),s.HEAPU8=K=new Uint8Array(Se),s.HEAPU16=new Uint16Array(Se),s.HEAPU32=Q=new Uint32Array(Se),s.HEAPF32=new Float32Array(Se),s.HEAPF64=new Float64Array(Se)}s.INITIAL_MEMORY;var j=[],X=[],te=[];function le(){if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)we(s.preRun.shift());At(j)}function ge(){At(X)}function ie(){if(s.postRun)for(typeof s.postRun=="function"&&(s.postRun=[s.postRun]);s.postRun.length;)Re(s.postRun.shift());At(te)}function we(Se){j.unshift(Se)}function Ce(Se){X.unshift(Se)}function Re(Se){te.unshift(Se)}var Le=0,lt=null;function st(Se){Le++,s.monitorRunDependencies&&s.monitorRunDependencies(Le)}function Et(Se){if(Le--,s.monitorRunDependencies&&s.monitorRunDependencies(Le),Le==0&&lt){var qe=lt;lt=null,qe()}}function Tt(Se){s.onAbort&&s.onAbort(Se),Se="Aborted("+Se+")",S(Se),T=!0,Se+=". Build with -sASSERTIONS for more info.";var qe=new WebAssembly.RuntimeError(Se);throw o(qe),qe}var xt="data:application/octet-stream;base64,";function J(Se){return Se.startsWith(xt)}function Ye(Se){return Se.startsWith("file://")}var Be;Be="tfjs-backend-wasm.wasm",J(Be)||(Be=f(Be));function tt(Se){try{if(Se==Be&&E)return new Uint8Array(E);if(m)return m(Se);throw"both async and sync fetching of the wasm failed"}catch(qe){Tt(qe)}}function Ue(){if(!E&&(c||d)){if(typeof fetch=="function"&&!Ye(Be))return fetch(Be,{credentials:"same-origin"}).then(function(Se){if(!Se.ok)throw"failed to load wasm binary file at '"+Be+"'";return Se.arrayBuffer()}).catch(function(){return tt(Be)});if(y)return new Promise(function(Se,qe){y(Be,function(pt){Se(new Uint8Array(pt))},qe)})}return Promise.resolve().then(function(){return tt(Be)})}function St(){var Se={env:Me,wasi_snapshot_preview1:Me};function qe(gn,sn){var ur=gn.exports;s.asm=ur,C=s.asm.memory,O(C.buffer),s.asm.__indirect_function_table,Ce(s.asm.__wasm_call_ctors),Et()}st();function pt(gn){qe(gn.instance)}function ht(gn){return Ue().then(function(sn){return WebAssembly.instantiate(sn,Se)}).then(function(sn){return sn}).then(gn,function(sn){S("failed to asynchronously prepare wasm: "+sn),Tt(sn)})}function xn(){return!E&&typeof WebAssembly.instantiateStreaming=="function"&&!J(Be)&&!Ye(Be)&&!h&&typeof fetch=="function"?fetch(Be,{credentials:"same-origin"}).then(function(gn){var sn=WebAssembly.instantiateStreaming(gn,Se);return sn.then(pt,function(ur){return S("wasm streaming compile failed: "+ur),S("falling back to ArrayBuffer instantiation"),ht(pt)})}):ht(pt)}if(s.instantiateWasm)try{var ar=s.instantiateWasm(Se,qe);return ar}catch(gn){S("Module.instantiateWasm callback failed with error: "+gn),o(gn)}return xn().catch(o),{}}function Je(Se){this.name="ExitStatus",this.message="Program terminated with exit("+Se+")",this.status=Se}function At(Se){for(;Se.length>0;)Se.shift()(s)}function Vt(){Tt("")}function re(){return 4294901760}function H(){return re()}function Ee(Se,qe,pt){K.copyWithin(Se>>>0,qe>>>0,qe+pt>>>0)}function Oe(Se){try{return C.grow(Se-z.byteLength+65535>>>16),O(C.buffer),1}catch{}}function Xe(Se){var qe=K.length;Se=Se>>>0;var pt=re();if(Se>pt)return!1;let ht=(ur,$r)=>ur+($r-ur%$r)%$r;for(var xn=1;xn<=4;xn*=2){var ar=qe*(1+.2/xn);ar=Math.min(ar,Se+100663296);var gn=Math.min(pt,ht(Math.max(Se,ar),65536)),sn=Oe(gn);if(sn)return!0}return!1}function $e(Se){return 52}function Lt(Se,qe,pt,ht,xn){return 70}var wt=[null,[],[]];function Pt(Se,qe){var pt=wt[Se];qe===0||qe===10?((Se===1?_:S)(k(pt,0)),pt.length=0):pt.push(qe)}function Ht(Se,qe,pt,ht){for(var xn=0,ar=0;ar<pt;ar++){var gn=Q[qe>>>2],sn=Q[qe+4>>>2];qe+=8;for(var ur=0;ur<sn;ur++)Pt(Se,K[gn+ur>>>0]);xn+=sn}return Q[ht>>>2]=xn,0}function et(Se){var qe=s["_"+Se];return qe}function mt(Se,qe){V.set(Se,qe>>>0)}function Ot(Se,qe,pt,ht,xn){var ar={string:$=>{var Y=0;if($!=null&&$!==0){var ye=($.length<<2)+1;Y=Ne(ye),B($,Y,ye)}return Y},array:$=>{var Y=Ne($.length);return mt($,Y),Y}};function gn($){return qe==="string"?R($):qe==="boolean"?!!$:$}var sn=et(Se),ur=[],$r=0;if(ht)for(var zr=0;zr<ht.length;zr++){var yn=ar[pt[zr]];yn?($r===0&&($r=it()),ur[zr]=yn(ht[zr])):ur[zr]=ht[zr]}var Wa=sn.apply(null,ur);function Va($){return $r!==0&&de($r),gn($)}return Wa=Va(Wa),Wa}function he(Se,qe,pt,ht){pt=pt||[];var xn=pt.every(gn=>gn==="number"||gn==="boolean"),ar=qe!=="string";return ar&&xn&&!ht?et(Se):function(){return Ot(Se,qe,pt,arguments)}}var Me={abort:Vt,emscripten_get_heap_max:H,emscripten_memcpy_big:Ee,emscripten_resize_heap:Xe,fd_close:$e,fd_seek:Lt,fd_write:Ht};St(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},s._init=function(){return(s._init=s.asm.init).apply(null,arguments)},s._init_with_threads_count=function(){return(s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},s._get_threads_count=function(){return(s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},s._register_tensor=function(){return(s._register_tensor=s.asm.register_tensor).apply(null,arguments)},s._dispose_data=function(){return(s._dispose_data=s.asm.dispose_data).apply(null,arguments)},s._dispose=function(){return(s._dispose=s.asm.dispose).apply(null,arguments)},s._Abs=function(){return(s._Abs=s.asm.Abs).apply(null,arguments)},s._Acos=function(){return(s._Acos=s.asm.Acos).apply(null,arguments)},s._Acosh=function(){return(s._Acosh=s.asm.Acosh).apply(null,arguments)},s._Add=function(){return(s._Add=s.asm.Add).apply(null,arguments)},s._AddN=function(){return(s._AddN=s.asm.AddN).apply(null,arguments)},s._All=function(){return(s._All=s.asm.All).apply(null,arguments)},s._Any=function(){return(s._Any=s.asm.Any).apply(null,arguments)},s._ArgMax=function(){return(s._ArgMax=s.asm.ArgMax).apply(null,arguments)},s._ArgMin=function(){return(s._ArgMin=s.asm.ArgMin).apply(null,arguments)},s._Asin=function(){return(s._Asin=s.asm.Asin).apply(null,arguments)},s._Asinh=function(){return(s._Asinh=s.asm.Asinh).apply(null,arguments)},s._Atan=function(){return(s._Atan=s.asm.Atan).apply(null,arguments)},s._Atan2=function(){return(s._Atan2=s.asm.Atan2).apply(null,arguments)},s._Atanh=function(){return(s._Atanh=s.asm.Atanh).apply(null,arguments)},s._AvgPool=function(){return(s._AvgPool=s.asm.AvgPool).apply(null,arguments)},s._AvgPool3D=function(){return(s._AvgPool3D=s.asm.AvgPool3D).apply(null,arguments)},s._AvgPool3DGrad=function(){return(s._AvgPool3DGrad=s.asm.AvgPool3DGrad).apply(null,arguments)},s._AvgPoolGrad=function(){return(s._AvgPoolGrad=s.asm.AvgPoolGrad).apply(null,arguments)},s._BatchMatMul=function(){return(s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},s._Bincount=function(){return(s._Bincount=s.asm.Bincount).apply(null,arguments)},s._BitwiseAnd=function(){return(s._BitwiseAnd=s.asm.BitwiseAnd).apply(null,arguments)},s._Ceil=function(){return(s._Ceil=s.asm.Ceil).apply(null,arguments)},s._ClipByValue=function(){return(s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},s._Conv2D=function(){return(s._Conv2D=s.asm.Conv2D).apply(null,arguments)},s._Conv2DBackpropInput=function(){return(s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},s._Conv3D=function(){return(s._Conv3D=s.asm.Conv3D).apply(null,arguments)},s._Conv3DBackpropFilterV2=function(){return(s._Conv3DBackpropFilterV2=s.asm.Conv3DBackpropFilterV2).apply(null,arguments)},s._Conv3DBackpropInputV2=function(){return(s._Conv3DBackpropInputV2=s.asm.Conv3DBackpropInputV2).apply(null,arguments)},s._Cos=function(){return(s._Cos=s.asm.Cos).apply(null,arguments)},s._Cosh=function(){return(s._Cosh=s.asm.Cosh).apply(null,arguments)},s._CropAndResize=function(){return(s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},s._Cumprod=function(){return(s._Cumprod=s.asm.Cumprod).apply(null,arguments)},s._Cumsum=function(){return(s._Cumsum=s.asm.Cumsum).apply(null,arguments)},s._DenseBincount=function(){return(s._DenseBincount=s.asm.DenseBincount).apply(null,arguments)},s._DepthToSpace=function(){return(s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},s._DepthwiseConv2dNative=function(){return(s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},s._Diag=function(){return(s._Diag=s.asm.Diag).apply(null,arguments)},s._Dilation2D=function(){return(s._Dilation2D=s.asm.Dilation2D).apply(null,arguments)},s._Dilation2DBackpropFilter=function(){return(s._Dilation2DBackpropFilter=s.asm.Dilation2DBackpropFilter).apply(null,arguments)},s._Dilation2DBackpropInput=function(){return(s._Dilation2DBackpropInput=s.asm.Dilation2DBackpropInput).apply(null,arguments)},s._Elu=function(){return(s._Elu=s.asm.Elu).apply(null,arguments)},s._EluGrad=function(){return(s._EluGrad=s.asm.EluGrad).apply(null,arguments)},s._Equal=function(){return(s._Equal=s.asm.Equal).apply(null,arguments)},s._Erf=function(){return(s._Erf=s.asm.Erf).apply(null,arguments)},s._Exp=function(){return(s._Exp=s.asm.Exp).apply(null,arguments)},s._Expm1=function(){return(s._Expm1=s.asm.Expm1).apply(null,arguments)},s._FlipLeftRight=function(){return(s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},s._Floor=function(){return(s._Floor=s.asm.Floor).apply(null,arguments)},s._FloorDiv=function(){return(s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},s._FusedBatchNorm=function(){return(s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},s._FusedConv2D=function(){return(s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},s._FusedDepthwiseConv2D=function(){return(s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},s._Gather=function(){return(s._Gather=s.asm.Gather).apply(null,arguments)},s._GatherNd=function(){return(s._GatherNd=s.asm.GatherNd).apply(null,arguments)},s._Greater=function(){return(s._Greater=s.asm.Greater).apply(null,arguments)},s._GreaterEqual=function(){return(s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},s._IsFinite=function(){return(s._IsFinite=s.asm.IsFinite).apply(null,arguments)},s._IsInf=function(){return(s._IsInf=s.asm.IsInf).apply(null,arguments)},s._IsNan=function(){return(s._IsNan=s.asm.IsNan).apply(null,arguments)},s._LRN=function(){return(s._LRN=s.asm.LRN).apply(null,arguments)},s._LRNGrad=function(){return(s._LRNGrad=s.asm.LRNGrad).apply(null,arguments)},s._LeakyRelu=function(){return(s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},s._Less=function(){return(s._Less=s.asm.Less).apply(null,arguments)},s._LessEqual=function(){return(s._LessEqual=s.asm.LessEqual).apply(null,arguments)},s._LinSpace=function(){return(s._LinSpace=s.asm.LinSpace).apply(null,arguments)},s._Log=function(){return(s._Log=s.asm.Log).apply(null,arguments)},s._Log1p=function(){return(s._Log1p=s.asm.Log1p).apply(null,arguments)},s._LogicalAnd=function(){return(s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},s._LogicalNot=function(){return(s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},s._LogicalOr=function(){return(s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},s._LogicalXor=function(){return(s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},s._Max=function(){return(s._Max=s.asm.Max).apply(null,arguments)},s._MaxPool=function(){return(s._MaxPool=s.asm.MaxPool).apply(null,arguments)},s._MaxPool3D=function(){return(s._MaxPool3D=s.asm.MaxPool3D).apply(null,arguments)},s._MaxPool3DGrad=function(){return(s._MaxPool3DGrad=s.asm.MaxPool3DGrad).apply(null,arguments)},s._MaxPoolGrad=function(){return(s._MaxPoolGrad=s.asm.MaxPoolGrad).apply(null,arguments)},s._MaxPoolWithArgmax=function(){return(s._MaxPoolWithArgmax=s.asm.MaxPoolWithArgmax).apply(null,arguments)},s._Maximum=function(){return(s._Maximum=s.asm.Maximum).apply(null,arguments)},s._Mean=function(){return(s._Mean=s.asm.Mean).apply(null,arguments)},s._Min=function(){return(s._Min=s.asm.Min).apply(null,arguments)},s._Minimum=function(){return(s._Minimum=s.asm.Minimum).apply(null,arguments)},s._MirrorPad=function(){return(s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},s._Mod=function(){return(s._Mod=s.asm.Mod).apply(null,arguments)},s._Multinomial=function(){return(s._Multinomial=s.asm.Multinomial).apply(null,arguments)},s._Multiply=function(){return(s._Multiply=s.asm.Multiply).apply(null,arguments)},s._Neg=function(){return(s._Neg=s.asm.Neg).apply(null,arguments)},s._NonMaxSuppressionV3=function(){return(s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},s._NonMaxSuppressionV4=function(){return(s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},s._NonMaxSuppressionV5=function(){return(s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},s._NotEqual=function(){return(s._NotEqual=s.asm.NotEqual).apply(null,arguments)},s._OneHot=function(){return(s._OneHot=s.asm.OneHot).apply(null,arguments)},s._PadV2=function(){return(s._PadV2=s.asm.PadV2).apply(null,arguments)},s._Pow=function(){return(s._Pow=s.asm.Pow).apply(null,arguments)},s._Prelu=function(){return(s._Prelu=s.asm.Prelu).apply(null,arguments)},s._Prod=function(){return(s._Prod=s.asm.Prod).apply(null,arguments)},s._RealDiv=function(){return(s._RealDiv=s.asm.RealDiv).apply(null,arguments)},s._Reciprocal=function(){return(s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},s._Relu=function(){return(s._Relu=s.asm.Relu).apply(null,arguments)},s._Relu6=function(){return(s._Relu6=s.asm.Relu6).apply(null,arguments)},s._ResizeBilinear=function(){return(s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},s._ResizeBilinearGrad=function(){return(s._ResizeBilinearGrad=s.asm.ResizeBilinearGrad).apply(null,arguments)},s._ResizeNearestNeighbor=function(){return(s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},s._ResizeNearestNeighborGrad=function(){return(s._ResizeNearestNeighborGrad=s.asm.ResizeNearestNeighborGrad).apply(null,arguments)},s._Reverse=function(){return(s._Reverse=s.asm.Reverse).apply(null,arguments)},s._RotateWithOffset=function(){return(s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},s._Round=function(){return(s._Round=s.asm.Round).apply(null,arguments)},s._Rsqrt=function(){return(s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},s._ScatterNd=function(){return(s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},s._SearchSorted=function(){return(s._SearchSorted=s.asm.SearchSorted).apply(null,arguments)},s._SelectV2=function(){return(s._SelectV2=s.asm.SelectV2).apply(null,arguments)},s._Selu=function(){return(s._Selu=s.asm.Selu).apply(null,arguments)},s._Sigmoid=function(){return(s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},s._Sign=function(){return(s._Sign=s.asm.Sign).apply(null,arguments)},s._Sin=function(){return(s._Sin=s.asm.Sin).apply(null,arguments)},s._Sinh=function(){return(s._Sinh=s.asm.Sinh).apply(null,arguments)},s._Softmax=function(){return(s._Softmax=s.asm.Softmax).apply(null,arguments)},s._Softplus=function(){return(s._Softplus=s.asm.Softplus).apply(null,arguments)},s._SparseFillEmptyRows=function(){return(s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},s._SparseReshape=function(){return(s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},s._SparseSegmentReduction=function(){return(s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},s._SparseToDense=function(){return(s._SparseToDense=s.asm.SparseToDense).apply(null,arguments)},s._Sqrt=function(){return(s._Sqrt=s.asm.Sqrt).apply(null,arguments)},s._Square=function(){return(s._Square=s.asm.Square).apply(null,arguments)},s._SquaredDifference=function(){return(s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},s._Step=function(){return(s._Step=s.asm.Step).apply(null,arguments)},s._StridedSlice=function(){return(s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},s._Sub=function(){return(s._Sub=s.asm.Sub).apply(null,arguments)},s._Sum=function(){return(s._Sum=s.asm.Sum).apply(null,arguments)},s._Tan=function(){return(s._Tan=s.asm.Tan).apply(null,arguments)},s._Tanh=function(){return(s._Tanh=s.asm.Tanh).apply(null,arguments)},s._TensorScatterUpdate=function(){return(s._TensorScatterUpdate=s.asm.TensorScatterUpdate).apply(null,arguments)},s._Tile=function(){return(s._Tile=s.asm.Tile).apply(null,arguments)},s._TopK=function(){return(s._TopK=s.asm.TopK).apply(null,arguments)},s._Transform=function(){return(s._Transform=s.asm.Transform).apply(null,arguments)},s._Transpose=function(){return(s._Transpose=s.asm.Transpose).apply(null,arguments)},s.__FusedMatMul=function(){return(s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},s._malloc=function(){return(s._malloc=s.asm.malloc).apply(null,arguments)},s._free=function(){return(s._free=s.asm.free).apply(null,arguments)},s.___errno_location=function(){return(s.___errno_location=s.asm.__errno_location).apply(null,arguments)};var it=s.stackSave=function(){return(it=s.stackSave=s.asm.stackSave).apply(null,arguments)},de=s.stackRestore=function(){return(de=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},Ne=s.stackAlloc=function(){return(Ne=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)};s.dynCall_iijjiiii=function(){return(s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},s.dynCall_jiji=function(){return(s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)},s.cwrap=he;var nt;lt=function Se(){nt||Mt(),nt||(lt=Se)};function Mt(Se){if(Le>0||(le(),Le>0))return;function qe(){nt||(nt=!0,s.calledRun=!0,!T&&(ge(),a(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),ie()))}s.setStatus?(s.setStatus("Running..."),setTimeout(function(){setTimeout(function(){s.setStatus("")},1),qe()},1)):qe()}if(s.preInit)for(typeof s.preInit=="function"&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();Mt();var ut;l&&(ut={uncaughtException:process.listeners("uncaughtException").filter(function(Se){return!l.uncaughtException.indexOf(Se)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(Se){return!l.unhandledRejection.indexOf(Se)>-1})});var Ze;if(typeof i<"u")Ze=i;else if(typeof WasmBackendModuleThreadedSimd<"u")Ze=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(ut){var kt=Ze._dispose;Ze._dispose=function(){kt(),ut.uncaughtException.forEach(function(Se){process.removeListener("uncaughtException",Se)}),ut.unhandledRejection.forEach(function(Se){process.removeListener("unhandledRejection",Se)})}}return i.ready}})();typeof t=="object"&&typeof e=="object"?e.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof t=="object"&&(t.WasmBackendModule=n)}),tC=class{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}},nw=class{refCount(t){return ba("refCount")}incRef(t){return ba("incRef")}timerAvailable(){return!0}time(t){return ba("time")}read(t){return ba("read")}readSync(t){return ba("readSync")}readToGPU(t,e){return ba("readToGPU")}numDataIds(){return ba("numDataIds")}disposeData(t,e){return ba("disposeData")}write(t,e,n){return ba("write")}move(t,e,n,r,i){return ba("move")}createTensorFromGPUData(t,e,n){return ba("createTensorFromGPUData")}memory(){return ba("memory")}floatPrecision(){return ba("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return ba("dispose")}};function ba(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function a7(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,EI(t,e,n)}function Kxe(t,e){if(t.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${e.length}`);let n=t.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,EI(t,n,r),EI(e,n,r)}function p1(t,e,n){return Math.max(t,Math.min(e,n))}function qxe(t){return t%2===0?t:t+1}function EI(t,e,n){let r=t[e];t[e]=t[n],t[n]=r}function Jxe(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function Yxe(t,e){let n=Math.random();return e*n+(1-n)*t}function Zxe(t,e){let n=0;for(let r=0;r<t.length;r++){let i=Number(t[r])-Number(e[r]);n+=i*i}return n}function ee(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function Vs(t,e,n=""){ee(pc(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function Ef(t){ee(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function fr(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function Qxe(t){return t.length===0}function o7(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==null&&e[n]!==null&&t[n]!==e[n])return!1;return!0}function pc(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function Vy(t){return t%1===0}function ebe(t){if(Math.tanh!=null)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{let e=Math.exp(2*t);return(e-1)/(e+1)}}function tbe(t){let e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function nbe(t){let e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return a7(e),e}function Mb(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function rbe(t,e=i=>0,n,r){return new Promise((i,s)=>{let a=0,o=()=>{if(t()){i();return}a++;let l=e(a);if(n!=null&&a>=n){s();return}r!=null?r(o,l):setTimeout(o,l)};o()})}function ibe(t,e){let n=1,r=-1;for(let s=0;s<t.length;++s)if(t[s]>=0)n*=t[s];else if(t[s]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(t[s]<0)throw Error(`Shapes can not be < 0. Found ${t[s]} at dim ${s}`);if(r===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);let i=t.slice();return i[r]=e/n,i}function Vo(t,e){let n=e.length;return t=t==null?e.map((r,i)=>i):[].concat(t),ee(t.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),ee(t.every(r=>Vy(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?n+r:r)}function l7(t,e){let n=[],r=[],i=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||i?null:Vo(e,t).sort(),a=0;for(let o=0;o<t.length;++o){if(s!=null){if(s[a]===o&&t[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${t[o]}' is not 1`);(s[a]==null||s[a]>o)&&t[o]===1&&(n.push(t[o]),r.push(o)),s[a]<=o&&a++}t[o]!==1&&(n.push(t[o]),r.push(o))}return{newShape:n,keptDims:r}}function u7(t,e){return T3(t,e)}function T3(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function c7(t,e){for(let n=0;n<t.length;n++){let r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function d7(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function sbe(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function II(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function h7(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function ud(t){return typeof t=="string"||t instanceof String}function p7(t){return typeof t=="boolean"}function f7(t){return typeof t=="number"}function rw(t){return Array.isArray(t)?rw(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":f7(t)?"float32":ud(t)?"string":p7(t)?"bool":"float32"}function Nd(t){return!!(t&&t.constructor&&t.call&&t.apply)}function TI(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function v0(t){let e=t.length;if(e<2)return[];let n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function m7(t,e,n,r=!1){let i=new Array;if(e.length===1){let s=e[0]*(r?2:1);for(let a=0;a<s;a++)i[a]=n[t+a]}else{let s=e[0],a=e.slice(1),o=a.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<s;l++)i[l]=m7(t+l*o,a,n,r)}return i}function wy(t,e,n=!1){if(t.length===0)return e[0];let r=t.reduce((i,s)=>i*s)*(n?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return m7(0,t,e,n)}function abe(t,e){if(Array.isArray(t))return t;if(e==="float32")return t instanceof Float32Array?t:new Float32Array(t);if(e==="int32")return t instanceof Int32Array?t:new Int32Array(t);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(t));throw new Error(`Unknown dtype ${e}`)}function C3(t,e){let n=nC(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function nC(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function obe(t,e){let n=t.reduce((r,i)=>r*i,1);if(e==null||e==="float32")return wy(t,new Float32Array(n));if(e==="int32")return wy(t,new Int32Array(n));if(e==="bool")return wy(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function Ha(t){t.forEach(e=>{ee(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function lbe(t,e,n){if(e===0)return 0;if(e===1)return t[0];let r=t[t.length-1];for(let i=0;i<t.length-1;++i)r+=n[i]*t[i];return r}function ube(t,e,n){if(e===0)return[];if(e===1)return[t];let r=new Array(e);for(let i=0;i<r.length-1;++i)r[i]=Math.floor(t/n[i]),t-=r[i]*n[i];return r[r.length-1]=t,r}function rC(t){return t&&t.then&&typeof t.then=="function"}var GW="tfjsflags",g7=class{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=cbe,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},this.urlFlags[t]!=null){let r=this.urlFlags[t];Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${r}.`),this.set(t,r)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];let e=this.evaluateFlag(t);if(rC(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let t=this.getQueryParams(this.global.location.search);GW in t&&t[GW].split(",").forEach(e=>{let[n,r]=e.split(":");this.urlFlags[n]=hbe(n,r)})}};function cbe(t){let e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(dbe(e,r[0],r[1]),r.join("="))),e}function dbe(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function hbe(t,e){let n=e.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:e}function Ie(){return M3}var M3=null;function pbe(t){M3=t}var yN;function y7(){if(yN==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");yN=t}return yN}function fbe(){let t=y7();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function k3(t,e){let n=fbe();if(n.has(t))return n.get(t);{let r=e();return n.set(t,r),n.get(t)}}var x0="Abs",If="Acos",Tf="Acosh",th="Add",Cf="AddN",b0="All",w0="Any",_0="ArgMax",S0="ArgMin",Mf="Asin",kf="Asinh",Nf="Atan",Rf="Atanh",Ff="Atan2",Df="AvgPool",iw="AvgPoolGrad",A0="AvgPool3D",sw="AvgPool3DGrad",Pf="BatchMatMul",E0="BatchToSpaceND",I0="Bincount",T0="BitwiseAnd",v7="BroadcastTo",aw="BroadcastArgs",Lf="Cast",Of="Ceil",nh="ClipByValue",iC="Complex",ow="ComplexAbs",C0="Concat",Bf="Conv2D",sC="Conv2DBackpropFilter",Uf="Conv2DBackpropInput",$f="Conv3D",M0="Conv3DBackpropFilterV2",k0="Conv3DBackpropInputV2",zf="Cos",Gf="Cosh",N0="Cumprod",Hf="Cumsum",R0="CropAndResize",lw="DenseBincount",F0="DepthToSpace",Wf="DepthwiseConv2dNative",aC="DepthwiseConv2dNativeBackpropFilter",oC="DepthwiseConv2dNativeBackpropInput",uw="Diag",Vf="Dilation2D",jy="Dilation2DBackpropInput",Xy="Dilation2DBackpropFilter",lC="Draw",jf="RealDiv",uC="Einsum",Xf="Elu",D0="EluGrad",Kf="Erf",P0="Equal",qf="Exp",L0="ExpandDims",Jf="Expm1",cC="FFT",cw="Fill",O0="FlipLeftRight",Yf="Floor",Zf="FloorDiv",Qf="FusedBatchNorm",B0="GatherV2",U0="GatherNd",$0="Greater",em="GreaterEqual",tm="Identity",dC="IFFT",hC="Imag",nm="IsFinite",rm="IsInf",im="IsNan",sm="LeakyRelu",z0="Less",G0="LessEqual",H0="LinSpace",am="Log",om="Log1p",W0="LogicalAnd",V0="LogicalNot",j0="LogicalOr",x7="LogicalXor",b7="LogSoftmax",mbe="LowerBound",lm="LRN",X0="LRNGrad",gbe="MatrixBandPart",um="Max",cm="Maximum",dm="MaxPool",dw="MaxPoolGrad",K0="MaxPool3D",hw="MaxPool3DGrad",pw="MaxPoolWithArgmax",hm="Mean",pm="Min",fm="Minimum",mm="MirrorPad",gm="Mod",q0="Multinomial",ym="Multiply",J0="Neg",Y0="NotEqual",Z0="NonMaxSuppressionV3",Q0="NonMaxSuppressionV4",ev="NonMaxSuppressionV5",tv="OnesLike",vm="OneHot",nv="Pack",xm="PadV2",ybe="Pool",bm="Pow",wm="Prelu",_m="Prod",pC="RaggedGather",fC="RaggedRange",mC="RaggedTensorToTensor",fw="Range",gC="Real",Sm="Reciprocal",Am="Relu",rv="Reshape",Em="ResizeNearestNeighbor",iv="ResizeNearestNeighborGrad",Im="ResizeBilinear",sv="ResizeBilinearGrad",Tm="Relu6",Cm="Reverse",Mm="Round",km="Rsqrt",av="ScatterNd",ov="TensorScatterUpdate",lv="SearchSorted",uv="Select",Nm="Selu",cv="Slice",Rm="Sin",Fm="Sinh",Dm="Sign",Pm="Sigmoid",Lm="Softplus",Om="Sqrt",Bm="Sum",dv="SpaceToBatchND",hv="SplitV",Um="Softmax",mw="SparseFillEmptyRows",pv="SparseReshape",gw="SparseSegmentMean",yw="SparseSegmentSum",fv="SparseToDense",$m="SquaredDifference",vw="Square",xw="StaticRegexReplace",mv="StridedSlice",bw="StringNGrams",ww="StringSplit",_w="StringToHashBucketFast",zm="Sub",Gm="Tan",Hm="Tanh",rh="Tile",gv="TopK",yv="Transform",Qu="Transpose",Sw="Unique",vv="Unpack",Aw="UnsortedSegmentSum",vbe="UpperBound",xv="ZerosLike",ih="Step",CI="FromPixels",bv="RotateWithOffset",Xp="_FusedMatMul",Kp="FusedConv2D",qp="FusedDepthwiseConv2D";function rd(...t){Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.warn(...t)}function xbe(...t){Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.log(...t)}var Ky=k3("kernelRegistry",()=>new Map),f1=k3("gradRegistry",()=>new Map);function m1(t,e){let n=N3(t,e);return Ky.get(n)}function sF(t){return f1.get(t)}function MI(t){let e=Ky.entries(),n=[];for(;;){let{done:r,value:i}=e.next();if(r)break;let[s,a]=i,[o]=s.split("_");o===t&&n.push(a)}return n}function Ew(t){let{kernelName:e,backendName:n}=t,r=N3(e,n);Ky.has(r)&&rd(`The kernel '${e}' for backend '${n}' is already registered`),Ky.set(r,t)}function w7(t){let{kernelName:e}=t;f1.has(e)&&Ie().getBool("DEBUG")&&rd(`Overriding the gradient for '${e}'`),f1.set(e,t)}function bbe(t,e){let n=N3(t,e);if(!Ky.has(n))throw new Error(`The kernel '${t}' for backend '${e}' is not registered`);Ky.delete(n)}function wbe(t){if(!f1.has(t))throw new Error(`The gradient '${t}' for backend is not registered`);f1.delete(t)}function _be(t,e){MI(t).forEach(n=>{let r=Object.assign({},n,{backendName:e});Ew(r)})}function N3(t,e){return`${e}_${t}`}var P={};wn(P,{arraysEqual:()=>pc,arraysEqualWithNull:()=>o7,assert:()=>ee,assertNonNegativeIntegerDimensions:()=>Ha,assertNonNull:()=>Ef,assertShapesMatch:()=>Vs,bytesFromStringArray:()=>h7,bytesPerElement:()=>II,checkConversionForErrors:()=>c7,clamp:()=>p1,computeStrides:()=>v0,convertBackendValuesAndArrayBuffer:()=>abe,createScalarValue:()=>Cbe,createShuffledIndices:()=>nbe,decodeString:()=>kI,distSquared:()=>Zxe,encodeString:()=>Tw,fetch:()=>kbe,fingerPrint64:()=>Tbe,flatten:()=>Rd,getArrayFromDType:()=>T3,getTypedArrayFromDType:()=>u7,hasEncodingLoss:()=>sbe,hexToLong:()=>Iw,indexToLoc:()=>ube,inferDtype:()=>rw,inferFromImplicitShape:()=>ibe,isBoolean:()=>p7,isFunction:()=>Nd,isInt:()=>Vy,isNumber:()=>f7,isPromise:()=>rC,isScalarShape:()=>Qxe,isString:()=>ud,isTypedArray:()=>zi,isValidDtype:()=>d7,locToIndex:()=>lbe,makeOnesTypedArray:()=>C3,makeZerosNestedTypedArray:()=>obe,makeZerosTypedArray:()=>nC,nearestDivisor:()=>TI,nearestLargerEven:()=>qxe,now:()=>g1,parseAxisParam:()=>Vo,randUniform:()=>Yxe,repeatedTry:()=>rbe,rightPad:()=>Mb,shuffle:()=>a7,shuffleCombo:()=>Kxe,sizeFromShape:()=>fr,sizeToSquarishShape:()=>tbe,squeezeShape:()=>l7,sum:()=>Jxe,swap:()=>EI,tanh:()=>ebe,toNestedArray:()=>wy,toTypedArray:()=>yC});function _7(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}var HW=eh(Nxe()),rp=HW.default||HW;function Iw(t){return rp.fromString(t,!0,16)}var S7=Iw("c3a5c85c97cb3127"),Zh=Iw("b492b66fbe98f273"),Ls=Iw("9ae16a3b2f90404f");function aF(t){return t.xor(t.shru(47))}function A7(t,e,n){let r=t.slice(e,e+n);return rp.fromBytes(Array.from(r),!0,!0)}function Tr(t,e){return A7(t,e,8)}function WW(t,e){return A7(t,e,4)}function $i(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function Sd(t,e,n=Iw("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let i=e.xor(r).mul(n);return i=i.xor(i.shru(47)),i=i.mul(n),i}function Sbe(t,e,n,r,i,s){i=i.add(t),s=$i(s.add(i).add(r),21);let a=i;return i=i.add(e),i=i.add(n),s=s.add($i(i,44)),[i.add(r),s.add(a)]}function gA(t,e,n,r){return Sbe(Tr(t,e),Tr(t,e+8),Tr(t,e+16),Tr(t,e+24),n,r)}function Abe(t,e=t.length){if(e>=8){let n=Ls.add(e*2),r=Tr(t,0).add(Ls),i=Tr(t,e-8),s=$i(i,37).mul(n).add(r),a=$i(r,25).add(i).mul(n);return Sd(s,a,n)}if(e>=4){let n=Ls.add(e*2),r=WW(t,0);return Sd(r.shl(3).add(e),WW(t,e-4),n)}if(e>0){let n=t[0],r=t[e>>1],i=t[e-1],s=n+(r<<8),a=e+(i<<2);return aF(Ls.mul(s).xor(S7.mul(a))).mul(Ls)}return Ls}function Ebe(t,e=t.length){let n=Ls.add(e*2),r=Tr(t,0).mul(Zh),i=Tr(t,8),s=Tr(t,e-8).mul(n),a=Tr(t,e-16).mul(Ls);return Sd($i(r.add(i),43).add($i(s,30)).add(a),r.add($i(i.add(Ls),18)).add(s),n)}function Ibe(t,e=t.length){let n=Ls.add(e*2),r=Tr(t,0).mul(Ls),i=Tr(t,8),s=Tr(t,e-8).mul(n),a=Tr(t,e-16).mul(Ls),o=$i(r.add(i),43).add($i(s,30)).add(a),l=Sd(o,r.add($i(i.add(Ls),18)).add(s),n),u=Tr(t,16).mul(n),c=Tr(t,24),d=o.add(Tr(t,e-32)).mul(n),h=l.add(Tr(t,e-24)).mul(n);return Sd($i(u.add(c),43).add($i(d,30)).add(h),u.add($i(c.add(r),18)).add(d),n)}function Tbe(t,e=t.length){let n=rp.fromNumber(81,!0);if(e<=32)return e<=16?Abe(t,e):Ebe(t,e);if(e<=64)return Ibe(t,e);let r=n,i=n.mul(Zh).add(113),s=aF(i.mul(Ls).add(113)).mul(Ls),a=[rp.UZERO,rp.UZERO],o=[rp.UZERO,rp.UZERO];r=r.mul(Ls).add(Tr(t,0));let l=0,u=(e-1>>6)*64,c=u+(e-1&63)-63;do r=$i(r.add(i).add(a[0]).add(Tr(t,l+8)),37).mul(Zh),i=$i(i.add(a[1]).add(Tr(t,l+48)),42).mul(Zh),r=r.xor(o[1]),i=i.add(a[0]).add(Tr(t,l+40)),s=$i(s.add(o[0]),33).mul(Zh),a=gA(t,l,a[1].mul(Zh),r.add(o[0])),o=gA(t,l+32,s.add(o[1]),i.add(Tr(t,l+16))),[s,r]=[r,s],l+=64;while(l!==u);let d=Zh.add(s.and(255).shl(1));return l=c,o[0]=o[0].add(e-1&63),a[0]=a[0].add(o[0]),o[0]=o[0].add(a[0]),r=$i(r.add(i).add(a[0]).add(Tr(t,l+8)),37).mul(d),i=$i(i.add(a[1]).add(Tr(t,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),i=i.add(a[0].mul(9).add(Tr(t,l+40))),s=$i(s.add(o[0]),33).mul(d),a=gA(t,l,a[1].mul(d),r.add(o[0])),o=gA(t,l+32,s.add(o[1]),i.add(Tr(t,l+16))),[s,r]=[r,s],Sd(Sd(a[0],o[0],d).add(aF(i).mul(S7)).add(s),Sd(a[1],o[1],d).add(r),d)}function Cbe(t,e){return e==="string"?Tw(t):yC([t],e)}function Mbe(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function yC(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=Rd(t)),Ie().getBool("DEBUG")&&c7(t,e),Mbe(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){let n=new Uint8Array(t.length);for(let r=0;r<n.length;++r)Math.round(t[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${e}`)}function g1(){return Ie().platform.now()}function kbe(t,e){return Ie().platform.fetch(t,e)}function Tw(t,e="utf-8"){return e=e||"utf-8",Ie().platform.encode(t,e)}function kI(t,e="utf-8"){return e=e||"utf-8",Ie().platform.decode(t,e)}function zi(t){return Ie().platform.isTypedArray!=null?Ie().platform.isTypedArray(t):_7(t)}function Rd(t,e=[],n=!1){if(e==null&&(e=[]),typeof t=="boolean"||typeof t=="number"||typeof t=="string"||rC(t)||t==null||zi(t)&&n)e.push(t);else if(Array.isArray(t)||zi(t))for(let r=0;r<t.length;++r)Rd(t[r],e,n);else{let r=-1;for(let i of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(i)&&(r=Math.max(r,Number(i)));for(let i=0;i<=r;i++)Rd(t[i],e,n)}return e}var Nbe=class{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new Fbe)}profileKernel(t,e,n){let r,i=()=>{r=n()},s,a=g1();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(i);else{i();for(let o of r)o.dataSync();s=Promise.resolve({kernelMs:g1()-a})}if(Ie().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let l=r[o];l.data().then(u=>{Rbe(u,l.dtype,t)})}return{kernelName:t,outputs:r,inputs:e,timeMs:s.then(o=>o.kernelMs),extraInfo:s.then(o=>o.getExtraProfileInfo!=null?o.getExtraProfileInfo():"")}}logKernelProfile(t){let{kernelName:e,outputs:n,timeMs:r,inputs:i,extraInfo:s}=t;n.forEach(a=>{Promise.all([a.data(),r,s]).then(o=>{this.logger.logKernelProfile(e,a,o[0],o[1],i,o[2])})})}};function Rbe(t,e,n){if(e!=="float32")return!1;for(let r=0;r<t.length;r++){let i=t[r];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${n}'`),!0}return!1}var Fbe=class{logKernelProfile(t,e,n,r,i,s){let a=typeof r=="number"?Mb(`${r}ms`,9):r.error,o=Mb(t,25),l=e.rank,u=e.size,c=Mb(e.shape.toString(),14),d="";for(let h in i){let p=i[h];if(p!=null){let f=p.shape||e.shape,g=f.length;d+=`${h}: ${g}D ${g>0?f:""} `}}console.log(`%c${o}	%c${a}	%c${l}D ${c}	%c${u}	%c${d}	%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function Dbe(t,e,n){let r={},i={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){let u=t[l],c=u.inputs;for(let d in c){let h=c[d],p=!1;for(let f=0;f<e.length;f++)if(r[h.id]){u.outputs.forEach(g=>r[g.id]=!0),p=!0,i[u.id]=!0;break}if(p)break}}let s={};s[n.id]=!0;let a={};for(let l=t.length-1;l>=0;l--){let u=t[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(s[u.outputs[d].id]){for(let h in c)s[c[h].id]=!0,a[u.id]=!0;break}}let o=[];for(let l=0;l<t.length;l++){let u=t[l];if(i[u.id]&&a[u.id]){let c={};for(let h in u.inputs){let p=u.inputs[h];r[p.id]&&(c[h]=p)}let d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,o.push(d)}}return o}function Pbe(t,e,n,r){for(let i=e.length-1;i>=0;i--){let s=e[i],a=[];if(s.outputs.forEach(l=>{let u=t[l.id];u!=null?a.push(u):a.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(a);for(let l in s.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);let u=n(()=>o[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);let c=s.inputs[l];if(!pc(u.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(t[c.id]==null)t[c.id]=u;else{let d=t[c.id];t[c.id]=r(d,u),d.dispose()}}}}var VW=20,Ux=3,vN=7;function Lbe(t,e,n,r){let i=v0(e),s=Obe(t,e,n,i),a=e.length,o=YA(t,e,n,i,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${a}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(o.map(u=>"    "+u).join(`
`)),l.join(`
`)}function Obe(t,e,n,r){let i=fr(e),s=r[r.length-1],a=new Array(s).fill(0),o=e.length,l=n==="complex64"?eb(t):t;if(o>1)for(let u=0;u<i/s;u++){let c=u*s;for(let d=0;d<s;d++)a[d]=Math.max(a[d],Qx(l[c+d],0,n).length)}return a}function Qx(t,e,n){let r;return Array.isArray(t)?r=`${parseFloat(t[0].toFixed(vN))} + ${parseFloat(t[1].toFixed(vN))}j`:ud(t)?r=`'${t}'`:n==="bool"?r=E7(t):r=parseFloat(t.toFixed(vN)).toString(),Mb(r,e)}function E7(t){return t===0?"false":"true"}function YA(t,e,n,r,i,s=!0){let a=n==="complex64"?2:1,o=e[0],l=e.length;if(l===0){if(n==="complex64"){let g=eb(t);return[Qx(g[0],0,n)]}return n==="bool"?[E7(t[0])]:[t[0].toString()]}if(l===1){if(o>VW){let g=Ux*a,y=Array.from(t.slice(0,g)),m=Array.from(t.slice((o-Ux)*a,o*a));return n==="complex64"&&(y=eb(y),m=eb(m)),["["+y.map((b,w)=>Qx(b,i[w],n)).join(", ")+", ..., "+m.map((b,w)=>Qx(b,i[o-Ux+w],n)).join(", ")+"]"]}return["["+(n==="complex64"?eb(t):Array.from(t)).map((g,y)=>Qx(g,i[y],n)).join(", ")+"]"]}let u=e.slice(1),c=r.slice(1),d=r[0]*a,h=[];if(o>VW){for(let g=0;g<Ux;g++){let y=g*d,m=y+d;h.push(...YA(t.slice(y,m),u,n,c,i,!1))}h.push("...");for(let g=o-Ux;g<o;g++){let y=g*d,m=y+d;h.push(...YA(t.slice(y,m),u,n,c,i,g===o-1))}}else for(let g=0;g<o;g++){let y=g*d,m=y+d;h.push(...YA(t.slice(y,m),u,n,c,i,g===o-1))}let p=l===2?",":"";h[0]="["+(o>0?h[0]+p:"");for(let g=1;g<h.length-1;g++)h[g]=" "+h[g]+p;let f=`,
`;for(let g=2;g<l;g++)f+=`
`;return h[h.length-1]=" "+h[h.length-1]+"]"+(s?"":f),h}function eb(t){let e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}var vi=class{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=fr(t),n!=null){let r=n.length;ee(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||T3(e,this.size),this.strides=v0(t)}set(t,...e){e.length===0&&(e=[0]),ee(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);let n=this.locToIndex(e);this.values[n]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(let r of t){if(r<0||r>=this.shape[e]){let i=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(i)}e++}let n=t[t.length-1];for(let r=0;r<t.length-1;++r)n+=this.strides[r]*t[r];return this.values[n]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];let e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return pl().makeTensor(this.values,this.shape,this.dtype)}},pl=null,Vg=null;function Bbe(t){pl=t}function Ube(t){Vg=t}var In=class{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=fr(t),this.strides=v0(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let t=await this.data();return Vg.buffer(this.shape,this.dtype,t)}bufferSync(){return Vg.buffer(this.shape,this.dtype,this.dataSync())}async array(){let t=await this.data();return wy(this.shape,t,this.dtype==="complex64")}arraySync(){return wy(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let t=pl().read(this.dataId);if(this.dtype==="string"){let e=await t;try{return e.map(n=>kI(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),pl().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();let t=pl().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>kI(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();let t=await pl().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),pl().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Vg.print(this,t)}clone(){return this.throwIfDisposed(),Vg.clone(this)}toString(t=!1){let e=this.dataSync();return Lbe(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Vg.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),pl().makeVariable(this,t,e,n)}};Object.defineProperty(In,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function Ge(){return k3("Tensor",()=>In)}Ge();var Jp=class extends In{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!pc(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);pl().disposeTensor(this),this.dataId=t.dataId,pl().incRef(this,null)}dispose(){pl().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Jp,Symbol.hasInstance,{value:t=>t instanceof In&&t.assign!=null&&t.assign instanceof Function});var vl={};wn(vl,{assertTypesMatch:()=>C7,getTensorsInContainer:()=>R3,isTensorInList:()=>zbe,makeTypesMatch:()=>qr});var oF;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(oF||(oF={}));var lF;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(lF||(lF={}));var uF;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(uF||(uF={}));var cF;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(cF||(cF={}));var dF;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(dF||(dF={}));var $be={float32:cF,int32:lF,bool:uF,complex64:dF};function uo(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return $be[t][e]}function vC(t){return uo(t,"int32")}function I7(t){return t!=null&&typeof t=="object"&&"texture"in t&&t.texture instanceof WebGLTexture}function T7(t){return typeof GPUBuffer<"u"&&t!=null&&typeof t=="object"&&"buffer"in t&&t.buffer instanceof GPUBuffer}function qr(t,e){if(t.dtype===e.dtype)return[t,e];let n=uo(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function C7(t,e){ee(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function zbe(t,e){return e.some(n=>n.id===t.id)}function R3(t){let e=[];return M7(t,e,new Set),e}function M7(t,e,n){if(t==null)return;if(t instanceof In){e.push(t);return}if(!Gbe(t))return;let r=t;for(let i in r){let s=r[i];n.has(s)||(n.add(s),M7(s,e,n))}}function Gbe(t){return Array.isArray(t)||typeof t=="object"}function xN(t){return t.kernelName!=null}var jW=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(let t in this.registeredVariables)this.registeredVariables[t].dispose()}},F3=class hF{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new jW}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let n=0;n<e.length;n++){let r=e[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,r=1){return e in this.registryFactory?(rd(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:n,asyncInit:r}=this.initializeBackend(e);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Nbe(this.backendInstance),!0}setupRegisteredKernels(){MI(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){MI(e).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[e])})}initializeBackend(e){let n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let r=n.factory();if(r&&!(r instanceof nw)&&typeof r.then=="function"){let i=++this.pendingBackendInitId,s=r.then(a=>i<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,rd(`Initialization of backend ${e} failed`),rd(a.stack||a.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return rd(`Initialization of backend ${e} failed`),rd(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let n=0;n<e.length;n++){let r=e[n],{success:i,asyncInit:s}=this.initializeBackend(r);if(s||i)return{name:r,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){let r=this.state.tensorInfo.get(n),i=r.backend,s=this.readSync(n),a=i.refCount(n);i.disposeData(n,!0),r.backend=e,e.move(n,s,r.shape,r.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let r=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let i;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(i),()=>(i=n(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,n,r){e();try{let i=r();return n(),i}catch(i){throw n(),i}}nextTensorId(){return hF.nextTensorId++}nextVariableId(){return hF.nextVariableId++}clone(e){let n=ue.runKernel(tm,{x:e}),r={x:e},i=a=>({x:()=>{let o="float32",l={x:a},u={dtype:o};return ue.runKernel(Lf,l,u)}}),s=[];return this.addTapeNode(this.state.activeScope.name,r,[n],i,s,{}),n}runKernel(e,n,r){if(this.backendName==null&&this.backend,m1(e,this.backendName)==null)throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,r){let i=this.backend.numDataIds(),s=0;r.forEach(l=>{s+=l.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=i-n-s-a;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let n,r=[],i=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l,u=xN(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(xN(e)){let{kernelName:f,inputs:g,attrs:y}=e;this.backendName==null&&this.backend;let m=m1(f,this.backendName);ee(m!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),o=()=>{let b=this.backend.numDataIds();l=m.kernelFunc({inputs:g,attrs:y,backend:this.backend});let w=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,b,w);let _=w.map(S=>S.rank!=null?S:this.makeTensorFromTensorInfo(S));if(i){let S=this.getTensorsForGradient(f,g,_);r=this.saveTensorsForBackwardMode(S)}return _}}else{let{forwardFunc:f}=e,g=y=>{i&&(r=y.map(m=>this.keep(this.clone(m))))};o=()=>{let y=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,g));let m=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,y,m),m}}let{inputs:c,attrs:d}=e,h=xN(e)?null:e.backwardsFunc,p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(p=this.profiler.profileKernel(u,c,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),n=p.outputs)}),i&&this.addTapeNode(u,c,n,h,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(f=>c[f]!=null?c[f].shape:null),outputShapes:n.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(e,n,r){let i=sF(e);if(i!=null){let s=i.inputsToSave||[],a=i.outputsToSave||[],o;i.saveAllInputs?(ee(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(u=>n[u])):o=s.map(u=>n[u]);let l=r.filter((u,c)=>a[c]);return o.concat(l)}return[]}makeTensor(e,n,r,i){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",i=i||this.backend;let s=e;r==="string"&&ud(e[0])&&(s=e.map(l=>Tw(l)));let a=i.write(s,n,r),o=new In(n,r,a,this.nextTensorId());if(this.trackTensor(o,i),r==="string"){let l=this.state.tensorInfo.get(a),u=h7(s);this.state.numBytes+=u-l.bytes,l.bytes=u}return o}makeTensorFromDataId(e,n,r,i){r=r||"float32";let s={dataId:e,shape:n,dtype:r};return this.makeTensorFromTensorInfo(s,i)}makeTensorFromTensorInfo(e,n){let{dataId:r,shape:i,dtype:s}=e,a=new In(i,s,r,this.nextTensorId());return this.trackTensor(a,n),a}makeVariable(e,n=!0,r,i){r=r||this.nextVariableId().toString(),i!=null&&i!==e.dtype&&(e=e.cast(i));let s=new Jp(e,n,r,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*II(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof Jp||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){let r=e.size*II(e.dtype);this.state.numBytes-=r}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(let i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,r,i,s,a){let o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:r,saved:s},l=sF(e);l!=null&&(i=l.gradFunc),i!=null&&(o.gradient=u=>(u=u.map((c,d)=>{if(c==null){let h=r[d],p=nC(h.size,h.dtype);return this.makeTensor(p,h.shape,h.dtype)}return c}),i(u.length>1?u:u[0],s,a))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){let n=R3(e),r=new Set(n.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let a=this.state.activeScope.track[s];!a.kept&&!r.has(a.id)&&a.dispose()}let i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(s=>{!s.kept&&s.scopeId===i.id&&this.track(s)})}gradients(e,n,r,i=!1){if(ee(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));ee(s instanceof In,()=>"The result y returned by f() must be a tensor.");let a=Dbe(this.state.activeTape,n,s);if(!i&&a.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let o={};o[s.id]=r??Hbe(s.shape),Pbe(o,a,u=>this.tidy(u),Wbe);let l=n.map(u=>o[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(let c of u.saved)c.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(e){return ee(Nd(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{ee(n.every(o=>o instanceof In),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r,i={};n.forEach((o,l)=>{i[l]=o});let s=(o,l)=>(r=e(...n,l),ee(r.value instanceof In,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),ee(Nd(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),a=(o,l)=>{let u=r.gradFunc(o,l),c=Array.isArray(u)?u:[u];ee(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),ee(c.every(h=>h instanceof In),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let d={};return c.forEach((h,p)=>{d[p]=()=>h}),d};return this.runKernelFunc({forwardFunc:s,backwardsFunc:a,inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){let n=g1(),r=await this.backend.time(e);return r.wallMs=g1()-n,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new jW;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};F3.nextTensorId=0;F3.nextVariableId=0;function Hbe(t){let e=C3(fr(t),"float32");return ue.makeTensor(e,t,"float32")}function k7(){let t=y7();if(t._tfengine==null){let e=new g7(t);t._tfengine=new F3(e)}return pbe(t._tfengine.ENV),Bbe(()=>t._tfengine),t._tfengine}var ue=k7();function Wbe(t,e){let n={a:t,b:e};return ue.runKernel(th,n)}var Cw={};wn(Cw,{isBrowser:()=>N7,isMobile:()=>Xbe,mockIsMobile:()=>jbe});function Vbe(){return typeof navigator<"u"&&navigator!=null}var pF;function jbe(t){pF=t}function Xbe(t){if(pF!==void 0)return pF;if(t||Vbe()){if(t||(t=navigator),t.product==="ReactNative")return!0;let e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){let n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function N7(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var ca=Ie();ca.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ca.registerFlag("IS_BROWSER",()=>N7());ca.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ca.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ca.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));ca.registerFlag("PROD",()=>!1);ca.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ca.getBool("DEBUG"));ca.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ca.registerFlag("IS_TEST",()=>!1);ca.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>ca.getBool("DEBUG"));ca.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ca.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ca.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function hu(t,e){let n=t;if(zi(t))return e==="string"?[]:[t.length];if(I7(t)){let i=t.channels||"RGBA";return[t.height,t.width*i.length]}else if(T7(t))return[t.buffer.size/(e==null?4:II(e))];if(!Array.isArray(t))return[];let r=[];for(;Array.isArray(n)||zi(n)&&e!=="string";)r.push(n.length),n=n[0];return Array.isArray(t)&&Ie().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&R7(t,r,[]),r}function R7(t,e,n){if(n=n||[],!Array.isArray(t)&&!zi(t)){ee(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}ee(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),ee(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);let r=e.slice(1);for(let i=0;i<t.length;++i)R7(t[i],r,n.concat(i))}function XW(t,e,n,r){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function q(t,e,n,r="numeric"){if(t instanceof Ge())return XW(r,t.dtype,e,n),t;let i=rw(t);if(i!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(i=r),XW(r,i,e,n),t==null||!zi(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){let o=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}let s=hu(t,i);!zi(t)&&!Array.isArray(t)&&(t=[t]);let a=i!=="string"?yC(t,i):Rd(t,[],!0);return ue.makeTensor(a,s,i)}function y1(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((i,s)=>q(i,`${e}[${s}]`,n,r))}var D3="__op";function ce(t){let e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0],r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+D3;let i=(...s)=>{ue.startScope(n);try{let a=r(...s);return rC(a)&&console.error("Cannot return a Promise inside of tidy."),ue.endScope(a),a}catch(a){throw ue.endScope(null),a}};return Object.defineProperty(i,"name",{value:n,configurable:!0}),i}function Kbe(t,e){let n=q(t,"real","complex"),r=q(e,"imag","complex");Vs(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let i={real:n,imag:r};return ue.runKernel(iC,i)}var cc=ce({complex_:Kbe});function sh(t,e,n,r){if(r==null)r=rw(t);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(T7(t)||I7(t)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return ue.backend.createTensorFromGPUData(t,e||n,r)}if(!zi(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Ha(e);let i=fr(e),s=fr(n);ee(i===s,()=>`Based on the provided shape, [${e}], the tensor should have ${i} values but has ${s}`);for(let a=0;a<n.length;++a){let o=n[a],l=a===n.length-1?o!==fr(e.slice(a)):!0;ee(n[a]===e[a]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!zi(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=r!=="string"?yC(t,r):Rd(t,[],!0),ue.makeTensor(t,e,r)}function Us(t,e,n){let r=hu(t,n);return sh(t,e,r,n)}var Yp={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},fc=class F7{static join(e){return new F7(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>zi(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let n=0;for(let r=0;r<e.length;r++){let i=e[r];r!==e.length-1&&i.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=n+i.byteLength;this.shards.push({buffer:i,start:n,end:s}),n=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,n=isNaN(Number(n))?0:n,e=Math.max(0,e),n=Math.min(this.byteLength,n),n<=e)return new ArrayBuffer(0);let r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);let i=n-e,s=new ArrayBuffer(i),a=new Uint8Array(s),o=0;for(let l=r;l<this.shards.length;l++){let u=this.shards[l],c=e+o-u.start,d=o,h=Math.min(n,u.end)-u.start,p=new Uint8Array(u.buffer,c,h-c);if(a.set(p,d),o+=p.length,n<u.end)break}return s}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function n(i){return e<i.start?-1:e>=i.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let r=qbe(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}};function qbe(t,e){let n=0,r=t.length;for(;n<=r;){let i=Math.floor((r-n)/2)+n,s=e(t[i]);if(s===0)return i;s<0?r=i:n=i+1}return-1}function Jbe(){Ie().set("PROD",!0)}function Ybe(){Ie().set("DEBUG",!0)}function Zbe(){Ie().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function D7(t){Ie().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Qbe(){ue.disposeVariables()}function No(){return ue}function fF(){return ue.memory()}function e1e(t){return ue.profile(t)}function xe(t,e){return ue.tidy(t,e)}function bn(t){R3(t).forEach(e=>e.dispose())}function Ci(t){return ue.keep(t)}function t1e(t){return ue.time(t)}function n1e(t){return ue.setBackend(t)}function r1e(){return ue.ready()}function P7(){return ue.backendName}function i1e(t){ue.removeBackend(t)}function s1e(t){return ue.findBackend(t)}function a1e(t){return ue.findBackendFactory(t)}function xC(t,e,n=1){return ue.registerBackend(t,e,n)}function P3(){return ue.backend}function o1e(t,e){Ie().setPlatform(t,e)}var Fd=4;async function l1e(t,e){let n=[],r=[],i=Array.isArray(t)?t.map(a=>a.name):Object.keys(t);for(let a=0;a<i.length;++a){let o=i[a],l=Array.isArray(t)?t[a].tensor:t[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);let u={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let c=new Promise(async d=>{let h=await l.bytes(),p=h.reduce((y,m)=>y+m.length,0)+Fd*h.length,f=new Uint8Array(p),g=0;for(let y=0;y<h.length;y++){let m=h[y],b=new Uint8Array(new Uint32Array([m.length]).buffer);f.set(b,g),g+=Fd,f.set(m,g),g+=m.length}d(f)});r.push(c)}else r.push(l.data());e!=null&&(u.group=e),n.push(u)}let s=await Promise.all(r);return{data:d1e(s),specs:n}}function L7(t,e){let n=new fc(t),r={},i=0;for(let s of e){let a=u1e(s,(o,l)=>n.slice(i+o,i+l));r[s.name]=O7(s,n.slice(i,i+a)),i+=a}return r}function u1e(t,e){let n=fr(t.shape),r;if("quantization"in t){let i=t.quantization;r=Yp[i.dtype]}else if(t.dtype==="string"){let i=0;for(let s=0;s<n;s++)i+=Fd+new Uint32Array(e(i,i+Fd))[0];return i}else r=Yp[t.dtype];return n*r}async function c1e(t,e){let n=fr(t.shape),r;if("quantization"in t){let i=t.quantization;r=Yp[i.dtype]}else if(t.dtype==="string"){let i=0;for(let s=0;s<n;s++)i+=Fd+new Uint32Array(await e(i,i+Fd))[0];return i}else r=Yp[t.dtype];return n*r}function O7(t,e){let n=t.name,r=t.dtype,i=t.shape,s=fr(i),a,o=0;if("quantization"in t){let l=t.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${t.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${t.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${t.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let u=Yp[l.dtype],c=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(r==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){a=new Float32Array(c.length);for(let d=0;d<c.length;d++){let h=c[d];a[d]=h*l.scale+l.min}}else if(l.dtype==="float16")a=v1e()(c);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(r==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);a=new Int32Array(c.length);for(let d=0;d<c.length;d++){let h=c[d];a[d]=Math.round(h*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=s*u}else if(r==="string"){let l=fr(t.shape);a=[];for(let u=0;u<l;u++){let c=new Uint32Array(e.slice(o,o+Fd))[0];o+=Fd;let d=new Uint8Array(e.slice(o,o+c));a.push(d),o+=c}}else{let l=Yp[r];if(r==="float32")a=new Float32Array(e);else if(r==="int32")a=new Int32Array(e);else if(r==="bool")a=new Uint8Array(e);else if(r==="complex64"){a=new Float32Array(e);let u=new Float32Array(a.length/2),c=new Float32Array(a.length/2);for(let f=0;f<u.length;f++)u[f]=a[f*2],c[f]=a[f*2+1];let d=Us(u,i,"float32"),h=Us(c,i,"float32"),p=cc(d,h);return d.dispose(),h.dispose(),p}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=s*l}return Us(a,i,r)}async function KW(t,e,n){let r=new Uint8Array(e);for(;r.byteLength<n;){let{done:i,value:s}=await t.read();if(i&&s==null){let o=n-r.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}let a=new Uint8Array(r.length+s.byteLength);a.set(r,0),a.set(new Uint8Array(s),r.length),r=a}return r.buffer}async function B7(t,e){let n={},r=t.getReader(),i=new ArrayBuffer(0);for(let s of e){let a=await c1e(s,async(u,c)=>(i=await KW(r,i,c),i.slice(u,c)));i=await KW(r,i,a);let o=i.slice(0,a);i=i.slice(a);let l=O7(s,o);if(n[s.name]=l,P7()==="webgpu"){let u=P3();"uploadToGPU"in u&&fr(l.shape)>=Ie().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return n}function d1e(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0,n=[];t.forEach(s=>{if(e+=s.byteLength,n.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let r=new Uint8Array(e),i=0;return n.forEach(s=>{r.set(new Uint8Array(s.buffer),i),i+=s.byteLength}),r.buffer}var L3=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function qW(t){return L3?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function h1e(t){if(L3)return Buffer.from(t).toString("base64");let e=new Uint8Array(t),n="";for(let r=0,i=e.length;r<i;r++)n+=String.fromCharCode(e[r]);return btoa(n)}function p1e(t){if(L3){let r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}function f1e(t){return fc.join(t)}function JW(t){let e="/";for(t=t.trim();t.endsWith(e);)t=t.slice(0,t.length-1);let n=t.split(e);return n[n.length-1]}function U7(t,e){let n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(n.initializerSignature=t.initializerSignature),t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),n}function $7(t,e,n){let r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(r.trainingConfig=t.trainingConfig),t.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=n}return t.signature!=null&&(r.signature=t.signature),t.userDefinedMetadata!=null&&(r.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(r.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(r.initializerSignature=t.initializerSignature),r}async function O3(t,e){let n,r;return t.weightsManifest!=null&&([n,r]=await e(t.weightsManifest)),$7(t,n,r)}function Mw(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:qW(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:qW(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:new fc(t.weightData).byteLength}}function mF(t){let e=[];for(let n of t)e.push(...n.weights);return e}function m1e(){let t=n=>{let r=n<<13,i=0;for(;!(r&8388608);)i-=8388608,r<<=1;return r&=-8388609,i+=947912704,r|i},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}function g1e(){let t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}function y1e(){let t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}function v1e(){let t=m1e(),e=g1e(),n=y1e();return r=>{let i=new ArrayBuffer(4*r.length),s=new Uint32Array(i);for(let a=0;a<r.length;a++){let o=r[a],l=t[n[o>>10]+(o&1023)]+e[o>>10];s[a]=l}return new Float32Array(i)}}var co=class al{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return al.instance==null&&(al.instance=new al),al.instance}static registerSaveRouter(e){al.getInstance().saveRouters.push(e)}static registerLoadRouter(e){al.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return al.getHandlers(e,"save")}static getLoadHandlers(e,n){return al.getHandlers(e,"load",n)}static getHandlers(e,n,r){let i=[];return(n==="load"?al.getInstance().loadRouters:al.getInstance().saveRouters).forEach(s=>{let a=s(e,r);a!==null&&i.push(a)}),i}},x1e=t=>co.registerSaveRouter(t),b1e=t=>co.registerLoadRouter(t),w1e=t=>co.getSaveHandlers(t),_1e=(t,e)=>co.getLoadHandlers(t,e),gF="tensorflowjs",yF=1,xp="models_store",cd="model_info_store";function z7(){if(!Ie().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function vF(t){let e=t.result;e.createObjectStore(xp,{keyPath:"modelPath"}),e.createObjectStore(cd,{keyPath:"modelPath"})}var Zp=class{constructor(t){if(this.indexedDB=z7(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((n,r)=>{let i=this.indexedDB.open(gF,yF);i.onupgradeneeded=()=>vF(i),i.onsuccess=()=>{let s=i.result;if(e==null){let a=s.transaction(xp,"readonly"),o=a.objectStore(xp).get(this.modelPath);o.onsuccess=()=>{if(o.result==null)return s.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(o.result.modelArtifacts)},o.onerror=l=>(s.close(),r(o.error)),a.oncomplete=()=>s.close()}else{e.weightData=fc.join(e.weightData);let a=Mw(e),o=s.transaction(cd,"readwrite"),l=o.objectStore(cd),u;try{u=l.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(d){return r(d)}let c;u.onsuccess=()=>{c=s.transaction(xp,"readwrite");let d=c.objectStore(xp),h;try{h=d.put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:a})}catch(p){return r(p)}h.onsuccess=()=>n({modelArtifactsInfo:a}),h.onerror=p=>{l=o.objectStore(cd);let f=l.delete(this.modelPath);f.onsuccess=()=>(s.close(),r(h.error)),f.onerror=g=>(s.close(),r(h.error))}},u.onerror=d=>(s.close(),r(u.error)),o.oncomplete=()=>{c==null?s.close():c.oncomplete=()=>s.close()}}},i.onerror=s=>r(i.error)})}};Zp.URL_SCHEME="indexeddb://";var G7=t=>Ie().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Zp.URL_SCHEME)?S1e(t.slice(Zp.URL_SCHEME.length)):null;co.registerSaveRouter(G7);co.registerLoadRouter(G7);function S1e(t){return new Zp(t)}function A1e(t){return t.startsWith(Zp.URL_SCHEME)?t.slice(Zp.URL_SCHEME.length):t}var E1e=class{constructor(){this.indexedDB=z7()}async listModels(){return new Promise((t,e)=>{let n=this.indexedDB.open(gF,yF);n.onupgradeneeded=()=>vF(n),n.onsuccess=()=>{let r=n.result,i=r.transaction(cd,"readonly"),s=i.objectStore(cd).getAll();s.onsuccess=()=>{let a={};for(let o of s.result)a[o.modelPath]=o.modelArtifactsInfo;t(a)},s.onerror=a=>(r.close(),e(s.error)),i.oncomplete=()=>r.close()},n.onerror=r=>e(n.error)})}async removeModel(t){return t=A1e(t),new Promise((e,n)=>{let r=this.indexedDB.open(gF,yF);r.onupgradeneeded=()=>vF(r),r.onsuccess=()=>{let i=r.result,s=i.transaction(cd,"readwrite"),a=s.objectStore(cd),o=a.get(t),l;o.onsuccess=()=>{if(o.result==null)return i.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{let u=a.delete(t),c=()=>{l=i.transaction(xp,"readwrite");let d=l.objectStore(xp).delete(t);d.onsuccess=()=>e(o.result.modelArtifactsInfo),d.onerror=h=>n(o.error)};u.onsuccess=c,u.onerror=d=>(c(),i.close(),n(o.error))}},o.onerror=u=>(i.close(),n(o.error)),s.oncomplete=()=>{l==null?i.close():l.oncomplete=()=>i.close()}},r.onerror=i=>n(r.error)})}},Hu="/",jg="tensorflowjs_models",H7="info",I1e="model_topology",T1e="weight_specs",C1e="weight_data",M1e="model_metadata";function W7(t){return{info:[jg,t,H7].join(Hu),topology:[jg,t,I1e].join(Hu),weightSpecs:[jg,t,T1e].join(Hu),weightData:[jg,t,C1e].join(Hu),modelMetadata:[jg,t,M1e].join(Hu)}}function V7(t){for(let e of Object.values(t))window.localStorage.removeItem(e)}function k1e(t){let e=t.split(Hu);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(Hu)}function N1e(t){return t.startsWith(Qp.URL_SCHEME)?t.slice(Qp.URL_SCHEME.length):t}var Qp=class{constructor(t){if(!Ie().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=W7(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=Mw(t),i=fc.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,h1e(i));let s={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch{throw V7(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;let i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){let a=JSON.parse(i);e.format=a.format,e.generatedBy=a.generatedBy,e.convertedBy=a.convertedBy,a.signature!=null&&(e.signature=a.signature),a.userDefinedMetadata!=null&&(e.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(e.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(e.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(e.trainingConfig=a.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(s==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=p1e(s),e}};Qp.URL_SCHEME="localstorage://";var j7=t=>Ie().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Qp.URL_SCHEME)?R1e(t.slice(Qp.URL_SCHEME.length)):null;co.registerSaveRouter(j7);co.registerLoadRouter(j7);function R1e(t){return new Qp(t)}var F1e=class{constructor(){ee(Ie().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),ee(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let t={},e=jg+Hu,n=Hu+H7;for(let r=0;r<this.LS.length;++r){let i=this.LS.key(r);if(i.startsWith(e)&&i.endsWith(n)){let s=k1e(i);t[s]=JSON.parse(this.LS.getItem(i))}}return t}async removeModel(t){t=N1e(t);let e=W7(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);let n=JSON.parse(this.LS.getItem(e.info));return V7(e),n}},_y="://",Dd=class jc{constructor(){this.managers={}}static getInstance(){return jc.instance==null&&(jc.instance=new jc),jc.instance}static registerManager(e,n){ee(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(_y)&&(e=e.slice(0,e.indexOf(_y))),ee(e.length>0,()=>"scheme must not be an empty string.");let r=jc.getInstance();ee(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=n}static getManager(e){let n=jc.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(jc.getInstance().managers)}};function ZA(t){if(t.indexOf(_y)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Dd.getSchemes().join(",")}`);return{scheme:t.split(_y)[0],path:t.split(_y)[1]}}async function X7(t,e,n=!1){ee(t!==e,()=>`Old path and new path are the same: '${t}'`);let r=co.getLoadHandlers(t);ee(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),ee(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);let i=r[0],s=co.getSaveHandlers(e);ee(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),ee(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);let a=s[0],o=ZA(t).scheme,l=ZA(t).path,u=o===ZA(t).scheme,c=await i.load();n&&u&&await Dd.getManager(o).removeModel(l);let d=await a.save(c);return n&&!u&&await Dd.getManager(o).removeModel(l),d.modelArtifactsInfo}async function D1e(){let t=Dd.getSchemes(),e={};for(let n of t){let r=await Dd.getManager(n).listModels();for(let i in r){let s=n+_y+i;e[s]=r[i]}}return e}async function P1e(t){let e=ZA(t);return Dd.getManager(e.scheme).removeModel(e.path)}async function L1e(t,e){return X7(t,e,!1)}async function O1e(t,e){return X7(t,e,!0)}var B1e=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){if(typeof window>"u"||!Ie().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,e);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let r=this.functionRefs[n.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return _7(t)}};if(Ie().get("IS_BROWSER")){Ie().setPlatform("browser",new B1e);try{Dd.registerManager(Qp.URL_SCHEME,new F1e)}catch{}try{Dd.registerManager(Zp.URL_SCHEME,new E1e)}catch{}}var U1e={importFetch:()=>Rxe()},bN,$1e=class{constructor(){this.util=Fxe(),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return Ie().global.fetch!=null?Ie().global.fetch(t,e):(bN==null&&(bN=U1e.importFetch()),bN(t,e))}now(){let t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}};Ie().get("IS_NODE")&&!Ie().get("IS_BROWSER")&&Ie().setPlatform("node",new $1e);function Rn(t,e="float32",n){return e=e||"float32",Ha(t),new vi(t,e,n)}function z1e(t,e){let n=q(t,"x","cast");if(!d7(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:n},i={dtype:e};return ue.runKernel(Lf,r,i)}var ft=ce({cast_:z1e});function G1e(t){let e={x:q(t,"x","clone","string_or_numeric")};return ue.runKernel(tm,e)}var su=ce({clone_:G1e});function B3(t,e=!1){console.log(t.toString(e))}k7();var H1e={buffer:Rn,cast:ft,clone:su,print:B3};Ube(H1e);function W1e(t,e){let n=q(t,"a","add"),r=q(e,"b","add");[n,r]=qr(n,r);let i={a:n,b:r};return ue.runKernel(th,i)}var ze=ce({add_:W1e});function V1e(t,e){let n=q(t,"a","floorDiv"),r=q(e,"b","floorDiv");[n,r]=qr(n,r);let i={a:n,b:r};return ue.runKernel(Zf,i)}var bC=ce({floorDiv_:V1e});function j1e(t,e){let n=q(t,"a","div"),r=q(e,"b","div");if([n,r]=qr(n,r),n.dtype==="int32"&&r.dtype==="int32")return bC(n,r);let i={a:n,b:r},s={};return ue.runKernel(jf,i,s)}var zt=ce({div_:j1e});function X1e(t,e){let n=q(t,"a","mul"),r=q(e,"b","mul");[n,r]=qr(n,r);let i={a:n,b:r};return ue.runKernel(ym,i)}var fe=ce({mul_:X1e});function K1e(t){let e=q(t,"x","abs");if(e.dtype==="complex64"){let n={x:e};return ue.runKernel(ow,n)}else{let n={x:e};return ue.runKernel(x0,n)}}var fi=ce({abs_:K1e});function q1e(t){let e={x:q(t,"x","acos")};return ue.runKernel(If,e)}var U3=ce({acos_:q1e});function J1e(t){let e={x:q(t,"x","acosh")};return ue.runKernel(Tf,e)}var $3=ce({acosh_:J1e});function Y1e(t){ee(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),ee(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);let e=t.map((i,s)=>q(i,`tensors${s}`,"addN")),n=e[0];e.forEach(i=>{if(i.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(i=>{if(!pc(i.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=e;return ue.runKernel(Cf,r)}var K7=ce({addN_:Y1e});function Z1e(t,e=null,n=!1){let r={x:q(t,"x","all","bool")},i={axis:e,keepDims:n};return ue.runKernel(b0,r,i)}var wC=ce({all_:Z1e});function Q1e(t,e=null,n=!1){let r={x:q(t,"x","any","bool")},i={axis:e,keepDims:n};return ue.runKernel(w0,r,i)}var v1=ce({any_:Q1e});function ewe(t,e=0){let n={x:q(t,"x","argMax")},r={axis:e};return ue.runKernel(_0,n,r)}var ef=ce({argMax_:ewe});function twe(t,e=0){let n={x:q(t,"x","argMin")},r={axis:e};return ue.runKernel(S0,n,r)}var z3=ce({argMin_:twe});function nwe(t){let e={x:q(t,"x","asin")};return ue.runKernel(Mf,e)}var G3=ce({asin_:nwe});function rwe(t){let e={x:q(t,"x","asinh")};return ue.runKernel(kf,e)}var H3=ce({asinh_:rwe});function iwe(t){let e={x:q(t,"x","atan")};return ue.runKernel(Nf,e)}var W3=ce({atan_:iwe});function swe(t,e){let n=q(t,"a","atan2"),r=q(e,"b","atan2");[n,r]=qr(n,r);let i={a:n,b:r};return ue.runKernel(Ff,i)}var V3=ce({atan2_:swe});function awe(t){let e={x:q(t,"x","atanh")};return ue.runKernel(Rf,e)}var j3=ce({atanh_:awe});function owe(t,e,n,r,i="NHWC",s){let a=t[3],o=[...e,a],l=Y7(i);return kw(t,o,n,s,r,null,null,l)}function q7(t,e,n,r,i,s,a="channelsLast"){let[o,l]=x1(e),u;if(a==="channelsLast")u=[o,l,t[3],t[3]];else if(a==="channelsFirst")u=[o,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${a}`);return kw(t,u,n,r,i,s,!1,a)}function lwe(t,e,n,r,i,s,a="NDHWC"){let[o,l,u]=xF(e),c,d;if(a==="NDHWC")d="channelsLast",c=[o,l,u,t[4],t[4]];else if(a==="NCDHW")d="channelsFirst",c=[o,l,u,t[1],t[1]];else throw new Error(`Unknown dataFormat ${a}`);return J7(t,c,n,r,i,!1,d,s)}function kw(t,e,n,r,i,s,a=!1,o="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if(o==="channelsLast")[l,u,c,d]=t;else if(o==="channelsFirst")[l,d,u,c]=t;else throw new Error(`Unknown dataFormat ${o}`);let[h,p,,f]=e,[g,y]=x1(n),[m,b]=x1(r),w=Sy(h,m),_=Sy(p,b),{padInfo:S,outHeight:E,outWidth:C}=dwe(i,u,c,g,y,w,_,s,o),T=a?f*d:f,M;return o==="channelsFirst"?M=[l,T,E,C]:o==="channelsLast"&&(M=[l,E,C,T]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:d,outHeight:E,outWidth:C,outChannels:T,padInfo:S,strideHeight:g,strideWidth:y,filterHeight:h,filterWidth:p,effectiveFilterHeight:w,effectiveFilterWidth:_,dilationHeight:m,dilationWidth:b,inShape:t,outShape:M,filterShape:e}}function J7(t,e,n,r,i,s=!1,a="channelsLast",o){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,d,h]=t;else if(a==="channelsFirst")[l,h,u,c,d]=t;else throw new Error(`Unknown dataFormat ${a}`);let[p,f,g,,y]=e,[m,b,w]=xF(n),[_,S,E]=xF(r),C=Sy(p,_),T=Sy(f,S),M=Sy(g,E),{padInfo:k,outDepth:R,outHeight:N,outWidth:B}=hwe(i,u,c,d,m,b,w,C,T,M,o),z=s?y*h:y,V;return a==="channelsFirst"?V=[l,z,R,N,B]:a==="channelsLast"&&(V=[l,R,N,B,z]),{batchSize:l,dataFormat:a,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:R,outHeight:N,outWidth:B,outChannels:z,padInfo:k,strideDepth:m,strideHeight:b,strideWidth:w,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:C,effectiveFilterHeight:T,effectiveFilterWidth:M,dilationDepth:_,dilationHeight:S,dilationWidth:E,inShape:t,outShape:V,filterShape:e}}function uwe(t,e,n,r,i){r==null&&(r=X3(t,e,n));let s=t[0],a=t[1],o=b1((s-e+2*r)/n+1,i),l=b1((a-e+2*r)/n+1,i);return[o,l]}function cwe(t,e,n,r,i,s){i==null&&(i=X3(t,e[0],r[0]));let a=[0,0,0,n];for(let o=0;o<3;o++)t[o]+2*i>=e[o]&&(a[o]=b1((t[o]-e[o]+2*i)/r[o]+1,s));return a}function X3(t,e,n,r=1){let i=Sy(e,r);return Math.floor((t[0]*(n-1)-n+i)/2)}function x1(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function xF(t){return typeof t=="number"?[t,t,t]:t}function Sy(t,e){return e<=1?t:t+(t-1)*(e-1)}function dwe(t,e,n,r,i,s,a,o,l){let u,c,d;if(typeof t=="number"){u={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};let h=uwe([e,n],s,r,t,o);c=h[0],d=h[1]}else if(t==="same"){c=Math.ceil(e/r),d=Math.ceil(n/i);let h=Math.max(0,(c-1)*r+s-e),p=Math.max(0,(d-1)*i+a-n),f=Math.floor(h/2),g=h-f,y=Math.floor(p/2),m=p-y;u={top:f,bottom:g,left:y,right:m,type:"SAME"}}else if(t==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-s+1)/r),d=Math.ceil((n-a+1)/i);else if(typeof t=="object"){let h=l==="channelsLast"?t[1][0]:t[2][0],p=l==="channelsLast"?t[1][1]:t[2][1],f=l==="channelsLast"?t[2][0]:t[3][0],g=l==="channelsLast"?t[2][1]:t[3][1];u={top:h,bottom:p,left:f,right:g,type:h===0&&p===0&&f===0&&g===0?"VALID":"EXPLICIT"},c=b1((e-s+h+p)/r+1,o),d=b1((n-a+f+g)/i+1,o)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:u,outHeight:c,outWidth:d}}function hwe(t,e,n,r,i,s,a,o,l,u,c){let d,h,p,f;if(t==="valid"&&(t=0),typeof t=="number"){d={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};let g=cwe([e,n,r,1],[o,l,u],1,[i,s,a],t,c);h=g[0],p=g[1],f=g[2]}else if(t==="same"){h=Math.ceil(e/i),p=Math.ceil(n/s),f=Math.ceil(r/a);let g=(h-1)*i+o-e,y=(p-1)*s+l-n,m=(f-1)*a+u-r,b=Math.floor(g/2),w=g-b,_=Math.floor(y/2),S=y-_,E=Math.floor(m/2),C=m-E;d={top:_,bottom:S,left:E,right:C,front:b,back:w,type:"SAME"}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}function b1(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function Pd(t){let[e,n,r]=x1(t);return e===1&&n===1&&r===1}function vu(t,e){return Pd(t)||Pd(e)}function tf(t){return x1(t).every(e=>e>0)}function Y7(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function js(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")ee(Vy(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(i=>{ee(Vy(i),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${i}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}function pwe(t,e){let n={x:q(t,"x","reshape","string_or_numeric")},r={shape:e};return ue.runKernel(rv,n,r)}var ve=ce({reshape_:pwe});function fwe(t,e,n,r,i){let s=q(t,"x","avgPool","float32"),a=1;ee(vu(n,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);let o=s,l=!1;s.rank===3&&(l=!0,o=ve(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ee(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),js("avgPool",r,i);let u={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:i},d=ue.runKernel(Df,u,c);return d=ft(d,s.dtype),l?ve(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var mc=ce({avgPool_:fwe});function mwe(t,e,n,r,i,s="NDHWC"){let a=q(t,"x","avgPool3d","float32"),o=a,l=!1;a.rank===4&&(l=!0,o=ve(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),ee(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),ee(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),ee(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),js("avgPool3d",r,i);let u={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:i,dataFormat:s},d=ue.runKernel(A0,u,c);return d=ft(d,o.dtype),l?ve(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var K3=ce({avgPool3d_:mwe});function gwe(t,e=0){ee(t.length>=1,()=>"Pass at least one tensor to concat");let n=y1(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),n.length===1)return su(n[0]);let r=n,i={axis:e};return ue.runKernel(C0,r,i)}var wr=ce({concat_:gwe});function ywe(t,e,n=!1,r=!1){let i=q(t,"a","matMul"),s=q(e,"b","matMul");[i,s]=qr(i,s);let a={a:i,b:s},o={transposeA:n,transposeB:r};return ue.runKernel(Pf,a,o)}var kn=ce({matMul_:ywe});function vwe(t){let e={x:q(t,"x","sigmoid","float32")};return ue.runKernel(Pm,e)}var Uo=ce({sigmoid_:vwe});function xwe(t,e,n){let r=q(t,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let i={x:r},s={begin:e,size:n};return ue.runKernel(cv,i,s)}var Gn=ce({slice_:xwe});function bwe(t){let e={x:q(t,"x","tanh","float32")};return ue.runKernel(Hm,e)}var Ld=ce({tanh_:bwe});function wwe(t,e,n,r,i,s){let a=q(t,"forgetBias","basicLSTMCell"),o=q(e,"lstmKernel","basicLSTMCell"),l=q(n,"lstmBias","basicLSTMCell"),u=q(r,"data","basicLSTMCell"),c=q(i,"c","basicLSTMCell"),d=q(s,"h","basicLSTMCell"),h=wr([u,d],1),p=kn(h,o),f=ze(p,l),g=f.shape[0],y=f.shape[1]/4,m=[g,y],b=Gn(f,[0,0],m),w=Gn(f,[0,y],m),_=Gn(f,[0,y*2],m),S=Gn(f,[0,y*3],m),E=ze(fe(Uo(b),Ld(w)),fe(c,Uo(ze(a,_)))),C=fe(Ld(E),Uo(S));return[E,C]}var Z7=ce({basicLSTMCell_:wwe});function _we(t,e,n){let r=q(t,"x","batchToSpaceND"),i=e.reduce((o,l)=>o*l);ee(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),ee(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),ee(r.shape[0]%i===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${i}`);let s={x:r},a={blockShape:e,crops:n};return ue.runKernel(E0,s,a)}var Nw=ce({batchToSpaceND_:_we});function Swe(t){let e;return t.rank===0||t.rank===1?e=ve(t,[1,1,1,t.size]):t.rank===2?e=ve(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=ve(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}function Awe(t,e,n,r,i,s){s==null&&(s=.001);let a=q(t,"x","batchNorm"),o=q(e,"mean","batchNorm"),l=q(n,"variance","batchNorm"),u;i!=null&&(u=q(i,"scale","batchNorm"));let c;r!=null&&(c=q(r,"offset","batchNorm")),ee(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),ee(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),ee(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let d={x:Swe(a),scale:u,offset:c,mean:o,variance:l},h={varianceEpsilon:s},p=ue.runKernel(Qf,d,h);return ve(p,a.shape)}var Wm=ce({batchNorm_:Awe});function Ewe(t,e,n,r,i,s){let a=q(t,"x","batchNorm"),o=q(e,"mean","batchNorm"),l=q(n,"variance","batchNorm"),u;i!=null&&(u=q(i,"scale","batchNorm"));let c;return r!=null&&(c=q(r,"offset","batchNorm")),ee(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),ee(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),ee(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&ee(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&ee(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Wm(a,o,l,c,u,s)}var q3=ce({batchNorm2d_:Ewe});function Iwe(t,e,n,r,i,s){let a=q(t,"x","batchNorm"),o=q(e,"mean","batchNorm"),l=q(n,"variance","batchNorm"),u;i!=null&&(u=q(i,"scale","batchNorm"));let c;return r!=null&&(c=q(r,"offset","batchNorm")),ee(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),ee(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),ee(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&ee(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&ee(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Wm(a,o,l,c,u,s)}var J3=ce({batchNorm3d_:Iwe});function Twe(t,e,n,r,i,s){let a=q(t,"x","batchNorm"),o=q(e,"mean","batchNorm"),l=q(n,"variance","batchNorm"),u;i!=null&&(u=q(i,"scale","batchNorm"));let c;return r!=null&&(c=q(r,"offset","batchNorm")),ee(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),ee(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),ee(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&ee(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&ee(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Wm(a,o,l,c,u,s)}var Y3=ce({batchNorm4d_:Twe});function Cwe(t,e,n){let r=q(t,"x","bincount"),i=q(e,"weights","bincount");ee(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),ee(n>=0,()=>`size must be non-negative, but got ${n}.`),ee(i.size===r.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${i.shape}.`);let s={x:r,weights:i},a={size:n};return ue.runKernel(I0,s,a)}var Z3=ce({bincount_:Cwe});function Mwe(t,e){let n=q(t,"x","bitwiseAnd"),r=q(e,"y","bitwiseAnd");if(!pc(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if(n.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);let i={a:n,b:r};return ue.runKernel(T0,i)}var Q7=ce({bitwiseAnd_:Mwe});function kwe(t,e){let n=q(t,"s0","broadcastArgs","int32"),r=q(e,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let i={s0:n,s1:r};return ue.runKernel(aw,i)}var eK=ce({broadcastArgs_:kwe});function Nwe(t,e){let n=q(t,"broadcastTo","x"),r=n.shape;if(Ha(e),e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){let l=n.shape.slice();for(;l.length<e.length;)l.unshift(1);n=ve(n,l)}let i=n.shape,s=Array.from(e);for(let l=e.length-1;l>=0;l--)if(i[l]===e[l])s[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(s.map((l,u)=>l>1?u:-1).filter(l=>l>=0).length===0)return su(n);let a={x:n},o={reps:s};return ue.runKernel(rh,a,o)}var Mp=ce({broadcastTo_:Nwe});function Rwe(t){let e={x:q(t,"x","ceil","float32")};return ue.runKernel(Of,e)}var Q3=ce({ceil_:Rwe});function Pa(t,e,n){Ha(t),n=n||rw(e);let r={shape:t,value:e,dtype:n};return ue.runKernel(cw,{},r)}function Fwe(t,e,n){let r=q(t,"x","clipByValue");if(ee(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),e===n)return Pa(r.shape,e,r.dtype);let i={x:r},s={clipValueMin:e,clipValueMax:n};return ue.runKernel(nh,i,s)}var bs=ce({clipByValue_:Fwe});function Dwe(t){return wr(t,0)}var eL=ce({concat1d_:Dwe});function Pwe(t,e){return wr(t,e)}var tL=ce({concat2d_:Pwe});function Lwe(t,e){return wr(t,e)}var nL=ce({concat3d_:Lwe});function Owe(t,e){return wr(t,e)}var rL=ce({concat4d_:Owe});function Bwe(t,e,n,r,i="NHWC",s=[1,1],a){let o=q(t,"x","conv2d","float32"),l=q(e,"filter","conv2d","float32"),u=o,c=!1;o.rank===3&&(c=!0,u=ve(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ee(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),ee(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),js("conv2d",r,a);let d=i==="NHWC"?u.shape[3]:u.shape[1];ee(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),ee(vu(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),ee(tf(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),ee(tf(n),()=>"Error in conv2D: Strides should be larger than 0.");let h={x:u,filter:l},p={strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:a},f=ue.runKernel(Bf,h,p);return c?ve(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var zs=ce({conv2d_:Bwe});function Uwe(t,e,n,r,i="NWC",s=1,a){let o=q(t,"x","conv1d"),l=q(e,"filter","conv1d"),u=o,c=!1;o.rank===2&&(c=!0,u=ve(o,[1,o.shape[0],o.shape[1]])),ee(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),ee(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),js("conv1d",r,a),ee(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),ee(vu(n,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`),ee(tf(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),ee(tf(n),()=>"Error in conv1D: Stride should be larger than 0."),ee(i==="NWC",()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);let d=ve(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=ve(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=zs(h,d,[1,n],r,"NHWC",[1,s],a);return c?ve(p,[p.shape[2],p.shape[3]]):ve(p,[p.shape[0],p.shape[2],p.shape[3]])}var _C=ce({conv1d_:Uwe});function $we(t,e,n,r,i,s="NHWC",a){ee(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let o=t,l=e,u=!1;e.rank===3&&(u=!0,l=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,t[0],t[1],t[2]]),ee(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),ee(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),ee(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let c=s==="NHWC"?o[3]:o[1],d=s==="NHWC"?l.shape[3]:l.shape[1];ee(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),ee(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),js("conv2dDerInput",i,a);let h={dy:l,filter:n},p={strides:r,pad:i,dataFormat:s,dimRoundingMode:a,inputShape:o},f=ue.runKernel(Uf,h,p);return u?ve(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var iL=ce({conv2DBackpropInput_:$we});function zwe(t,e,n,r,i,s){let a=q(t,"x","conv2dTranspose"),o=q(e,"filter","conv2dTranspose");return iL(n,a,o,r,i,"NHWC",s)}var SC=ce({conv2dTranspose_:zwe});function Gwe(t,e,n,r,i="NDHWC",s=[1,1,1]){let a=q(t,"x","conv3d"),o=q(e,"filter","conv3d"),l=a,u=!1;a.rank===4&&(u=!0,l=ve(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),ee(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),ee(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),ee(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),ee(vu(n,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),ee(i==="NDHWC",()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),ee(tf(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),ee(tf(n),()=>"Error in conv3D: Strides should be larger than 0.");let c={x:l,filter:o},d={strides:n,pad:r,dataFormat:i,dilations:s},h=ue.runKernel($f,c,d);return u?ve(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var sL=ce({conv3d_:Gwe});function Hwe(t,e,n,r,i){ee(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let s=t,a=e,o=!1;e.rank===4&&(o=!0,a=ve(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,t[0],t[1],t[2],t[3]]);let l=s[4],u=a.shape[4];ee(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),ee(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),ee(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),ee(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),ee(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);let c={dy:a,filter:n},d={pad:i,strides:r,inputShape:s},h=ue.runKernel(k0,c,d);return o?ve(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var tK=ce({conv3DBackpropInput_:Hwe});function Wwe(t,e,n,r,i){let s=q(t,"x","conv3dTranspose"),a=q(e,"filter","conv3dTranspose");return tK(n,s,a,r,i)}var aL=ce({conv3dTranspose_:Wwe});function Vwe(t){let e={x:q(t,"x","cos","float32")};return ue.runKernel(zf,e)}var Rw=ce({cos_:Vwe});function jwe(t){let e={x:q(t,"x","cosh","float32")};return ue.runKernel(Gf,e)}var AC=ce({cosh_:jwe});function Xwe(t,e=0,n=!1,r=!1){let i={x:q(t,"x","cumprod")},s={axis:e,exclusive:n,reverse:r};return ue.runKernel(N0,i,s)}var w1=ce({cumprod_:Xwe});function Kwe(t,e=0,n=!1,r=!1){let i={x:q(t,"x","cumsum")},s={axis:e,exclusive:n,reverse:r};return ue.runKernel(Hf,i,s)}var EC=ce({cumsum_:Kwe});function qwe(t,e,n,r=!1){let i=q(t,"x","denseBincount"),s=q(e,"weights","denseBincount");ee(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),ee(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),ee(n>=0,()=>`size must be non-negative, but got ${n}.`),ee(s.size===i.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${s.shape}.`);let a={x:i,weights:s},o={size:n,binaryOutput:r};return ue.runKernel(lw,a,o)}var NI=ce({denseBincount_:qwe});function Jwe(t,e,n="NHWC"){let r=q(t,"x","depthToSpace","float32"),i=n==="NHWC"?r.shape[1]:r.shape[2],s=n==="NHWC"?r.shape[2]:r.shape[3],a=n==="NHWC"?r.shape[3]:r.shape[1];ee(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),ee(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e}  for depthToSpace with input shape
    ${r.shape}`),ee(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${r.shape}`),ee(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${r.shape}`);let o={x:r},l={blockSize:e,dataFormat:n};return ue.runKernel(F0,o,l)}var oL=ce({depthToSpace_:Jwe});function Ywe(t,e,n,r,i="NHWC",s=[1,1],a){let o=q(t,"x","depthwiseConv2d","float32"),l=q(e,"filter","depthwiseConv2d","float32"),u=o,c=!1;o.rank===3&&(c=!0,u=ve(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ee(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),ee(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let d=i==="NHWC"?u.shape[3]:u.shape[1];ee(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),js("depthwiseConv2d",r,a);let h={x:u,filter:l},p={strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:a},f=ue.runKernel(Wf,h,p);return c?ve(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Vm=ce({depthwiseConv2d_:Ywe});function Zwe(t){let e={x:q(t,"x","diag")};return ue.runKernel(uw,e)}var nK=ce({diag_:Zwe});function Qwe(t,e,n,r,i=[1,1],s="NHWC"){let a=q(t,"x","dilation2d"),o=q(e,"filter","dilation2d");ee(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),ee(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),ee(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=a,u=!1;a.rank===3&&(l=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=!0),ee(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);let c={x:l,filter:o},d={strides:n,pad:r,dilations:i},h=ue.runKernel(Vf,c,d);return u?ve(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var lL=ce({dilation2d_:Qwe}),wv={};wn(wv,{assertAndGetBroadcastShape:()=>_r,getBroadcastDims:()=>rK,getReductionAxes:()=>bi});function rK(t,e){let n=t.length,r=[];for(let i=0;i<n;i++){let s=n-1-i,a=t[s]||1;(e[e.length-1-i]||1)>1&&a===1&&r.unshift(s)}return r}function bi(t,e){let n=[];for(let r=0;r<e.length;r++){let i=t[t.length-r-1],s=e.length-r-1,a=e[s];(i==null||i===1&&a>1)&&n.unshift(s)}return n}function _r(t,e){let n=Math.max(t.length,e.length),r=new Array(n);for(let i=0;i<n;i++){let s=t[t.length-i-1];s==null&&(s=1);let a=e[e.length-i-1];if(a==null&&(a=1),s===1)r[n-i-1]=a;else if(a===1)r[n-i-1]=s;else if(s!==a){let o=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(o)}else r[n-i-1]=s}return r}function e_e(t,e){let n=q(t,"a","equal","string_or_numeric"),r=q(e,"b","equal","string_or_numeric");[n,r]=qr(n,r),_r(n.shape,r.shape);let i={a:n,b:r};return ue.runKernel(P0,i)}var Ua=ce({equal_:e_e});function t_e(t,e,n){let r=q(e,"a","where"),i=q(n,"b","where"),s=q(t,"condition","where","bool"),a=_r(_r(s.shape,r.shape),i.shape),o=Mp(s,a),l=Mp(r,a),u=Mp(i,a),c={condition:o,t:l,e:u};return ue.runKernel(uv,c)}var qi=ce({where_:t_e});function n_e(t){let e={x:q(t,"x","zerosLike")};return ue.runKernel(xv,e)}var Kn=ce({zerosLike_:n_e});function r_e(t,e){let n=q(t,"a","div"),r=q(e,"b","div");[n,r]=qr(n,r);let i=zt(n,r),s=Kn(i),a=Ua(r,s);return qi(a,s,i)}var uL=ce({divNoNan_:r_e});function i_e(t,e){let n=q(t,"t1","dot"),r=q(e,"t2","dot");ee((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let i=n.rank===1?n.size:n.shape[1],s=r.rank===1?r.size:r.shape[0];if(ee(i===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${s}.`),n.rank===1&&r.rank===1){let a=ve(n,[1,-1]),o=ve(r,[-1,1]),l=kn(a,o);return ve(l,[])}else if(n.rank===1&&r.rank===2){let a=ve(n,[1,-1]),o=ve(r,[r.shape[0],r.shape[1]]),l=kn(a,o);return ve(l,[l.size])}else if(n.rank===2&&r.rank===1){let a=ve(r,[-1,1]),o=kn(n,a);return ve(o,[o.size])}else{let a=ve(r,[r.shape[0],r.shape[1]]);return kn(n,a)}}var cL=ce({dot_:i_e});function s_e(t,...e){let n=e.map((i,s)=>q(i,`tensors${s}`,"einsum")),r={equation:t};return ue.runKernel(uC,n,r)}var ip=ce({einsum_:s_e});function a_e(t){let e={x:q(t,"x","elu","float32")};return ue.runKernel(Xf,e)}var _v=ce({elu_:a_e});function o_e(t,e){let n=q(t,"x","ensureShape","string_or_numeric");if(!o7(n.shape,e))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${e}`);return t}var iK=ce({ensureShape_:o_e});function l_e(t){let e=q(t,"x","erf");ee(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=ft(e,"float32"));let n={x:e};return ue.runKernel(Kf,n)}var IC=ce({erf_:l_e});function dL(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function sK(t,e,n){let r=t.length+e.length,i=[],s=0,a=0;for(let o=0;o<r;o++)n.indexOf(o)===-1?i.push(t[s++]):i.push(e[a++]);return i}function aK(t,e){let n=[],r=t.length;for(let s=0;s<r;s++)e.indexOf(s)===-1&&n.push(t[s]);let i=e.map(s=>t[s]);return[n,i]}function nf(t,e){let n=e.map(r=>1);return sK(t,n,e)}function u_e(t,e,n){ee(dL(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function oK(t,e){if(dL(t,e))return null;let n=[];for(let r=0;r<e;++r)t.indexOf(r)===-1&&n.push(r);return t.forEach(r=>n.push(r)),n}function hL(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function c_e(t,e){let n=[];for(let r=e-t;r<e;++r)n.push(r);return n}function d_e(t,e=null,n=!1){let r={x:q(t,"x","max")},i={reductionIndices:e,keepDims:n};return ue.runKernel(um,r,i)}var oo=ce({max_:d_e});function h_e(t,e=null,n=!1){let r={x:q(t,"x","min")},i={axis:e,keepDims:n};return ue.runKernel(pm,r,i)}var qy=ce({min_:h_e});function p_e(t,e){let n=q(t,"base","pow"),r=q(e,"exp","pow");[n,r]=qr(n,r);let i={a:n,b:r};return ue.runKernel(bm,i)}var pu=ce({pow_:p_e});function rn(t,e){if((zi(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&zi(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return sh(t,[],[],e)}function f_e(t){let e={x:q(t,"x","sqrt","float32")};return ue.runKernel(Om,e)}var Zi=ce({sqrt_:f_e});function m_e(t){let e=q(t,"x","square"),n={};return ue.runKernel("Square",{x:e},n)}var xr=ce({square_:m_e});function g_e(t,e=null,n=!1){let r=q(t,"x","sum");r.dtype==="bool"&&(r=ft(r,"int32"));let i={x:r},s={axis:e,keepDims:n};return ue.runKernel(Bm,i,s)}var Xt=ce({sum_:g_e});function y_e(t,e="euclidean",n=null,r=!1){t=q(t,"x","norm");let i=lK(t,e,n),s=i.shape;if(r){let a=Vo(n,t.shape);s=nf(i.shape,a)}return ve(i,s)}function lK(t,e,n=null){if(t.rank===0)return fi(t);if(t.rank!==1&&n===null)return lK(ve(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return Xt(fi(t),n);if(e===1/0)return oo(fi(t),n);if(e===-1/0)return qy(fi(t),n);if(e==="euclidean"||e===2)return Zi(Xt(pu(fi(t),rn(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return oo(Xt(fi(t),n[0]),n[1]-1);if(e===1/0)return oo(Xt(fi(t),n[1]),n[0]);if(e===-1/0)return qy(Xt(fi(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return Zi(Xt(xr(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var Sv=ce({norm_:y_e});function v_e(t,e=null,n=!1){return Sv(t,"euclidean",e,n)}var pL=ce({euclideanNorm_:v_e});function x_e(t){let e={x:q(t,"x","exp")};return ue.runKernel(qf,e)}var ws=ce({exp_:x_e});function b_e(t,e=0){let n=q(t,"x","expandDims","string_or_numeric");ee(e<=n.rank,()=>"Axis must be <= rank of the tensor");let r={input:n},i={dim:e};return ue.runKernel(L0,r,i)}var Gi=ce({expandDims_:b_e});function w_e(t){let e={x:q(t,"x","expm1")};return ue.runKernel(Jf,e)}var fL=ce({expm1_:w_e});function __e(t,e){let n=q(t,"x","tile","string_or_numeric");ee(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);let r={x:n},i={reps:e};return ue.runKernel(rh,r,i)}var Na=ce({tile_:__e});function S_e(t,e,n,r="float32"){e==null&&(e=t);let i=Rn([t,e],r),s=t<=e?t:e;for(let o=0;o<s;++o)i.set(1,o,o);let a=ve(i.toTensor(),[t,e]);if(n==null)return a;if(n.length===1)return Na(Gi(a,0),[n[0],1,1]);if(n.length===2)return Na(Gi(Gi(a,0),0),[n[0],n[1],1,1]);if(n.length===3)return Na(Gi(Gi(Gi(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var TC=ce({eye_:S_e});function A_e(t){let e={x:q(t,"x","floor","float32")};return ue.runKernel(Yf,e)}var Av=ce({floor_:A_e});function E_e(t,e,n=0,r=0){let i=q(t,"x","gather"),s=q(e,"indices","gather","int32"),a={x:i,indices:s},o={axis:n,batchDims:r};return ue.runKernel(B0,a,o)}var Ev=ce({gather_:E_e});function I_e(t,e){let n=q(t,"a","greater","string_or_numeric"),r=q(e,"b","greater","string_or_numeric");[n,r]=qr(n,r),_r(n.shape,r.shape);let i={a:n,b:r};return ue.runKernel($0,i)}var Xs=ce({greater_:I_e});function T_e(t,e){let n=q(t,"a","greaterEqual","string_or_numeric"),r=q(e,"b","greaterEqual","string_or_numeric");[n,r]=qr(n,r),_r(n.shape,r.shape);let i={a:n,b:r};return ue.runKernel(em,i)}var gc=ce({greaterEqual_:T_e});function C_e(t){let e={input:q(t,"input","imag")};return ue.runKernel(hC,e)}var Fw=ce({imag_:C_e});function M_e(t){let e={x:q(t,"x","isFinite")};return ue.runKernel(nm,e)}var mL=ce({isFinite_:M_e});function k_e(t){let e={x:q(t,"x","isInf")};return ue.runKernel(rm,e)}var gL=ce({isInf_:k_e});function N_e(t){let e={x:q(t,"x","isNaN")};return ue.runKernel(im,e)}var yL=ce({isNaN_:N_e});function R_e(t,e=.2){let n={x:q(t,"x","leakyRelu")},r={alpha:e};return ue.runKernel(sm,n,r)}var Dw=ce({leakyRelu_:R_e});function F_e(t,e){let n=q(t,"a","less","string_or_numeric"),r=q(e,"b","less","string_or_numeric");[n,r]=qr(n,r),_r(n.shape,r.shape);let i={a:n,b:r};return ue.runKernel(z0,i)}var Jy=ce({less_:F_e});function D_e(t,e){let n=q(t,"a","lessEqual","string_or_numeric"),r=q(e,"b","lessEqual","string_or_numeric");[n,r]=qr(n,r),_r(n.shape,r.shape);let i={a:n,b:r};return ue.runKernel(G0,i)}var ah=ce({lessEqual_:D_e});function uK(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:t,stop:e,num:n};return ue.runKernel(H0,{},r)}function P_e(t,e=5,n=1,r=1,i=.5){let s=q(t,"x","localResponseNormalization");ee(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),ee(Vy(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=s,o=!1;s.rank===3&&(o=!0,a=ve(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:a},u={depthRadius:e,bias:n,alpha:r,beta:i},c=ue.runKernel(lm,l,u);return o?ve(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var vL=ce({localResponseNormalization_:P_e});function L_e(t){let e={x:q(t,"x","log","float32")};return ue.runKernel(am,e)}var $a=ce({log_:L_e});function O_e(t){let e={x:q(t,"x","log1p")};return ue.runKernel(om,e)}var Pw=ce({log1p_:O_e});function B_e(t){return ee(Nd(t),()=>"The f passed in grad(f) must be a function"),(e,n)=>{let r=q(e,"x","tf.grad","string_or_numeric"),i=n!=null?q(n,"dy","tf.grad"):null;return ue.tidy(()=>{let{value:s,grads:a}=ue.gradients(()=>t(r),[r],i);return i!=null&&Vs(s.shape,i.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),CC(a),a[0]})}}function U_e(t){return ee(Nd(t),()=>"The f passed in grads(f) must be a function"),(e,n)=>{ee(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=y1(e,"args","tf.grads","string_or_numeric"),i=n!=null?q(n,"dy","tf.grads"):null;return ue.tidy(()=>{let{value:s,grads:a}=ue.gradients(()=>t(...r),r,i);return i!=null&&Vs(s.shape,i.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),CC(a),a})}}function $_e(t){return ee(Nd(t),()=>"The f passed in valueAndGrad(f) must be a function"),(e,n)=>{ee(e instanceof In,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),ee(n==null||n instanceof In,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:i}=ue.gradients(()=>t(e),[e],n);return CC(r),{grad:r[0],value:i}}}function z_e(t){return ee(Nd(t),()=>"The f passed in valueAndGrads(f) must be a function"),(e,n)=>{ee(Array.isArray(e)&&e.every(i=>i instanceof In),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),ee(n==null||n instanceof In,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=ue.gradients(()=>t(...e),e,n);return n!=null&&Vs(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),CC(r.grads),r}}function cK(t,e){ee(Nd(t),()=>"The f passed in variableGrads(f) must be a function"),ee(e==null||Array.isArray(e)&&e.every(u=>u instanceof Jp),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=e!=null;if(!n){e=[];for(let u in ue.registeredVariables)e.push(ue.registeredVariables[u])}let r=n?e.filter(u=>!u.trainable):null,i=e.length;e=e.filter(u=>u.trainable),ee(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);let s=!0,{value:a,grads:o}=ue.gradients(t,e,null,s);ee(o.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),ee(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);let l={};return e.forEach((u,c)=>{o[c]!=null&&(l[u.name]=o[c])}),r!=null&&r.forEach(u=>l[u.name]=null),{value:a,grads:l}}function fu(t){return ue.customGrad(t)}function CC(t){if(t.filter(e=>e==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function G_e(t){let e={x:q(t,"x","neg")};return ue.runKernel(J0,e)}var Mr=ce({neg_:G_e});function H_e(t){let e={x:q(t,"x","softplus")};return ue.runKernel(Lm,e)}var jm=ce({softplus_:H_e});function W_e(t){let e=q(t,"x","logSigmoid");return fu(n=>({value:Mr(jm(Mr(n))),gradFunc:r=>fe(r,Uo(Mr(n)))}))(e)}var xL=ce({logSigmoid_:W_e});function V_e(t,e){let n=q(t,"a","sub"),r=q(e,"b","sub");[n,r]=qr(n,r);let i={a:n,b:r};return ue.runKernel(zm,i)}var Dt=ce({sub_:V_e});function j_e(t,e=-1){let n=q(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return fu((r,i)=>{let s=oo(r,e,!0),a=Dt(r,s),o=Dt(ft(a,"float32"),$a(Xt(ws(a),e,!0)));return i([o]),{value:o,gradFunc:(l,u)=>{let[c]=u,d=!0,h=ws(c);return Dt(l,fe(Xt(l,e,d),h))}}})(n)}var MC=ce({logSoftmax_:j_e});function X_e(t,e=null,n=!1){let r=q(t,"x","logSumExp"),i=Vo(e,r.shape),s=oo(r,i,!0),a=Dt(r,s),o=ws(a),l=Xt(o,i),u=$a(l),c=ze(ve(s,u.shape),u);if(n){let d=nf(c.shape,i);return ve(c,d)}return c}var Lw=ce({logSumExp_:X_e});function K_e(t,e){let n=q(t,"a","logicalAnd","bool"),r=q(e,"b","logicalAnd","bool");_r(n.shape,r.shape);let i={a:n,b:r};return ue.runKernel(W0,i)}var Go=ce({logicalAnd_:K_e});function q_e(t){let e={x:q(t,"x","logicalNot","bool")};return ue.runKernel(V0,e)}var Ow=ce({logicalNot_:q_e});function J_e(t,e){let n=q(t,"a","logicalOr","bool"),r=q(e,"b","logicalOr","bool");_r(n.shape,r.shape);let i={a:n,b:r};return ue.runKernel(j0,i)}var kC=ce({logicalOr_:J_e});function Y_e(t,e){let n=q(t,"a","logicalXor","bool"),r=q(e,"b","logicalXor","bool");return _r(n.shape,r.shape),Go(kC(t,e),Ow(Go(t,e)))}var bL=ce({logicalXor_:Y_e}),yA=2147483648;function Z_e(t,e,n="left"){let r=q(t,"sortedSequence","searchSorted"),i=q(e,"values","searchSorted"),s=r.shape[r.shape.length-1],a=i.shape[i.shape.length-1],o=ve(r,[-1,s]),l=ve(i,[-1,a]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(fr(l.shape)>=yA)throw new Error(`values tensor size must less than ${yA}`);if(o.shape[1]>=yA)throw new Error(`trailing dim_size must less than ${yA} for int32 output type, was ${o.shape[1]}`);let u={sortedSequence:o,values:l},c={side:n};return ue.runKernel(lv,u,c)}var NC=ce({searchSorted_:Z_e});function dK(t,e){return NC(t,e,"left")}function Q_e(t,e,n,r,i){let s=q(t,"x","maxPool"),a=1,o=s,l=!1;s.rank===3&&(l=!0,o=ve(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ee(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),ee(vu(n,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),js("maxPool",r,i);let u={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:i},d=ue.runKernel(dm,u,c);return l?ve(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Oi=ce({maxPool_:Q_e});function eSe(t,e=[1,1,1],n,r,i,s="NDHWC"){let a=q(t,"x","maxPool3d"),o=a,l=!1;a.rank===4&&(l=!0,o=ve(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),ee(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),ee(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),js("maxPool3d",r,i);let u={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:i,dataFormat:s},d=ue.runKernel(K0,u,c);return l?ve(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var wL=ce({maxPool3d_:eSe});function tSe(t,e,n,r,i=!1){let s={x:q(t,"x","maxPoolWithArgmax")},a={filterSize:e,strides:n,pad:r,includeBatchInIndex:i},o=ue.runKernel(pw,s,a);return{result:o[0],indexes:o[1]}}var hK=ce({maxPoolWithArgmax_:tSe});function nSe(t,e){let n=q(t,"a","maximum"),r=q(e,"b","maximum");[n,r]=qr(n,r),n.dtype==="bool"&&(n=ft(n,"int32"),r=ft(r,"int32")),_r(n.shape,r.shape);let i={a:n,b:r};return ue.runKernel(cm,i)}var xu=ce({maximum_:nSe});function rSe(t,e=null,n=!1){let r={x:q(t,"x","mean")},i={axis:e,keepDims:n};return ue.runKernel(hm,r,i)}var Wr=ce({mean_:rSe});function Vr(t,e="float32"){if(Ha(t),e==="complex64"){let r=Vr(t,"float32"),i=Vr(t,"float32");return cc(r,i)}let n=nC(fr(t),e);return ue.makeTensor(n,t,e)}function ra(t,e="float32"){if(Ha(t),e==="complex64"){let r=ra(t,"float32"),i=Vr(t,"float32");return cc(r,i)}let n=C3(fr(t),e);return ue.makeTensor(n,t,e)}function pK(t,e,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(t===void 0)return[];let r=q(t,"x","meshgrid",t instanceof In?t.dtype:"float32");if(e===void 0)return[r];let i=q(e,"y","meshgrid",e instanceof In?e.dtype:"float32"),s=fr(r.shape),a=fr(i.shape);return n==="xy"?(r=ve(r,[1,-1]),i=ve(i,[-1,1]),[kn(ra([a,1],r.dtype),r),kn(i,ra([1,s],i.dtype))]):(r=ve(r,[-1,1]),i=ve(i,[1,-1]),[kn(r,ra([1,a],r.dtype)),kn(ra([s,1],i.dtype),i)])}function iSe(t,e){let n=q(t,"a","minimum"),r=q(e,"b","minimum");[n,r]=qr(n,r),n.dtype==="bool"&&(n=ft(n,"int32"),r=ft(r,"int32")),_r(n.shape,r.shape);let i={a:n,b:r};return ue.runKernel(fm,i)}var Od=ce({minimum_:iSe});function sSe(t,e,n){ee(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=q(t,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");ee(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);let i=n==="reflect"?1:0;for(let o=0;o<r.rank;o++)ee(e[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ee(e[o][0]>=0&&e[o][0]<=r.shape[o]-i&&e[o][1]>=0&&e[o][1]<=r.shape[o]-i,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-i} or less than 0 for input of shape ${r.shape}`);let s={paddings:e,mode:n},a={x:r};return ue.runKernel(mm,a,s)}var _L=ce({mirrorPad_:sSe});function aSe(t,e){let n=q(t,"a","mod"),r=q(e,"b","mod");[n,r]=qr(n,r);let i={a:n,b:r};return ue.runKernel(gm,i)}var SL=ce({mod_:aSe});function oSe(t,e=null,n=!1){t=q(t,"x","moments");let r=Vo(e,t.shape),i=Wr(t,r,n),s=i.shape;n||(s=nf(i.shape,r));let a=xr(Dt(ft(t,"float32"),ve(i,s))),o=Wr(a,r,n);return{mean:i,variance:o}}var Bw=ce({moments_:oSe});function lSe(t,e,n,r){let i=q(e,"data","multiRNNCell"),s=y1(n,"c","multiRNNCell"),a=y1(r,"h","multiRNNCell"),o=i,l=[];for(let d=0;d<t.length;d++){let h=t[d](o,s[d],a[d]);l.push(h[0]),l.push(h[1]),o=h[1]}let u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}var fK=ce({multiRNNCell_:lSe});function uSe(t,e,n,r=!1){let i=q(t,"logits","multinomial"),s=i.size,a=i.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);n=n||Math.random();let o={logits:a===1?ve(i,[1,-1]):i},l={numSamples:e,seed:n,normalized:r},u=ue.runKernel(q0,o,l);return a===1?ve(u,[u.size]):u}var mK=ce({multinomial_:uSe});function cSe(t,e){let n=q(t,"a","notEqual","string_or_numeric"),r=q(e,"b","notEqual","string_or_numeric");[n,r]=qr(n,r),_r(n.shape,r.shape);let i={a:n,b:r};return ue.runKernel(Y0,i)}var rf=ce({notEqual_:cSe});function dSe(t,e,n=1,r=0,i="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);let s={indices:q(t,"indices","oneHot","int32")},a={dtype:i,depth:e,onValue:n,offValue:r};return ue.runKernel(vm,s,a)}var Yy=ce({oneHot_:dSe});function hSe(t){let e={x:q(t,"x","onesLike")};return ue.runKernel(tv,e)}var za=ce({onesLike_:hSe});function pSe(t,e){let n=q(t,"v1","outerProduct"),r=q(e,"v2","outerProduct");ee(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);let i=ve(n,[-1,1]),s=ve(r,[1,-1]);return kn(i,s)}var gK=ce({outerProduct_:pSe});function fSe(t,e,n=0){let r=q(t,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let i={paddings:e,constantValue:n},s={x:r};return ue.runKernel(xm,s,i)}var Ml=ce({pad_:fSe});function mSe(t,e,n=0){return ee(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Ml(t,[e],n)}var yK=ce({pad1d_:mSe});function gSe(t,e,n=0){return ee(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ml(t,e,n)}var vK=ce({pad2d_:gSe});function ySe(t,e,n=0){return ee(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ml(t,e,n)}var xK=ce({pad3d_:ySe});function vSe(t,e,n=0){return ee(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ml(t,e,n)}var bK=ce({pad4d_:vSe});function xSe(t,e,n){let r=q(t,"x","spaceToBatchND");ee(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),ee(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),ee(r.shape.reduce((a,o,l)=>l>0&&l<=e.length?a&&(o+n[l-1][0]+n[l-1][1])%e[l-1]===0:a,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);let i={x:r},s={blockShape:e,paddings:n};return ue.runKernel(dv,i,s)}var Uw=ce({spaceToBatchND_:xSe});function bSe(t,e,n,r,i,s,a){i==null&&(i=[1,1]),s==null&&(s=1),r===0&&(r="valid");let o=q(t,"x","maxPool"),l=o,u=!1;o.rank===3&&(u=!0,l=ve(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ee(vu(s,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${i}'`);let c=q7(l.shape,e,s,i,r),d=[c.dilationHeight,c.dilationWidth],h;r==="same"?h=_Se([c.filterHeight,c.filterWidth],d):h=[[0,0],[0,0]];let p=d[0]===1&&d[1]===1,[f,g]=wSe([c.inHeight,c.inWidth],d,h),y=p?r:"valid",m=p?l:Uw(l,d,f),b=(n==="avg"?()=>mc(m,e,s,y,a):()=>Oi(m,e,s,y,a))(),w=p?b:Nw(b,d,g);return u?ve(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function wSe(t,e,n){let r=n.map(c=>c[0]),i=n.map(c=>c[1]),s=t.concat(r,i),a=e.map((c,d)=>(c-s[d]%c)%c),o=i.map((c,d)=>c+a[d]),l=e.map((c,d)=>[r[d],o[d]]),u=e.map((c,d)=>[0,a[d]]);return[l,u]}function _Se(t,e){let n=t.map((s,a)=>s+(s-1)*(e[a]-1)).map(s=>s-1),r=n.map(s=>Math.floor(s/2)),i=n.map((s,a)=>s-r[a]);return n.map((s,a)=>[r[a],i[a]])}var AL=ce({pool_:bSe});function SSe(t,e){let n=q(t,"x","prelu"),r=q(e,"alpha","prelu"),i={x:n,alpha:r};return ue.runKernel(wm,i)}var $w=ce({prelu_:SSe});function ASe(t,e=null,n=!1){let r=q(t,"x","prod");r.dtype==="bool"&&(r=ft(r,"int32"));let i={x:r},s={axis:e,keepDims:n};return ue.runKernel(_m,i,s)}var EL=ce({prod_:ASe});function ESe(t,e,n,r){let i=t.map((c,d)=>q(c,`tensors${d}`,"raggedGather","int32")),s=q(e,"paramsDenseValues","raggedGather"),a=q(n,"indices","raggedGather","int32"),o={paramsNestedSplits:i,paramsDenseValues:s,indices:a},l={outputRaggedRank:r},u=ue.runKernel(pC,o,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}var wK=ce({raggedGather_:ESe});function ISe(t,e,n){let r=q(t,"starts","raggedRange"),i=q(e,"limits","raggedRange",r.dtype),s=q(n,"deltas","raggedRange",r.dtype),a={starts:r,limits:i,deltas:s},o=ue.runKernel(fC,a);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var _K=ce({raggedRange_:ISe});function TSe(t,e,n,r,i){let s=q(t,"shape","raggedTensorToTensor","int32"),a=q(e,"values","raggedTensorToTensor"),o=q(n,"defaultValue","raggedTensorToTensor",a.dtype),l=r.map((d,h)=>q(d,`tensors${h}`,"raggedTensorToTensor","int32")),u={shape:s,values:a,defaultValue:o,rowPartitionTensors:l},c={rowPartitionTypes:i};return ue.runKernel(mC,u,c)}var SK=ce({raggedTensorToTensor_:TSe});function CSe(t,e,n){Ha(t);let r=fr(t),i=null;if(n==null||n==="float32")i=new Float32Array(r);else if(n==="int32")i=new Int32Array(r);else if(n==="bool")i=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let s=0;s<r;s++)i[s]=e();return ue.makeTensor(i,t,n)}var AK=ce({rand_:CSe}),IL=eh(eC()),EK={};wn(EK,{TEST_EPSILON_FLOAT16:()=>IK,createVideoElement:()=>LSe,encodeStrings:()=>TK,expectArrayBuffersEqual:()=>PSe,expectArraysClose:()=>kSe,expectArraysEqual:()=>RSe,expectNumbersClose:()=>FSe,expectPromiseToFail:()=>NSe,expectValuesInRange:()=>DSe,play:()=>OSe,testEpsilon:()=>TL});var MSe=.001,IK=.1;function kSe(t,e,n){return n==null&&(n=TL()),bF(t,e,(r,i)=>CL(r,i,n))}function TL(){return ue.backend.floatPrecision()===32?MSe:IK}function bF(t,e,n){let r=!0;if((zi(t)||zi(e))&&(r=!1),zi(t)&&zi(e)&&(r=!0),r){let a=t.constructor.name,o=e.constructor.name;if(a!==o)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${o}`)}if(Array.isArray(t)&&Array.isArray(e)){let a=hu(t),o=hu(e);if(!pc(a,o))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${o}]`)}let i=zi(t)?t:Rd(t),s=zi(e)?e:Rd(e);if(i.length!==s.length)throw new Error(`Arrays have different lengths actual: ${i.length} vs expected: ${s.length}.
Actual:   ${i}.
Expected: ${s}.`);for(let a=0;a<s.length;++a){let o=i[a],l=s[a];if(!n(o,l))throw new Error(`Arrays differ: actual[${a}] = ${o}, expected[${a}] = ${l}.
Actual:   ${i}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function NSe(t,e){t().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function RSe(t,e){let n=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return ud(t)||ud(t[0])||ud(e)||ud(e[0])?bF(t,n,(r,i)=>r==i):bF(t,e,(r,i)=>CL(r,i,0))}function FSe(t,e,n){if(n==null&&(n=TL()),!CL(t,e,n))throw new Error(`Numbers differ: actual === ${t}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function CL(t,e,n){return!isFinite(t)&&!isFinite(e)?!0:!(isNaN(t)||isNaN(e)||Math.abs(t-e)>n)}function DSe(t,e,n){for(let r=0;r<t.length;r++)if(t[r]<e||t[r]>n)throw new Error(`Value out of range:${t[r]} low: ${e}, high: ${n}`)}function PSe(t,e){let n=new Float32Array(t),r=new Float32Array(e);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let i=0;i<r.length;i++)if(n[i]!==r[i])throw new Error(`Expected ArrayBuffer value at ${i} to be ${r[i]} but got ${n[i]} instead`)}function TK(t){for(let e=0;e<t.length;e++){let n=t[e];Array.isArray(n)?TK(n):t[e]=Tw(n)}return t}function LSe(t){let e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(t),new Promise(n=>{e.addEventListener("loadeddata",r=>n(e)),e.load()})}async function OSe(t){await t.play(),"requestVideoFrameCallback"in t&&await new Promise(e=>{t.requestVideoFrameCallback(e)})}var ML=class{constructor(t,e,n,r,i){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let s=i||Math.random();this.random=IL.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let r=this.nextVal;return this.nextVal=NaN,r}let t,e,n=!1;for(;!n;){let r,i,s;do r=2*this.random()-1,i=2*this.random()-1,s=r*r+i*i;while(s>=1||s===0);let a=Math.sqrt(-2*Math.log(s)/s);t=this.mean+this.stdDev*r*a,e=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(t))&&(n=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}},BSe=class{constructor(t,e,n,r){this.alpha=t,this.beta=1/e,this.dtype=n;let i=r||Math.random();this.randu=IL.alea(i.toString()),this.randn=new ML(0,1,n,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,n,r,i,s;for(;;){do r=this.randn.nextValue(),s=1+this.c*r;while(s<=0);if(s*=s*s,t=r*r,e=1-.331*t*t,n=.5*t+this.d*(1-s+Math.log(s)),i=this.randu(),i<e||Math.log(i)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}},USe=class{constructor(t=0,e=1,n,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=n,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=IL.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function $Se(t,e,n=1,r="float32",i){if(Ha(t),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let s=new BSe(e,n,r,i),a=Rn(t,r);for(let o=0;o<a.values.length;o++)a.values[o]=s.nextValue();return a.toTensor()}var CK=ce({randomGamma_:$Se});function zSe(t,e=0,n=1,r,i){if(Ha(t),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let s=new ML(e,n,r,!1,i),a=Rn(t,r);for(let o=0;o<a.values.length;o++)a.values[o]=s.nextValue();return a.toTensor()}var RC=ce({randomNormal_:zSe});function GSe(t,e,n){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return RC(t,0,1,e,n)}var MK=ce({randomStandardNormal_:GSe});function HSe(t,e=0,n=1,r="float32",i){Ha(t);let s=Rn(t,r),a=new USe(e,n,null,i);for(let o=0;o<s.values.length;o++)s.values[o]=a.nextValue();return s.toTensor()}var oh=ce({randomUniform_:HSe});function WSe(t,e,n,r){return oh(t,e,n,"int32",r)}var kK=ce({randomUniformInt_:WSe});function sf(t,e,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");let i={start:t,stop:e,step:n,dtype:r};return ue.runKernel(fw,{},i)}function VSe(t){let e={input:q(t,"input","real")};return ue.runKernel(gC,e)}var Zy=ce({real_:VSe});function jSe(t){let e={x:q(t,"x","reciprocal")};return ue.runKernel(Sm,e)}var kL=ce({reciprocal_:jSe});function XSe(t){let e={x:q(t,"x","relu")};return ue.runKernel(Am,e)}var pr=ce({relu_:XSe});function KSe(t){let e={x:q(t,"x","relu6")};return ue.runKernel(Tm,e)}var FC=ce({relu6_:KSe});function qSe(t,e){let n={x:q(t,"x","reverse")},r={dims:e};return ue.runKernel(Cm,n,r)}var ho=ce({reverse_:qSe});function JSe(t){let e=q(t,"x","reverse");return ee(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),ho(e,0)}var NK=ce({reverse1d_:JSe});function YSe(t,e){let n=q(t,"x","reverse");return ee(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),ho(n,e)}var RK=ce({reverse2d_:YSe});function ZSe(t,e){let n=q(t,"x","reverse");return ee(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),ho(n,e)}var FK=ce({reverse3d_:ZSe});function QSe(t,e){let n=q(t,"x","reverse");return ee(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),ho(n,e)}var DK=ce({reverse4d_:QSe});function eAe(t){let e={x:q(t,"x","round")};return ue.runKernel(Mm,e)}var DC=ce({round_:eAe});function tAe(t){let e={x:q(t,"x","rsqrt","float32")};return ue.runKernel(km,e)}var PC=ce({rsqrt_:tAe});function nAe(t){let e={x:q(t,"x","selu")};return ue.runKernel(Nm,e)}var LC=ce({selu_:nAe});function rAe(t,e,n,r,i,s=[1,1],a="NHWC"){let o=q(t,"x","separableConv2d"),l=q(e,"depthwiseFilter","separableConv2d"),u=q(n,"pointwiseFilter","separableConv2d"),c=o,d=!1;if(o.rank===3&&(d=!0,c=ve(o,[1,o.shape[0],o.shape[1],o.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");ee(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),ee(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),ee(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),ee(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),ee(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let h=l.shape[2],p=l.shape[3];ee(u.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`);let f=Vm(c,l,r,i,a,s),g=zs(f,u,1,"valid",a);return d?ve(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var Iv=ce({separableConv2d_:rAe});async function iAe(t,e){let n=q(t,"x","setdiff1d"),r=q(e,"y","setdiff1d");ee(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),ee(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),ee(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let i=await n.data(),s=await r.data(),a=new Set(s),o=0;for(let c=0;c<i.length;c++)a.has(i[c])||o++;let l=new vi([o],n.dtype),u=new vi([o],"int32");for(let c=0,d=0;c<i.length;c++)a.has(i[c])||(l.values[d]=i[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]}var PK=iAe;function sAe(t){let e={x:q(t,"x","sign")};return ue.runKernel(Dm,e)}var NL=ce({sign_:sAe});function aAe(t){let e={x:q(t,"x","sin","float32")};return ue.runKernel(Rm,e)}var OC=ce({sin_:aAe});function oAe(t){let e={x:q(t,"x","sinh")};return ue.runKernel(Fm,e)}var BC=ce({sinh_:oAe});function lAe(t,e,n){let r=q(t,"x","slice1d");return ee(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Gn(r,[e],[n])}var zw=ce({slice1d_:lAe});function uAe(t,e,n){let r=q(t,"x","slice2d");return ee(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Gn(r,e,n)}var UC=ce({slice2d_:uAe});function cAe(t,e,n){let r=q(t,"x","slice3d");return ee(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Gn(r,e,n)}var Tv=ce({slice3d_:cAe});function dAe(t,e,n){let r=q(t,"x","slice4d");return ee(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Gn(r,e,n)}var Qy=ce({slice4d_:dAe});function hAe(t,e=-1){let n=q(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);let r={logits:n},i={dim:e};return ue.runKernel(Um,r,i)}var lh=ce({softmax_:hAe});function pAe(t){ee(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);let e={input:t};return ue.runKernel(cC,e)}var Gw=ce({fft_:pAe});function fAe(t){ee(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);let e={input:t};return ue.runKernel(dC,e)}var e0=ce({ifft_:fAe});function mAe(t){let e=t.shape[t.shape.length-1],n=t.size/e,r;if(e<=2){let i=ve(t,[n,e]);r=e0(i)}else{let i=[n,2*(e-1)],s=ve(Zy(t),[n,e]),a=ve(Fw(t),[n,e]),o=ho(Gn(s,[0,1],[n,e-2]),1),l=fe(ho(Gn(a,[0,1],[n,e-2]),1),rn(-1)),u=wr([s,o],1),c=wr([a,l],1),d=ve(cc(u,c),[i[0],i[1]]);r=e0(d)}if(r=Zy(r),t.rank===3&&t.shape[0]!==0){let i=r,s=t.shape[0];r=ve(r,[s,r.shape[0]/s,r.shape[1]]),i.dispose()}return r}var $C=ce({irfft_:mAe});function gAe(t,e,n=0){let r={x:q(t,"x","split")},i={numOrSizeSplits:e,axis:n};return ue.runKernel(hv,r,i)}var aa=ce({split_:gAe});function yAe(t,e){ee(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1],r=t.size/n,i;if(e!=null&&e<n){let f=t.shape.map(y=>0),g=t.shape.map(y=>y);g[t.shape.length-1]=e,i=Gn(t,f,g),n=e}else if(e!=null&&e>n){let f=t.shape.map(g=>g);f[t.shape.length-1]=e-n,i=wr([t,Vr(f)],t.shape.length-1),n=e}else i=t;let s=Kn(i),a=ve(cc(i,s),[r,n]),o=Gw(a),l=Math.floor(n/2)+1,u=Zy(o),c=Fw(o),d=aa(u,[l,n-l],u.shape.length-1),h=aa(c,[l,n-l],c.shape.length-1),p=i.shape.slice();return p[i.shape.length-1]=l,ve(cc(d[0],h[0]),p)}var Hw=ce({rfft_:yAe});function vAe(t,e){let n=q(t,"a","squaredDifference"),r=q(e,"b","squaredDifference");[n,r]=qr(n,r),_r(n.shape,r.shape);let i={a:n,b:r},s={};return ue.runKernel($m,i,s)}var zC=ce({squaredDifference_:vAe});function xAe(t,e){let n=q(t,"x","squeeze","string_or_numeric");return ve(n,l7(n.shape,e).newShape)}var uh=ce({squeeze_:xAe});function bAe(t,e=0){let n=y1(t,"tensors","stack","string_or_numeric");ee(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&ee(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");let r=n,i={axis:e};return ue.runKernel(nv,r,i)}var xi=ce({stack_:bAe});function wAe(t,e=0){let n={x:q(t,"x","step")},r={alpha:e};return ue.runKernel(ih,n,r)}var Xm=ce({step_:wAe});function _Ae(t,e,n,r,i=0,s=0,a=0,o=0,l=0){let u={x:q(t,"x","stridedSlice","string_or_numeric")},c={begin:e,end:n,strides:r,beginMask:i,endMask:s,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};return ue.runKernel(mv,u,c)}var RL=ce({stridedSlice_:_Ae});function SAe(t){let e={x:q(t,"x","tan","float32")};return ue.runKernel(Gm,e)}var FL=ce({tan_:SAe});function cr(t,e){Ef(t);let n=hu(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return sh(t,null,n,e)}function au(t,e,n){if(Ef(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=hu(t,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return sh(t,e,r,n)}function GC(t,e,n){if(Ef(t),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=hu(t,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return sh(t,e,r,n)}function Bd(t,e,n){if(Ef(t),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=hu(t,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return sh(t,e,r,n)}function LK(t,e,n){if(Ef(t),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=hu(t,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return sh(t,e,r,n)}function OK(t,e,n){if(Ef(t),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=hu(t,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,sh(t,e,r,n)}var HC={};wn(HC,{calculateShapes:()=>BK,validateInput:()=>WC,validateUpdateShape:()=>DL});function DL(t,e,n){let r=e.rank>1?e.shape[e.rank-1]:1,i=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${i}.`;if(n.rank<i)throw new Error(s+` update.rank < ${i}. `);if(t.length<r+(n.rank-i))throw new Error(s+` Output shape length < ${r+(n.rank-i)}`);if(n.rank!==i+t.length-r)throw new Error(s+` update.rank != ${i+t.length-r}`);for(let a=0;a<i;++a)if(n.shape[a]!==e.shape[a])throw new Error(s+` updates.shape[${a}] (${n.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<n.rank-i;++a)if(n.shape[a+i]!==t[a+r])throw new Error(s+` updates.shape[${a+i}] (${n.shape[a+i]}) != shape[${a+i}] (${t[a+i]})`)}function WC(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}DL(n,e,t)}function BK(t,e,n){let r=e.shape.length,i=r>1?e.shape[r-1]:1,s=n.length,a=1;for(let d=i;d<s;++d)a*=n[d];let o=i<1?1:i,l=fr(e.shape)/o,u=[...v0(n.slice(0,i)),1],c=fr(n);return{sliceRank:i,numUpdates:l,sliceSize:a,strides:u,outputSize:c}}function AAe(t,e,n){let r=q(t,"tensor","tensorScatterupdate"),i=q(e,"indices","tensorScatterupdate","int32"),s=q(n,"updates","tensorScatterupdate");if(WC(s,i,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);let a={tensor:r,indices:i,updates:s},o={};return ue.runKernel(ov,a,o)}var UK=ce({tensorScatterUpdate_:AAe});function EAe(t,e=1,n=!0){let r=q(t,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let i=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);let s={x:r},a={k:e,sorted:n},[o,l]=ue.runKernel(gv,s,a);return{values:o,indices:l}}var PL=ce({topk_:EAe});function IAe(t,e=0,n=1,r,i){if(Ha(t),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new ML(e,n,r,!0,i),a=Rn(t,r);for(let o=0;o<a.values.length;o++)a.values[o]=s.nextValue();return a.toTensor()}var VC=ce({truncatedNormal_:IAe});function TAe(t,e=0){let n=q(t,"x","unique","string_or_numeric");ee(n.rank>0,()=>"The input tensor must be at least 1D");let r={x:n},i={axis:e},[s,a]=ue.runKernel(Sw,r,i);return{values:s,indices:a}}var LL=ce({unique_:TAe});function CAe(t,e,n){let r=q(t,"x","unsortedSegmentSum"),i=q(e,"segmentIds","unsortedSegmentSum","int32");ee(Vy(n),()=>"numSegments must be of dtype int");let s={x:r,segmentIds:i},a={numSegments:n};return ue.runKernel(Aw,s,a)}var jC=ce({unsortedSegmentSum_:CAe});function MAe(t,e=0){let n=q(t,"x","unstack","string_or_numeric");ee(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);let r={value:n},i={axis:e};return ue.runKernel(vv,r,i)}var ii=ce({unstack_:MAe});function $K(t,e){return NC(t,e,"right")}function OL(t,e=!0,n,r){return ue.makeVariable(t,e,n,r)}function zK(t,e){let n=[];for(let s=0;s<e.length;s++)e[s]&&n.push(s);let r=Rn(t,"int32"),i=Rn([n.length,t.length],"int32");for(let s=0;s<n.length;s++){let a=r.indexToLoc(n[s]),o=s*t.length;i.values.set(a,o)}return i.toTensor()}async function kAe(t){let e=q(t,"condition","whereAsync","bool"),n=await e.data(),r=zK(e.shape,n);return t!==e&&e.dispose(),r}var BL=kAe;async function NAe(t,e,n){let r=q(t,"tensor","boolMask"),i=q(e,"mask","boolMask","bool"),s=n??0,a=i.rank,o=r.shape;ee(a>0,()=>"mask cannot be scalar"),Vs(o.slice(s,s+a),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let g=s;g<s+a;g++)l*=o[g];let u=o.slice(0,s).concat([l],o.slice(s+a)),c=ve(r,u),d=ve(i,[-1]),h=await BL(d),p=uh(h,[1]),f=Ev(c,p,s);return t!==r&&r.dispose(),e!==i&&i.dispose(),p.dispose(),c.dispose(),d.dispose(),h.dispose(),f}var GK=NAe;function RAe(t,e,n){let r=q(t,"x","transpose");if(e==null&&(e=r.shape.map((a,o)=>o).reverse()),ee(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(a=>{ee(a>=0&&a<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();let i={x:r},s={perm:e};return r.dtype==="complex64"?xe(()=>{let a=Zy(r),o=Fw(r);return a=ue.runKernel(Qu,{x:a},s),o=ue.runKernel(Qu,{x:o},s),n&&(o=Mr(o)),cc(a,o)}):ue.runKernel(Qu,i,s)}var Nn=ce({transpose_:RAe});function FAe(t,e,n,r,i=!0){let s=q(t,"v","movingAverage"),a=q(e,"x","movingAverage"),o=q(n,"decay","movingAverage");C7(s,a),ee(pc(s.shape,a.shape),()=>"Shape mismatch in v and x");let l=rn(1),u=Dt(l,o),c=fe(Dt(a,s),u);if(i){ee(r!=null,()=>"When using zeroDebias: true, step is required.");let d=q(r,"step","movingAverage");c=zt(c,Dt(l,pu(o,d)))}return ze(s,c)}var HK=ce({movingAverage_:FAe});function DAe(t,e,n){Ha(n);let r=q(t,"indices","scatterND","int32"),i=q(e,"updates","scatterND");WC(i,r,n);let s={indices:r,updates:i},a={shape:n};return ue.runKernel(av,s,a)}var WK=ce({scatterND_:DAe});function PAe(t,e,n,r){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);let i=t.rank>0?t.shape[0]:1,s=t.rank>1?t.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let a=e.size;if(!(e.rank===0||e.rank===1&&a===i))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${i}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function LAe(t,e,n,r=0){Ha(n);let i=q(t,"sparseIndices","sparseToDense","int32"),s=q(e,"sparseValues","sparseToDense","string_or_numeric"),a=q(r,"defaultValue","sparseToDense",s.dtype);PAe(i,s,n,a);let o={sparseIndices:i,sparseValues:s,defaultValue:a},l={outputShape:n};return ue.runKernel(fv,o,l)}var VK=ce({sparseToDense_:LAe});function OAe(t,e){let n=q(e,"indices","gatherND","int32"),r={params:q(t,"x","gatherND","string_or_numeric"),indices:n};return ue.runKernel(U0,r)}var jK=ce({gatherND_:OAe});function BAe(t,e){if(e==null)return t.shape.slice();if(pc(t.shape,e))return e;if(t.shape.length===e.length){let n=[];for(let r=0;r<t.shape.length;r++)e[r]==null&&t.shape[r]!=null?n.push(t.shape[r]):n.push(e[r]);return n}return e}function UAe(t,e,n,r){let i=q(t,"x","dropout");if(ee(i.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),ee(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof In?i.clone():i;let s=BAe(i,n),a=1-e,o=zt(Av(ze(oh(s,0,1,"float32",r),a)),a);return fe(i,o)}var UL=ce({dropout_:UAe});function $L(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function XC(t,e,n){let r=1-t%2,i=new Float32Array(t);for(let s=0;s<t;++s){let a=2*Math.PI*s/(t+r-1);i[s]=e-n*Math.cos(a)}return cr(i,"float32")}async function $Ae(t,e,n=1){let r=q(t,"predictions","inTopK"),i=q(e,"targets","inTopK");ee(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),ee(r.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${i.rank}`),Vs(r.shape.slice(0,r.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];ee(n>0&&n<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);let a=await r.data(),o=await i.data(),[l,u]=[a.length/s,s],c=u7("bool",l);for(let d=0;d<l;d++){let h=d*u,p=a.subarray(h,h+u),f=[];for(let g=0;g<p.length;g++)f.push({value:p[g],index:g});f.sort((g,y)=>y.value-g.value),c[d]=0;for(let g=0;g<n;g++)if(f[g].index===o[d]){c[d]=1;break}}return t!==r&&r.dispose(),e!==i&&i.dispose(),Us(c,i.shape,"bool")}var XK=$Ae,t0={};wn(t0,{conv2d:()=>HAe,depthwiseConv2d:()=>XAe,matMul:()=>qAe});function zAe(t,e,n,r,i,s="NHWC",a){let o=t;t.rank===3&&(o=ve(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]])),ee(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),ee(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),ee(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let u=s==="NHWC"?o.shape[3]:o.shape[1],c=s==="NHWC"?l.shape[3]:l.shape[1];ee(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),ee(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),js("conv2dDerFilter",i,a);let d={x:o,dy:l},h={strides:r,pad:i,dataFormat:s,dimRoundingMode:a,filterShape:n};return ue.runKernel(sC,d,h)}var zL=ce({conv2DBackpropFilter_:zAe});function KC(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return fe(t,Xm(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function qC(t,e){let n=e,r=bi(t.shape,e.shape);return r.length>0&&(n=Xt(n,r)),ve(n,t.shape)}function JC(t,e,n,r){if(e==="linear")return t;if(e==="relu")return pr(t);if(e==="elu")return _v(t);if(e==="relu6")return FC(t);if(e==="prelu")return $w(t,n);if(e==="leakyrelu")return Dw(t,r);if(e==="sigmoid")return Uo(t);throw new Error(`Unknown fused activation ${e}.`)}var YC=(t,e)=>!(t>0)||e==="linear";function GAe({x:t,filter:e,strides:n,pad:r,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",YC(ue.state.gradientDepth,l)===!1){ee(i==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let E=zs(t,e,n,r,i,s,a);return o!=null&&(E=ze(E,o)),JC(E,l,u,c)}let d=q(t,"x","conv2d","float32"),h=q(e,"filter","conv2d","float32"),p=d,f=!1;d.rank===3&&(f=!0,p=ve(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ee(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),ee(h.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),js("fused conv2d",r,a);let g=i==="NHWC"?p.shape[3]:p.shape[1];ee(h.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${h.shape[2]}.`),ee(vu(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);let y=kw(p.shape,h.shape,n,s,r,a),m;o!=null&&(m=q(o,"bias","fused conv2d"),[m]=qr(m,d),i==="NHWC"?_r(y.outShape,m.shape):(ee(m.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${m.shape.length}.`),ee(m.shape.length===0||m.shape[0]===y.outChannels||m.shape[0]===1,()=>`Error in fused conv2d: bias shape (${m.shape}) is not compatible with the number of output channels (${y.outChannels})`)));let b;if(u!=null){let E=u.shape;if(ee(E.length<=1||E.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${E.length}.`),E.length===1)ee(E[0]===1||E[0]===y.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the number of output channels (${y.outChannels}).`);else if(E.length===3)try{_r(E,y.outShape)}catch{let T=`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(T)}b=q(u,"prelu weights","fused conv2d")}let w=(E,C)=>{ee(i==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);let[T,M,k,R]=C,N=KC(E,k,l);ee(Pd(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let B=iL(M.shape,N,T,n,r),z=zL(M,N,T.shape,n,r),V=[B,z];if(R!=null){let K=qC(R,N);V.push(K)}return V},_={x:p,filter:h,bias:m,preluActivationWeights:b},S={strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return o==null?fu((E,C,T)=>{let M=ue.runKernel(Kp,_,S);return T([C,E,M]),f&&(M=ve(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:w}})(p,h):fu((E,C,T,M)=>{let k=ue.runKernel(Kp,_,S);return M([C,E,k,T]),f&&(k=ve(k,[k.shape[1],k.shape[2],k.shape[3]])),{value:k,gradFunc:w}})(p,h,m)}var HAe=ce({fusedConv2d_:GAe});function WAe(t,e,n,r,i,s=[1,1],a){let o=t;t.rank===3&&(o=ve(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u={x:o,dy:l},c={strides:r,pad:i,dimRoundingMode:a,dilations:s,filterShape:n};return ue.runKernel(aC,u,c)}var KK=ce({depthwiseConv2dNativeBackpropFilter_:WAe});function VAe(t,e,n,r,i,s=[1,1],a){let o=e,l=!1;e.rank===3&&(l=!0,o=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u={dy:o,filter:n},c={strides:r,pad:i,dimRoundingMode:a,dilations:s,inputShape:t},d=ue.runKernel(oC,u,c);return l?ve(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var qK=ce({depthwiseConv2dNativeBackpropInput_:VAe});function jAe({x:t,filter:e,strides:n,pad:r,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(YC(ue.state.gradientDepth,l)===!1){let S=Vm(t,e,n,r,i,s,a);return o!=null&&(S=ze(S,o)),JC(S,l,u,c)}let d=q(t,"x","depthwiseConv2d","float32"),h=q(e,"filter","depthwiseConv2d","float32"),p=d,f=!1;d.rank===3&&(f=!0,p=ve(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ee(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),ee(h.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),ee(p.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),s==null&&(s=[1,1]),ee(vu(n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),js("fused depthwiseConv2d",r,a);let g=kw(p.shape,h.shape,n,s,r,a,!0),y;o!=null&&(y=q(o,"bias","fused conv2d"),[y]=qr(y,d),_r(g.outShape,y.shape));let m;u!=null&&(m=q(u,"prelu weights","fused depthwiseConv2d"));let b=(S,E)=>{ee(Pd(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[C,T,M,k]=E,R=KC(S,M,l),N=qK(T.shape,R,C,n,r,s,a),B=KK(T,R,C.shape,n,r,s,a);if(k!=null){let z=qC(y,R);return[N,B,z]}return[N,B]},w={x:p,filter:h,bias:y,preluActivationWeights:m},_={strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return o==null?fu((S,E,C)=>{let T=ue.runKernel(qp,w,_);return C([E,S,T]),f&&(T=ve(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:b}})(p,h):fu((S,E,C,T)=>{let M=ue.runKernel(qp,w,_);return T([E,S,M,C]),f&&(M=ve(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:b}})(p,h,y)}var XAe=ce({fusedDepthwiseConv2d_:jAe});function KAe({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:i,activation:s="linear",preluActivationWeights:a,leakyreluAlpha:o=.2}){if(YC(ue.state.gradientDepth,s)===!1){let k=kn(t,e,n,r);return i!=null&&(k=ze(k,i)),JC(k,s,a,o)}let l=q(t,"a","fused matMul"),u=q(e,"b","fused matMul");[l,u]=qr(l,u);let c=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),g=u.shape.slice(0,-2),y=fr(f),m=fr(g);ee(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`);let b=_r(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([h,p]),w=n?ve(l,[y,c,h]):ve(l,[y,h,c]),_=r?ve(u,[m,p,d]):ve(u,[m,d,p]),S;i!=null&&(S=q(i,"bias","fused matMul"),[S]=qr(S,l),_r(b,S.shape));let E;a!=null&&(E=q(a,"prelu weights","fused matMul"));let C=(k,R)=>{let[N,B,z,V]=R,K=KC(ve(k,z.shape),z,s),Q,O;if(!n&&!r?(Q=kn(K,B,!1,!0),O=kn(N,K,!0,!1)):!n&&r?(Q=kn(K,B,!1,!1),O=kn(K,N,!0,!1)):n&&!r?(Q=kn(B,K,!1,!0),O=kn(N,K,!1,!1)):(Q=kn(B,K,!0,!0),O=kn(K,N,!0,!0)),i!=null){let j=qC(V,K);return[Q,O,j]}else return[Q,O]},T={a:w,b:_,bias:S,preluActivationWeights:E},M={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:o};return i==null?fu((k,R,N)=>{let B=ue.runKernel(Xp,T,M);return N([k,R,B]),{value:ve(B,b),gradFunc:C}})(w,_):fu((k,R,N,B)=>{let z=ue.runKernel(Xp,T,M);return B([k,R,z,N]),{value:ve(z,b),gradFunc:C}})(w,_,S)}var qAe=ce({fusedMatMul_:KAe});function JAe(t){return XC(t,.54,.46)}var YAe=ce({hammingWindow_:JAe});function ZAe(t){return XC(t,.5,.5)}var JK=ce({hannWindow_:ZAe});function QAe(t,e,n,r=!1,i=0){let s=0,a=[];for(;s+e<=t.size;)a.push(Gn(t,s,e)),s+=n;if(r)for(;s<t.size;){let o=s+e-t.size,l=wr([Gn(t,s,e-o),Pa([o],i)]);a.push(l),s+=n}return a.length===0?au([],[0,e]):ve(wr(a),[a.length,e])}var YK=ce({frame_:QAe});function eEe(t,e,n,r,i=JK){r==null&&(r=$L(e));let s=YK(t,e,n),a=fe(s,i(e));return Hw(a,r)}var tEe=ce({stft_:eEe});function nEe(t,e,n,r,i="bilinear",s=0){let a=q(t,"image","cropAndResize"),o=q(e,"boxes","cropAndResize","float32"),l=q(n,"boxInd","cropAndResize","int32"),u=o.shape[0];ee(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),ee(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),ee(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),ee(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),ee(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),ee(i==="bilinear"||i==="nearest",()=>`method must be bilinear or nearest, but was ${i}`);let c={image:a,boxes:o,boxInd:l},d={method:i,extrapolationValue:s,cropSize:r};return ue.runKernel(R0,c,d)}var rEe=ce({cropAndResize_:nEe});function iEe(t){let e=q(t,"image","flipLeftRight","float32");ee(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);let n={image:e};return ue.runKernel(O0,n,{})}var sEe=ce({flipLeftRight_:iEe});function aEe(t){let e=q(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];ee(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),ee(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let i=new Array(e.rank);return i.fill(1,0,n),i[n]=3,Na(e,i)}var oEe=ce({grayscaleToRGB_:aEe});function lEe(t){let e=q(t,"image","RGBToGrayscale"),n=e.rank-1,r=e.shape[n];ee(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),ee(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);let i=e.dtype,s=ft(e,"float32"),a=cr([.2989,.587,.114]),o;switch(e.rank){case 2:o=ip("ij,j->i",s,a);break;case 3:o=ip("ijk,k->ij",s,a);break;case 4:o=ip("ijkl,l->ijk",s,a);break;case 5:o=ip("ijklm,m->ijkl",s,a);break;case 6:o=ip("ijklmn,n->ijklm",s,a);break;default:throw new Error("Not a valid tensor rank.")}return o=Gi(o,-1),ft(o,i)}var uEe=ce({rgbToGrayscale_:lEe});function cEe(t,e,n=0,r=.5){let i=q(t,"image","rotateWithOffset","float32");ee(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);let s={image:i},a={radians:e,fillValue:n,center:r};return ue.runKernel(bv,s,a)}var dEe=ce({rotateWithOffset_:cEe});function Cv(t,e,n,r,i,s){r==null&&(r=.5),i==null&&(i=Number.NEGATIVE_INFINITY),s==null&&(s=0);let a=t.shape[0];return n=Math.min(n,a),ee(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),ee(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),ee(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),ee(e.rank===1,()=>"scores must be a 1D tensor"),ee(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),ee(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:i,softNmsSigma:s}}function hEe(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY){let s=q(t,"boxes","nonMaxSuppression","float32"),a=q(e,"scores","nonMaxSuppression","float32"),o=Cv(s,a,n,r,i);n=o.maxOutputSize,r=o.iouThreshold,i=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:i};return ue.runKernel(Z0,{boxes:s,scores:a},l)}var pEe=ce({nonMaxSuppression_:hEe});function fEe(t,e,n){let r=mEe(t,e,n),i=r<0?-(r+1):r;t.splice(i,0,e)}function mEe(t,e,n){return yEe(t,e,n||gEe)}function gEe(t,e){return t>e?1:t<e?-1:0}function yEe(t,e,n){let r=0,i=t.length,s=0,a=!1;for(;r<i;){s=r+(i-r>>>1);let o=n(e,t[s]);o>0?r=s+1:(i=s,a=!o)}return a?r:-r-1}function ZK(t,e,n,r,i){return GL(t,e,n,r,i,0)}function QK(t,e,n,r,i,s){return GL(t,e,n,r,i,0,!1,s,!0)}function eq(t,e,n,r,i,s){return GL(t,e,n,r,i,s,!0)}function GL(t,e,n,r,i,s,a=!1,o=!1,l=!1){let u=[];for(let y=0;y<e.length;y++)e[y]>i&&u.push({score:e[y],boxIndex:y,suppressBeginIndex:0});u.sort(YW);let c=s>0?-.5/s:0,d=[],h=[];for(;d.length<n&&u.length>0;){let y=u.pop(),{score:m,boxIndex:b,suppressBeginIndex:w}=y;if(m<i)break;let _=!1;for(let S=d.length-1;S>=w;--S){let E=vEe(t,b,d[S]);if(E>=r){_=!0;break}if(y.score=y.score*xEe(r,c,E),y.score<=i)break}y.suppressBeginIndex=d.length,_||(y.score===m?(d.push(b),h.push(y.score)):y.score>i&&fEe(u,y,YW))}let p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));let g={selectedIndices:d};return a&&(g.selectedScores=h),l&&(g.validOutputs=p),g}function vEe(t,e,n){let r=t.subarray(e*4,e*4+4),i=t.subarray(n*4,n*4+4),s=Math.min(r[0],r[2]),a=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(i[0],i[2]),c=Math.min(i[1],i[3]),d=Math.max(i[0],i[2]),h=Math.max(i[1],i[3]),p=(o-s)*(l-a),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;let g=Math.max(s,u),y=Math.max(a,c),m=Math.min(o,d),b=Math.min(l,h),w=Math.max(m-g,0)*Math.max(b-y,0);return w/(p+f-w)}function xEe(t,e,n){let r=Math.exp(e*n*n);return n<=t?r:0}function YW(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}async function bEe(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY){let s=q(t,"boxes","nonMaxSuppressionAsync"),a=q(e,"scores","nonMaxSuppressionAsync"),o=Cv(s,a,n,r,i);n=o.maxOutputSize,r=o.iouThreshold,i=o.scoreThreshold;let l=await Promise.all([s.data(),a.data()]),u=l[0],c=l[1],{selectedIndices:d}=ZK(u,c,n,r,i);return s!==t&&s.dispose(),a!==e&&a.dispose(),cr(d,"int32")}var wEe=bEe;function _Ee(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY,s=0){let a=q(t,"boxes","nonMaxSuppression"),o=q(e,"scores","nonMaxSuppression"),l=Cv(a,o,n,r,i,s);n=l.maxOutputSize,r=l.iouThreshold,i=l.scoreThreshold,s=l.softNmsSigma;let u={boxes:a,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:i,softNmsSigma:s},d=ue.runKernel(ev,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}var SEe=ce({nonMaxSuppressionWithScore_:_Ee});async function AEe(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY,s=0){let a=q(t,"boxes","nonMaxSuppressionAsync"),o=q(e,"scores","nonMaxSuppressionAsync"),l=Cv(a,o,n,r,i,s);n=l.maxOutputSize,r=l.iouThreshold,i=l.scoreThreshold,s=l.softNmsSigma;let u=await Promise.all([a.data(),o.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=eq(c,d,n,r,i,s);return a!==t&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:cr(h,"int32"),selectedScores:cr(p)}}var EEe=AEe;function IEe(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY,s=!1){let a=q(t,"boxes","nonMaxSuppression"),o=q(e,"scores","nonMaxSuppression"),l=Cv(a,o,n,r,i,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,h={boxes:a,scores:o},p={maxOutputSize:u,iouThreshold:c,scoreThreshold:d,padToMaxOutputSize:s},f=ue.runKernel(Q0,h,p);return{selectedIndices:f[0],validOutputs:f[1]}}var TEe=ce({nonMaxSuppressionPadded_:IEe});async function CEe(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY,s=!1){let a=q(t,"boxes","nonMaxSuppressionAsync"),o=q(e,"scores","nonMaxSuppressionAsync"),l=Cv(a,o,n,r,i,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=await Promise.all([a.data(),o.data()]),{selectedIndices:f,validOutputs:g}=QK(h,p,u,c,d,s);return a!==t&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:cr(f,"int32"),validOutputs:rn(g,"int32")}}var MEe=CEe;function kEe(t,e,n=!1,r=!1){let i=q(t,"images","resizeBilinear");ee(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),ee(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),ee(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=i,a=!1;i.rank===3&&(a=!0,s=ve(i,[1,i.shape[0],i.shape[1],i.shape[2]]));let o={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},u=ue.runKernel(Im,o,l);return a?ve(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var tq=ce({resizeBilinear_:kEe});function NEe(t,e,n=!1,r=!1){let i=q(t,"images","resizeNearestNeighbor");ee(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),ee(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),ee(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),ee(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=i,a=!1;i.rank===3&&(a=!0,s=ve(i,[1,i.shape[0],i.shape[1],i.shape[2]]));let o={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},u=ue.runKernel(Em,o,l);return a?ve(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var nq=ce({resizeNearestNeighbor_:NEe});function REe(t,e="binary",n=!1,r=.5){let i=q(t,"image","threshold"),s=.2989,a=.587,o=.114,l=i.shape[0]*i.shape[1],u=fe(cr([r]),255),c,d,h,p;if(ee(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),ee(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),ee(i.dtype==="int32"||i.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),ee(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),i.shape[2]===3){[c,d,h]=aa(i,[1,1,1],-1);let g=fe(c,s),y=fe(d,a),m=fe(h,o);p=ze(ze(g,y),m)}else p=t;if(e==="otsu"){let g=Z3(ft(DC(p),"int32"),Us([]),256);u=FEe(g,l)}let f=n?ah(p,u):Xs(p,u);return ft(fe(f,255),"int32")}function FEe(t,e){let n=cr([-1]),r=cr([0]),i=cr([0]),s,a,o,l,u,c;for(let d=0;d<t.size-1;d++){s=Gn(t,0,d+1),a=Gn(t,d+1),u=zt(Xt(s),e),c=zt(Xt(a),e);let h=Xt(fe(s,sf(0,s.size)));o=zt(h,Xt(s));let p=Pa(a.shape,s.size),f=ze(sf(0,a.size),p),g=fe(a,f);l=zt(Xt(g),Xt(a));let y=Dt(o,l),m=Dt(o,l),b=fe(u,c);i=fe(fe(b,y),m);let w=Xs(i,r);r=qi(w,i,r),n=qi(w,cr([d]),n)}return n}var DEe=ce({threshold_:REe});function PEe(t,e,n="nearest",r="constant",i=0,s){let a=q(t,"image","transform","float32"),o=q(e,"transforms","transform","float32");ee(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),ee(o.rank===2&&(o.shape[0]===a.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),ee(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let l={image:a,transforms:o},u={interpolation:n,fillMode:r,fillValue:i,outputShape:s};return ue.runKernel(yv,l,u)}var LEe=ce({transform_:PEe});function OEe(t,e,n){let r=q(t,"a","bandPart");ee(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let i=r.shape,[s,a]=r.shape.slice(-2),o,l;typeof e=="number"?(ee(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),ee(e<=s,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`),o=q(e<0?s:e,"numLower","bandPart")):(ee(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=qi(Jy(e,0),s,Od(e,s))),typeof n=="number"?(ee(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),ee(n<=a,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${a}).`),l=q(n<0?a:n,"numUpper","bandPart")):(ee(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=qi(Jy(n,0),a,Od(n,a)));let u=ve(sf(0,s,1,"int32"),[-1,1]),c=sf(0,a,1,"int32"),d=Dt(u,c),h=Go(ah(d,o),gc(d,Mr(l))),p=Vr([s,a],r.dtype);return ve(xi(ii(ve(r,[-1,s,a])).map(f=>qi(h,f,p))),i)}var BEe=ce({bandPart_:OEe});function UEe(t){let e;if(Array.isArray(t)){e=!1,ee(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let i=t[0].shape[0];for(let s=1;s<t.length;++s)ee(t[s].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[s].shape[0]} vs. ${i})`)}else e=!0,t=aa(t,t.shape[0],0).map(i=>uh(i,[0]));ee(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);let n=[],r=t;for(let i=0;i<t.length;++i)n.push(ue.tidy(()=>{let s=r[i];if(i>0)for(let a=0;a<i;++a){let o=fe(Xt(fe(n[a],s)),n[a]);s=Dt(s,o)}return zt(s,Sv(s,"euclidean"))}));return e?xi(n,0):n}var $Ee=ce({gramSchmidt_:UEe});function zEe(t,e=!1){if(ee(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return ZW(t,e);{let n=t.shape.slice(0,t.shape.length-2).reduce((l,u)=>l*u),r=ii(ve(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),i=[],s=[];r.forEach(l=>{let[u,c]=ZW(l,e);i.push(u),s.push(c)});let a=ve(xi(i,0),t.shape),o=ve(xi(s,0),t.shape);return[a,o]}}function ZW(t,e=!1){return ue.tidy(()=>{ee(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);let n=t.shape[0],r=t.shape[1],i=TC(n),s=su(t),a=au([[1]],[1,1]),o=su(a),l=n>=r?r:n;for(let u=0;u<l;++u){let c=s,d=o,h=i;[o,s,i]=ue.tidy(()=>{let p=Gn(s,[u,u],[n-u,1]),f=Sv(p),g=Gn(s,[u,u],[1,1]),y=qi(Xs(g,0),au([[-1]]),au([[1]])),m=Dt(g,fe(y,f)),b=zt(p,m);b.shape[0]===1?o=su(a):o=wr([a,Gn(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);let w=Mr(zt(kn(y,m),f)),_=Gn(s,[u,0],[n-u,r]),S=fe(w,o),E=Nn(o);if(u===0)s=Dt(_,kn(S,kn(E,_)));else{let M=Dt(_,kn(S,kn(E,_)));s=wr([Gn(s,[0,0],[u,r]),M],0)}let C=Nn(S),T=Gn(i,[0,u],[n,i.shape[1]-u]);if(u===0)i=Dt(T,kn(kn(T,o),C));else{let M=Dt(T,kn(kn(T,o),C));i=wr([Gn(i,[0,0],[n,u]),M],1)}return[o,s,i]}),bn([c,d,h])}return!e&&n>r&&(i=Gn(i,[0,0],[n,r]),s=Gn(s,[0,0],[r,r])),[i,s]})}var GEe=ce({qr_:zEe}),Os;(function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Os||(Os={}));function HEe(t,e,n=Os.SUM_BY_NONZERO_WEIGHTS){let r=q(t,"losses","computeWeightedLoss"),i=null;e!=null&&(i=q(e,"weights","computeWeightedLoss"));let s=i==null?r:fe(r,i);if(n===Os.NONE)return s;if(n===Os.SUM)return Xt(s);if(n===Os.MEAN){if(i==null)return Wr(s);{let a=r.size/i.size,o=zt(Xt(s),Xt(i));return a>1?zt(o,rn(a)):o}}if(n===Os.SUM_BY_NONZERO_WEIGHTS){if(i==null)return zt(Xt(s),rn(r.size));{let a=fe(i,ra(r.shape)),o=ft(Xt(rf(a,rn(0))),"float32");return zt(Xt(s),o)}}throw Error(`Unknown reduction: ${n}`)}var yc=ce({computeWeightedLoss_:HEe});function WEe(t,e,n,r=Os.SUM_BY_NONZERO_WEIGHTS){let i=q(t,"labels","absoluteDifference"),s=q(e,"predictions","absoluteDifference"),a=null;n!=null&&(a=q(n,"weights","absoluteDifference")),Vs(i.shape,s.shape,"Error in absoluteDifference: ");let o=fi(Dt(i,s));return yc(o,a,r)}var VEe=ce({absoluteDifference_:WEe});function jEe(t,e,n,r,i=Os.SUM_BY_NONZERO_WEIGHTS){let s=q(t,"labels","cosineDistance"),a=q(e,"predictions","cosineDistance"),o=null;r!=null&&(o=q(r,"weights","cosineDistance")),Vs(s.shape,a.shape,"Error in cosineDistance: ");let l=rn(1),u=Dt(l,Xt(fe(s,a),n,!0));return yc(u,o,i)}var XEe=ce({cosineDistance_:jEe});function KEe(t,e,n,r=Os.SUM_BY_NONZERO_WEIGHTS){let i=q(t,"labels","hingeLoss"),s=q(e,"predictions","hingeLoss"),a=null;n!=null&&(a=q(n,"weights","hingeLoss")),Vs(i.shape,s.shape,"Error in hingeLoss: ");let o=rn(1);i=Dt(fe(rn(2),i),o);let l=pr(Dt(o,fe(i,s)));return yc(l,a,r)}var qEe=ce({hingeLoss_:KEe});function JEe(t,e,n,r=1,i=Os.SUM_BY_NONZERO_WEIGHTS){let s=q(t,"labels","huberLoss"),a=q(e,"predictions","huberLoss"),o=null;n!=null&&(o=q(n,"weights","huberLoss")),Vs(s.shape,a.shape,"Error in huberLoss: ");let l=rn(r),u=fi(Dt(a,s)),c=Od(u,l),d=Dt(u,c),h=ze(fe(rn(.5),xr(c)),fe(l,d));return yc(h,o,i)}var YEe=ce({huberLoss_:JEe});function ZEe(t,e,n,r=1e-7,i=Os.SUM_BY_NONZERO_WEIGHTS){let s=q(t,"labels","logLoss"),a=q(e,"predictions","logLoss"),o=null;n!=null&&(o=q(n,"weights","logLoss")),Vs(s.shape,a.shape,"Error in logLoss: ");let l=rn(1),u=rn(r),c=Mr(fe(s,$a(ze(a,u)))),d=fe(Dt(l,s),$a(ze(Dt(l,a),u))),h=Dt(c,d);return yc(h,o,i)}var QEe=ce({logLoss_:ZEe});function eIe(t,e,n,r=Os.SUM_BY_NONZERO_WEIGHTS){let i=q(t,"labels","meanSquaredError"),s=q(e,"predictions","meanSquaredError"),a=null;n!=null&&(a=q(n,"weights","meanSquaredError")),Vs(i.shape,s.shape,"Error in meanSquaredError: ");let o=zC(i,s);return yc(o,a,r)}var tIe=ce({meanSquaredError_:eIe});function nIe(t,e){let n=q(t,"labels","sigmoidCrossEntropyWithLogits"),r=q(e,"logits","sigmoidCrossEntropyWithLogits");Vs(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let i=pr(r),s=fe(r,n),a=Pw(ws(Mr(fi(r))));return ze(Dt(i,s),a)}function rIe(t,e,n,r=0,i=Os.SUM_BY_NONZERO_WEIGHTS){let s=q(t,"multiClassLabels","sigmoidCrossEntropy"),a=q(e,"logits","sigmoidCrossEntropy"),o=null;if(n!=null&&(o=q(n,"weights","sigmoidCrossEntropy")),Vs(s.shape,a.shape,"Error in sigmoidCrossEntropy: "),r>0){let u=rn(r),c=rn(1),d=rn(.5);s=ze(fe(s,Dt(c,u)),fe(d,u))}let l=nIe(s,a);return yc(l,o,i)}var iIe=ce({sigmoidCrossEntropy_:rIe});function sIe(t,e,n=-1){if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return fu((r,i,s)=>{let a=Lw(i,[n],!0),o=Dt(ft(i,"float32"),a);s([r,o]);let l=Mr(fe(o,r));return{value:Xt(l,[n]),gradFunc:(u,c)=>{let[d,h]=c,p=nf(u.shape,[n]);return[fe(ve(u,p),Dt(ft(d,"float32"),ws(h))),fe(ve(u,p),Dt(ws(h),ft(d,"float32")))]}}})(t,e)}function aIe(t,e,n,r=0,i=Os.SUM_BY_NONZERO_WEIGHTS){let s=q(t,"onehotLabels","softmaxCrossEntropy"),a=q(e,"logits","softmaxCrossEntropy"),o=null;if(n!=null&&(o=q(n,"weights","softmaxCrossEntropy")),Vs(s.shape,a.shape,"Error in softmaxCrossEntropy: "),r>0){let u=rn(r),c=rn(1),d=rn(s.shape[1]);s=ze(fe(s,Dt(c,u)),zt(u,d))}let l=sIe(s,a);return yc(l,o,i)}var oIe=ce({softmaxCrossEntropy_:aIe});function lIe(t,e,n,r){let i=q(t,"indices","sparseFillEmptyRows","int32"),s=q(e,"values","sparseFillEmptyRows"),a=q(n,"denseShape","sparseFillEmptyRows","int32"),o=q(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(i.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${i.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:i,values:s,denseShape:a,defaultValue:o},u=ue.runKernel(mw,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var uIe=ce({sparseFillEmptyRows_:lIe});function cIe(t,e,n){let r=q(t,"inputIndices","sparseReshape","int32"),i=q(e,"inputShape","sparseReshape","int32"),s=q(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(i.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let a={inputIndices:r,inputShape:i,newShape:s},o=ue.runKernel(pv,a);return{outputIndices:o[0],outputShape:o[1]}}var dIe=ce({sparseReshape_:cIe});function hIe(t,e,n){let r=q(t,"data","sparseSegmentMean"),i=q(e,"indices","sparseSegmentMean","int32"),s=q(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${i.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let a={data:r,indices:i,segmentIds:s};return ue.runKernel(gw,a)}var pIe=ce({sparseSegmentMean_:hIe});function fIe(t,e,n){let r=q(t,"data","sparseSegmentSum"),i=q(e,"indices","sparseSegmentSum","int32"),s=q(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${i.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let a={data:r,indices:i,segmentIds:s};return ue.runKernel(yw,a)}var mIe=ce({sparseSegmentSum_:fIe});function gIe(t,e,n,r,i,s,a,o){let l=q(t,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=q(e,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:n,nGramWidths:r,leftPad:i,rightPad:s,padWidth:a,preserveShortSequences:o},d={data:l,dataSplits:u},h=ue.runKernel(bw,d,c);return{nGrams:h[0],nGramsSplits:h[1]}}var yIe=ce({stringNGrams_:gIe});function vIe(t,e,n=!0){let r=q(t,"input","stringSplit","string"),i=q(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(i.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${i.shape}`);let s={skipEmpty:n},a={input:r,delimiter:i},o=ue.runKernel(ww,a,s);return{indices:o[0],values:o[1],shape:o[2]}}var xIe=ce({stringSplit_:vIe});function bIe(t,e){let n=q(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");let i={input:n};return ue.runKernel(_w,i,r)}var wIe=ce({stringToHashBucketFast_:bIe});function _Ie(t,e,n,r=!0){let i=q(t,"input","staticRegexReplace","string"),s={pattern:e,rewrite:n,replaceGlobal:r};return ue.runKernel(xw,{x:i},s)}var SIe=ce({staticRegexReplace_:_Ie}),rq={fft:Gw,ifft:e0,rfft:Hw,irfft:$C},iq={hammingWindow:YAe,hannWindow:JK,frame:YK,stft:tEe},to={flipLeftRight:sEe,grayscaleToRGB:oEe,resizeNearestNeighbor:nq,resizeBilinear:tq,rgbToGrayscale:uEe,rotateWithOffset:dEe,cropAndResize:rEe,nonMaxSuppression:pEe,nonMaxSuppressionAsync:wEe,nonMaxSuppressionWithScore:SEe,nonMaxSuppressionWithScoreAsync:EEe,nonMaxSuppressionPadded:TEe,nonMaxSuppressionPaddedAsync:MEe,threshold:DEe,transform:LEe},HL={bandPart:BEe,gramSchmidt:$Ee,qr:GEe},sq={absoluteDifference:VEe,computeWeightedLoss:yc,cosineDistance:XEe,hingeLoss:qEe,huberLoss:YEe,logLoss:QEe,meanSquaredError:tIe,sigmoidCrossEntropy:iIe,softmaxCrossEntropy:oIe},aq={sparseFillEmptyRows:uIe,sparseReshape:dIe,sparseSegmentMean:pIe,sparseSegmentSum:mIe},oq={stringNGrams:yIe,stringSplit:xIe,stringToHashBucketFast:wIe,staticRegexReplace:SIe},rt={};wn(rt,{Serializable:()=>lq,SerializationMap:()=>uq,getRegisteredName:()=>EIe,registerClass:()=>cq});var AIe=new Map,wF=new Map,lq=class{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}},uq=class Xg{constructor(){this.classNameMap={}}static getMap(){return Xg.instance==null&&(Xg.instance=new Xg),Xg.instance}static register(e){Xg.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function cq(t,e,n){ee(t.className!=null,()=>"Class being registered does not have the static className property defined."),ee(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),ee(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof n>"u"&&(n=t.className);let r=n,i=e+">"+r;return uq.register(t),AIe.set(i,t),wF.set(t,i),t}function EIe(t){return wF.has(t)?wF.get(t):t.className}var vc=class extends lq{minimize(t,e=!1,n){let{value:r,grads:i}=this.computeGradients(t,n);if(n!=null){let s=n.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(s)}else this.applyGradients(i);return bn(i),e?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return cK(t,e)}dispose(){this.iterations_!=null&&bn(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:rn(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}};Object.defineProperty(vc,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});var WL=class extends vc{static get className(){return"Adadelta"}constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=ue.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(e=>e.name):Object.keys(t)).forEach((e,n)=>{let r=ue.registeredVariables[e],i=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${e}/accum_grad`,variable:xe(()=>Kn(r).variable(i))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${e}/accum_var`,variable:xe(()=>Kn(r).variable(i))});let s=Array.isArray(t)?t[n].tensor:t[e];if(s==null)return;let a=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;xe(()=>{let l=ze(fe(a,this.rho),fe(xr(s),1-this.rho)),u=fe(zt(Zi(ze(o,this.epsilon)),Zi(ze(a,this.epsilon))),s),c=ze(fe(o,this.rho),fe(xr(u),1-this.rho));a.assign(l),o.assign(c);let d=ze(fe(u,-this.learningRate),r);r.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(bn(this.accumulatedGrads.map(t=>t.variable)),bn(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){let t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=t.length/2,n=!1;this.accumulatedGrads=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedUpdates=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}},VL=class extends vc{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(e=>e.name):Object.keys(t)).forEach((e,n)=>{let r=ue.registeredVariables[e];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${e}/accumulator`,variable:xe(()=>Pa(r.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(t)?t[n].tensor:t[e];if(i==null)return;let s=this.accumulatedGrads[n].variable;xe(()=>{let a=ze(s,xr(i));s.assign(a);let o=ze(fe(zt(i,Zi(ze(a,ue.backend.epsilon()))),-this.learningRate),r);r.assign(o)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&bn(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=!1;this.accumulatedGrads=t.map(n=>({originalName:n.name,variable:n.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}},jL=class extends vc{static get className(){return"Adam"}constructor(t,e,n,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],xe(()=>{this.accBeta1=rn(e).variable(),this.accBeta2=rn(n).variable()}),r==null&&(this.epsilon=ue.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);xe(()=>{let n=Dt(1,this.accBeta1),r=Dt(1,this.accBeta2);e.forEach((i,s)=>{let a=ue.registeredVariables[i],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${i}/m`,variable:xe(()=>Kn(a).variable(o))}),this.accumulatedSecondMoment[s]==null&&(this.accumulatedSecondMoment[s]={originalName:`${i}/v`,variable:xe(()=>Kn(a).variable(o))});let l=Array.isArray(t)?t[s].tensor:t[i];if(l==null)return;let u=this.accumulatedFirstMoment[s].variable,c=this.accumulatedSecondMoment[s].variable,d=ze(fe(u,this.beta1),fe(l,1-this.beta1)),h=ze(fe(c,this.beta2),fe(xr(l),1-this.beta2)),p=zt(d,n),f=zt(h,r);u.assign(d),c.assign(h);let g=ze(fe(zt(p,ze(Zi(f),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(fe(this.accBeta1,this.beta1)),this.accBeta2.assign(fe(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&bn(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&bn(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),xe(()=>{this.accBeta1.assign(pu(this.beta1,this.iterations_+1)),this.accBeta2.assign(pu(this.beta2,this.iterations_+1))});let e=t.length/2,n=!1;this.accumulatedFirstMoment=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}},XL=class extends vc{static get className(){return"Adamax"}constructor(t,e,n,r=null,i=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],xe(()=>{this.iteration=rn(0).variable(),this.accBeta1=rn(e).variable()}),r==null&&(this.epsilon=ue.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);xe(()=>{let n=Dt(1,this.accBeta1),r=zt(-this.learningRate,ze(fe(this.iteration,this.decay),1));e.forEach((i,s)=>{let a=ue.registeredVariables[i],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${i}/m`,variable:Kn(a).variable(o)}),this.accumulatedWeightedInfNorm[s]==null&&(this.accumulatedWeightedInfNorm[s]={originalName:`${i}/v`,variable:Kn(a).variable(o)});let l=Array.isArray(t)?t[s].tensor:t[i];if(l==null)return;let u=this.accumulatedFirstMoment[s].variable,c=this.accumulatedWeightedInfNorm[s].variable,d=ze(fe(u,this.beta1),fe(l,1-this.beta1)),h=fe(c,this.beta2),p=fi(l),f=xu(h,p);u.assign(d),c.assign(f);let g=ze(fe(zt(r,n),zt(d,ze(f,this.epsilon))),a);a.assign(g)}),this.iteration.assign(ze(this.iteration,1)),this.accBeta1.assign(fe(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&bn(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&bn(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}},ZC=class extends vc{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(e=>e.name):Object.keys(t)).forEach((e,n)=>{let r=Array.isArray(t)?t[n].tensor:t[e];if(r==null)return;let i=ue.registeredVariables[e];xe(()=>{let s=ze(fe(this.c,r),i);i.assign(s)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=Ci(rn(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}},KL=class extends ZC{static get className(){return"Momentum"}constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=rn(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(e=>e.name):Object.keys(t)).forEach((e,n)=>{let r=ue.registeredVariables[e];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${e}/momentum`,variable:xe(()=>Kn(r).variable(!1))});let i=this.accumulations[n].variable,s=Array.isArray(t)?t[n].tensor:t[e];s!=null&&xe(()=>{let a,o=ze(fe(this.m,i),s);this.useNesterov?a=ze(fe(this.c,ze(s,fe(o,this.m))),r):a=ze(fe(this.c,o),r),i.assign(o),r.assign(a)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&bn(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=!1;this.accumulations=t.map(n=>({originalName:n.name,variable:n.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}},qL=class extends vc{static get className(){return"RMSProp"}constructor(t,e=.9,n=0,r=null,i=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=ue.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(e=>e.name):Object.keys(t)).forEach((e,n)=>{let r=ue.registeredVariables[e],i=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${e}/rms`,variable:xe(()=>Kn(r).variable(i))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${e}/momentum`,variable:xe(()=>Kn(r).variable(i))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${e}/mg`,variable:xe(()=>Kn(r).variable(i))});let s=Array.isArray(t)?t[n].tensor:t[e];if(s==null)return;let a=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;xe(()=>{let l=ze(fe(a,this.decay),fe(xr(s),1-this.decay));if(this.centered){let u=this.accumulatedMeanGrads[n].variable,c=ze(fe(u,this.decay),fe(s,1-this.decay)),d=zt(fe(s,this.learningRate),Zi(Dt(l,ze(xr(c),this.epsilon)))),h=ze(fe(o,this.momentum),d);a.assign(l),u.assign(c),o.assign(h);let p=Dt(r,h);r.assign(p)}else{let u=ze(fe(a,this.decay),fe(xr(s),1-this.decay)),c=ze(fe(o,this.momentum),zt(fe(s,this.learningRate),Zi(ze(u,this.epsilon))));a.assign(u),o.assign(c);let d=Dt(r,c);r.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&bn(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&bn(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&bn(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedMoments=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}},IIe=[WL,VL,jL,XL,KL,qL,ZC];function TIe(){for(let t of IIe)cq(t)}var us={};wn(us,{CompositeArrayBuffer:()=>fc,browserFiles:()=>DIe,browserHTTPRequest:()=>$Ie,concatenateArrayBuffers:()=>f1e,copyModel:()=>L1e,decodeWeights:()=>L7,decodeWeightsStream:()=>B7,encodeWeights:()=>l1e,fromMemory:()=>GIe,fromMemorySync:()=>mq,getLoadHandlers:()=>_1e,getModelArtifactsForJSON:()=>O3,getModelArtifactsForJSONSync:()=>$7,getModelArtifactsInfoForJSON:()=>Mw,getSaveHandlers:()=>w1e,getWeightSpecs:()=>mF,http:()=>YL,isHTTPScheme:()=>SF,listModels:()=>D1e,loadWeights:()=>LIe,moveModel:()=>O1e,registerLoadRouter:()=>b1e,registerSaveRouter:()=>x1e,removeModel:()=>P1e,weightsLoaderFactory:()=>hq,withSaveHandler:()=>HIe,withSaveHandlerSync:()=>WIe});var CIe="model",MIe=".json",kIe=".weights.bin";function QW(t){return new Promise(e=>setTimeout(e)).then(t)}var RI=class _F{constructor(e){if(!Ie().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(_F.URL_SCHEME)&&(e=e.slice(_F.URL_SCHEME.length)),(e==null||e.length===0)&&(e=CIe),this.modelJsonFileName=e+MIe,this.weightDataFileName=e+kIe}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let n=fc.join(e.weightData),r=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let i=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],s=U7(e,i),a=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=a,await QW(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){let l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=r,await QW(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Mw(e)}}}};RI.URL_SCHEME="downloads://";var NIe=class{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,e)=>{let n=new FileReader;n.onload=r=>{let i=JSON.parse(r.target.result),s=i.modelTopology;if(s==null){e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(i.weightsManifest==null){e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:s});return}let a=O3(i,o=>this.loadWeights(o));t(a)},n.onerror=r=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(t){let e=[],n=[];for(let s of t)e.push(...s.weights),n.push(...s.paths);let r=this.checkManifestAndWeightFiles(t),i=n.map(s=>this.loadWeightsFile(s,r[s]));return Promise.all(i).then(s=>[e,s])}loadWeightsFile(t,e){return new Promise((n,r)=>{let i=new FileReader;i.onload=s=>{let a=s.target.result;n(a)},i.onerror=s=>r(`Failed to weights data from file of path '${t}'.`),i.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){let e=[],n=this.weightsFiles.map(i=>JW(i.name)),r={};for(let i of t)i.paths.forEach(s=>{let a=JW(s);if(e.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),n.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);r[s]=this.weightsFiles[n.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}},RIe=t=>Ie().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(RI.URL_SCHEME)?FIe(t.slice(RI.URL_SCHEME.length)):null;co.registerSaveRouter(RIe);function FIe(t="model"){return new RI(t)}function DIe(t){return new NIe(t)}function eV(t,e,n,r){a(t),n=n??0,r=r??1,o(n,r);let i=0,s=l=>(l.then(u=>{let c=n+ ++i/t.length*(r-n);return e(c),u}),l);function a(l){ee(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,u){ee(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),ee(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),ee(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(t.map(s))}async function dq(t,e){e==null&&(e={});let n=e.fetchFunc==null?Ie().platform.fetch:e.fetchFunc,r=t.map(s=>n(s,e.requestInit,{isBinary:!0})),i=(e.onProgress==null?await Promise.all(r):await eV(r,e.onProgress,0,.5)).map(s=>s.arrayBuffer());return e.onProgress==null?await Promise.all(i):await eV(i,e.onProgress,.5,1)}function PIe(t,e){var n;let r=e.fetchFunc==null?Ie().platform.fetch:e.fetchFunc,i=0,s;return(n=e.onProgress)===null||n===void 0||n.call(e,0),new ReadableStream({pull:async a=>{for(var o;i<t.length;){s||(s=(await r(t[i],e.requestInit,{isBinary:!0})).body.getReader());let{done:l,value:u}=await s.read();if(l){i++,s=void 0,(o=e.onProgress)===null||o===void 0||o.call(e,i/t.length);continue}a.enqueue(u);return}a.close()}})}async function LIe(t,e="",n,r){return hq(i=>dq(i,{requestInit:r}))(t,e,n)}function hq(t){return async(e,n="",r)=>{let i=e.map(()=>!1),s={},a=r!=null?r.map(()=>!1):[],o=[];if(e.forEach((p,f)=>{let g=0;p.weights.forEach(y=>{let m="quantization"in y?y.quantization.dtype:y.dtype,b=Yp[m]*fr(y.shape),w=()=>{i[f]=!0,s[f]==null&&(s[f]=[]),s[f].push({manifestEntry:y,groupOffset:g,sizeBytes:b})};r!=null?r.forEach((_,S)=>{_===y.name&&(w(),a[S]=!0)}):w(),o.push(y.name),g+=b})}),!a.every(p=>p)){let p=r.filter((f,g)=>!a[g]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}let l=i.reduce((p,f,g)=>(f&&p.push(g),p),[]),u=[];l.forEach(p=>{e[p].paths.forEach(f=>{let g=n+(n.endsWith("/")?"":"/")+f;u.push(g)})});let c=await t(u),d={},h=0;return l.forEach(p=>{let f=e[p].paths.length,g=new fc(c.slice(h,h+f));s[p].forEach(y=>{let m=g.slice(y.groupOffset,y.groupOffset+y.sizeBytes),b=L7(m,[y.manifestEntry]);for(let w in b)d[w]=b[w]}),h+=f}),d}}var OIe="application/octet-stream",BIe="application/json",JL=class{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(ee(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=Ie().platform.fetch,ee(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&ee(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{},this.loadOptions=e}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r=U7(t,n);if(e.body.append("model.json",new Blob([JSON.stringify(r)],{type:BIe}),"model.json"),t.weightData!=null){let s=fc.join(t.weightData);e.body.append("model.weights.bin",new Blob([s],{type:OIe}),"model.weights.bin")}let i=await this.fetch(this.path,e);if(i.ok)return{modelArtifactsInfo:Mw(t),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){let t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch{let s=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?s+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":s+=" Please make sure the server is serving valid JSON for this request.",new Error(s)}let n=e.modelTopology,r=e.weightsManifest;if(n==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let t=await this.loadModelJSON();return O3(t,e=>this.loadWeights(e))}async loadStream(){let t=await this.loadModelJSON(),e=await this.getWeightUrls(t.weightsManifest),n=mF(t.weightsManifest),r=()=>PIe(e,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:n,getWeightStream:r})}async getWeightUrls(t){let e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=UIe(e),i=this.weightPathPrefix||n,s=[],a=[];for(let o of t)for(let l of o.paths)this.weightUrlConverter!=null?a.push(this.weightUrlConverter(l)):s.push(i+l+r);return this.weightUrlConverter&&s.push(...await Promise.all(a)),s}async loadWeights(t){let e=await this.getWeightUrls(t),n=mF(t),r=await dq(e,this.loadOptions);return[n,r]}};JL.URL_SCHEME_REGEX=/^https?:\/\//;function UIe(t){let e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),i=n>e?t.substring(n):"";return[r+"/",i]}function SF(t){return t.match(JL.URL_SCHEME_REGEX)!=null}var pq=(t,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let n=!0;if(Array.isArray(t)?n=t.every(r=>SF(r)):n=SF(t),n)return YL(t,e)}return null};co.registerSaveRouter(pq);co.registerLoadRouter(pq);function YL(t,e){return new JL(t,e)}function $Ie(t,e){return YL(t,e)}var wN=class{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}},fq=class{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}},zIe=class{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}};function GIe(t,e,n,r){let i=arguments;return new zIe(mq(...i))}function mq(t,e,n,r){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new wN(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new wN({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new wN({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))}function HIe(t){return new fq(t)}function WIe(t){return new fq(t)}var gq={};wn(gq,{confusionMatrix:()=>jIe});function VIe(t,e,n){let r=q(t,"labels","confusionMatrix"),i=q(e,"predictions","confusionMatrix");ee(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),ee(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),ee(i.rank===1,()=>`Expected the rank of predictions to be 1, but got ${i.rank}`),ee(r.shape[0]===i.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${i.shape[0]}. Labels and predictions should have the same number of elements.`),ee(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let s=Yy(ft(r,"int32"),n),a=Yy(ft(i,"int32"),n),o=Nn(s),l=kn(o,a);return ft(l,"int32")}var jIe=ce({confusionMatrix_:VIe}),Ww={};wn(Ww,{draw:()=>eTe,fromPixels:()=>tTe,fromPixelsAsync:()=>YIe,toPixels:()=>QIe});var Hh,tV=!1;function yq(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,i=!1,s=!1,a=!1,o=!1;if(t.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)s=!0;else if(t.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&t instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if(m1(CI,ue.backendName)!=null){let h={pixels:t},p={numChannels:e};return ue.runKernel(CI,h,p)}let[l,u]=i?[t.videoWidth,t.videoHeight]:[t.width,t.height],c;if(a)c=t.getContext("2d").getImageData(0,0,l,u).data;else if(r||n)c=t.data;else if(s||i||o){if(Hh==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Hh=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Hh=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Hh.canvas.width=l,Hh.canvas.height=u,Hh.drawImage(t,0,0,l,u),c=Hh.getImageData(0,0,l,u).data}let d;if(e===4)d=new Int32Array(c);else{let h=l*u;d=new Int32Array(h*e);for(let p=0;p<h;p++)for(let f=0;f<e;++f)d[p*e+f]=c[p*4+f]}return GC(d,[u,l,e],"int32")}function XIe(t){return t!=null&&t.data instanceof Uint8Array}function KIe(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function qIe(t){return t!=null&&t.width!==0&&t.height!==0}function JIe(t){return KIe()&&!(t instanceof ImageBitmap)&&qIe(t)&&!XIe(t)}async function YIe(t,e=3){let n=null;if(Ie().getBool("WRAP_TO_IMAGEBITMAP")&&JIe(t)){let r;try{r=await createImageBitmap(t,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===t.width&&r.height===t.height?n=r:n=t}else n=t;return yq(n,e)}function vq(t){if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);let e=t.rank===2?1:t.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`)}function ZIe(t){let e=(t==null?void 0:t.alpha)||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function QIe(t,e){let n=q(t,"img","toPixels");if(!(t instanceof In)){let u=n;n=ft(u,"int32"),u.dispose()}vq(n);let[r,i]=n.shape.slice(0,2),s=n.rank===2?1:n.shape[2],a=await n.data(),o=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(i*r*4);for(let u=0;u<r*i;++u){let c=[0,0,0,255];for(let h=0;h<s;h++){let p=a[u*s+h];if(n.dtype==="float32"){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if(n.dtype==="int32"&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);s===1?(c[0]=p*o,c[1]=p*o,c[2]=p*o):c[h]=p*o}let d=u*4;l[d+0]=Math.round(c[0]),l[d+1]=Math.round(c[1]),l[d+2]=Math.round(c[2]),l[d+3]=Math.round(c[3])}if(e!=null){tV||m1(lC,ue.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),tV=!0),e.width=i,e.height=r;let u=e.getContext("2d"),c=new ImageData(l,i,r);u.putImageData(c,0,0)}return n!==t&&n.dispose(),l}function eTe(t,e,n){let r=q(t,"img","draw");if(!(t instanceof In)){let a=r;r=ft(a,"int32"),a.dispose()}vq(r),ZIe(n==null?void 0:n.imageOptions);let i={image:r},s={canvas:e,options:n};ue.runKernel(lC,i,s)}var tTe=ce({fromPixels_:yq}),ZL={};wn(ZL,{prepareAndValidate:()=>xq});function xq(t,e){let n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if(fr(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);let i=e.shape,s=i[i.length-1],a=1;for(let d=0;d<i.length-1;++d)a*=i[d];let o=t.shape,l=i.slice();l.pop();let u=1;for(let d=s;d<n;++d)u*=o[d],l.push(o[d]);let c=[...v0(t.shape).map(d=>d/u),1].slice(0,s);return[l,a,u,c]}var Ni={};wn(Ni,{assertParamsValid:()=>rTe,computeFlatOffset:()=>lTe,computeOutShape:()=>sTe,getNormalizedAxes:()=>aTe,isSliceContinous:()=>oTe,maskToAxes:()=>iTe,parseSliceParams:()=>Cq,sliceInfo:()=>uTe,startForAxis:()=>Iq,startIndicesWithElidedDims:()=>Sq,stopForAxis:()=>Tq,stopIndicesWithElidedDims:()=>Aq,stridesForAxis:()=>Eq,stridesWithElidedDims:()=>bq});var AF=-2,nTe=-1;function rTe(t,e,n){let r=t.shape.length;ee(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),ee(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let i=0;i<r;++i)ee(e[i]+n[i]<=t.shape[i],()=>`Error in slice${r}D: begin[${i}] + size[${i}] (${e[i]+n[i]}) would overflow input.shape[${i}] (${t.shape[i]})`)}function iTe(t){let e=[],n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function sTe(t,e,n){let r=[];for(let i=0;i<t.length;i++)r[i]=Math.ceil((e[i]-t[i])/n[i]);return r}function bq(t,e,n,r){let i=[...t];for(let s=i.length;s<r.length;s++)i.push(1);for(let s=0;s<n;s++)s===0?i[e]=1:(i.splice(e,0,1),i.pop());return i}function wq(t,e,n){return n<=t?n:n-(e-1)}function _q(t,e){let n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function aTe(t,e,n,r,i,s,a,o,l){let u=t.length,c=new Array(u),d=new Array(u),h=new Array(u);if(e.length&&n>0){let p=e[0],f=n+1;c=Sq(a,p,f,r,t),d=Aq(o,p,f,i,t),h=bq(s,p,f,t)}else for(let p=0;p<u;p++)c[p]=Iq(a,r,s,t,p,l),d[p]=Tq(o,i,s,t,p,l),h[p]=Eq(s,p,l);return{begin:c,end:d,strides:h}}function Sq(t,e,n,r,i){let s=[...i],a=_q(n,e);for(let o=0;o<s.length;o++)if(a.indexOf(o)>-1)s[o]=0;else{let l=wq(e,n,o),u=r[l];t&1<<l&&(u=0),s[o]=u}return s}function Aq(t,e,n,r,i){let s=[...i],a=_q(n,e);for(let o=0;o<s.length;o++)if(a.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let l=wq(e,n,o),u=r[l];t&1<<l&&(u=Number.MAX_SAFE_INTEGER),s[o]=u}for(let o=0;o<s.length;o++){let l=i[o];s[o]<0&&(s[o]+=l),s[o]=p1(0,s[o],i[o])}return s}function Eq(t,e,n){let r=t[e];return(n&1<<e||r==null)&&(r=1),r}function Iq(t,e,n,r,i,s){let a=e[i],o=n[i]||1;(t&1<<i||s&1<<i||a==null)&&(o>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);let l=r[i];return a<0&&(a+=l),a=p1(0,a,l-1),a}function Tq(t,e,n,r,i,s){let a=e[i],o=n[i]||1;(t&1<<i||s&1<<i||a==null)&&(o>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);let l=r[i];return a<0&&(a+=l),o>0?a=p1(0,a,l):a=p1(-1,a,l-1),a}function oTe(t,e,n){let r=n.length;for(let i=0;i<n.length;i++)if(n[i]>1){r=i;break}for(let i=r+1;i<n.length;i++)if(e[i]>0||n[i]!==t[i])return!1;return!0}function lTe(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function Cq(t,e,n){let r,i=t.shape.length;typeof e=="number"?r=[e,...new Array(i-1).fill(0)]:e.length<i?r=e.concat(new Array(i-e.length).fill(0)):r=e.slice(),r.forEach(a=>{ee(a!==-1,()=>"slice() does not support negative begin indexing.")});let s;return n==null?s=new Array(i).fill(-1):typeof n=="number"?s=[n,...new Array(i-1).fill(-1)]:n.length<i?s=n.concat(new Array(i-n.length).fill(-1)):s=n,s=s.map((a,o)=>a>=0?a:(ee(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${o}.`),t.shape[o]-r[o])),[r,s]}function uTe(t,e,n,r,i,s,a,o,l){let u;if(r==null?(u=new Array(e.length),u.fill(1)):u=r,a!=null&&a&a-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,d={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:u.slice(),beginMask:i,endMask:s,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<d.dims;b++)c&&1<<b&o&&d.numAddAxisAfterEllipsis++,1<<b&a&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);let h={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};cTe(d,h);let p=!0,f=!0,g=!0,y=[],m=[];for(let b=0;b<t.length;++b){if(h.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);let w=!!(h.shrinkAxisMask&1<<b),_=t[b];if(_===-1){y.push(w?1:-1);continue}let S=[h.beginMask&1<<b,h.endMask&1<<b],E=[h.strides[b]>0?0:-1,h.strides[b]>0?_:_-1];if(w&&h.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&h.strides[b]===1;let C=!!(h.beginMask&1<<b&&h.endMask&1<<b);if(h.beginValid&&h.endValid){if(w){let R=h.begin[b]<0?_+h.begin[b]:h.begin[b];if(h.begin[b]=R,h.end[b]=h.begin[b]+1,R<0||R>=_)throw Error(`slice index ${h.begin[b]} of dimension ${b} out of bounds.`)}else h.begin[b]=nV(h.begin[b],0,h.strides[b],_,S,E),h.end[b]=nV(h.end[b],1,h.strides[b],_,S,E);let k=h.strides[b]===1&&h.begin[b]===0&&h.end[b]===_;p=p&&k,f=f&&(b===0&&h.strides[b]===1||k)}else p=p&&h.strides[b]===1&&C,f=f&&(b===0&&h.strides[b]===1||C);let T,M=!1;if(h.beginValid&&h.endValid?(T=h.end[b]-h.begin[b],M=!0):w?(T=1,M=!0):C&&_>=0&&(h.strides[b]<0?T=-_:T=_,M=!0),M){let k;T===0||T<0!=h.strides[b]<0?k=0:k=Math.trunc(T/h.strides[b])+(T%h.strides[b]!==0?1:0),y.push(k)}else y.push(-1)}for(let b=0;b<h.finalShapeGatherIndices.length;++b){let w=h.finalShapeGatherIndices[b];w>=0?m.push(y[w]):w===AF&&m.push(1)}return{finalShapeSparse:m.filter((b,w)=>h.finalShapeGatherIndices[w]!==AF),finalShape:m,isIdentity:p,sliceDim0:f,isSimpleSlice:g,begin:h.begin,end:h.end,strides:h.strides}}function cTe(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){let i=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<i;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(AF),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[r]),t.end!=null&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(nTe),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}function nV(t,e,n,r,i,s){if(i[e])return n>0?s[e]:s[e+1&1];{let a=t<0?r+t:t;return a<s[0]?s[0]:a>s[1]?s[1]:a}}var dTe="4.22.0",Mq=class{static sgd(t){return new ZC(t)}static momentum(t,e,n=!1){return new KL(t,e,n)}static rmsprop(t,e=.9,n=0,r=null,i=!1){return new qL(t,e,n,r,i)}static adam(t=.001,e=.9,n=.999,r=null){return new jL(t,e,n,r)}static adadelta(t=.001,e=.95,n=null){return new WL(t,e,n)}static adamax(t=.002,e=.9,n=.999,r=null,i=0){return new XL(t,e,n,r,i)}static adagrad(t,e=.1){return new VL(t,e)}},Qh=Mq,hTe=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function QL(){return new Promise(t=>hTe(()=>t()))}var W={};wn(W,{ERF_A1:()=>TTe,ERF_A2:()=>CTe,ERF_A3:()=>MTe,ERF_A4:()=>kTe,ERF_A5:()=>NTe,ERF_P:()=>ITe,PARALLELIZE_THRESHOLD:()=>eO,RowPartitionType:()=>jl,SELU_SCALE:()=>Nq,SELU_SCALEALPHA:()=>kq,applyActivation:()=>JC,assertAndGetBroadcastShape:()=>_r,assertAxesAreInnerMostDims:()=>u_e,assertParamsConsistent:()=>pTe,assignToTypedArray:()=>OTe,axesAreInnerMostDims:()=>dL,calculateShapes:()=>BK,checkEinsumDimSizes:()=>HTe,checkPadOnDimRoundingMode:()=>js,combineLocations:()=>sK,combineRaggedTensorToTensorShapes:()=>mTe,complexWithEvenIndex:()=>DTe,complexWithOddIndex:()=>PTe,computeConv2DInfo:()=>kw,computeConv3DInfo:()=>J7,computeDefaultPad:()=>X3,computeDilation2DInfo:()=>owe,computeOptimalWindowSize:()=>xTe,computeOutAndReduceShapes:()=>aK,computeOutShape:()=>fTe,computePool2DInfo:()=>q7,computePool3DInfo:()=>lwe,convertConv2DDataFormat:()=>Y7,decodeEinsumEquation:()=>zTe,eitherStridesOrDilationsAreOne:()=>vu,expandShapeToKeepDim:()=>nf,exponent:()=>UTe,exponents:()=>BTe,fromStringArrayToUint8:()=>cCe,fromUint8ToStringArray:()=>uCe,getAxesPermutation:()=>oK,getBroadcastDims:()=>rK,getComplexWithIndex:()=>LTe,getEinsumComputePath:()=>WTe,getEinsumPermutation:()=>GTe,getFusedBiasGradient:()=>qC,getFusedDyActivation:()=>KC,getImageCenter:()=>bTe,getInnerMostAxes:()=>c_e,getPermuted:()=>_Te,getRaggedRank:()=>yTe,getReductionAxes:()=>bi,getReshaped:()=>wTe,getReshapedPermuted:()=>STe,getRowPartitionTypesHelper:()=>gTe,getSliceBeginCoords:()=>ATe,getSliceSize:()=>ETe,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>KTe,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>qTe,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>JTe,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>QTe,getSparseReshapeInputOutputMismatchErrorMessage:()=>tCe,getSparseReshapeInputOutputMultipleErrorMessage:()=>eCe,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>YTe,getSparseReshapeNegativeOutputDimErrorMessage:()=>ZTe,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>sCe,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>nCe,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>rCe,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>iCe,getUndoAxesPermutation:()=>hL,isIdentityPermutation:()=>VTe,log:()=>xbe,mergeRealAndImagArrays:()=>RTe,prepareAndValidate:()=>xq,prepareSplitSize:()=>XTe,segment_util:()=>Rq,shouldFuse:()=>YC,slice_util:()=>Ni,splitRealAndImagArrays:()=>FTe,stridesOrDilationsArePositive:()=>tf,tupleValuesAreOne:()=>Pd,upcastType:()=>uo,validateDefaultValueShape:()=>vTe,validateInput:()=>WC,validateUpdateShape:()=>DL,warn:()=>rd});function pTe(t,e){let n=t[0].length;t.forEach((i,s)=>{ee(i.length===n,()=>`Error in concat${n}D: rank of tensors[${s}] must be the same as the rank of the rest (${n})`)}),ee(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=t[0];t.forEach((i,s)=>{for(let a=0;a<n;a++)ee(a===e||i[a]===r[a],()=>`Error in concat${n}D: Shape of tensors[${s}] (${i}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function fTe(t,e){let n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}var jl;(function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"})(jl||(jl={}));function mTe(t,e,n){let r=new Array;if(n==null&&e==null)return r;if(e==null)for(;r.length<t+n.length;)r.push(-1);else r=e.slice();if(n==null)return r;if(t+n.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t+n.length}, but shape.rank = ${r.length}`);for(let i=1;i<n.length;++i){let s=n[i],a=r[r.length-n.length+i],o=r[a];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${i+t}] = ${s} but shape[${i+t}] = ${o}`)}else r[a]=s}return r}function gTe(t){let e={FIRST_DIM_SIZE:jl.FIRST_DIM_SIZE,VALUE_ROWIDS:jl.VALUE_ROWIDS,ROW_LENGTHS:jl.ROW_LENGTHS,ROW_SPLITS:jl.ROW_SPLITS,ROW_LIMITS:jl.ROW_LIMITS,ROW_STARTS:jl.ROW_STARTS},n=[];for(let r of t)if(r in e)n.push(e[r]);else break;return n}function yTe(t){return t.length===0?0:t[0]===jl.FIRST_DIM_SIZE?t.length-1:t.length}function vTe(t,e){if(t==null||e==null)return;let n=t.length,r=e.length;if(n>=r)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let i=0;i<Math.min(n,r-1);++i){let s=t[i],a=e[i+1];if(s>=0&&a>=0&&s!==1&&s!==a)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${i-t.length}] = ${s} but ragged tensor input.flatValues.shape[${i-t.length}] = ${a}`)}}var eO=30;function xTe(t){return t<=eO?t:TI(t,Math.floor(Math.sqrt(t)))}function bTe(t,e,n){let r=n*(typeof t=="number"?t:t[0]),i=e*(typeof t=="number"?t:t[1]);return[r,i]}function wTe(t,e,n,r=!0){let i=[];if(r)i=i.concat(e.slice(0)),i.push(t[0]/n),i=i.concat(t.slice(1));else{i=i.concat(t[0]);let s=e.length;for(let a=0;a<s;++a)i=i.concat([t[a+1]/e[a],e[a]]);i=i.concat(t.slice(s+1))}return i}function _Te(t,e,n=!0){let r=[];if(n){r.push(e);for(let i=e+1;i<t;++i)i<=2*e?(r.push(i),r.push(i-(e+1))):r.push(i)}else{let i=[],s=[];for(let a=1;a<t;++a)a>=e*2+1||a%2===1?s.push(a):i.push(a);r.push(...i),r.push(0),r.push(...s)}return r}function STe(t,e,n,r=!0){let i=[];r?i.push(t[0]/n):i.push(t[0]*n);for(let s=1;s<t.length;++s)s<=e.length?r?i.push(e[s-1]*t[s]):i.push(t[s]/e[s-1]):i.push(t[s]);return i}function ATe(t,e){let n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function ETe(t,e,n){let r=t.slice(0,1);for(let i=0;i<n;++i)r.push(t[i+1]-e[i][0]-e[i][1]);return r}var kq=1.7580993408473768,Nq=1.0507009873554805,ITe=.3275911,TTe=.254829592,CTe=-.284496736,MTe=1.421413741,kTe=-1.453152027,NTe=1.061405429;function RTe(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);let n=new Float32Array(t.length*2);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function FTe(t){let e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function DTe(t){let e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let i=0;i<t.length;i+=4)n[Math.floor(i/4)]=t[i],r[Math.floor(i/4)]=t[i+1];return{real:n,imag:r}}function PTe(t){let e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let i=2;i<t.length;i+=4)n[Math.floor(i/4)]=t[i],r[Math.floor(i/4)]=t[i+1];return{real:n,imag:r}}function LTe(t,e){let n=t[e*2],r=t[e*2+1];return{real:n,imag:r}}function OTe(t,e,n,r){t[r*2]=e,t[r*2+1]=n}function BTe(t,e){let n=new Float32Array(t/2),r=new Float32Array(t/2);for(let i=0;i<Math.ceil(t/2);i++){let s=(e?2:-2)*Math.PI*(i/t);n[i]=Math.cos(s),r[i]=Math.sin(s)}return{real:n,imag:r}}function UTe(t,e,n){let r=(n?2:-2)*Math.PI*(t/e),i=Math.cos(r),s=Math.sin(r);return{real:i,imag:s}}var _N="->",$Te=/->/g,rV=",",iV="...";function zTe(t,e){t=t.replace(/\s/g,"");let n=(t.length-t.replace($Te,"").length)/_N.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${_N}").`);let[r,i]=t.split(_N);ee(r.indexOf(iV)===-1,()=>`The ellipsis notation ("${iV}") is not supported yet.`);let s=r.split(rV),a=s.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let h=0;h<i.length;++h){let p=i[h];if(!s.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);o.indexOf(p)===-1&&o.push(p)}for(let h=0;h<r.length;++h){let p=r[h];o.indexOf(p)===-1&&p!==rV&&o.push(p)}let l=new Array(s.length);for(let h=0;h<a;++h){if(new Set(s[h].split("")).size!==s[h].length)throw new Error(`Found duplicate axes in input component ${s[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let p=0;p<s[h].length;++p)l[h].push(o.indexOf(s[h][p]))}let u=o.length,c=i.length,d=[];for(let h=c;h<u;++h)d.push(h);return{allDims:o,summedDims:d,idDims:l}}function GTe(t,e){let n=new Array(t);n.fill(-1);for(let i=0;i<e.length;++i)n[e[i]]=i;let r=[];for(let i=0;i<t;++i)n[i]===-1&&r.push(i);return n=n.filter(i=>i!==-1),{permutationIndices:n,expandDims:r}}function HTe(t,e,n){let r=new Array(t);for(let i=0;i<n.length;++i){let s=n[i].shape;for(let a=0;a<e[i].length;++a)r[e[i][a]]===void 0?r[e[i][a]]=s[a]:ee(r[e[i][a]]===s[a],()=>`Expected dimension ${r[e[i][a]]} at axis ${a} of input shaped ${JSON.stringify(s)}, but got dimension ${s[a]}`)}}function WTe(t,e){let n=t,r=[],i=0;t.length===0&&n.push(-1),i=t.length+1;for(let a=0;a<i;++a)r.push([]);let s=[];for(let a=0;a<n.length;++a){let o=n[a],l=jTe(e,o);for(let u of l)s.indexOf(u)===-1&&(r[a].push(u),s.push(u))}return{path:n,steps:r}}function VTe(t){return t.every((e,n)=>e===n)}function jTe(t,e){let n=[];for(let r=0;r<t.length;++r)(t[r].length===0||t[r].indexOf(e)!==-1||e===-1)&&n.push(r);return n}function XTe(t,e,n=0){let r=[];if(typeof e=="number")ee(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(t.shape[n]/e);else{let i=e.reduce((a,o)=>(o===-1&&(a+=1),a),0);ee(i<=1,()=>"There should be only one negative value in split array.");let s=e.indexOf(-1);if(s!==-1){let a=e.reduce((o,l)=>l>0?o+l:o);e[s]=t.shape[n]-a}ee(t.shape[n]===e.reduce((a,o)=>a+o),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}function KTe(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function qTe(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function JTe(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}function YTe(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function ZTe(t,e){return`size ${t} must be non-negative, not ${e}`}function QTe(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function eCe(t,e){let n=fr(t),r=fr(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${t} outputShape= ${e}`}function tCe(t,e){let n=fr(t),r=fr(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${t} outputShape=${e}`}function nCe(){return"segment ids must be >= 0"}function rCe(){return"segment ids are not increasing"}function iCe(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function sCe(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}var Rq={};wn(Rq,{collectGatherOpShapeInfo:()=>lCe,computeOutShape:()=>oCe,segOpComputeOptimalWindowSize:()=>aCe});function aCe(t,e){let n=!1,r;for(t<=eO?(r=t,n=!0):r=TI(t,Math.floor(Math.sqrt(t)));!n;)r>e||r===t?n=!0:r=TI(t,r+1);return r}function oCe(t,e,n){let r=[],i=t.length;for(let s=0;s<i;s++)s!==e?r.push(t[s]):r.push(n);return r}function lCe(t,e,n,r){let i=e.shape.length,s=t.shape.length;if(r!==0&&(r<-i||r>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${r}`);if(r<0&&(r+=i),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(t.shape[d]!==e.shape[d])throw new Error(`x.shape[${d}]: ${t.shape[d]} should be equal to indices.shape[${d}]: ${e.shape[d]}.`);let a=t.shape[n],o=[],l=1,u=1,c=1;for(let d=0;d<r;++d)o.push(t.shape[d]),l*=t.shape[d];for(let d=r;d<n;d++)o.push(t.shape[d]),u*=t.shape[d];for(let d=r;d<i;d++)o.push(e.shape[d]);for(let d=n+1;d<s;d++)o.push(t.shape[d]),c*=t.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:a,outputShape:o}}function uCe(t){try{return t.map(e=>kI(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function cCe(t){return t.map(e=>Tw(e))}var bu={};wn(bu,{nonMaxSuppressionV3Impl:()=>ZK,nonMaxSuppressionV4Impl:()=>QK,nonMaxSuppressionV5Impl:()=>eq,whereImpl:()=>zK});TIe();var Fq={kernelName:x0,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>fe(t,Xm(ft(n,"float32"),-1))}}},dCe={kernelName:If,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>{let r=xr(ft(n,"float32")),i=Zi(Dt(rn(1),r));return Mr(zt(t,i))}}}},hCe={kernelName:Tf,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>{let r=Zi(Dt(xr(ft(n,"float32")),1));return zt(t,r)}}}},pCe={kernelName:th,inputsToSave:["a","b"],gradFunc:(t,e)=>{let[n,r]=e,i=_r(n.shape,r.shape);return{a:()=>{let s=t,a=bi(n.shape,i);return a.length>0&&(s=Xt(s,a)),ve(s,n.shape)},b:()=>{let s=t,a=bi(r.shape,i);return a.length>0&&(s=Xt(s,a)),ve(s,r.shape)}}}},fCe={kernelName:Cf,saveAllInputs:!0,gradFunc:(t,e)=>{let n={};return e.forEach((r,i)=>{n[i]=()=>t.clone()}),n}},mCe={kernelName:_0,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>Kn(n)}}},gCe={kernelName:S0,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>Kn(n)}}},yCe={kernelName:Mf,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>zt(t,Zi(Dt(rn(1),xr(ft(n,"float32")))))}}},vCe={kernelName:kf,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>{let r=Zi(ze(rn(1),xr(ft(n,"float32"))));return zt(t,r)}}}},xCe={kernelName:Ff,inputsToSave:["a","b"],gradFunc:(t,e)=>{let[n,r]=e,i=_r(n.shape,r.shape);return{a:()=>{let s=ze(xr(n),xr(r)),a=fe(t,zt(r,s)),o=bi(n.shape,i);return o.length>0&&(a=Xt(a,o)),ve(a,n.shape)},b:()=>{let s=ze(xr(n),xr(r)),a=Mr(fe(t,zt(n,s))),o=bi(r.shape,i);return o.length>0&&(a=Xt(a,o)),ve(a,r.shape)}}}},bCe={kernelName:Nf,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>zt(t,ze(xr(ft(n,"float32")),1))}}},wCe={kernelName:Rf,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>zt(t,Dt(rn(1),xr(ft(n,"float32"))))}}};function _Ce(t,e,n,r,i,s){let a=q(t,"dy","avgPool3dGrad"),o=q(e,"input","avgPool3dGrad"),l=a,u=o,c=!1;o.rank===4&&(c=!0,l=ve(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),u=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ee(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),ee(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),js("avgPool3dGrad",i,s);let d={dy:l,input:u},h={filterSize:n,strides:r,pad:i,dimRoundingMode:s},p=ue.runKernel(sw,d,h);return c?ve(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var SCe=ce({avgPool3dGrad_:_Ce}),ACe={kernelName:A0,inputsToSave:["x"],gradFunc:(t,e,n)=>{let[r]=e,{filterSize:i,strides:s,pad:a,dimRoundingMode:o}=n;return{x:()=>SCe(t,r,i,s,a,o)}}};function ECe(t,e,n,r,i){let s=q(t,"dy","avgPoolGrad"),a=q(e,"input","avgPoolGrad");ee(a.rank===s.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${s.rank})`);let o=a,l=s,u=!1;a.rank===3&&(u=!0,o=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=ve(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ee(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),ee(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let c={dy:l,input:o},d={filterSize:n,strides:r,pad:i},h=ue.runKernel(iw,c,d);return u?ve(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var ICe=ce({avgPoolGrad_:ECe}),TCe={kernelName:Df,inputsToSave:["x"],gradFunc:(t,e,n)=>{let[r]=e,{filterSize:i,strides:s,pad:a}=n;return{x:()=>ICe(t,r,i,s,a)}}},CCe={kernelName:Pf,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{let[r,i]=e,{transposeA:s,transposeB:a}=n;return!s&&!a?{a:()=>kn(t,i,!1,!0),b:()=>kn(r,t,!0,!1)}:!s&&a?{a:()=>kn(t,i,!1,!1),b:()=>kn(t,r,!0,!1)}:s&&!a?{a:()=>kn(i,t,!1,!0),b:()=>kn(r,t,!1,!1)}:{a:()=>kn(i,t,!0,!0),b:()=>kn(t,r,!0,!0)}}},MCe={kernelName:E0,gradFunc:(t,e,n)=>{let{blockShape:r,crops:i}=n;return{x:()=>Uw(t,r,i)}}},kCe={kernelName:v7,gradFunc:(t,e,n)=>{let r=n,i=r.inputShape,s=r.shape,a=Array.from(s);for(let l=i.length-1;l>=0;l--)if(i[l]===s[l])a[l]=1;else if(i[l]!==1)throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${s}].`);let o=[];for(let l=0;l<a.length;l++)a[l]>1&&o.push(l);return{x:()=>Xt(t,o,!0)}}},NCe={kernelName:Lf,gradFunc:t=>({x:()=>t.clone()})},RCe={kernelName:Of,gradFunc:t=>({x:()=>Kn(t)})},FCe={kernelName:nh,inputsToSave:["x"],gradFunc:(t,e,n)=>{let[r]=e,{clipValueMin:i,clipValueMax:s}=n;return{x:()=>qi(Go(gc(r,i),ah(r,s)),t,Kn(t))}}},DCe={kernelName:ow,inputsToSave:["x"],gradFunc:Fq.gradFunc},PCe={kernelName:C0,saveAllInputs:!0,gradFunc:(t,e,n)=>{let r=e.map(o=>o.shape),{axis:i}=n,s=Vo(i,e[0].shape)[0],a=r.map(o=>o[s]);return aa(t,a,s).map(o=>()=>o)}},LCe={kernelName:Bf,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{let[r,i]=e,{dilations:s,strides:a,pad:o,dataFormat:l}=n;return ee(Pd(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>iL(r.shape,t,i,a,o,l),filter:()=>zL(r,t,i.shape,a,o,l)}}},OCe={kernelName:Uf,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{let[r,i]=e,{strides:s,pad:a,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>zs(t,i,s,a,o,1,l),filter:()=>zL(t,r,i.shape,s,a,o,l)}}};function BCe(t,e,n,r,i){let s=t;t.rank===4&&(s=ve(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let a=e;a.rank===4&&(a=ve(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),ee(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),ee(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),ee(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),ee(s.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`),ee(a.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${n[4]}).`);let o={x:s,dy:a},l={strides:r,pad:i,filterShape:n};return ue.runKernel(M0,o,l)}var UCe=ce({conv3DBackpropFilter_:BCe}),$Ce={kernelName:$f,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{let{dilations:r,strides:i,pad:s}=n;ee(Pd(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[a,o]=e;return{x:()=>tK(a.shape,t,o,i,s),filter:()=>UCe(a,t,o.shape,i,s)}}},zCe={kernelName:zf,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>fe(Mr(OC(ft(n,"float32"))),t)}}},GCe={kernelName:Gf,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>fe(BC(ft(n,"float32")),t)}}},HCe={kernelName:Hf,inputsToSave:["x"],gradFunc:(t,e,n)=>{let[r]=e,{axis:i,exclusive:s,reverse:a}=n;return{x:()=>{let o=oK([i],r.rank),l=EC(t,i,s,!a);return o!=null&&(l=Nn(l,o)),l}}}},WCe={kernelName:Wf,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{let{dilations:r,strides:i,pad:s,dimRoundingMode:a}=n,o=r??[1,1];ee(Pd(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[l,u]=e;return ee(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),ee(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),ee(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),ee(vu(i,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${o}'.`),js("depthwiseConv2d",s,a),{x:()=>qK(l.shape,t,u,i,s,o,a),filter:()=>KK(l,t,u.shape,i,s,o,a)}}},VCe={kernelName:Vf,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{let[r,i]=e,s={x:r,filter:i,dy:t},a={x:r,filter:i,dy:t};return{x:()=>ue.runKernel(jy,s,n),filter:()=>ue.runKernel(Xy,a,n)}}},jCe={kernelName:Xf,outputsToSave:[!0],gradFunc:(t,e)=>{let[n]=e,r={dy:t,y:n};return{x:()=>ue.runKernel(D0,r)}}},XCe={kernelName:Kf,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e,r=fe(ws(Mr(xr(n))),2/Math.sqrt(Math.PI));return{x:()=>fe(t,r)}}},KCe={kernelName:qf,outputsToSave:[!0],gradFunc:(t,e)=>{let[n]=e;return{x:()=>fe(t,n)}}},qCe={kernelName:L0,inputsToSave:["input"],gradFunc:(t,e)=>{let[n]=e;return{input:()=>ve(t,n.shape)}}},JCe={kernelName:Jf,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>fe(t,ws(n))}}},YCe={kernelName:Yf,gradFunc:t=>({x:()=>Kn(t)})},ZCe={kernelName:Zf,inputsToSave:["a","b"],gradFunc:(t,e)=>{let[n,r]=e,i=_r(n.shape,r.shape);return{a:()=>{let s=zt(t,ft(r,"float32")),a=bi(n.shape,i);return a.length>0?ve(Xt(s,a),n.shape):s},b:()=>{let s=fe(t,ft(n,"float32")),a=bi(r.shape,i);a.length>0&&(s=ve(Xt(s,a),r.shape));let o=xr(r);return Mr(zt(s,ft(o,"float32")))}}}},QCe={kernelName:Qf,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{let{varianceEpsilon:r}=n,[i,s,a,o]=e,l=o??rn(1),u=bi(s.shape,i.shape),c=[];if(s.rank===1){for(let g=0;g<i.shape.length-1;++g)c.push(i.shape[g]);c.push(1)}let d=Dt(i,s),h=fe(t,l),p=PC(ze(a,rn(r))),f=fe(fe(fe(p,p),p),rn(-.5));return{x:()=>s.rank===1?ve(fe(fe(t,Na(ve(p,[1,1,1,s.shape[0]]),c)),l),i.shape):ve(fe(fe(t,p),l),i.shape),mean:()=>{let g=fe(fe(p,rn(-1)),h);return s.rank===1&&(g=Xt(g,u)),ve(g,s.shape)},variance:()=>{let g=fe(fe(f,d),h);return s.rank===1&&(g=Xt(g,u)),ve(g,s.shape)},scale:()=>{let g=fe(d,p),y=fe(t,g);return s.rank===1&&(y=Xt(y,u)),ve(y,s.shape)},offset:()=>{let g=t;return s.rank===1&&(g=Xt(g,u)),ve(g,s.shape)}}}},eMe={kernelName:B0,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{let[r,i]=e,{axis:s,batchDims:a}=n,o=Vo(s,r.shape)[0],l=(u,c,d)=>()=>{let h=u.shape,p=c.size,f=h.slice(0,o),g=f.length,y=h.slice(s,h.length).slice(1),m=y.length,b=sV(0,g),w=sV(g+1,g+1+m),_=aV([f,[p],y]),S=ve(d,_),E=ve(c,[p]),C=aV([[g],b,w]),T=Nn(S,C),M=jC(T,E,u.shape[o]),k=hL(C);return M=Nn(M,k),M};if(a===1){let u=r.shape[0],c=r.split(u,0);return{x:()=>xi(c.map((d,h)=>l(d,i.slice(h,1),t.slice(h,1))())).reshape(r.shape),indices:()=>i}}else return{x:l(r,i,t),indices:()=>i}}};function sV(t,e){let n=[];for(let r=t;r<e;++r)n.push(r);return n}function aV(t){let e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}var tMe={kernelName:em,inputsToSave:["a","b"],gradFunc:(t,e)=>{let[n,r]=e;return{a:()=>Kn(n),b:()=>Kn(r)}}},nMe={kernelName:tm,gradFunc:t=>({x:()=>ft(t,"float32")})},rMe={kernelName:nm,gradFunc:t=>({x:()=>Kn(t)})},iMe={kernelName:rm,gradFunc:t=>({x:()=>Kn(t)})},sMe={kernelName:im,gradFunc:t=>({x:()=>Kn(t)})},aMe={kernelName:sm,inputsToSave:["x"],gradFunc:(t,e,n)=>{let[r]=e,{alpha:i}=n,s=Xs(r,0);return{x:()=>qi(s,t,fe(t,i))}}},oMe={kernelName:om,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>zt(t,ze(n,1))}}},lMe={kernelName:am,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>zt(t,ft(n,"float32"))}}},uMe={kernelName:b7,inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{let[r]=e,{axis:i}=n;return{logits:()=>{let s=ws(r);return Dt(t,fe(Xt(t,i,!0),s))}}}};function cMe(t,e,n,r=5,i=1,s=1,a=.5){let o={x:t,y:e,dy:n},l={depthRadius:r,bias:i,alpha:s,beta:a};return ue.runKernel(X0,o,l)}var dMe=ce({localResponseNormalizationBackprop_:cMe}),hMe={kernelName:lm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{let[r,i]=e,{depthRadius:s,bias:a,alpha:o,beta:l}=n;return{x:()=>dMe(r,i,t,s,a,o,l)}}};function Dq(t,e,n,r){return e.rank<n.rank&&(e=ve(e,nf(e.shape,r))),t.rank<n.rank&&(t=ve(t,nf(t.shape,r))),{x:()=>fe(t,ft(Ua(n,e),t.dtype))}}var oV={kernelName:um,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{let r=n,{reductionIndices:i}=r,s=e[0],a=e[1],o=Vo(i,s.shape),l=Dq(t,a,s,o);return{x:()=>l.x()}}},pMe={kernelName:cm,inputsToSave:["a","b"],gradFunc:(t,e)=>{let[n,r]=e;return{a:()=>fe(t,ft(gc(n,r),"float32")),b:()=>fe(t,ft(Jy(n,r),"float32"))}}};function fMe(t,e,n,r,i,s,a){let o=q(t,"dy","maxPool3dGrad"),l=q(e,"input","maxPool3dGrad"),u=q(n,"output","maxPool3dGrad"),c=o,d=l,h=u,p=!1;l.rank===4&&(p=!0,c=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=ve(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=ve(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),ee(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),ee(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),ee(h.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),js("maxPool3dGrad",s,a);let f={dy:c,input:d,output:h},g={filterSize:r,strides:i,pad:s,dimRoundingMode:a},y=ue.runKernel(hw,f,g);return p?ve(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}var mMe=ce({maxPool3dGrad_:fMe}),gMe={kernelName:K0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{let[r,i]=e,{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=n;return{x:()=>mMe(t,r,i,s,a,o,l)}}};function yMe(t,e,n,r,i,s,a){let o=q(t,"dy","maxPoolGrad"),l=q(e,"input","maxPoolGrad"),u=q(n,"output","maxPoolGrad");ee(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),ee(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),ee(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),js("maxPoolGrad",s,a);let c={dy:o,input:l,output:u},d={filterSize:r,strides:i,pad:s,dimRoundingMode:a};return ue.runKernel(dw,c,d)}var vMe=ce({maxPoolGrad_:yMe}),xMe={kernelName:dm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{let[r,i]=e,{filterSize:s,strides:a,pad:o}=n;return{x:()=>vMe(t,r,i,s,a,o)}}},bMe={kernelName:hm,inputsToSave:["x"],gradFunc:(t,e,n)=>{let[r]=e,{axis:i}=n,s=Vo(i,r.shape),a=aK(r.shape,s)[1],o=fr(a);return{x:()=>{let l=r.shape.slice();s.forEach(c=>{l[c]=1});let u=ve(t,l);return zt(fe(u,ra(r.shape,"float32")),o)}}}},wMe={kernelName:pm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{let r=n,{axis:i}=r,[s,a]=e,o=Vo(i,s.shape),l=Dq(t,a,s,o);return{x:()=>l.x()}}},_Me={kernelName:fm,inputsToSave:["a","b"],gradFunc:(t,e)=>{let[n,r]=e;return{a:()=>fe(t,ft(ah(n,r),"float32")),b:()=>fe(t,ft(Xs(n,r),"float32"))}}},SMe={kernelName:mm,inputsToSave:["x"],gradFunc:(t,e,n)=>{let r=e[0],{paddings:i}=n,s=i.map(a=>a[0]);return{x:()=>Gn(t,s,r.shape)}}},AMe={kernelName:gm,inputsToSave:["a","b"],gradFunc:(t,e)=>{let[n,r]=e,i=_r(n.shape,r.shape);return{a:()=>{let s=bi(n.shape,i);return s.length>0?ve(Xt(t,s),n.shape):t},b:()=>{let s=fe(t,Mr(Av(zt(n,r)))),a=bi(r.shape,i);return a.length>0?ve(Xt(s,a),r.shape):s}}}},EMe={kernelName:ym,inputsToSave:["a","b"],gradFunc:(t,e)=>{let[n,r]=e,i=_r(n.shape,r.shape);return{a:()=>{let s=fe(t,ft(r,"float32")),a=bi(n.shape,i);return a.length>0?ve(Xt(s,a),n.shape):s},b:()=>{let s=fe(t,ft(n,"float32")),a=bi(r.shape,i);return a.length>0?ve(Xt(s,a),r.shape):s}}}},IMe={kernelName:J0,gradFunc:t=>({x:()=>Mr(t)})},TMe={kernelName:vm,inputsToSave:["indices"],gradFunc:(t,e)=>{let n=e[0];return{indices:()=>Vr(n.shape,"float32")}}},CMe={kernelName:tv,gradFunc:t=>({x:()=>Kn(t)})},MMe={kernelName:nv,saveAllInputs:!0,gradFunc:(t,e,n)=>{let{axis:r}=n;return ii(t,r).map(i=>()=>i)}},lV={kernelName:xm,inputsToSave:["x"],gradFunc:(t,e,n)=>{let r=e[0],{paddings:i}=n,s=i.map(a=>a[0]);return{x:()=>Gn(t,s,r.shape)}}},kMe={kernelName:bm,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{let[n,r,i]=e,s=n,a=r,o=_r(s.shape,a.shape);return{a:()=>{let l=ft(a,"float32"),u=fe(t,fe(l,pu(s,Dt(l,rn(1))))),c=bi(s.shape,o);return c.length>0&&(u=Xt(u,c)),ve(u,s.shape)},b:()=>{let l=Xs(s,0),u=qi(l,$a(s),Kn(s)),c=fe(t,fe(i,u)),d=bi(a.shape,o);return d.length>0&&(c=Xt(c,d)),ve(c,a.shape)}}}},NMe={kernelName:wm,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{let[n,r]=e,i=Xs(n,0);return{x:()=>qi(i,t,fe(t,r)),alpha:()=>{let s=qi(i,Kn(t),fe(t,n)),a=bi(r.shape,t.shape);return a.length>0&&(s=Xt(s,a)),ve(s,r.shape)}}}};function RMe(t,e,n){let r=t.shape.slice();r[n]=1;let i=ve(e,r),s=w1(t,n,!0,!1),a=w1(t,n,!0,!0),o=fe(s,a);return fe(i,o)}function FMe(t,e,n){let r=t.shape.length,i=r-n.length,s=W.getAxesPermutation(n,r),a=t;s!=null&&(a=Nn(t,s));let o=a.shape.slice(),l=o.splice(r-n.length,n.length).reduce((d,h)=>d*h,1);o.push(l);let u=a.reshape(o),c=RMe(u,e,i);if(c=c.reshape(a.shape),s!=null){let d=W.getUndoAxesPermutation(s);c=Nn(c,d)}return c}var DMe={kernelName:_m,inputsToSave:["x"],gradFunc:(t,e,n)=>{let[r]=e,{axis:i}=n,s=[];return i==null?s=r.shape.map((a,o)=>o):typeof i=="number"?s=[i]:s=i,{x:()=>FMe(r,t,s)}}},PMe={kernelName:jf,inputsToSave:["a","b"],gradFunc:(t,e)=>{let[n,r]=e,i=_r(n.shape,r.shape);return{a:()=>{let s=zt(t,ft(r,"float32")),a=bi(n.shape,i);return a.length>0?ve(Xt(s,a),n.shape):s},b:()=>{let s=fe(t,ft(n,"float32")),a=bi(r.shape,i);a.length>0&&(s=ve(Xt(s,a),r.shape));let o=xr(r);return Mr(zt(s,ft(o,"float32")))}}}},LMe={kernelName:Sm,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>zt(t,Mr(xr(n)))}}},OMe={kernelName:Tm,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e,r=fe(ah(n,6),Xm(n));return{x:()=>fe(t,ft(r,"float32"))}}},BMe={kernelName:Am,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>fe(t,ft(Xm(n),"float32"))}}},UMe={kernelName:rv,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>ve(t,n.shape)}}},$Me={kernelName:Im,inputsToSave:["images"],gradFunc:(t,e,n)=>{let[r]=e,i={dy:t,images:r};return{images:()=>ue.runKernel(sv,i,n)}}},zMe={kernelName:Em,inputsToSave:["images"],gradFunc:(t,e,n)=>{let[r]=e,i={dy:t,images:r};return{images:()=>ue.runKernel(iv,i,n)}}},GMe={kernelName:Cm,gradFunc:(t,e,n)=>{let{dims:r}=n,i=Vo(r,t.shape);return{x:()=>ho(t,i)}}},HMe={kernelName:Mm,gradFunc:t=>({x:()=>Kn(t)})},WMe={kernelName:km,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>Mr(zt(t,fe(pu(n,1.5),2)))}}},VMe={kernelName:uv,inputsToSave:["condition"],gradFunc:(t,e)=>{let[n]=e;return{condition:()=>ft(Kn(n),"float32"),t:()=>fe(t,ft(n,t.dtype)),e:()=>fe(t,ft(Ow(n),t.dtype))}}},jMe={kernelName:Nm,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>{let r=Xs(n,rn(0)),i=rn(kq),s=rn(Nq),a=fe(t,s),o=fe(fe(t,i),ws(ft(n,"float32")));return qi(r,a,o)}}}},XMe={kernelName:Pm,outputsToSave:[!0],gradFunc:(t,e)=>{let[n]=e;return{x:()=>fe(t,fe(n,Dt(rn(1),n)))}}},KMe={kernelName:Dm,gradFunc:t=>({x:()=>Kn(t)})},qMe={kernelName:Rm,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>fe(Rw(ft(n,"float32")),t)}}},JMe={kernelName:Fm,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>fe(AC(ft(n,"float32")),t)}}},YMe={kernelName:cv,inputsToSave:["x"],gradFunc:(t,e,n)=>{let[r]=e,{begin:i,size:s}=n,a=r.shape,[o,l]=Cq(r,i,s),u=[];for(let c=0;c<t.rank;c++)u.push([o[c],a[c]-o[c]-l[c]]);return{x:()=>Ml(t,u)}}},ZMe={kernelName:Um,outputsToSave:[!0],gradFunc:(t,e,n)=>{let[r]=e,{dim:i}=n,s=!0,a=fe(t,r);return{logits:()=>Dt(a,fe(Xt(a,[i],s),r))}}},QMe={kernelName:Lm,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>fe(t,Uo(n))}}},uV={kernelName:dv,gradFunc:(t,e,n)=>{let{blockShape:r,paddings:i}=n;return{x:()=>Nw(t,r,i)}}},cV={kernelName:hv,gradFunc:(t,e,n)=>{let{axis:r}=n;return{x:()=>wr(t,r)}}},e2e={kernelName:Om,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>zt(t,fe(Zi(ft(n,"float32")),2))}}},t2e={kernelName:vw,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>fe(t,fe(ft(n,"float32"),2))}}},n2e={kernelName:$m,inputsToSave:["a","b"],gradFunc:(t,e)=>{let[n,r]=e,i=rn(2);return{a:()=>fe(t,fe(i,Dt(n,r))),b:()=>fe(t,fe(i,Dt(r,n)))}}},r2e={kernelName:ih,gradFunc:t=>({x:()=>Kn(t)})},i2e={kernelName:zm,inputsToSave:["a","b"],gradFunc:(t,e)=>{let[n,r]=e,i=_r(n.shape,r.shape);return{a:()=>{let s=t,a=bi(n.shape,i);return a.length>0&&(s=Xt(s,a)),ve(s,n.shape)},b:()=>{let s=t,a=bi(r.shape,i);return a.length>0&&(s=Xt(s,a)),ve(Mr(s),r.shape)}}}},s2e={kernelName:Bm,inputsToSave:["x"],gradFunc:(t,e,n)=>{let[r]=e,i=r.shape.slice(),{axis:s}=n;Vo(s,r.shape).forEach(l=>{i[l]=1});let a=ve(t,i),o=fe(a,ra(r.shape,"float32"));return{x:()=>o}}},a2e={kernelName:Gm,inputsToSave:["x"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>zt(t,xr(Rw(n)))}}},o2e={kernelName:Hm,outputsToSave:[!0],gradFunc:(t,e)=>{let[n]=e;return{x:()=>fe(Dt(rn(1),xr(n)),t)}}},l2e={kernelName:rh,inputsToSave:["x"],gradFunc:(t,e,n)=>{let[r]=e,{reps:i}=n;return{x:()=>{let s=Kn(r);if(r.rank===1)for(let a=0;a<i[0];++a)s=ze(s,Gn(t,[a*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let a=0;a<i[0];++a)for(let o=0;o<i[1];++o)s=ze(s,Gn(t,[a*r.shape[0],o*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let a=0;a<i[0];++a)for(let o=0;o<i[1];++o)for(let l=0;l<i[2];++l)s=ze(s,Gn(t,[a*r.shape[0],o*r.shape[1],l*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let a=0;a<i[0];++a)for(let o=0;o<i[1];++o)for(let l=0;l<i[2];++l)for(let u=0;u<i[3];++u)s=ze(s,Gn(t,[a*r.shape[0],o*r.shape[1],l*r.shape[2],u*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return s}}}},u2e={kernelName:Qu,gradFunc:(t,e,n)=>{let r=n,{perm:i}=r,s=hL(i);return{x:()=>Nn(t,s)}}},c2e={kernelName:vv,gradFunc:(t,e,n)=>{let r=n,{axis:i}=r;return{value:()=>xi(t,i)}}},d2e={kernelName:Aw,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{let[n]=e;return{x:()=>h2e(t,n)}}};function h2e(t,e){let n=xu(e,Kn(e)),r=Ev(t,n),i=gc(e,rn(0,"int32")),s=r.rank-i.rank;for(let o=0;o<s;++o)i=Gi(i,o+1);i=Go(i,ra(r.shape,"bool"));let a=Kn(r);return qi(i,r,a)}var p2e={kernelName:xv,gradFunc:t=>({x:()=>Kn(t)})},f2e=[Fq,dCe,hCe,pCe,fCe,mCe,gCe,yCe,vCe,xCe,bCe,wCe,ACe,TCe,CCe,MCe,kCe,NCe,RCe,FCe,DCe,PCe,OCe,LCe,$Ce,zCe,GCe,HCe,WCe,VCe,PMe,jCe,XCe,KCe,qCe,JCe,ZCe,YCe,QCe,eMe,tMe,nMe,rMe,iMe,sMe,aMe,oMe,lMe,uMe,hMe,oV,oV,pMe,gMe,xMe,bMe,wMe,_Me,SMe,AMe,EMe,IMe,TMe,CMe,MMe,lV,lV,kMe,NMe,DMe,LMe,OMe,BMe,UMe,$Me,zMe,GMe,HMe,WMe,VMe,jMe,XMe,KMe,qMe,JMe,YMe,ZMe,QMe,uV,uV,cV,cV,e2e,n2e,t2e,r2e,i2e,s2e,a2e,o2e,l2e,u2e,c2e,d2e,p2e];for(let t of f2e)w7(t);Ge().prototype.abs=function(){return this.throwIfDisposed(),fi(this)};Ge().prototype.acos=function(){return this.throwIfDisposed(),U3(this)};Ge().prototype.acosh=function(){return this.throwIfDisposed(),$3(this)};Ge().prototype.add=function(t){return this.throwIfDisposed(),ze(this,t)};Ge().prototype.all=function(t,e){return this.throwIfDisposed(),wC(this,t,e)};Ge().prototype.any=function(t,e){return this.throwIfDisposed(),v1(this,t,e)};Ge().prototype.argMax=function(t){return this.throwIfDisposed(),ef(this,t)};Ge().prototype.argMin=function(t){return this.throwIfDisposed(),z3(this,t)};Ge().prototype.asScalar=function(){return this.throwIfDisposed(),ee(this.size===1,()=>"The array must have only 1 element."),ve(this,[])};Ge().prototype.asType=function(t){return this.throwIfDisposed(),ft(this,t)};Ge().prototype.as1D=function(){return this.throwIfDisposed(),ve(this,[this.size])};Ge().prototype.as2D=function(t,e){return this.throwIfDisposed(),ve(this,[t,e])};Ge().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),ve(this,[t,e,n])};Ge().prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),ve(this,[t,e,n,r])};Ge().prototype.as5D=function(t,e,n,r,i){return this.throwIfDisposed(),ve(this,[t,e,n,r,i])};Ge().prototype.asin=function(){return this.throwIfDisposed(),G3(this)};Ge().prototype.asinh=function(){return this.throwIfDisposed(),H3(this)};Ge().prototype.atan=function(){return this.throwIfDisposed(),W3(this)};Ge().prototype.atan2=function(t){return this.throwIfDisposed(),V3(this,t)};Ge().prototype.atanh=function(){return this.throwIfDisposed(),j3(this)};Ge().prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),mc(this,t,e,n,r)};Ge().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),Nw(this,t,e)};Ge().prototype.batchNorm=function(t,e,n,r,i){return this.throwIfDisposed(),Wm(this,t,e,n,r,i)};Ge().prototype.broadcastTo=function(t){return this.throwIfDisposed(),Mp(this,t)};Ge().prototype.cast=function(t){return this.throwIfDisposed(),ft(this,t)};Ge().prototype.ceil=function(){return this.throwIfDisposed(),Q3(this)};Ge().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),bs(this,t,e)};Ge().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof In&&(t=[t]),wr([this,...t],e)};Ge().prototype.conv1d=function(t,e,n,r,i,s){return this.throwIfDisposed(),_C(this,t,e,n,r,i,s)};Ge().prototype.conv2dTranspose=function(t,e,n,r,i){return this.throwIfDisposed(),SC(this,t,e,n,r,i)};Ge().prototype.conv2d=function(t,e,n,r,i,s){return this.throwIfDisposed(),zs(this,t,e,n,r,i,s)};Ge().prototype.cos=function(){return this.throwIfDisposed(),Rw(this)};Ge().prototype.cosh=function(){return this.throwIfDisposed(),AC(this)};Ge().prototype.cumprod=function(t,e,n){return this.throwIfDisposed(),w1(this,t,e,n)};Ge().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),EC(this,t,e,n)};Ge().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),oL(this,t,e)};Ge().prototype.depthwiseConv2d=function(t,e,n,r,i,s){return this.throwIfDisposed(),Vm(this,t,e,n,r,i,s)};Ge().prototype.dilation2d=function(t,e,n,r,i){return this.throwIfDisposed(),lL(this,t,e,n,r,i)};Ge().prototype.divNoNan=function(t){return this.throwIfDisposed(),uL(this,t)};Ge().prototype.div=function(t){return this.throwIfDisposed(),zt(this,t)};Ge().prototype.dot=function(t){return this.throwIfDisposed(),cL(this,t)};Ge().prototype.elu=function(){return this.throwIfDisposed(),_v(this)};Ge().prototype.equal=function(t){return this.throwIfDisposed(),Ua(this,t)};Ge().prototype.erf=function(){return this.throwIfDisposed(),IC(this)};Ge().prototype.euclideanNorm=function(t,e){return this.throwIfDisposed(),pL(this,t,e)};Ge().prototype.exp=function(){return this.throwIfDisposed(),ws(this)};Ge().prototype.expandDims=function(t){return this.throwIfDisposed(),Gi(this,t)};Ge().prototype.expm1=function(){return this.throwIfDisposed(),fL(this)};Ge().prototype.fft=function(){return this.throwIfDisposed(),Gw(this)};Ge().prototype.flatten=function(){return this.throwIfDisposed(),ve(this,[this.size])};Ge().prototype.floor=function(){return this.throwIfDisposed(),Av(this)};Ge().prototype.floorDiv=function(t){return this.throwIfDisposed(),bC(this,t)};Ge().prototype.gather=function(t,e,n){return this.throwIfDisposed(),Ev(this,t,e,n)};Ge().prototype.greaterEqual=function(t){return this.throwIfDisposed(),gc(this,t)};Ge().prototype.greater=function(t){return this.throwIfDisposed(),Xs(this,t)};Ge().prototype.ifft=function(){return this.throwIfDisposed(),e0(this)};Ge().prototype.irfft=function(){return this.throwIfDisposed(),$C(this)};Ge().prototype.isFinite=function(){return this.throwIfDisposed(),mL(this)};Ge().prototype.isInf=function(){return this.throwIfDisposed(),gL(this)};Ge().prototype.isNaN=function(){return this.throwIfDisposed(),yL(this)};Ge().prototype.leakyRelu=function(t){return this.throwIfDisposed(),Dw(this,t)};Ge().prototype.lessEqual=function(t){return this.throwIfDisposed(),ah(this,t)};Ge().prototype.less=function(t){return this.throwIfDisposed(),Jy(this,t)};Ge().prototype.localResponseNormalization=function(t,e,n,r){return this.throwIfDisposed(),vL(this,t,e,n,r)};Ge().prototype.logSigmoid=function(){return this.throwIfDisposed(),xL(this)};Ge().prototype.logSoftmax=function(t){return this.throwIfDisposed(),MC(this,t)};Ge().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),Lw(this,t,e)};Ge().prototype.log=function(){return this.throwIfDisposed(),$a(this)};Ge().prototype.log1p=function(){return this.throwIfDisposed(),Pw(this)};Ge().prototype.logicalAnd=function(t){return this.throwIfDisposed(),Go(this,t)};Ge().prototype.logicalNot=function(){return this.throwIfDisposed(),Ow(this)};Ge().prototype.logicalOr=function(t){return this.throwIfDisposed(),kC(this,t)};Ge().prototype.logicalXor=function(t){return this.throwIfDisposed(),bL(this,t)};Ge().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),kn(this,t,e,n)};Ge().prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),Oi(this,t,e,n,r)};Ge().prototype.max=function(t,e){return this.throwIfDisposed(),oo(this,t,e)};Ge().prototype.maximum=function(t){return this.throwIfDisposed(),xu(this,t)};Ge().prototype.mean=function(t,e){return this.throwIfDisposed(),Wr(this,t,e)};Ge().prototype.min=function(t,e){return this.throwIfDisposed(),qy(this,t,e)};Ge().prototype.minimum=function(t){return this.throwIfDisposed(),Od(this,t)};Ge().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),_L(this,t,e)};Ge().prototype.mod=function(t){return this.throwIfDisposed(),SL(this,t)};Ge().prototype.mul=function(t){return this.throwIfDisposed(),fe(this,t)};Ge().prototype.neg=function(){return this.throwIfDisposed(),Mr(this)};Ge().prototype.norm=function(t,e,n){return this.throwIfDisposed(),Sv(this,t,e,n)};Ge().prototype.notEqual=function(t){return this.throwIfDisposed(),rf(this,t)};Ge().prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),Yy(this,t,e,n)};Ge().prototype.onesLike=function(){return this.throwIfDisposed(),za(this)};Ge().prototype.pad=function(t,e){return this.throwIfDisposed(),Ml(this,t,e)};Ge().prototype.pool=function(t,e,n,r,i,s){return this.throwIfDisposed(),AL(this,t,e,n,r,i,s)};Ge().prototype.pow=function(t){return this.throwIfDisposed(),pu(this,t)};Ge().prototype.prelu=function(t){return this.throwIfDisposed(),$w(this,t)};Ge().prototype.prod=function(t,e){return this.throwIfDisposed(),EL(this,t,e)};Ge().prototype.reciprocal=function(){return this.throwIfDisposed(),kL(this)};Ge().prototype.relu=function(){return this.throwIfDisposed(),pr(this)};Ge().prototype.relu6=function(){return this.throwIfDisposed(),FC(this)};Ge().prototype.reshapeAs=function(t){return this.throwIfDisposed(),ve(this,t.shape)};Ge().prototype.reshape=function(t){return this.throwIfDisposed(),ve(this,t)};Ge().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),tq(this,t,e,n)};Ge().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),nq(this,t,e,n)};Ge().prototype.reverse=function(t){return this.throwIfDisposed(),ho(this,t)};Ge().prototype.rfft=function(){return this.throwIfDisposed(),Hw(this)};Ge().prototype.round=function(){return this.throwIfDisposed(),DC(this)};Ge().prototype.rsqrt=function(){return this.throwIfDisposed(),PC(this)};Ge().prototype.selu=function(){return this.throwIfDisposed(),LC(this)};Ge().prototype.separableConv2d=function(t,e,n,r,i,s){return this.throwIfDisposed(),Iv(this,t,e,n,r,i,s)};Ge().prototype.sigmoid=function(){return this.throwIfDisposed(),Uo(this)};Ge().prototype.sign=function(){return this.throwIfDisposed(),NL(this)};Ge().prototype.sin=function(){return this.throwIfDisposed(),OC(this)};Ge().prototype.sinh=function(){return this.throwIfDisposed(),BC(this)};Ge().prototype.slice=function(t,e){return this.throwIfDisposed(),Gn(this,t,e)};Ge().prototype.softmax=function(t){return this.throwIfDisposed(),lh(this,t)};Ge().prototype.softplus=function(){return this.throwIfDisposed(),jm(this)};Ge().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),Uw(this,t,e)};Ge().prototype.split=function(t,e){return this.throwIfDisposed(),aa(this,t,e)};Ge().prototype.sqrt=function(){return this.throwIfDisposed(),Zi(this)};Ge().prototype.square=function(){return this.throwIfDisposed(),xr(this)};Ge().prototype.squaredDifference=function(t){return this.throwIfDisposed(),zC(this,t)};Ge().prototype.squeeze=function(t){return this.throwIfDisposed(),uh(this,t)};Ge().prototype.stack=function(t,e){this.throwIfDisposed();let n=t instanceof In?[this,t]:[this,...t];return xi(n,e)};Ge().prototype.step=function(t){return this.throwIfDisposed(),Xm(this,t)};Ge().prototype.stridedSlice=function(t,e,n,r,i,s,a,o){return this.throwIfDisposed(),RL(this,t,e,n,r,i,s,a,o)};Ge().prototype.sub=function(t){return this.throwIfDisposed(),Dt(this,t)};Ge().prototype.sum=function(t,e){return this.throwIfDisposed(),Xt(this,t,e)};Ge().prototype.tan=function(){return this.throwIfDisposed(),FL(this)};Ge().prototype.tanh=function(){return this.throwIfDisposed(),Ld(this)};Ge().prototype.tile=function(t){return this.throwIfDisposed(),Na(this,t)};Ge().prototype.toBool=function(){return this.throwIfDisposed(),ft(this,"bool")};Ge().prototype.toFloat=function(){return this.throwIfDisposed(),ft(this,"float32")};Ge().prototype.toInt=function(){return this.throwIfDisposed(),ft(this,"int32")};Ge().prototype.topk=function(t,e){return this.throwIfDisposed(),PL(this,t,e)};Ge().prototype.transpose=function(t){return this.throwIfDisposed(),Nn(this,t)};Ge().prototype.unique=function(t){return this.throwIfDisposed(),LL(this,t)};Ge().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),jC(this,t,e)};Ge().prototype.unstack=function(t){return this.throwIfDisposed(),ii(this,t)};Ge().prototype.where=function(t,e){return this.throwIfDisposed(),qi(t,this,e)};Ge().prototype.zerosLike=function(){return this.throwIfDisposed(),Kn(this)};var Zc=class Pq extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Pq.prototype)}},Zl=class Lq extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Lq.prototype)}},be=class Oq extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Oq.prototype)}},Pn=class Bq extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Bq.prototype)}},m2e=class Uq extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Uq.prototype)}},$q=class{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=t}};function af(t,e){if(Array.isArray(t)){let n=[];for(let r=0;r<e;r++)n=n.concat(t);return n}else{let n=new Array(e);return n.fill(t),n}}function Xl(t,e){if(!t)throw new m2e(e)}function dV(t,e){let n=0;for(let r of t)r===e&&n++;return n}function ea(t){return t.length===1?t[0]:t}function dr(t){return Array.isArray(t)?t:[t]}function Uu(t){let e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function sp(t){return t.length<=1||t.indexOf("_")===-1?t:t.replace(/[_]+(\w|$)/g,(e,n)=>n.toUpperCase())}var To={};function tO(t){if(t==null)return null;let e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function EF(t){if(!(t==null||typeof t!="object"))if(Array.isArray(t))t.forEach(e=>EF(e));else{let e=Object.keys(t);for(let n of e){let r=t[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?t[n]=r.value:EF(r))}}}function Vw(t,e={},n={},r="object",i=!1){if(typeof t=="string"){let s=t,a;if(s in n)a=n[s];else if(s in To)a=To[s];else if(a=e[s],a==null)throw new be(`Unknown ${r}: ${t}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{let s=t;if(s.className==null||s.config==null)throw new be(`${r}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let a=s.className,o,l;if(a in n?[o,l]=n[a]:a in To?[o,l]=To.className:a in e&&([o,l]=e[a]),o==null)throw new be(`Unknown ${r}: ${a}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let u={};for(let p of Object.keys(To))u[p]=To[p];for(let p of Object.keys(n))u[p]=n[p];let c=s.config;c.customObjects=u;let d=Object.assign({},To);for(let p of Object.keys(n))To[p]=n[p];EF(s.config);let h=l(o,s.config,n,i);return To=Object.assign({},d),h}else{let u=Object.assign({},To);for(let d of Object.keys(n))To[d]=n[d];let c=new o(s.config);return To=Object.assign({},u),c}}}function g2e(t,e){return t<e?-1:t>e?1:0}function vA(t,e){return-1*g2e(t,e)}function Ad(t){if(t==null)return t;let e=[];for(let n of t)e.indexOf(n)===-1&&e.push(n);return e}function y2e(t){if(t==null)throw new be(`Invalid value in obj: ${JSON.stringify(t)}`);for(let e in t)if(t.hasOwnProperty(e))return!1;return!0}function Km(t,e,n){if(n!=null&&t.indexOf(n)<0)throw new be(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function nO(t,e,n=0,r=1/0){return Xl(n>=0),Xl(r>=n),Array.isArray(t)&&t.length>=n&&t.length<=r&&t.every(i=>typeof i===e)}function ji(t,e){Array.isArray(t)?(P.assert(t.length>0,()=>`${e} is unexpectedly an empty array.`),t.forEach((n,r)=>ji(n,`element ${r+1} of ${e}`))):P.assert(Number.isInteger(t)&&t>0,()=>`Expected ${e} to be a positive integer, but got ${zq(t)}.`)}function zq(t){return t===null?"null":Array.isArray(t)?"["+t.map(e=>zq(e)).join(",")+"]":typeof t=="string"?`"${t}"`:`${t}`}function v2e(t,e,n){let r=n!=null?n():P.now(),i;return(...s)=>{let a=n!=null?n():P.now();return a-r<e||(r=a,i=t(...s)),i}}function Gq(t){return t==="relu"?"relu":t==="linear"?"linear":t==="elu"?"elu":null}var x2e=0;function Hq(){return x2e++}var xA={};function QC(t=""){return t in xA||(xA[t]=0),xA[t]+=1,t+xA[t].toString()}var b2e=["channelsFirst","channelsLast"],w2e=["nearest","bilinear"],_2e=["valid","same","causal"],S2e=["max","avg"],A2e=["sum","mul","concat","ave"],Ug=new Map;function ci(t){Km(b2e,"DataFormat",t)}function E2e(t){Km(w2e,"InterpolationFormat",t)}function mo(t){Km(_2e,"PaddingMode",t)}function Wq(t){Km(S2e,"PoolMode",t)}var kb=[],hV="/";function kp(t,e){kb.push(t);try{let n=e();return kb.pop(),n}catch(n){throw kb.pop(),n}}function I2e(){return kb.length===0?"":kb.join(hV)+hV}function Vq(t){if(!Xq(t))throw new Error("Not a valid tensor name: '"+t+"'");return I2e()+t}function jq(t){if(!Xq(t))throw new Error("Not a valid tensor name: '"+t+"'");Ug.has(t)||Ug.set(t,0);let e=Ug.get(t);if(Ug.set(t,Ug.get(t)+1),e>0){let n=`${t}_${e}`;return Ug.set(n,1),n}else return t}var T2e=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Xq(t){return!!t.match(T2e)}function C2e(t){return t===parseInt(t.toString(),10)}function Ed(t,e,n){e==null&&(e=0),n==null&&(n=t.length);let r=1;for(let i=e;i<n;++i)r*=t[i];return r}function n0(t){if(t.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){let r=t[n];r<e&&(e=r)}return e}function Ud(t){if(t.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){let r=t[n];r>e&&(e=r)}return e}function _l(t,e){if(e<t)throw new be(`end (${e}) < begin (${t}) is forbidden.`);let n=[];for(let r=t;r<e;++r)n.push(r);return n}var SN;function Mi(){return SN==null&&(SN=P3().epsilon()),SN}function Sl(){return"channelsLast"}function dc(t,e){return ft(t,e)}function jw(t,e=-1){let n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),ve(t,n)}function M2e(t,e){return xe(()=>{if(t.shape.length!==2)throw new be(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);let n=jw(t,1);return IF(n,[1,e,1])})}function k2e(t){let e=[Ed(t.shape)];return ve(t,e)}function N2e(t){if(t.rank<=1)throw new be(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);let e=[t.shape[0],Ed(t.shape,1)];return ve(t,e)}function Np(t,e,n){return xe(()=>{switch(t.rank){case 1:return zw(t,e,n);case 2:return UC(t,[e,0],[n,t.shape[1]]);case 3:return Tv(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return Qy(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return Gn(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return Gn(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new be(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function AN(t,e,n){return xe(()=>{switch(t.rank){case 1:return zw(t,e,n);case 2:return UC(t,[0,e],[t.shape[0],n]);case 3:return Tv(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return Qy(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new be(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function bA(t,e,n,r){return xe(()=>{switch(t.rank){case 1:return zw(t,e,n);case 2:switch(r){case 1:return Np(t,e,n);case 2:return AN(t,e,n);default:throw new be(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Np(t,e,n);case 2:return Tv(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return AN(t,e,n);default:throw new be(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Np(t,e,n);case 2:return Qy(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return Qy(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return AN(t,e,n);default:throw new be(`The axis is not within the rank of the tensor ${r}`)}default:throw new be(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function rO(t,e=-1){let n;return e<0&&(n=t[0].rank,n!==0?e=n:e=0),e===t[0].rank&&(e=-1),wr(t,e)}function pV(t,e){switch(t.rank){case 1:return eL([t,e]);case 2:return tL([t,e],0);case 3:return nL([t,e],0);case 4:return rL([t,e],0);default:throw new be(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function IF(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new be(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return Na(t,e)}function eM(t,e=0,n=1,r,i){return RC(t,e,n,r,i)}function ou(t,e,n,r){if(t.rank<2||e.rank<2)throw new Pn(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3){let i=t.shape.slice(-1)[0],s=e.shape.slice(-2)[0];if(i!==s)throw new Pn(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`)}if(t.rank===2&&e.rank===2)return t0.matMul({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?TF(t.rank,r,Sl()):null,activation:n});{let i=t.shape.slice(),s=i.pop();t=ve(t,[-1,s]);let a=e.shape.slice(),o=a.pop(),l=a.pop(),u=[...a,o],c=Array.from({length:e.rank},(h,p)=>p===0?e.rank-2:p<=e.rank-2?p-1:p);e=ve(Nn(e,c),[l,-1]);let d=[...i,...u];return ve(t0.matMul({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?TF(t.rank,r,Sl()):null,activation:n}),d)}}function Kq(t,e,n){return xe(()=>(Array.isArray(e)?e=cr(e,"int32"):e=ft(e,"int32"),Ev(t,e,n)))}function Xw(t){return fe(t,t)}function TF(t,e,n){let r=e.shape;if(e.rank!==1&&e.rank!==t)throw new be(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);if(t===5){if(n==="channelsFirst")return r.length===1?ve(e,[1,r[0],1,1,1]):ve(e,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?ve(e,[1,1,1,1,r[0]]):ve(e,[1].concat(r))}else if(t===4){if(n==="channelsFirst")return r.length===1?ve(e,[1,r[0],1,1]):ve(e,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?ve(e,[1,1,1,r[0]]):ve(e,[1].concat(r))}else if(t===3){if(n==="channelsFirst")return r.length===1?ve(e,[1,r[0],1]):ve(e,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?ve(e,[1,1,r[0]]):ve(e,[1].concat(r))}else if(t<3)return e;throw new be(`Unsupported input rank by biasAdd: ${e.rank}`)}function kl(t,e,n){return xe(()=>(n==null&&(n=Sl()),ci(n),ze(t,TF(t.rank,e,n))))}function R2e(t,e=1){if(e!==1)throw new Pn(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return _v(t)}function F2e(t){return xe(()=>zt(t,ze(fi(t),1)))}function qq(t,e,n,r){return xe(()=>UL(t,e,n,r))}function D2e(t){return xe(()=>{let e=ze(.5,fe(.2,t));return bs(e,0,1)})}function Kw(t,e,n=!1){return n?t():e()}var P2e=["fanIn","fanOut","fanAvg"],L2e=["normal","uniform","truncatedNormal"];function O2e(t){Km(P2e,"FanMode",t)}function B2e(t){Km(L2e,"Distribution",t)}var jo=class extends rt.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},iO=class extends jo{apply(t,e){return Vr(t,e)}};iO.className="Zeros";rt.registerClass(iO);var tM=class extends jo{apply(t,e){return ra(t,e)}};tM.className="Ones";rt.registerClass(tM);var sO=class extends jo{constructor(t){if(super(),typeof t!="object")throw new be(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new be(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return xe(()=>fe(rn(this.value),ra(t,e)))}getConfig(){return{value:this.value}}};sO.className="Constant";rt.registerClass(sO);var aO=class extends jo{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return oh(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};aO.className="RandomUniform";rt.registerClass(aO);var oO=class extends jo{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Pn(`randomNormal does not support dType ${e}.`);return eM(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};oO.className="RandomNormal";rt.registerClass(oO);var lO=class extends jo{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Pn(`truncatedNormal does not support dType ${e}.`);return VC(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};lO.className="TruncatedNormal";rt.registerClass(lO);var uO=class extends jo{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,e){return xe(()=>{if(t.length!==2||t[0]!==t[1])throw new be("Identity matrix initializer can only be used for 2D square matrices.");return fe(this.gain,TC(t[0]))})}getConfig(){return{gain:this.gain}}};uO.className="Identity";rt.registerClass(uO);function U2e(t,e="channelsLast"){let n,r;if(ci(e),t.length===2)n=t[0],r=t[1];else if([3,4,5].indexOf(t.length)!==-1){if(e==="channelsFirst"){let i=Ed(t,2);n=t[1]*i,r=t[0]*i}else if(e==="channelsLast"){let i=Ed(t,0,t.length-2);n=t[t.length-2]*i,r=t[t.length-1]*i}}else{let i=Ed(t);n=Math.sqrt(i),r=Math.sqrt(i)}return[n,r]}var da=class extends jo{constructor(t){if(super(),t.scale<0)throw new be(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,O2e(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,B2e(this.distribution),this.seed=t.seed}apply(t,e){let n=U2e(t),r=n[0],i=n[1],s=this.scale;if(this.mode==="fanIn"?s/=Math.max(1,r):this.mode==="fanOut"?s/=Math.max(1,i):s/=Math.max(1,(r+i)/2),this.distribution==="normal"){let a=Math.sqrt(s);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Pn(`${this.getClassName()} does not support dType ${e}.`);return VC(t,0,a,e,this.seed)}else{let a=Math.sqrt(3*s);return oh(t,-a,a,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};da.className="VarianceScaling";rt.registerClass(da);var nM=class extends da{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return da.className}};nM.className="GlorotUniform";rt.registerClass(nM);var rM=class extends da{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return da.className}};rM.className="GlorotNormal";rt.registerClass(rM);var iM=class extends da{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return da.className}};iM.className="HeNormal";rt.registerClass(iM);var sM=class extends da{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return da.className}};sM.className="HeUniform";rt.registerClass(sM);var aM=class extends da{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return da.className}};aM.className="LeCunNormal";rt.registerClass(aM);var oM=class extends da{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return da.className}};oM.className="LeCunUniform";rt.registerClass(oM);var cO=class extends jo{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,e){return xe(()=>{if(t.length<2)throw new Pn("Shape must be at least 2D.");if(e!=="int32"&&e!=="float32"&&e!==void 0)throw new TypeError(`Unsupported data type ${e}.`);e=e;let n=P.sizeFromShape(t.slice(0,-1)),r=t[t.length-1],i=n*r;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);let s=[Math.max(r,n),Math.min(r,n)],a=eM(s,0,1,e,this.seed),o=HL.qr(a,!1),l=o[0],u=o[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return l=fe(l,u.sign()),n<r&&(l=l.transpose()),fe(rn(this.gain),l.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}};cO.className="Orthogonal";rt.registerClass(cO);var fV={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function mV(t,e={}){return Vw(t,rt.SerializationMap.getMap().classNameMap,e,"initializer")}function Xr(t){return tO(t)}function Br(t){if(typeof t=="string"){let e=t in fV?fV[t]:t;if(e==="GlorotNormal")return new rM;if(e==="GlorotUniform")return new nM;if(e==="HeNormal")return new iM;if(e==="HeUniform")return new sM;if(e==="LeCunNormal")return new aM;if(e==="LeCunUniform")return new oM;{let n={};return n.className=e,n.config={},mV(n)}}else return t instanceof jo?t:mV(t)}function CF(t){return Array.isArray(t)&&Array.isArray(t[0])}function FI(t){return t.length===0?[]:Array.isArray(t[0])?t:[t]}function mn(t){let e;if(Array.isArray(t)){if(t.length!==1)throw new be(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function tr(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(t.length===1)return t=t,t[0];throw new be(`Expected exactly 1 Shape; got ${t.length}`)}else return t}function DI(t){let e=0;for(let n of t)n.shape.length===0?e+=1:e+=n.shape.reduce((r,i)=>r*i);return e}var gV="Variable",Jq=class{constructor(t,e="float32",n=gV,r=!0,i=null){this.dtype=e??"float32",this.shape=t.shape,this.id=Hq(),n=n??gV,this.originalName=Vq(n),this.name=jq(this.originalName),this.trainable_=r,this.constraint=i,this.val=OL(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),$2e(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}};function $2e(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}function MF(t){return t.map(e=>e.read())}function dO(t){t.forEach(e=>{e[0].write(e[1])})}var gi=class{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}},Al=class{constructor(t,e,n,r,i,s,a){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=r,this.callArgs=i,this.outputTensorIndex=a,this.id=Hq(),s!=null&&(this.originalName=Vq(s),this.name=jq(this.originalName)),this.rank=e.length}},z2e=0,lM=class{constructor(t,e){this.callArgs=e,this.id=z2e++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(let n of t.inboundLayers)n!=null&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){let t=[];for(let e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},G2e=0,On=class extends rt.Serializable{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=G2e++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){let n=this.getClassName();e=Uu(n)+"_"+QC(n)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let n;if(t.batchInputShape!=null)n=t.batchInputShape;else if(t.inputShape!=null){let i=null;t.batchSize!=null&&(i=t.batchSize),n=[i].concat(t.inputShape)}this.batchInputShape=n;let r=t.dtype;r==null&&(r=t.inputDType),r==null&&(r="float32"),this.dtype=r}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new Zl(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new be(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return ea(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return ea(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Zc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Zc(`Layer ${this.name} is not connected, no input to return.`);return ea(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Zc(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Zc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ea(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){let e=dr(t);if(this.inputSpec==null||this.inputSpec.length===0)return;let n=dr(this.inputSpec);if(e.length!==n.length)throw new be(`Layer ${this.name} expects ${n.length} inputs, but it received ${e.length} input tensors. Input received: ${t}`);for(let r=0;r<e.length;r++){let i=e[r],s=n[r];if(s==null)continue;let a=i.rank;if(s.ndim!=null&&a!==s.ndim)throw new be(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(s.maxNDim!=null&&a>s.maxNDim)throw new be(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(s.minNDim!=null&&a<s.minNDim)throw new be(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(s.dtype!=null&&i.dtype!==s.dtype)throw new be(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${i.dtype}.`);if(s.axes){let o=i.shape;for(let l in s.axes){let u=Number(l),c=s.axes[l],d=u>=0?o[u]:o[o.length+u];if(c!=null&&[c,null].indexOf(d)===-1)throw new be(`Input ${r} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${o}.`)}}if(s.shape!=null)for(let o=0;o<s.shape.length;++o){let l=s.shape[o],u=i.shape[o];if(l!=null&&u!=null&&l!==u)throw new be(`Input ${r} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${i.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();let n=dr(t),r=V2e(t),i=j2e(t);if(r===i)throw new be("Arguments to apply() must be all SymbolicTensors or all Tensors");return kp(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);let s=[];for(let a of dr(t))s.push(a.shape);this.build(ea(s)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(t),i){let s=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,s);let a=dr(s),o=[];for(let l of a)n.indexOf(l)!==-1&&(l=l.clone()),o.push(l);if(s=ea(o),this.activityRegularizer!=null)throw new Pn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}else{let s=H2e(t),a=this.computeOutputShape(s),o,l=W2e(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?s[0]:s),a!=null&&a.length>0&&Array.isArray(a[0])?o=a.map((u,c)=>new Al(l,u,this,dr(t),e,this.name,c)):o=new Al(l,a,this,dr(t),e,this.name),this.addInboundNode(t,o,null,null,s,a,e),this._refCount++,this.activityRegularizer!=null)throw new Pn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((n,r)=>{n!=null&&t[r]!=null&&t[r]!==n&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Zc(`The layer ${this.name} has never been called and thus has no defined output shape.`);let t=[];for(let e of this.inboundNodes){let n=JSON.stringify(e.outputShapes);t.indexOf(n)===-1&&t.push(n)}if(t.length===1){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new Zc(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Zl(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return DI(this.weights)}build(t){this.built=!0}getWeights(t=!1){return MF(t?this.trainableWeights:this.weights)}setWeights(t){xe(()=>{let e=this.weights;if(e.length!==t.length)throw new be(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;let n=[],r=MF(e);for(let i=0;i<r.length;++i){let s=r[i],a=e[i],o=t[i];if(!P.arraysEqual(s.shape,o.shape))throw new be(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([a,o])}dO(n)})}addWeight(t,e,n,r,i,s,a,o){if(this._addedWeightNames.indexOf(t)!==-1)throw new be(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(r=o!=null?o():Br("zeros"));let l=r.apply(e,n),u=new Jq(l,n,t,s,a);return l.dispose(),i!=null&&this.addLoss(()=>i.apply(u.read())),s==null&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=dr(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}setMaskMetadata(t,e,n){if(!this.supportsMasking)return;let r=this.computeMask(t,n),i=dr(e),s=dr(r);if(i.length!==s.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let a=0;a<i.length;a++)i[a].kerasMask=s[a]}addInboundNode(t,e,n,r,i,s,a=null){let o=dr(t);e=dr(e),n=dr(n),r=dr(r),i=FI(i),s=FI(s);let l=[],u=[],c=[];for(let d of o)l.push(d.sourceLayer),u.push(d.nodeIndex),c.push(d.tensorIndex);new lM({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:e,inputMasks:n,outputMasks:r,inputShapes:i,outputShapes:s},a);for(let d=0;d<e.length;d++)e[d].sourceLayer=this,e[d].nodeIndex=this.inboundNodes.length-1,e[d].tensorIndex=d}getConfig(){let t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}};function H2e(t){t=dr(t);let e=[];for(let n of t)e.push(n.shape);return ea(e)}function W2e(t){return"float32"}function Yq(t,e,n){if((e==null||n!=null&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),e.inboundNodes.length===0)return[t];{let r=e.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{let i=[];for(let s=0;s<r.inboundLayers.length;s++){let a=r.inputTensors[s],o=r.inboundLayers[s],l=r.nodeIndices[s],u=Yq(a,o,l);for(let c of u)i.indexOf(c)===-1&&i.push(c)}return i}}}function V2e(t){let e=!0;for(let n of dr(t))if(!(n instanceof Al)){e=!1;break}return e}function j2e(t){let e=!0;for(let n of dr(t))if(n instanceof Al){e=!1;break}return e}var Mv=class extends On{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:QC("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new be("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new be("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new be("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];let r=new Al(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new lM({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new be(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};Mv.className="InputLayer";rt.registerClass(Mv);function Zq(t){if(t.batchShape==null&&t.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(t.batchShape!=null&&t.shape!=null)throw new be("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;t.shape!=null&&e==null&&(e=[null].concat(t.shape));let n=t.dtype;return n==null&&(n="float32"),new Mv({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}function X2e(t,e){if(t.dtype==null||t.dtype===e.dtype)return e;try{return ft(e,t.dtype)}catch{throw new be(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}var uy=class Qq{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Qq)for(let n in e.id2Value)this.id2Value[n]=e.id2Value[n],n in e.id2Mask&&(this.id2Mask[n]=e.id2Mask[n]);else{if(e==null)return;for(let n of e)this.add(n.key,n.value)}}add(e,n,r){if(this.id2Value[e.id]==null)this.id2Value[e.id]=X2e(e,n),this.name2Id[e.name]=e.id,r!=null&&(this.id2Mask[e.id]=r);else throw new be(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Al){if(this.id2Value[e.id]==null)throw new be(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{let n=this.name2Id[e];if(n==null)throw new be(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[n]}}getMask(e){if(e instanceof Al){if(this.id2Value[e.id]==null)throw new be(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{let n=this.name2Id[e];if(n==null)throw new be(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&bn(this.id2Mask)}},PI=new $q,LI=new $q;function K2e(t){PI!=null&&PI.setMaxEntries(t),LI!=null&&LI.setMaxEntries(t)}function tb(t,e,n,r){let i=n==null?!1:n.training,s=Array.isArray(t),a=s?t:[t],o=a.map(f=>f.name),l=[],u=e.names();for(let f of o)u.indexOf(f)!==-1?l.push(e.getValue(f)):l.push(null);let c=o.join(",")+"|"+e.names().sort().join(","),d=PI.get(c),h;if(d==null){let f=q2e(a,e);d=f.sorted,h=f.recipientCounts,PI.put(c,d),LI.put(c,h)}h={},i||Object.assign(h,LI.get(c));let p=new uy(e);for(let f=0;f<d.length;++f){let g=d[f],y=g.sourceLayer;if(y instanceof Mv)continue;let m=[],b=[],w=[],_=!1;for(let M of g.inputs){let k=p.getValue(M),R=p.getMask(M);m.push(k),b.push(R),R!=null&&(_=!0),i||(h[M.name]--,h[M.name]===0&&!e.hasKey(M)&&o.indexOf(M.name)===-1&&!k.isDisposed&&M.sourceLayer.stateful!==!0&&w.push(k))}_&&(n=n||{},n.mask=b[0]);let S=dr(y.apply(m,n)),E=null;y.supportsMasking&&(E=y.computeMask(m,b));let C=Y2e(g),T=Array.isArray(C)?C:[C];for(let M=0;M<T.length;++M){p.hasKey(T[M])||p.add(T[M],S[M],Array.isArray(E)?E[0]:E);let k=o.indexOf(T[M].name);k!==-1&&(l[k]=S[M])}i||bn(w)}return p.disposeMasks(),s?l:l[0]}function q2e(t,e){P.assert(t!=null&&t.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(t.length===1){let i=yV(t[0],e);n=i.sorted,r=i.recipientMap}else{let i=new Set;for(let s of t){let{sorted:a,recipientMap:o}=yV(s,e);for(let l of a)i.has(l.name)||(n.push(l),i.add(l.name));for(let l in o)r[l]==null&&(r[l]=new Set),o[l].forEach(u=>r[l].add(u))}}return{sorted:n,recipientCounts:J2e(r)}}function J2e(t){let e={};for(let n in t)e[n]=t[n].size;return e}function yV(t,e){let n=new Set,r=[],i={};for(let o of e.names())n.add(o);let s=[],a=[];for(s.push(t);s.length>0;){let o=s[s.length-1];if(n.has(o.name)){s.pop();continue}let l=a[a.length-1]===s.length-1;if(o.inputs.length===0||l)s.pop(),r.push(o),n.add(o.name),l&&a.pop();else{a.push(s.length-1);for(let u of o.inputs)i[u.name]==null&&(i[u.name]=new Set),i[u.name].add(o.name),!n.has(u.name)&&s.push(u)}}return{sorted:r,recipientMap:i}}function Y2e(t){let e;if(t.sourceLayer.inboundNodes.length===1)e=t.sourceLayer.output;else{let n=null;for(let r=0;r<t.sourceLayer.inboundNodes.length;++r)for(let i of t.sourceLayer.inboundNodes[r].outputTensors)if(i.id===t.id){n=r;break}e=t.sourceLayer.getOutputAt(n)}return e}var Z2e=Ie();Z2e.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,K2e);var eJ={};wn(eJ,{maxNorm:()=>Q2e,minMaxNorm:()=>nke,nonNeg:()=>tke,unitNorm:()=>eke});function hO(t,e){return xe(()=>Zi(Xt(fe(t,t),e,!0)))}var qw=class extends rt.Serializable{getConfig(){return{}}},pO=class extends qw{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return xe(()=>{let e=hO(t,this.axis),n=bs(e,0,this.maxValue);return fe(t,zt(n,ze(Mi(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};pO.className="MaxNorm";rt.registerClass(pO);var fO=class extends qw{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return xe(()=>zt(t,ze(Mi(),hO(t,this.axis))))}getConfig(){return{axis:this.axis}}};fO.className="UnitNorm";rt.registerClass(fO);var mO=class extends qw{apply(t){return pr(t)}};mO.className="NonNeg";rt.registerClass(mO);var gO=class extends qw{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return xe(()=>{let e=hO(t,this.axis),n=ze(fe(this.rate,bs(e,this.minValue,this.maxValue)),fe(1-this.rate,e));return fe(t,zt(n,ze(Mi(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};gO.className="MinMaxNorm";rt.registerClass(gO);var vV={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Ri(t){return tO(t)}function xV(t,e={}){return Vw(t,rt.SerializationMap.getMap().classNameMap,e,"constraint")}function Fi(t){if(t==null)return null;if(typeof t=="string"){let e={className:t in vV?vV[t]:t,config:{}};return xV(e)}else return t instanceof qw?t:xV(t)}function Q2e(t){return new pO(t)}function eke(t){return new fO(t)}function tke(){return new mO}function nke(t){return new gO(t)}var tJ={};wn(tJ,{constant:()=>ske,glorotNormal:()=>hke,glorotUniform:()=>dke,heNormal:()=>pke,heUniform:()=>fke,identity:()=>uke,leCunNormal:()=>mke,leCunUniform:()=>gke,ones:()=>ike,orthogonal:()=>yke,randomNormal:()=>oke,randomUniform:()=>ake,truncatedNormal:()=>lke,varianceScaling:()=>cke,zeros:()=>rke});function rke(){return new iO}function ike(){return new tM}function ske(t){return new sO(t)}function ake(t){return new aO(t)}function oke(t){return new oO(t)}function lke(t){return new lO(t)}function uke(t){return new uO(t)}function cke(t){return new da(t)}function dke(t){return new nM(t)}function hke(t){return new rM(t)}function pke(t){return new iM(t)}function fke(t){return new sM(t)}function mke(t){return new aM(t)}function gke(t){return new oM(t)}function yke(t){return new cO(t)}var nJ={};wn(nJ,{Layer:()=>On,RNN:()=>xc,RNNCell:()=>Yw,activation:()=>KNe,add:()=>rRe,alphaDropout:()=>$Re,average:()=>iRe,averagePooling1d:()=>CB,averagePooling2d:()=>MB,averagePooling3d:()=>kB,avgPool1d:()=>pRe,avgPool2d:()=>mRe,avgPool3d:()=>yRe,avgPooling1d:()=>fRe,avgPooling2d:()=>gRe,avgPooling3d:()=>vRe,batchNormalization:()=>cRe,bidirectional:()=>RRe,categoryEncoding:()=>VRe,centerCrop:()=>HRe,concatenate:()=>sRe,conv1d:()=>UNe,conv2d:()=>$Ne,conv2dTranspose:()=>zNe,conv3d:()=>GNe,conv3dTranspose:()=>HNe,convLstm2d:()=>CRe,convLstm2dCell:()=>MRe,cropping2D:()=>VNe,dense:()=>qNe,depthwiseConv2d:()=>XNe,dot:()=>uRe,dropout:()=>JNe,elu:()=>FNe,embedding:()=>nRe,flatten:()=>ZNe,gaussianDropout:()=>URe,gaussianNoise:()=>BRe,globalAveragePooling1d:()=>xRe,globalAveragePooling2d:()=>bRe,globalMaxPool1d:()=>DRe,globalMaxPool2d:()=>PRe,globalMaxPooling1d:()=>iY,globalMaxPooling2d:()=>sY,gru:()=>_Re,gruCell:()=>SRe,input:()=>bJ,inputLayer:()=>RNe,layerNormalization:()=>dRe,leakyReLU:()=>PNe,lstm:()=>ARe,lstmCell:()=>ERe,masking:()=>zRe,maxPool1d:()=>LRe,maxPool2d:()=>ORe,maxPooling1d:()=>aY,maxPooling2d:()=>oY,maxPooling3d:()=>wRe,maximum:()=>aRe,minimum:()=>oRe,multiply:()=>lRe,permute:()=>tRe,prelu:()=>LNe,randomWidth:()=>jRe,reLU:()=>DNe,repeatVector:()=>QNe,rescaling:()=>GRe,reshape:()=>eRe,resizing:()=>WRe,rnn:()=>kRe,separableConv2d:()=>WNe,simpleRNN:()=>IRe,simpleRNNCell:()=>TRe,softmax:()=>ONe,spatialDropout1d:()=>YNe,stackedRNNCells:()=>NRe,thresholdedReLU:()=>BNe,timeDistributed:()=>FRe,upSampling2d:()=>jNe,zeroPadding2d:()=>hRe});async function Xc(t){if(t==null)return;let e=[],n=[],r=[];for(let i in t){let s=t[i];if(typeof s!="number"){let a=s;e.push(a.data()),n.push(i),r.push(a)}}if(e.length>0){let i=await Promise.all(e);for(let s=0;s<i.length;++s)t[n[s]]=i[s][0];bn(r)}}function rJ(t){if(t!=null)for(let e in t){let n=t[e];typeof n!="number"&&n.dispose()}}var bV;(function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"})(bV||(bV={}));var vke=125,r0=class{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}},iJ=class{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(let e of this.callbacks)e.setParams(t)}setModel(t){for(let e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainEnd(t)}},xke=class extends r0{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});let n=e.size==null?0:e.size;this.seen+=n;for(let r in e){let i=e[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*n;else{let s;r in this.totals?s=this.totals[r]:this.totals[r]=0;let a=xe(()=>ze(this.totals[r],fe(i,n)));this.totals[r]=a,s!=null&&s.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?e[n]=this.totals[n]/this.seen:xe(()=>{let r=fe(zt(1,this.seen),this.totals[n]);e[n]=r,this.totals[n].dispose(),Ci(e[n])}))}},sJ=class extends r0{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(let n in e)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){let t=[],e=[],n=[];for(let i in this.history){let s=this.history[i];for(let a=0;a<s.length;++a)if(typeof s[a]!="number"){let o=s[a];t.push(o.data()),e.push(i),n.push(a)}}let r=await Promise.all(t);for(let i=0;i<r.length;++i)this.history[e[i]][n[i]].dispose(),this.history[e[i]][n[i]]=r[i][0]}},aJ=class extends r0{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||QL,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=vke),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");P.isNumber(this.yieldEvery)&&(this.maybeWait=v2e(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){let r=[];this.yield!=null&&(await Xc(n),r.push(this.yield(t,e,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await Xc(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){let n=[];this.epochEnd!=null&&(await Xc(e),n.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(t,e){this.batchBegin!=null&&(await Xc(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){let n=[];this.batchEnd!=null&&(await Xc(e),n.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):P.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){this.trainBegin!=null&&(await Xc(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await Xc(t),await this.trainEnd(t))}};function oJ(t,e){return t==null&&(t={}),t instanceof r0?[t]:Array.isArray(t)&&t[0]instanceof r0?t:dr(t).map(n=>new aJ(n,e))}var yO=class zl{constructor(){}static registerCallbackConstructor(e,n){P.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),zl.checkForDuplicate(n),zl.constructors[e]==null&&(zl.constructors[e]=[]),zl.constructors[e].push(n)}static checkForDuplicate(e){for(let n in zl.constructors)zl.constructors[+n].forEach(r=>{if(r===e)throw new be("Duplicate callback constructor.")})}static clear(){zl.constructors={}}static createCallbacks(e){let n=[];for(let r in zl.constructors){let i=+r;e>=i&&n.push(...zl.constructors[i])}return n.map(r=>new r)}};yO.constructors={};function lJ(t,e,n,r,i,s,a,o,l){let u=new sJ,c=[new xke,...yO.createCallbacks(e)];t!=null&&c.push(...t),c.push(u);let d=new iJ(c);return d.setParams({epochs:n,initialEpoch:r,samples:i,steps:s,batchSize:a,verbose:e,doValidation:o,metrics:l}),{callbackList:d,history:u}}function xl(t,e={},n=!1){return Vw(t,rt.SerializationMap.getMap().classNameMap,e,"layer",n)}function OI(t,e){return xe(()=>{t.dtype!=="float32"&&(t=ft(t,"float32"));let n=Xt(Xw(t),e,!0),r=Pa(n.shape,Mi()),i=Zi(xu(n,r));return zt(t,i)})}function qm(t,e){return xe(()=>Wr(Xw(Dt(e,t)),-1))}function uM(t,e){return xe(()=>Wr(fi(Dt(e,t)),-1))}function kv(t,e){return xe(()=>{let n=Dt(t,e),r=bs(fi(t),Mi(),Number.MAX_VALUE),i=fi(zt(n,r));return fe(100,Wr(i,-1))})}function bke(t,e){return xe(()=>{let n=bs(e,Mi(),Number.MAX_VALUE),r=$a(ze(1,n)),i=bs(t,Mi(),Number.MAX_VALUE),s=$a(ze(1,i));return Wr(Xw(Dt(r,s)),-1)})}function wke(t,e){return xe(()=>{let n=xu(0,Dt(1,fe(t,e)));return Wr(Xw(n),-1)})}function _ke(t,e){return xe(()=>{let n=xu(0,Dt(1,fe(t,e)));return Wr(n,-1)})}function Ske(t,e){return xe(()=>{let n=Xt(fe(t,e),-1),r=oo(fe(Dt(1,t),e),-1);return xu(0,ze(1,Dt(r,n)))})}function Ake(t,e){return xe(()=>{let n=Math.log(2),r=Dt(e,t),i=Dt(ze(r,jm(fe(-2,r))),n);return Wr(i,-1)})}function _1(t,e,n=!1){return xe(()=>{if(n)e=lh(e);else{let r=Xt(e,e.shape.length-1,!0);e=zt(e,r)}return e=bs(e,Mi(),1-Mi()),Mr(Xt(fe(ft(t,"float32"),$a(e)),e.shape.length-1))})}function BI(t,e,n=!1){return xe(()=>{let r=ft(Av(k2e(t)),"int32");e=bs(e,Mi(),1-Mi());let i=e.shape,s=ve(Yy(r,i[i.length-1]),i);return _1(s,e,n)})}function Eke(t,e){if(!P.arraysEqual(t.shape,e.shape))throw new be(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return xe(()=>{let n=pr(e),r=Mr(fi(e));return ze(Dt(n,fe(e,t)),Pw(ws(r)))})}function cM(t,e){return xe(()=>{let n;return n=bs(e,Mi(),1-Mi()),n=$a(zt(n,Dt(1,n))),Wr(Eke(t,n),-1)})}function Ike(t,e){return xe(()=>{let n=bs(t,Mi(),1),r=bs(e,Mi(),1);return Xt(fe(t,$a(zt(n,r))),-1)})}function Tke(t,e){return xe(()=>{let n=$a(ze(Mi(),e));return Wr(Dt(e,fe(t,n)),-1)})}function vO(t,e){return xe(()=>{let n=OI(t,-1),r=OI(e,-1),i=fe(n,r);return Mr(Xt(i,-1))})}var UI={meanSquaredError:qm,meanAbsoluteError:uM,meanAbsolutePercentageError:kv,meanSquaredLogarithmicError:bke,squaredHinge:wke,hinge:_ke,categoricalHinge:Ske,logcosh:Ake,categoricalCrossentropy:_1,sparseCategoricalCrossentropy:BI,binaryCrossentropy:cM,kullbackLeiblerDivergence:Ike,poisson:Tke,cosineProximity:vO};function EN(t){if(typeof t=="string"){if(t in UI)return UI[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new be(e)}else return t}function xO(t,e){return xe(()=>{let n=fe(.5,za(e)),r=dc(Xs(e,n),t.dtype);return Wr(Ua(t,r),-1)})}function bO(t,e){return xe(()=>dc(Ua(ef(t,-1),ef(e,-1)),"float32"))}function uJ(t,e){return xe(()=>ft(Xt(Go(Ua(t,1),Ua(e,1))),"float32"))}function Cke(t,e){return xe(()=>ft(Xt(Go(Ua(t,1),Ua(e,0))),"float32"))}function Mke(t,e){return xe(()=>ft(Xt(Go(Ua(t,0),Ua(e,1))),"float32"))}function cJ(t,e){return xe(()=>{let n=uJ(t,e),r=Mke(t,e),i=ze(n,r);return ft(qi(Xs(i,0),zt(n,i),0),"float32")})}function kke(t,e){return xe(()=>{let n=uJ(t,e),r=Cke(t,e),i=ze(n,r);return ft(qi(Xs(i,0),zt(n,i),0),"float32")})}function dJ(t,e){return cM(t,e)}function hJ(t,e){return t.rank===e.rank&&(t=uh(t,[t.rank-1])),e=ef(e,-1),e.dtype!==t.dtype&&(e=ft(e,t.dtype)),ft(Ua(t,e),"float32")}function Nke(t,e){return xe(()=>{let n=t.sub(e).square().sum(),r=t.sub(t.mean()).square().sum();return rn(1).sub(n.div(r))})}var Rke=qm,Fke=qm,Dke=uM,Pke=uM,Lke=kv,Oke=kv,wO=_1,Bke=vO,pJ=BI,$I={binaryAccuracy:xO,categoricalAccuracy:bO,precision:cJ,categoricalCrossentropy:wO,sparseCategoricalCrossentropy:pJ,mse:Rke,MSE:Fke,mae:Dke,MAE:Pke,mape:Lke,MAPE:Oke,cosine:Bke};function Uke(t){if(typeof t=="string"&&t in $I)return $I[t];if(typeof t!="string"&&t!=null)return t;throw new be(`Unknown metric ${t}`)}function wA(t){if(Xl(t!==null,`Unknown LossOrMetricFn ${t}`),typeof t=="string")return t;{let e;for(let n of Object.keys(UI))if(UI[n]===t){e=n;break}if(e!==void 0)return e;for(let n of Object.keys($I))if($I[n]===t){e=n;break}return e!==void 0?e:t.name}}function $ke(t){let e={Adagrad:()=>Qh.adagrad(.01),Adadelta:()=>Qh.adadelta(1,.95,Mi()),Adam:()=>Qh.adam(.001,.9,.999,Mi()),Adamax:()=>Qh.adamax(.002,.9,.999,Mi(),0),RMSProp:()=>Qh.rmsprop(.001,.9,0,Mi()),SGD:()=>Qh.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new be(`Unknown Optimizer ${t}`)}function wV(t,e,n=!1){if(t==null||typeof t!="object"||Object.getPrototypeOf(t)!==Object.prototype||!kF(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let r=JSON.stringify(t);r.length>1048576&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function kF(t){if(t===null)return!0;if(typeof t=="object")if(Object.getPrototypeOf(t)===Object.prototype){let e=Object.keys(t);for(let n of e)if(typeof n!="string"||!kF(t[n]))return!1;return!0}else if(Array.isArray(t)){for(let e of t)if(!kF(e))return!1;return!0}else return!1;else{let e=typeof t;return e==="string"||e==="number"||e==="boolean"}}function zke(t,e,n,r=console.log){let i=Hke(t),s=["Layer (type)","Input Shape","Output shape","Param #"];i?(e=e||90,n=n||[.32,.61,.89,1]):(e=e||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(e*c)));let a;if(!i){s.push("Receives inputs"),a=[];for(let c in t.nodesByDepth)a.push(...t.nodesByDepth[c])}r("_".repeat(e)),zI(s,n,r),r("=".repeat(e));let o=t.layers;for(let c=0;c<o.length;++c)i?Wke(o[c],n,r):Vke(o[c],n,a,r),r((c===o.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();let l=Gke(t),u=DI(t.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(e))}function Gke(t){let e;return t.collectedTrainableWeights!=null?e=DI(t.collectedTrainableWeights):e=DI(t.trainableWeights),e}function Hke(t){let e=!0,n=[],r=[];for(let i in t.nodesByDepth)n.push(t.nodesByDepth[i]);for(let i of n){if(i.length>1||i.length===1&&i[0].inboundLayers.length>1){e=!1;break}r.push(...i)}if(e)for(let i of t.layers){let s=!1;for(let a of i.inboundNodes)if(r.indexOf(a)!==-1)if(s){e=!1;break}else s=!0;if(!e)break}return e}function zI(t,e,n=console.log){let r="";for(let i=0;i<t.length;++i)i>0&&(r=r.slice(0,r.length-1)+" "),r+=t[i],r=r.slice(0,e[i]),r+=" ".repeat(e[i]-r.length);n(r)}function Wke(t,e,n){let r,i;try{i=t.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(t.outputShape)}catch{r="multiple"}let s=t.name,a=t.getClassName(),o=[`${s} (${a})`,i,r,t.countParams().toString()];zI(o,e,n)}function Vke(t,e,n,r){let i,s;try{s=t.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{s="multiple"}try{i=JSON.stringify(t.outputShape)}catch{i="multiple"}let a=[];for(let d of t.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(d)===-1))for(let h=0;h<d.inboundLayers.length;++h){let p=d.inboundLayers[h].name,f=d.nodeIndices[h],g=d.tensorIndices[h];a.push(`${p}[${f}][${g}]`)}let o=t.name,l=t.getClassName(),u=a.length===0?"":a[0],c=[`${o} (${l})`,s,i,t.countParams().toString(),u];zI(c,e,r);for(let d=1;d<a.length;++d)zI(["","","","",a[d]],e,r)}function fJ(t,e,n){return(t==="inboundNodes"||t==="outputLayers"||t==="inputLayers")&&e===0&&typeof n=="string"}function S1(t,e){if(t===null)return null;if(typeof t=="string")return sp(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){let n=[],r=t.length;for(let i=0;i<r;++i){let s=t[i];fJ(e,i,s)?n.push(s):n.push(S1(s,e))}return n}else{let n={};for(let r of Object.keys(t)){let i=t[r];if(r==="name"&&typeof i=="string")n[r]=i;else{let s=sp(r);n[s]=S1(i,s)}}return n}}function NF(t,e){if(t==null)return null;if(typeof t=="string")return Uu(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){let n=[],r=t.length;for(let i=0;i<r;++i){let s=t[i];fJ(e,i,s)?n.push(s):n.push(NF(s,e))}return n}else{let n={};for(let r of Object.keys(t)){let i=t[r],s=Uu(r);(r==="name"||r==="className")&&typeof i=="string"?n[s]=i:n[s]=NF(i,r)}return n}}var _O="4.22.0",jke=t=>{let e=Object.keys(t);if(e.length===0)return!1;let n=e[0].split("/");return!isNaN(parseInt(n[n.length-1],10))},Xke=class Gl extends On{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){let b=this.getClassName().toLowerCase();this.name=QC(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Ad(this.inputs).length!==this.inputs.length)throw new be(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Ad(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let b of this.outputs){let w=b.sourceLayer,_=b.nodeIndex,S=b.tensorIndex;this.outputLayers.push(w),this.outputLayersNodeIndices.push(_),this.outputLayersTensorIndices.push(S)}for(let b of this.inputs){let w=b.sourceLayer,_=b.nodeIndex,S=b.tensorIndex;Xl(_===0,"input layer has >1 nodes"),Xl(S===0,"input layer has >1 tensors"),this.inputLayers.push(w),this.inputLayersNodeIndices.push(_),this.inputLayersTensorIndices.push(S)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){let w=this.inputLayers[b];if(!(w instanceof Mv))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${w.getClassName()}.`);this.inputNames.push(w.name),this.feedInputShapes.push(w.batchInputShape),this.feedInputNames.push(w.name)}for(let b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);let n={},r={},i={},s={},a={},o=[],l=(b,w,_,S,E,C)=>{(S==null||E==null||C==null)&&(S=b.sourceLayer,E=b.nodeIndex,C=b.tensorIndex);let T=S.inboundNodes[E];if(_.indexOf(T)!==-1)throw new Zl(`The tensor ${b.name} at layer "${S.name}" is part of a cycle.`);if(w.indexOf(T)!==-1)return;this.containerNodes.add(Gl.nodeKey(S,E)),S.id in a||(a[S.id]=Object.keys(a).length),_.indexOf(T)===-1&&_.push(T);let M=T.inboundLayers.length;for(let k=0;k<M;k++){let R=T.inputTensors[k],N=T.inboundLayers[k],B=T.nodeIndices[k],z=T.tensorIndices[k];l(R,w,_,N,B,z)}for(w.push(T);_.indexOf(T)>=0;)_.splice(_.indexOf(T),1);o.push(T)},u=[],c=[];for(let b of this.outputs)l(b,u,c);let d=o.slice().reverse();for(let b of d){r[b.id]=b,b.id in n||(n[b.id]=0);let w=n[b.id],_=i[b.outboundLayer.id]==null?0:i[b.outboundLayer.id];w=Math.max(w,_),i[b.outboundLayer.id]=w,s[b.outboundLayer.id]=b.outboundLayer,n[b.id]=w;for(let S=0;S<b.inboundLayers.length;S++){let E=b.inboundLayers[S],C=b.nodeIndices[S],T=E.inboundNodes[C],M=n[T.id]==null?0:n[T.id];n[T.id]=Math.max(w+1,M),r[T.id]=T}}let h={};for(let b in n){let w=n[b];w in h||(h[w]=[]),h[w].push(r[b])}let p={};for(let b in i){let w=i[b];w in p||(p[w]=[]),p[w].push(s[b])}let f=Object.keys(p).map(b=>parseInt(b,10)).sort(vA);this.layers=[];for(let b of f){let w=p[b];w.sort((_,S)=>{let E=a[_.id],C=a[S.id];return E<C?-1:E>C?1:0});for(let _ of w)_ instanceof Gl&&this.internalContainerRefs.push(_),this.layers.push(_)}this.layersByDepth=p,f=Object.keys(h).map(b=>parseInt(b,10)).sort(vA);let g=this.inputs.slice(),y=[];for(let b of f)for(let w of h[b]){let _=w.outboundLayer;if(_!=null){for(let S of w.inputTensors)if(g.indexOf(S)===-1)throw new Zl(`Graph disconnected: cannot obtain value for tensor ${S} at layer "${_.name}". The following previous layers were accessed without issue: ${y}`);for(let S of w.outputTensors)g.push(S);y.push(_.name)}}this.nodesByDepth=h;let m=this.layers.map(b=>b.name);for(let b of m){let w=m.filter(_=>_===b).length;if(w!==1)throw new Zl(`The name "${b}" is used ${w} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(m))}this.outboundNodes=[],this.inboundNodes=[],new lM({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let n of this.layers)e.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)e.numDisposedVariables+=n.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(n=>{n._trainableWeights.forEach(r=>r.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new be("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let n of this.layers)e=e.concat(n.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let n of this.layers)e.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let r of this.layers)n.push(...r.trainableWeights);return n.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,n=!0){let r={},i=0,s=jke(e);s&&this.parseWeights(e);for(let o of this.layers)for(let[l,u]of o.weights.entries()){let c=s?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(r[c]!=null)throw new be(`Duplicate weight name: ${c}`);r[c]=u,i++}let a=[];for(let o in e){let l=o;if(r[o]==null){let u=o.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(r[l]!=null)a.push([r[l],e[o]]);else if(n)throw new be(`Provided weight data has no target variable: ${o}`);delete r[l]}if(n){let o=[];for(let l in r)o.push(l);if(o.length>0)throw new be(`${o.length} of ${i} weights are not set: ${o}`)}dO(a)}parseWeights(e){for(let n in Object.keys(e)){let r=n.split("/"),i=["vars","layer_checkpoint_dependencies"],s=r.map(a=>a.startsWith("_")?a.slice(1):a).filter(a=>!i.includes(a)).join("/");s!==n&&(e[s]=e[n],delete e[n])}}updatedConfig(){let e=this.getConfig(),n={};return n.className=this.getClassName(),n.config=e,n.kerasVersion=`tfjs-layers ${_O}`,n.backend="TensorFlow.js",n}toJSON(e,n=!0){let r=NF(this.updatedConfig());return n?JSON.stringify(r):r}call(e,n){return xe(()=>{e=dr(e);let r=new uy;for(let i=0;i<this.inputs.length;++i)r.add(this.inputs[i],e[i]);return tb(this.outputs,r,n)})}computeMask(e,n){return xe(()=>{e=dr(e);let r;return n==null?r=af(null,e.length):r=dr(n),this.runInternalGraph(e,r)[1]})}computeOutputShape(e){let n=FI(e);if(n.length!==this.inputLayers.length)throw new be(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let r={};for(let o=0;o<n.length;o++){let l=this.inputLayers[o],u=n[o],c=l.name+"_0_0";r[c]=u}let i=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(vA);if(i.length>1)for(let o of i){let l=this.nodesByDepth[o];for(let u of l){let c=u.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(c.id)!==-1)continue;let d=[];for(let g=0;g<u.inboundLayers.length;g++){let y=u.inboundLayers[g],m=u.nodeIndices[g],b=u.tensorIndices[g],w=`${y.name}_${m}_${b}`,_=r[w];d.push(_)}let h=c.computeOutputShape(ea(d)),p=FI(h),f=c.inboundNodes.indexOf(u);for(let g=0;g<p.length;g++){let y=`${c.name}_${f}_${g}`;r[y]=p[g]}}}let s=[],a=[];for(let o=0;o<this.outputLayers.length;o++){let l=this.outputLayers[o],u=this.outputLayersNodeIndices[o],c=this.outputLayersTensorIndices[o],d=`${l.name}_${u}_${c}`;a.push(d)}for(let o=0;o<a.length;o++){let l=a[o];Xl(l in r),s.push(r[l])}return ea(s)}runInternalGraph(e,n){n==null&&(n=af(null,e.length));let r={};for(let l=0;l<this.inputs.length;++l){let u=this.inputs[l],c=e[l],d=n[l];r[u.id]=[c,d]}let i=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(vA);for(let l of i){let u=this.nodesByDepth[l];for(let c of u){let d=c.outboundLayer,h=c.inputTensors,p=c.outputTensors,f=new Array;for(let g of h)g.id in r&&f.push(r[g.id]);if(f.length===h.length){let g={},y,m,b,w;if(c.callArgs!=null&&(g=c.callArgs),f.length===1){let[_,S]=f[0];g.mask==null&&(g.mask=S),b=dr(d.call(_,g)),w=dr(d.computeMask(_,S)),y=[_],m=[S]}else y=f.map(_=>_[0]),m=f.map(_=>_[1]),g.mask==null&&(g.mask=m),b=dr(d.call(y,g)),w=dr(d.computeMask(y,m));if(d.activityRegularizer)throw new Pn("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let _=0;_<p.length;++_){let S=p[_],E=b[_],C=w[_];r[S.id]=[E,C]}}}}let s=[],a=[],o=[];for(let l of this.outputs){Xl(l.id in r,`Could not compute output ${l.name} : ${l.id}`);let[u,c]=r[l.id];o.push(u.shape),s.push(u),a.push(c)}return[s,a,o]}buildNodeConversionMap(e){let n={},r;for(let i of this.layers){r=i instanceof Gl?1:0;for(let s=0;s<i.inboundNodes.length;s++){let a=Gl.nodeKey(i,s);this.containerNodes.has(a)&&(n[a]=r,r+=1)}}return n}getLayer(e,n){if(n!=null)return this.findLayer(n);if(e==null)throw new be("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(let r of this.layers)if(r.name===e)return r;throw new be(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new be(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return xe(()=>{let e=[];for(let n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){let i=Gl.nodeKey(n,r);this.containerNodes.has(i)&&e.push(...n.calculateLosses())}return e})}getConfig(){let e={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(let a of this.layers){let o=a.getClassName(),l=a.getConfig(),u=[];for(let d=0;d<a.inboundNodes.length;d++){let h=a.inboundNodes[d],p=Gl.nodeKey(a,d),f={};if(this.containerNodes.has(p)){if(h.callArgs)try{JSON.stringify(h.callArgs),f=h.callArgs}catch{console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(h.inboundLayers.length>0){let g=[];for(let y=0;y<h.inboundLayers.length;y++){let m=h.inboundLayers[y],b=h.nodeIndices[y],w=h.tensorIndices[y],_=Gl.nodeKey(m,b),S=n[_];S==null&&(S=0),g.push([m.name,S,w,f])}u.push(g)}}}let c={};c.name=a.name,c.className=o,c.config=l,c.inboundNodes=u,r.push(c)}e.layers=r;let i=[];for(let a=0;a<this.inputLayers.length;a++){let o=this.inputLayers[a],l=this.inputLayersNodeIndices[a],u=Gl.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);let d=this.inputLayersTensorIndices[a];i.push([o.name,c,d])}e.inputLayers=i;let s=[];for(let a=0;a<this.outputLayers.length;a++){let o=this.outputLayers[a],l=this.outputLayersNodeIndices[a],u=Gl.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);let d=this.outputLayersTensorIndices[a];s.push([o.name,c,d])}return e.outputLayers=s,e}static fromConfig(e,n,r={},i=!1){let s={},a={};function o(y,m){y.name in a?a[y.name].push(m):a[y.name]=[m]}function l(y,m){let b=[],w;for(let _ of m){let S=_[0],E=_[1],C=_[2];if(w=_[3]==null?{}:_[3],!(S in s)){o(y,m);return}let T=s[S];if(T.inboundNodes.length<=E){o(y,m);return}let M=T.inboundNodes[E];b.push(M.outputTensors[C])}b.length>0&&y.apply(ea(b),w)}function u(y){let m=y.name,b=xl(y,n.customObjects!=null?n.customObjects:{});b.setFastWeightInitDuringBuild(i),s[m]=b,y.inboundNodes.forEach(w=>{if(!(w instanceof Array))throw new be(`Corrupted configuration, expected array for nodeData: ${w}`);o(b,w)})}let c=n.name,d=n.layers;for(let y of d)u(y);for(;!y2e(a);)for(let y of d){let m=s[y.name];if(m.name in a){let b=a[m.name];delete a[m.name];for(let w of b)l(m,w)}}let h=[],p=[],f=n.inputLayers;for(let y of f){let m=y[0],b=y[1],w=y[2];Xl(m in s);let _=s[m].inboundNodes[b].outputTensors;h.push(_[w])}let g=n.outputLayers;for(let y of g){let m=y[0],b=y[1],w=y[2];Xl(m in s);let _=s[m].inboundNodes[b].outputTensors;p.push(_[w])}return new e({inputs:h,outputs:p,name:c})}get stateful(){if(this._stateful)throw new be("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){xe(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}};function Kke(t,e,n){let r=e.length;if(t==null||Array.isArray(t)&&t.length===0)return e.map(i=>null);if(r===1)return Array.isArray(t)&&t.length===1?t:typeof t=="object"&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error(`Provided ${n} is an array of ${t.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return t}else if(typeof t=="object"&&Object.keys(t).length>0&&typeof t[Object.keys(t)[0]]=="object"){let i=[];return e.forEach(s=>{s in t?i.push(t[s]):i.push(null)}),i}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${e} keys. Provided ${n} not understood: ${JSON.stringify(t)}`)}function mJ(t,e){return Kke(t,e,"classWeight")}async function gJ(t,e,n,r){if(n!=null){let i=xe(()=>{if(t.shape.length===1)return su(t);if(t.shape.length===2){if(t.shape[1]>1)return ef(t,1);if(t.shape[1]===1)return ve(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await i.data());bn(i);let a=[];return s.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);a.push(n[o])}),cr(a,"float32")}else return null}function qke(t,e){return fe(t,e)}var Jke=32;function yJ(t,e){let n,r,i=e;n=i.xs,r=i.ys,P.assert(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);let s=_V("input",t.inputNames,n),a=_V("output",t.outputNames,r),o=s[0].shape[0];P.assert(s.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),P.assert(a.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let l=0;l<s.length;l++)P.assert(s[l].shape[0]===o,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`);for(let l=0;l<a.length;l++)P.assert(a[l].shape[0]===o,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`);return{xs:s,ys:a}}function _V(t,e,n){if(n instanceof In)return[n];if(Array.isArray(n))return P.assert(n.length===e.length,()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`),n;{let r=[];for(let i of e){if(n[i]==null)throw new be(`The feature data generated by the dataset lacks the required ${t} key '${i}'.`);r.push(n[i])}return r}}function Yke(t){if(t.length===3)throw new Pn("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}async function Zke(t,e,n){let r=n.batchesPerEpoch!=null;if(P.assert(t.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),P.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),P.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),P.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),P.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{let i=n.validationData!=null,s,a;if(i)if(SV(n.validationData))P.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let y=Yke(n.validationData);s=y.xs,a=y.ys}let o=t.makeTrainFunction(),l=t.getDedupedMetricsNames(),u;i?u=l.slice().concat(l.map(y=>"val_"+y)):u=l.slice();let c=oJ(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:h,history:p}=lJ(c,d,n.epochs,null,null,Qke(e,n),null,i,u);h.setModel(t),t.history=p,await h.onTrainBegin(),t.stopTraining_=!1;let f=n.initialEpoch==null?0:n.initialEpoch,g=await e.iterator();for(;f<n.epochs;){let y={};await h.onEpochBegin(f);let m=0,b=0;for(r||(g=await e.iterator());!r||m<n.batchesPerEpoch;){let w=await g.next();if(r&&w.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${m} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(w.value!=null){let{xs:_,ys:S}=yJ(t,w.value),E={};E.batch=b,E.size=_[0].shape[0],await h.onBatchBegin(b,E);let C=[];if(n.classWeight!=null){let k=mJ(n.classWeight,t.outputNames);for(let R=0;R<k.length;++R)C.push(await gJ(S[R],null,k[R]))}let T=_.concat(S).concat(C),M=o(T);bn(T);for(let k=0;k<l.length;++k){let R=l[k],N=M[k];E[R]=N,Ci(N)}await h.onBatchEnd(b,E),rJ(E),b++,m++}if(r?m>=n.batchesPerEpoch:w.done){if(i){let _;SV(n.validationData)?_=dr(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):_=dr(t.evaluate(s,a,{batchSize:n.validationBatchSize==null?Jke:n.validationBatchSize,verbose:0}));for(let S=0;S<t.metricsNames.length;++S)y[`val_${t.metricsNames[S]}`]=_[S]}break}if(t.stopTraining_)break}if(await h.onEpochEnd(f,y),f++,t.stopTraining_)break}return await h.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}function Qke(t,e){let n=null;return e.batchesPerEpoch!=null?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}function SV(t){return typeof t.iterator=="function"}function eNe(t){return typeof t.next=="function"}async function tNe(t,e,n){n=n||{};let r=n.batches!=null,i=t.testFunction,s=[];if(n.verbose>0)throw new Pn("Verbose mode is not implemented yet.");P.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let a=eNe(e)?e:await e.iterator(),o=0,l=0;for(;!r||l<n.batches;){let u=await a.next();if(s=xe(()=>{if(u.value){let{xs:c,ys:d}=yJ(t,u.value),h=c.concat(d),p=xe(()=>i(h));if(bn(h),l===0)for(let g=0;g<p.length;++g)s.push(rn(0));let f=h[0].shape[0];for(let g=0;g<p.length;++g){let y=p[g],m=s[g];s[g]=xe(()=>ze(s[g],fe(f,y))),l>0&&bn(m)}bn(p),o+=f,++l}return s}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){let c=s[u];s[u]=zt(s[u],o),bn(c)}return ea(s)}function IN(t){P.assert(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function $x(t,e,n){return t==null?[null]:Array.isArray(t)?t.map(r=>Np(r,e,n-e)):Np(t,e,n-e)}function RF(t,e){return xe(()=>t==null?null:Array.isArray(t)?t.map(n=>RF(n,e)):Kq(t,e.dtype==="int32"?e:ft(e,"int32")))}function TN(t,e){let n=[],r=0,i=null;for(;r<t;)i=r+e,i>=t&&(i=t),n.push([r,i]),r=i;return n}function vJ(t){let e=[];t instanceof In&&(t=[t]);for(let n=0;n<t.length;++n){let r=t[n];if(r.rank===1)e.push(jw(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function sl(t,e){if(t==null)return;let n=[];if(e instanceof In)n.push(e.id);else if(Array.isArray(e))e.forEach(i=>n.push(i.id));else if(e!=null)for(let i in e){let s=e[i];n.push(s.id)}let r=[];if(t instanceof In)n.indexOf(t.id)===-1&&r.push(t);else if(Array.isArray(t))t.forEach(i=>{n.indexOf(i.id)===-1&&r.push(i)});else if(t!=null)for(let i in t){let s=t[i];n.indexOf(s.id)===-1&&r.push(s)}r.forEach(i=>{i.isDisposed||i.dispose()})}function nNe(t){return t instanceof In}function FF(t){return Array.isArray(t)}function AV(t){return!nNe(t)&&!FF(t)}function EV(t,e,n,r=!0,i=""){if(e==null||e.length===0){if(t!=null){let a=!1;if(FF(t)&&t.length>0)a=!0;else if(AV(t)){for(let o in t)if(t.hasOwnProperty(o)){a=!0;break}}else a=!0;if(a)throw new be(`Error when checking model ${i} expected no data, but got ${t}`)}return[]}if(t==null)return e.map(a=>null);let s;if(AV(t)){t=t,s=[];for(let a of e){if(t[a]==null)throw new be(`No data provided for "${a}". Need data for each key in: ${e}`);s.push(t[a])}}else if(FF(t)){if(t=t,t.length!==e.length)throw new be(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);s=t}else{if(t=t,e.length>1)throw new be(`The model ${i} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);s=[t]}if(s=vJ(s),n!=null)for(let a=0;a<e.length;++a){if(n[a]==null)continue;let o=s[a];if(o.shape.length!==n[a].length)throw new be(`Error when checking ${i}: expected ${e[a]} to have ${n[a].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[a].length;++l){if(l===0&&!r)continue;let u=o.shape[l],c=n[a][l];if(c!=null&&c>=0&&u!==c)throw new be(`${i} expected a batch of elements where each example has shape [${n[a].slice(1,n[a].length)}] (i.e.,tensor shape [*,${n[a].slice(1,n[a].length)}]) but the ${i} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function rNe(t,e,n){let r=Ad(t.map(s=>s.shape[0]));r.sort();let i=Ad(e.map(s=>s.shape[0]));if(i.sort(),r.length>1)throw new be(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(i.length>1)throw new be(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(r.length>0&&i.length>0&&!P.arraysEqual(r,i))throw new be(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${i[0]} target sample(s).`)}function iNe(t,e,n){let r=[qm,cM,_1];for(let i=0;i<t.length;++i){let s=t[i],a=e[i],o=n[i];if(a!=null){if(a===_1&&s.shape[s.shape.length-1]===1)throw new be(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(a)!==-1){let l=s.shape.slice(1),u=o.slice(1);for(let c=0;c<l.length;++c){let d=l[c],h=u[c];if(h!=null&&d!==h)throw new be(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function IV(t,e,n,r=!0,i=""){let s;if(Array.isArray(t)){if(t.length!==e.length)throw new be(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);s=t}else{if(e.length>1)throw new be(`The model expects ${e.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);s=[t]}if(n!=null)for(let a=0;a<e.length;++a){if(n[a]==null)continue;let o=s[a];if(o.shape.length!==n[a].length)throw new be(`Error when checking ${i}: expected ${e[a]} to have ${n[a].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[a].length;++l){if(l===0&&!r)continue;let u=o.shape[l],c=n[a][l];if(c!=null&&c!==u)throw new be(`Error when checking ${i}: expected ${e[a]} to have shape ${JSON.stringify(n[a])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function sNe(t,e){if(t==null||Array.isArray(t)&&t.length===0)return e.map(r=>[]);let n;if(typeof t=="string"||typeof t=="function")n=[t];else if(Array.isArray(t)||typeof t=="object")n=t;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);if(Array.isArray(n))return e.map(r=>n);{let r=[];for(let i of e){let s=n.hasOwnProperty(i)?n[i]:[];Array.isArray(s)||(s=[s]),r.push(s)}return r}}var aNe="layers-model",ec=class extends Xke{constructor(t){super(t),this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new be("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");zke(this,t,e,n)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=$ke(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof vc))throw new be("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(let s in t.loss)if(this.outputNames.indexOf(s)===-1)throw new be(`Unknown entry in loss dictionary: "${s}". Only expected the following keys: ${this.outputNames}`);for(let s of this.outputNames)t.loss[s]==null&&console.warn(`Output "${s}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${s} during training`),e.push(EN(t.loss[s]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new be(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(s=>EN(s))}else{let s=EN(t.loss);this.outputs.forEach(a=>{e.push(s)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let a=this.internalOutputShapes[s],o=this.outputNames[s];this.feedOutputNames.push(o),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],kp("loss",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let a=this.lossFunctions[s];this.outputs.length>1&&(this.metricsTensors.push([a,s]),this.metricsNames.push(this.outputNames[s]+"_loss"))}});let r=sNe(t.metrics,this.outputNames),i=(s,a,o)=>{this.outputNames.length>1&&(a=this.outputNames[s]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([o,s])};kp("metric",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let a=r[s];(o=>{let l="",u,c,d;for(let h of o){if(typeof h=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(h)!==-1){let f=this.internalOutputShapes[s];f[f.length-1]===1||this.lossFunctions[s]===cM?["accuracy","acc"].indexOf(h)!==-1?c=xO:["crossentropy","ce"].indexOf(h)!==-1&&(c=dJ):this.lossFunctions[s]===BI?["accuracy","acc"].indexOf(h)!==-1?c=hJ:["crossentropy","ce"].indexOf(h)!==-1&&(c=pJ):["accuracy","acc"].indexOf(h)!==-1?c=bO:["crossentropy","ce"].indexOf(h)!==-1&&(c=wO);let g;["accuracy","acc"].indexOf(h)!==-1?g="acc":["crossentropy","ce"].indexOf(h)!==-1&&(g="ce"),d=c,u=l+g}else d=Uke(h),u=l+wA(h);let p;kp(u,()=>{p=d}),i(s,u,p)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){let r=n.batchSize==null?32:n.batchSize;IN(r);let i=this.standardizeUserDataXY(t,e,!0,r);try{let s=i[0].concat(i[1]);this.makeTestFunction();let a=this.testFunction,o=this.testLoop(a,s,r,n.verbose,n.steps);return ea(o)}finally{sl(i[0],t),sl(i[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),tNe(this,t,e)}checkNumSamples(t,e,n,r="steps"){let i;if(n!=null){if(i=null,e!=null)throw new be(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?i=t[0].shape[0]:i=t.shape[0];else throw new be(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new be("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(e),r=n?e:[e],i=this.retrieveSymbolicTensors(r),s=new uy;if(t instanceof In&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new be(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)s.add(this.inputs[o],t[o])}else for(let o of this.inputs){let l=t[o.name];if(l==null)throw new be(`No value is provided for the model's input ${o.name}`);s.add(o,l)}let a=tb(i,s);return n?a:a[0]}retrieveSymbolicTensors(t){let e=af(null,t.length),n=t.length;for(let r of this.layers){let i=Array.isArray(r.output)?r.output:[r.output],s=i.map(a=>a.name);for(let a=0;a<t.length;++a){let o=s.indexOf(t[a]);if(o!==-1&&(e[a]=i[o],n--),n===0)break}if(n===0)break}if(n>0){let r=[];throw e.forEach((i,s)=>{i==null&&r.push(t[s])}),new be(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return e}predictLoop(t,e=32,n=!1){return xe(()=>{let r=this.checkNumSamples(t);if(n)throw new Pn("Verbose predictLoop() is not implemented yet.");let i=TN(r,e),s=this.outputs.map(a=>[]);for(let a=0;a<i.length;++a)xe(()=>{let o=i[a][0],l=i[a][1],u=$x(t,o,l),c=[];if(Array.isArray(u))for(let h=0;h<u.length;++h)c.push({key:this.inputs[h],value:u[h]});else c.push({key:this.inputs[0],value:u});let d=new uy(c);return tb(this.outputs,d)}).forEach((o,l)=>s[l].push(o));return ea(s.map(a=>wr(a,0)))})}predict(t,e={}){let n=vJ(t);IV(n,this.inputNames,this.feedInputShapes,!1);try{let r=e.batchSize==null?32:e.batchSize;return IN(r),this.predictLoop(n,r)}finally{sl(n,t)}}predictOnBatch(t){IV(t,this.inputNames,this.feedInputShapes,!0);let e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,r){if(this.optimizer_==null)throw new Zl("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let i=[];for(let s=0;s<this.feedOutputShapes.length;++s){let a=this.feedOutputShapes[s];this.feedLossFns[s]===BI?i.push(a.slice(0,a.length-1).concat([1])):i.push(a)}if(t=EV(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=EV(e,this.feedOutputNames,i,!1,"target"),rNe(t,e),iNe(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&t[0].shape[0]%r!==0)throw new be(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,n,r,i=!0,s){let[a,o]=this.standardizeUserDataXY(t,e,i,s);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(r!=null){let u=mJ(r,this.outputNames);l=[];for(let c=0;c<u.length;++c)l.push(await gJ(o[c],null,u[c]))}return[a,o,l]}testLoop(t,e,n,r=0,i){return xe(()=>{let s=this.checkNumSamples(e,n,i,"steps"),a=[];if(r>0)throw new Pn("Verbose mode is not implemented yet.");if(i!=null)throw new Pn("steps mode in testLoop() is not implemented yet");{let o=TN(s,n),l=cr(_l(0,s));for(let u=0;u<o.length;++u){let c=o[u][0],d=o[u][1],h=Np(l,c,d-c),p=RF(e,h),f=t(p);if(u===0)for(let g=0;g<f.length;++g)a.push(rn(0));for(let g=0;g<f.length;++g){let y=f[g];a[g]=ze(a[g],fe(d-c,y))}}for(let u=0;u<a.length;++u)a[u]=zt(a[u],s)}return a})}getDedupedMetricsNames(){let t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){let r=t[n],i=r;if(dV(t,r)>1){let s=dV(t.slice(0,n),r);i+=`_${s}`}e.push(i)}return e}makeTrainFunction(){return t=>{let e=[],n=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),s=[],a=()=>{let l=[];for(let h=0;h<this.inputs.length;++h)l.push({key:this.inputs[h],value:n[h]});let u=new uy(l),c=tb(this.outputs,u,{training:!0}),d;for(let h=0;h<this.lossFunctions.length;++h){let p=this.lossFunctions[h],f=p(r[h],c[h]);i[h]!=null&&(f=qke(f,i[h]));let g=Wr(f);e.push(g),h===0?d=f:d=ze(d,f)}for(let h=0;h<this.metricsTensors.length;++h){let p;if(this.outputs.length>1&&h<this.outputs.length)p=e[h];else{let f=this.metricsTensors[h][0],g=this.metricsTensors[h][1];p=Wr(f(r[g],c[g]))}Ci(p),s.push(p)}return d=Wr(d),this.calculateLosses().forEach(h=>{d=ze(d,h)}),d},o=this.collectedTrainableWeights.map(l=>l.read());return[this.optimizer_.minimize(a,!0,o)].concat(s)}}makeTestFunction(){this.testFunction=t=>xe(()=>{let e=[],n,r=t.slice(0,this.inputs.length),i=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let l=0;l<this.inputs.length;++l)s.push({key:this.inputs[l],value:r[l]});let a=new uy(s),o=tb(this.outputs,a);for(let l=0;l<this.lossFunctions.length;++l){let u=this.lossFunctions[l],c=Wr(u(i[l],o[l]));l===0?n=c:n=ze(n,c),e.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let u=this.metricsTensors[l][0],c=this.metricsTensors[l][1],d=Wr(u(i[c],o[c]));e.push(d)}return e})}async fit(t,e,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,i,s,a,o,l,u,c,d;try{let h=n.batchSize==null?32:n.batchSize;IN(h);let p=await this.standardizeUserData(t,e,n.sampleWeight,n.classWeight,!1,h);r=p[0],i=p[1],d=p[2];let f=!1,g;if(n.validationData!=null&&n.validationData.length>0){if(f=!0,n.validationData.length===2)o=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new Pn("validationData including sample weights is not supported yet."):new be(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let E=await this.standardizeUserData(o,l,null,null,!0,h);u=E[0],c=E[1],g=u.concat(c)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){f=!0;let E=Math.floor(r[0].shape[0]*(1-n.validationSplit)),C=r[0].shape[0];u=$x(r,E,C),s=r,r=$x(r,0,E),c=$x(i,E,C),a=i,i=$x(i,0,E),g=u.concat(c)}else n.validationSteps!=null&&(f=!0);let y=r.concat(i).concat(d);this.checkTrainableWeightsConsistency();let m=this.makeTrainFunction(),b=this.getDedupedMetricsNames(),w,_;f?(this.makeTestFunction(),w=this.testFunction,_=b.slice().concat(b.map(E=>"val_"+E))):(w=null,g=[],_=b.slice());let S=oJ(n.callbacks,n.yieldEvery);return await this.fitLoop(m,y,b,h,n.epochs,n.verbose,S,w,g,n.shuffle,_,n.initialEpoch,null,null)}finally{this.isTraining=!1,sl(r,t),sl(i,e),sl(s,t),sl(a,e),sl(u,o),sl(c,l),d!=null&&bn(d)}}async fitLoop(t,e,n,r,i,s,a,o,l,u,c,d,h,p){r==null&&(r=32),i==null&&(i=1),u==null&&(u=!0),d==null&&(d=0);let f=!1;if(o!=null&&l!=null&&(f=!0),p!=null&&(f=!0,h==null))throw new be("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=this.checkNumSamples(e,r,h,"steps_per_epoch"),y;g!=null&&(y=_l(0,g)),s==null&&(s=1);let{callbackList:m,history:b}=lJ(a,s,i,d,g,h,r,f,c);m.setModel(this),this.history=b,await m.onTrainBegin(),this.stopTraining_=!1;for(let w=d;w<i;++w){await m.onEpochBegin(w);let _={};if(h!=null)throw new Pn("stepsPerEpoch mode is not implemented yet.");{if(u==="batch")throw new Pn("batch shuffling is not implemneted yet");u&&P.shuffle(y);let S=cr(y),E=TN(g,r);for(let C=0;C<E.length;++C){let T={};if(await m.onBatchBegin(C,T),xe(()=>{let M=E[C][0],k=E[C][1],R=Np(S,M,k-M);T.batch=C,T.size=k-M;let N=RF(e,R),B=t(N);for(let z=0;z<n.length;++z){let V=n[z],K=B[z];T[V]=K,Ci(K)}if(C===E.length-1&&f){let z=this.testLoop(o,l,r);for(let V=0;V<n.length;++V){let K=n[V],Q=z[V];Ci(Q),_["val_"+K]=Q}}}),await m.onBatchEnd(C,T),rJ(T),this.stopTraining_)break}S.dispose()}if(await m.onEpochEnd(w,_),this.stopTraining_)break}return await m.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,e){return Zke(this,t,e)}async trainOnBatch(t,e){let n=await this.standardizeUserData(t,e),r=n[0],i=n[1],s=this.makeTrainFunction()(r.concat(i)),a=[];for(let o of s){let l=await o.data();a.push(l[0])}return bn(s),sl(n[0],t),sl(n[1],e),ea(a)}getNamedWeights(t){let e=[],n=t!=null&&t.trainableOnly,r=n?this.trainableWeights:this.weights,i=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||e.push({name:r[s].originalName,tensor:i[s]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){let t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let e=fF().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-fF().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=Uu(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>Uu(e))}else{let e=Object.keys(this.loss);t={};let n=this.loss;for(let r of e)if(typeof n[r]=="string")t[r]=Uu(n[r]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Uu(wA(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>Uu(wA(t)));{let t={};for(let e in this.metrics)t[e]=Uu(wA(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let e=S1(t.optimizer_config),n=xl(e),r;if(typeof t.loss=="string")r=sp(t.loss);else if(Array.isArray(t.loss))r=t.loss.map(s=>sp(s));else if(t.loss!=null){r={};for(let s in t.loss)r[s]=sp(t.loss[s])}let i;if(Array.isArray(t.metrics))i=t.metrics.map(s=>sp(s));else if(t.metrics!=null){i={};for(let s in t.metrics)i[s]=sp(t.metrics[s])}this.compile({loss:r,metrics:i,optimizer:n})}async save(t,e){if(typeof t=="string"){let i=us.getSaveHandlers(t);if(i.length===0)throw new be(`Cannot find any save handlers for URL '${t}'`);if(i.length>1)throw new be(`Found more than one (${i.length}) save handlers for URL '${t}'`);t=i[0]}if(t.save==null)throw new be("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await us.encodeWeights(this.getNamedWeights(e)),r={modelTopology:this.toJSON(null,!1),format:aNe,generatedBy:`TensorFlow.js tfjs-layers v${_O}`,convertedBy:null};if(e!=null&&e.includeOptimizer&&this.optimizer!=null){r.trainingConfig=this.getTrainingConfig();let i="optimizer",{data:s,specs:a}=await us.encodeWeights(await this.optimizer.getWeights(),i);n.specs.push(...a),n.data=us.concatenateArrayBuffers([n.data,s])}return this.userDefinedMetadata!=null&&(wV(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,t.save(r)}setUserDefinedMetadata(t){wV(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}};ec.className="Model";rt.registerClass(ec);var xJ=class extends ec{};xJ.className="Functional";rt.registerClass(xJ);async function oNe(t,e){"modelTopology"in t||(t={modelTopology:t}),t=t;let n=t.modelTopology;n.model_config!=null&&(n=n.model_config);let r=S1(n),i=xl(r,e);if(t.weightsManifest!=null){let s=await us.loadWeights(t.weightsManifest,t.pathPrefix,i.weights.map(o=>o.originalName)),a={};for(let o of i.weights)a[o.originalName]=s[o.originalName];i.loadWeights(a),bn(s)}return i}async function lNe(t,e){if(e==null&&(e={}),typeof t=="string"){let n=us.getLoadHandlers(t,e);if(n.length===0)n.push(us.browserHTTPRequest(t,e));else if(n.length>1)throw new be(`Found more than one (${n.length}) load handlers for URL '${t}'`);t=n[0]}return uNe(t,void 0,e)}async function uNe(t,e,n){if(n==null&&(n={}),t.load==null)throw new be("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await t.load(),i=r.modelTopology;i.model_config!=null&&(i=i.model_config);let s=n.strict==null?!0:n.strict,a=r.weightData!=null&&r.weightSpecs!=null&&s,o=xl(S1(i),e,a),l=r.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),r.userDefinedMetadata!=null&&o.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new be("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:u,optimizerWeights:c}=cNe(r.weightData,r.weightSpecs);o.loadWeights(u,s),o.optimizer!=null&&c.length>0&&await o.optimizer.setWeights(c),bn(u),bn(c.map(d=>d.tensor))}return o}function cNe(t,e){let n=us.decodeWeights(t,e),r={},i=[];return e.forEach(s=>{s.group==="optimizer"?i.push({name:s.name,tensor:n[s.name]}):r[s.name]=n[s.name]}),{modelWeights:r,optimizerWeights:i}}var dM=class DF extends ec{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:QC("sequential_"),e.layers!=null)for(let n of e.layers)this.add(n)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new be(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let n=e instanceof DF||e instanceof ec,r;if(n){if(r=e,r.outputs.length!==1)throw new be("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new be("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new be("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let i=Zq({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(n)this.outputs=r.outputs,this.inputs=r.inputs;else{if(e.inboundNodes.length!==1)throw new be(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new be("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=Yq(this.outputs[0])}this.inboundNodes=[],new lM({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:af(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{let i=e.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,n){return this.model==null&&this.build(),this.model.call(e,n)}build(e){if(tr(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new ec({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,n,r=console.log){this.built||this.build(),super.summary(e,n,r)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,n,r={}){if(!this.built)throw new Zl("The model needs to be compiled before being used.");return this.model.evaluate(e,n,r)}async evaluateDataset(e,n){if(!this.built)throw new Zl("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,n)}predict(e,n={}){return this.model==null&&this.build(),this.model.predict(e,n)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,n,r={}){if(!this.built)throw new Zl("The model needs to be compiled before being used.");return this.model.fit(e,n,r)}async fitDataset(e,n){if(!this.built)throw new Zl("The model needs to be compiled before being used.");return this.model.fitDataset(e,n)}async trainOnBatch(e,n){return this.model.trainOnBatch(e,n)}static fromConfig(e,n,r={},i=!1){let s,a={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new be("Legacy serialization format not supported yet.");s=n}else P.assert(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=n.layers,delete n.layers,a=n;let o=new e(a);if(!(o instanceof DF))throw new Pn(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let l of s){let u=xl(l,void 0,i);i&&u.setFastWeightInitDuringBuild(!0),o.add(u)}return o}set stopTraining(e){if(this.model==null)throw new be("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new be("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let n of this.layers){let r={};r.className=n.getClassName(),r.config=n.getConfig(),e.push(r)}return{name:this.name,layers:e}}};dM.className="Sequential";rt.registerClass(dM);function dNe(t){return new ec(t)}function hNe(t){return new dM(t)}function bJ(t){return Zq(t)}function pNe(t,e){yO.registerCallbackConstructor(t,e)}var Ss=class extends rt.Serializable{getConfig(){return{}}},wJ=class extends Ss{apply(t,e=1){return R2e(t,e)}};wJ.className="elu";rt.registerClass(wJ);var _J=class extends Ss{apply(t){return LC(t)}};_J.className="selu";rt.registerClass(_J);var SJ=class extends Ss{apply(t){return pr(t)}};SJ.className="relu";rt.registerClass(SJ);var AJ=class extends Ss{apply(t){return xe(()=>Od(6,pr(t)))}};AJ.className="relu6";rt.registerClass(AJ);var EJ=class extends Ss{apply(t){return t}};EJ.className="linear";rt.registerClass(EJ);var IJ=class extends Ss{apply(t){return Uo(t)}};IJ.className="sigmoid";rt.registerClass(IJ);var TJ=class extends Ss{apply(t){return D2e(t)}};TJ.className="hardSigmoid";rt.registerClass(TJ);var CJ=class extends Ss{apply(t){return jm(t)}};CJ.className="softplus";rt.registerClass(CJ);var MJ=class extends Ss{apply(t){return F2e(t)}};MJ.className="softsign";rt.registerClass(MJ);var kJ=class extends Ss{apply(t){return Ld(t)}};kJ.className="tanh";rt.registerClass(kJ);var SO=class extends Ss{apply(t,e=-1){return lh(t,e)}};SO.className="softmax";rt.registerClass(SO);var NJ=class extends Ss{apply(t,e=-1){return MC(t,e)}};NJ.className="logSoftmax";rt.registerClass(NJ);var RJ=class extends Ss{apply(t){return xe(()=>xe(()=>{let e=Math.sqrt(2),n=fe(.5,ze(1,IC(zt(t,e))));return fe(t,n)}))}};RJ.className="gelu";rt.registerClass(RJ);var FJ=class extends Ss{apply(t){return xe(()=>fe(.5,fe(t,ze(1,Ld(fe(Zi(zt(2,Math.PI)),ze(t,fe(.044715,pu(t,3)))))))))}};FJ.className="gelu_new";rt.registerClass(FJ);var DJ=class extends Ss{apply(t){return xe(()=>fe(t,Ld(jm(t))))}};DJ.className="mish";rt.registerClass(DJ);var PJ=class extends Ss{apply(t,e=1){return xe(()=>fe(Uo(fe(t,e)),t))}};PJ.className="swish";rt.registerClass(PJ);function $d(t){return t.getClassName()}function CN(t,e={}){return Vw(t,rt.SerializationMap.getMap().classNameMap,e,"activation")}function zd(t){if(t==null){let e={};return e.className="linear",e.config={},CN(e)}if(typeof t=="string"){let e={};return e.className=t,e.config={},CN(e)}else return t instanceof Ss?t:CN(t)}function AO(t){if(t!=null&&typeof t!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}var LJ=class extends rt.Serializable{},Jw=class extends LJ{constructor(t){super(),AO(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return xe(()=>{let e=Vr([1]);return this.hasL1&&(e=ze(e,Xt(fe(this.l1,fi(t))))),this.hasL2&&(e=ze(e,Xt(fe(this.l2,Xw(t))))),ve(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}};Jw.className="L1L2";rt.registerClass(Jw);function fNe(t){return AO(t),new Jw({l1:t!=null?t.l1:null,l2:0})}function mNe(t){return AO(t),new Jw({l2:t!=null?t.l2:null,l1:0})}var TV={l1l2:"L1L2"};function Er(t){return tO(t)}function CV(t,e={}){return Vw(t,rt.SerializationMap.getMap().classNameMap,e,"regularizer")}function Ur(t){if(t==null)return null;if(typeof t=="string"){let e={className:t in TV?TV[t]:t,config:{}};return CV(e)}else return t instanceof LJ?t:CV(t)}var EO=class extends On{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=mn(t);let n=pr(t);return this.maxValue!=null&&(n=bs(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){let t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}};EO.className="ReLU";rt.registerClass(EO);var IO=class extends On{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let n=mn(t);return Dw(n,this.alpha)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};IO.className="LeakyReLU";rt.registerClass(IO);var TO=class extends On{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=Br(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Ur(t.alphaRegularizer),this.alphaConstraint=Fi(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new be(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=tr(t);let e=t.slice(1);if(this.sharedAxes!=null)for(let r of this.sharedAxes)e[r-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let r=1;r<t.length;++r)n[r]=t[r];this.inputSpec=[new gi({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=mn(t),$w(t,this.alpha.read())}getConfig(){let t={alphaInitializer:Xr(this.alphaInitializer),alphaRegularizer:Er(this.alphaRegularizer),alphaConstraint:Ri(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}};TO.className="PReLU";rt.registerClass(TO);var CO=class extends On{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new Pn(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let n=mn(t);return _v(n)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};CO.className="ELU";rt.registerClass(CO);var MO=class extends On{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){let n=mn(t);return fe(n,ft(Xs(n,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){let t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}};MO.className="ThresholdedReLU";rt.registerClass(MO);var kO=class extends On{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new SO().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){return xe(()=>{let n=mn(t),r=e.mask;if(r!=null){let i=fe(Dt(ra(n.shape),ft(r,n.dtype)),rn(-1e9));n=ze(n,i)}return this.axis instanceof Array?this.axis.length>1?ws(Dt(n,Lw(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(t){return t}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}};kO.className="Softmax";rt.registerClass(kO);function Ay(t,e,n){if(typeof t=="number")return af(t,e);if(t.length!==e)throw new be(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let r=0;r<e;++r){let i=t[r];if(!C2e(i))throw new be(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${i}`)}return t}function bl(t,e,n,r,i=1){if(t==null)return t;let s=e+(e-1)*(i-1),a;return n==="same"?a=t:a=t-s+1,Math.floor((a+r-1)/r)}function Kl(t,e,n,r){if(t==null)return null;if(r==="valid")t=t*e+Ud([n-e,0]);else if(r==="same")t=t*e;else throw new be(`Unsupport padding mode: ${r}.`);return t}function NO(t,e){return xe(()=>(ci(e),e==="channelsFirst"?Nn(t,[0,2,3,1]):t))}function OJ(t,e){return xe(()=>(ci(e),e==="channelsFirst"?Nn(t,[0,2,3,4,1]):t))}function gNe(t,e,n,r=1,i="valid",s,a=1){return xe(()=>{if(s==null&&(s=Sl()),ci(s),t.shape.length!==3)throw new be(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(e.shape.length!==3)throw new be(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new be(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(s==="channelsFirst"&&(t=Nn(t,[0,2,1])),i==="causal")throw new Pn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=_C(t,e,r,i==="same"?"same":"valid","NWC",a);return n!=null&&(o=kl(o,n)),o})}function MV(t,e,n,r=[1,1],i="valid",s,a,o=null){return xe(()=>{if(s==null&&(s=Sl()),ci(s),t.rank!==3&&t.rank!==4)throw new be(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(e.rank!==3&&e.rank!==4)throw new be(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=NO(t,s);if(i==="causal")throw new Pn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=t0.conv2d({x:l,filter:e,strides:r,pad:i==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:n,activation:o}),s==="channelsFirst"&&(l=Nn(l,[0,3,1,2])),l})}function yNe(t,e,n,r=[1,1,1],i="valid",s,a){return xe(()=>{if(s==null&&(s=Sl()),ci(s),t.rank!==4&&t.rank!==5)throw new be(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(e.rank!==4&&e.rank!==5)throw new be(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let o=OJ(t,s);if(i==="causal")throw new Pn("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=sL(o,e,r,i==="same"?"same":"valid","NDHWC",a),n!=null&&(o=kl(o,n)),s==="channelsFirst"&&(o=Nn(o,[0,4,1,2,3])),o})}var BJ=class UJ extends On{constructor(e,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",UJ.verifyArgs(n),this.rank=e,ji(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Pn(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Ay(n.kernelSize,e,"kernelSize"),this.strides=Ay(n.strides==null?1:n.strides,e,"strides"),this.padding=n.padding==null?"valid":n.padding,mo(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,ci(this.dataFormat),this.activation=zd(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=Br(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Fi(n.biasConstraint),this.biasRegularizer=Ur(n.biasRegularizer),this.activityRegularizer=Ur(n.activityRegularizer),this.dilationRate=Ay(n.dilationRate==null?1:n.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new be(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new be(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new be(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(Xl("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!nO(e.kernelSize,"number",1,3))throw new be(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:$d(this.activation),useBias:this.useBias,biasInitializer:Xr(this.biasInitializer),biasRegularizer:Er(this.biasRegularizer),activityRegularizer:Er(this.activityRegularizer),biasConstraint:Ri(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}},hM=class $J extends BJ{constructor(e,n){super(e,n),this.kernel=null,$J.verifyArgs(n),this.filters=n.filters,ji(this.filters,"filters"),this.kernelInitializer=Br(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Fi(n.kernelConstraint),this.kernelRegularizer=Ur(n.kernelRegularizer)}build(e){e=tr(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new be(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],i=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:r}}],this.built=!0}call(e,n){return xe(()=>{e=mn(e);let r,i=this.bias==null?null:this.bias.read(),s=Gq(this.activation.getClassName());if(s!=null&&this.rank===2)r=MV(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)r=gNe(e,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=MV(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=yNe(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Pn("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(e){e=tr(e);let n=[],r=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<r.length;++s){let a=bl(r[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);n.push(a)}let i=[e[0]];return this.dataFormat==="channelsLast"?(i=i.concat(n),i.push(this.filters)):(i.push(this.filters),i=i.concat(n)),i}getConfig(){let e={filters:this.filters,kernelInitializer:Xr(this.kernelInitializer),kernelRegularizer:Er(this.kernelRegularizer),kernelConstraint:Ri(this.kernelConstraint)},n=super.getConfig();return Object.assign(e,n),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new be(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},pM=class zJ extends hM{constructor(e){super(2,e),zJ.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!nO(e.kernelSize,"number",1,2))throw new be(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};pM.className="Conv2D";rt.registerClass(pM);var fM=class GJ extends hM{constructor(e){super(3,e),GJ.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new be(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};fM.className="Conv3D";rt.registerClass(fM);var RO=class extends pM{constructor(t){if(super(t),this.inputSpec=[new gi({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new be(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=tr(t),t.length!==4)throw new be("Input should have rank 4; Received input shape: "+JSON.stringify(t));let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new be("The channel dimension of the inputs should be defined. Found `None`.");let n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new gi({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return xe(()=>{let n=mn(t);if(n.shape.length!==4)throw new be(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,i=r[0],s,a;this.dataFormat==="channelsFirst"?(s=2,a=3):(s=1,a=2);let o=r[s],l=r[a],u=this.kernelSize[0],c=this.kernelSize[1],d=this.strides[0],h=this.strides[1],p=Kl(o,d,u,this.padding),f=Kl(l,h,c,this.padding),g=[i,p,f,this.filters];this.dataFormat!=="channelsLast"&&(n=Nn(n,[0,2,3,1]));let y=SC(n,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=Nn(y,[0,3,1,2])),this.bias!=null&&(y=kl(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(t){t=tr(t);let e=t.slice(),n,r,i;this.dataFormat==="channelsFirst"?(n=1,r=2,i=3):(n=3,r=1,i=2);let s=this.kernelSize[0],a=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[r]=Kl(e[r],o,s,this.padding),e[i]=Kl(e[i],l,a,this.padding),e}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};RO.className="Conv2DTranspose";rt.registerClass(RO);var FO=class extends fM{constructor(t){if(super(t),this.inputSpec=[new gi({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new be(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=tr(t),t.length!==5)throw new be("Input should have rank 5; Received input shape: "+JSON.stringify(t));let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new be("The channel dimension of the inputs should be defined. Found `None`.");let n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new gi({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return xe(()=>{let n=mn(t);if(n.shape.length!==5)throw new be(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,i=r[0],s,a,o;this.dataFormat==="channelsFirst"?(o=2,s=3,a=4):(o=1,s=2,a=3);let l=r[o],u=r[s],c=r[a],d=this.kernelSize[0],h=this.kernelSize[1],p=this.kernelSize[2],f=this.strides[0],g=this.strides[1],y=this.strides[2],m=Kl(l,f,d,this.padding),b=Kl(u,g,h,this.padding),w=Kl(c,y,p,this.padding),_=[i,m,b,w,this.filters];this.dataFormat!=="channelsLast"&&(n=Nn(n,[0,2,3,4,1]));let S=aL(n,this.kernel.read(),_,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(S=Nn(S,[0,4,1,2,3])),this.bias!==null&&(S=kl(S,this.bias.read(),this.dataFormat)),this.activation!==null&&(S=this.activation.apply(S)),S})}computeOutputShape(t){t=tr(t);let e=t.slice(),n,r,i,s;this.dataFormat==="channelsFirst"?(n=1,r=2,i=3,s=4):(n=4,r=1,i=2,s=3);let a=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],d=this.strides[2];return e[n]=this.filters,e[r]=Kl(e[r],u,a,this.padding),e[i]=Kl(e[i],c,o,this.padding),e[s]=Kl(e[s],d,l,this.padding),e}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};FO.className="Conv3DTranspose";rt.registerClass(FO);var HJ=class extends hM{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new be("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new be("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new be(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Br(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Ur(e.depthwiseRegularizer),this.depthwiseConstraint=Fi(e.depthwiseConstraint),this.pointwiseInitializer=Br(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Ur(e.pointwiseRegularizer),this.pointwiseConstraint=Fi(e.pointwiseConstraint)}build(t){if(t=tr(t),t.length<this.rank+2)throw new be(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new be(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);let n=t[e],r=this.kernelSize.concat([n,this.depthMultiplier]),i=[];for(let a=0;a<this.rank;++a)i.push(1);i.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new gi({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return xe(()=>{t=mn(t);let n;if(this.rank===1)throw new Pn("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=Nn(t,[0,2,3,1])),n=Iv(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=kl(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Nn(n,[0,3,1,2])),n})}getConfig(){let t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Xr(this.depthwiseInitializer),t.pointwiseInitializer=Xr(this.pointwiseInitializer),t.depthwiseRegularizer=Er(this.depthwiseRegularizer),t.pointwiseRegularizer=Er(this.pointwiseRegularizer),t.depthwiseConstraint=Ri(this.depthwiseConstraint),t.pointwiseConstraint=Ri(this.pointwiseConstraint),t}};HJ.className="SeparableConv";var DO=class extends HJ{constructor(t){super(2,t)}};DO.className="SeparableConv2D";rt.registerClass(DO);var PO=class WJ extends hM{constructor(e){super(1,e),WJ.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!nO(e.kernelSize,"number",1,1))throw new be(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}};PO.className="Conv1D";rt.registerClass(PO);var LO=class extends On{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return xe(()=>{if(t=mn(t),this.dataFormat==="channelsLast"){let n=bA(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return bA(n,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=bA(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return bA(n,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};LO.className="Cropping2D";rt.registerClass(LO);var OO=class extends On{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ci(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,E2e(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){let e=t[2]==null?null:this.size[0]*t[2],n=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,n]}else{let e=t[1]==null?null:this.size[0]*t[1],n=t[2]==null?null:this.size[1]*t[2];return[t[0],e,n,t[3]]}}call(t,e){return xe(()=>{let n=mn(t),r=n.shape;if(this.dataFormat==="channelsFirst"){n=Nn(n,[0,2,3,1]);let i=this.size[0]*r[2],s=this.size[1]*r[3],a=this.interpolation==="nearest"?to.resizeNearestNeighbor(n,[i,s]):to.resizeBilinear(n,[i,s]);return Nn(a,[0,3,1,2])}else{let i=this.size[0]*r[1],s=this.size[1]*r[2];return this.interpolation==="nearest"?to.resizeNearestNeighbor(n,[i,s]):to.resizeBilinear(n,[i,s])}})}getConfig(){let t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}};OO.className="UpSampling2D";rt.registerClass(OO);function vNe(t,e,n=[1,1],r="valid",i,s){return xe(()=>{i==null&&(i=Sl()),ci(i);let a=NO(t,i);if(t.rank!==4)throw new be(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(e.rank!==4)throw new be(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=Vm(a,e,n,r==="same"?"same":"valid","NHWC",s),i==="channelsFirst"&&(a=Nn(a,[0,3,1,2])),a})}var BO=class extends BJ{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Br(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Fi(t.depthwiseConstraint),this.depthwiseRegularizer=Ur(t.depthwiseRegularizer)}build(t){if(t=tr(t),t.length<4)throw new be(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);let e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new be(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);let n=t[e],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return xe(()=>{t=mn(t);let n=vNe(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=kl(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(t){t=tr(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,i=bl(e,this.kernelSize[0],this.padding,this.strides[0]),s=bl(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],r,i,s]:[t[0],i,s,r]}getConfig(){let t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Xr(this.depthwiseInitializer),t.depthwiseRegularizer=Er(this.depthwiseRegularizer),t.depthwiseConstraint=Ri(this.depthwiseRegularizer),t}};BO.className="DepthwiseConv2D";rt.registerClass(BO);function VJ(t,e,n,r){if(Array.isArray(t)){if(e!=null||n!=null)throw new be("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function i(s){return s==null||Array.isArray(s)?s:[s]}return e=i(e),n=i(n),{inputs:t,initialState:e,constants:n}}function jJ(t,e,n,r=!1,i,s,a=!1,o=!1){return xe(()=>{let l=e.shape.length;if(l<3)throw new be(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(_l(2,l));e=Nn(e,u),s!=null,a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),i!=null&&(i=ft(ft(i,"bool"),"float32"),i.rank===l-1&&(i=Gi(i,-1)),i=Nn(i,u)),r&&(e=ho(e,0),i!=null&&(i=ho(i,0)));let c=[],d,h=n,p=e.shape[0],f=ii(e),g;i!=null&&(g=ii(i));for(let m=0;m<p;++m){let b=f[m],w=xe(()=>t(b,h));if(i==null)d=w[0],h=w[1];else{let _=xe(()=>{let S=g[m],E=Dt(za(S),S),C=ze(fe(w[0],S),fe(h[0],E)),T=h.map((M,k)=>ze(fe(w[1][k],S),fe(M,E)));return{output:C,newStates:T}});d=_.output,h=_.newStates}o&&c.push(d)}let y;return o&&(y=xi(c,1)),[d,y,h]})}var xc=class XJ extends On{constructor(e){super(e);let n;if(e.cell==null)throw new be("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?n=new yM({cells:e.cell}):n=e.cell,n.stateSize==null)throw new be("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new gi({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return _l(0,e).map(n=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){CF(e)&&(e=e[0]),e=e;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let r=n[0],i;if(this.returnSequences?i=[e[0],e[1],r]:i=[e[0],r],this.returnState){let s=[];for(let a of n)s.push([e[0],a]);return[i].concat(s)}else return i}computeMask(e,n){return xe(()=>{Array.isArray(n)&&(n=n[0]);let r=this.returnSequences?n:null;if(this.returnState){let i=this.states.map(s=>null);return[r].concat(i)}else return r})}get states(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let r=0;r<e;++r)n.push(null);return n}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Pn("Constants support is not implemented in RNN yet.");CF(e)&&(e=e[0]),e=e;let n=this.stateful?e[0]:null,r=e.slice(2);this.inputSpec[0]=new gi({shape:[n,null,...r]});let i=[e[0]].concat(e.slice(2));this.cell.build(i);let s;if(Array.isArray(this.cell.stateSize)?s=this.cell.stateSize:s=[this.cell.stateSize],this.stateSpec!=null){if(!P.arraysEqual(this.stateSpec.map(a=>a.shape[a.shape.length-1]),s))throw new be(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(a=>new gi({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(e,n=!1){xe(()=>{if(!this.stateful)throw new Zc("Cannot call resetStates() on an RNN Layer that is not stateful.");let r=this.inputSpec[0].shape[0];if(r==null)throw new be("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>Vr([r,i])):this.states_=[Vr([r,this.cell.stateSize])];else if(e==null)bn(this.states_),this.keptStates!=null&&(bn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>Vr([r,i])):this.states_[0]=Vr([r,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new be(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n===!0?this.keptStates.push(this.states_.slice()):bn(this.states_);for(let i=0;i<this.states_.length;++i){let s=e[i],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,o=[r,a];if(!P.arraysEqual(s.shape,o))throw new be(`State ${i} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[i]=s}}this.states_=this.states_.map(i=>Ci(i.clone()))})}apply(e,n){let r=n==null?null:n.initialState,i=n==null?null:n.constants;n==null&&(n={});let s=VJ(e,r,i,this.numConstants);e=s.inputs,r=s.initialState,i=s.constants;let a=[],o=[];if(r!=null){n.initialState=r,a=a.concat(r),this.stateSpec=[];for(let l of r)this.stateSpec.push(new gi({shape:l.shape}));o=o.concat(this.stateSpec)}if(i!=null&&(n.constants=i,a=a.concat(i),this.numConstants=i.length),a[0]instanceof Al){let l=[e].concat(a),u=this.inputSpec.concat(o),c=this.inputSpec;this.inputSpec=u;let d=super.apply(l,n);return this.inputSpec=c,d}else return super.apply(e,n)}call(e,n){return xe(()=>{let r=n==null?null:n.mask,i=n==null?null:n.training,s=n==null?null:n.initialState;e=mn(e),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(e));let a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new be(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let o={training:i},l=jJ((p,f)=>{let g=this.cell.call([p].concat(f),o);return[g[0],g.slice(1)]},e,s,this.goBackwards,r,null,this.unroll,this.returnSequences),u=l[0],c=l[1],d=l[2];this.stateful&&this.resetStates(d,i);let h=this.returnSequences?c:u;return this.returnState?[h].concat(d):h})}getInitialState(e){return xe(()=>{let n=Vr(e.shape);return n=Xt(n,[1,2]),n=jw(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?IF(n,[1,r]):n):this.cell.stateSize>1?[IF(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let r=this.cell.getConfig();return this.getClassName()===XJ.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),e),n)}static fromConfig(e,n,r={}){let i=n.cell,s=xl(i,r);return new e(Object.assign(n,{cell:s}))}};xc.className="RNN";rt.registerClass(xc);var Yw=class extends On{},mM=class extends Yw{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,ji(this.units,"units"),this.activation=zd(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Br(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Br(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Br(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ur(t.kernelRegularizer),this.recurrentRegularizer=Ur(t.recurrentRegularizer),this.biasRegularizer=Ur(t.biasRegularizer),this.kernelConstraint=Fi(t.kernelConstraint),this.recurrentConstraint=Fi(t.recurrentConstraint),this.biasConstraint=Fi(t.biasConstraint),this.dropout=n0([1,Ud([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=n0([1,Ud([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=tr(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return xe(()=>{if(t=t,t.length!==2)throw new be(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];let r=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Gd({ones:()=>za(t),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Gd({ones:()=>za(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i,s=this.dropoutMask,a=this.recurrentDropoutMask;s!=null?i=ou(fe(t,s),this.kernel.read()):i=ou(t,this.kernel.read()),this.bias!=null&&(i=kl(i,this.bias.read())),a!=null&&(n=fe(n,a));let o=ze(i,ou(n,this.recurrentKernel.read()));return this.activation!=null&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:$d(this.activation),useBias:this.useBias,kernelInitializer:Xr(this.kernelInitializer),recurrentInitializer:Xr(this.recurrentInitializer),biasInitializer:Xr(this.biasInitializer),kernelRegularizer:Er(this.kernelRegularizer),recurrentRegularizer:Er(this.recurrentRegularizer),biasRegularizer:Er(this.biasRegularizer),activityRegularizer:Er(this.activityRegularizer),kernelConstraint:Ri(this.kernelConstraint),recurrentConstraint:Ri(this.recurrentConstraint),biasConstraint:Ri(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}};mM.className="SimpleRNNCell";rt.registerClass(mM);var UO=class extends xc{constructor(t){t.cell=new mM(t),super(t)}call(t,e){return xe(()=>{this.cell.dropoutMask!=null&&(bn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(bn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:i})})}static fromConfig(t,e){return new t(e)}};UO.className="SimpleRNN";rt.registerClass(UO);var gM=class extends Yw{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new be("GRUCell does not support reset_after parameter set to true.");this.units=t.units,ji(this.units,"units"),this.activation=zd(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=zd(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Br(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Br(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Br(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ur(t.kernelRegularizer),this.recurrentRegularizer=Ur(t.recurrentRegularizer),this.biasRegularizer=Ur(t.biasRegularizer),this.kernelConstraint=Fi(t.kernelConstraint),this.recurrentConstraint=Fi(t.recurrentConstraint),this.biasConstraint=Fi(t.biasConstraint),this.dropout=n0([1,Ud([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=n0([1,Ud([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=tr(t);let e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return xe(()=>{if(t=t,t.length!==2)throw new be(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);let n=e.training==null?!1:e.training,r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Gd({ones:()=>za(t),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Gd({ones:()=>za(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,s=this.recurrentDropoutMask,a,o,l;0<this.dropout&&this.dropout<1&&(t=fe(t,i[0]));let u=ou(t,this.kernel.read());this.useBias&&(u=kl(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=fe(r,s[0]));let c=this.recurrentKernel.read(),[d,h]=aa(c,[2*this.units,this.units],c.rank-1),p=ou(r,d),[f,g,y]=aa(u,3,u.rank-1),[m,b]=aa(p,2,p.rank-1);a=this.recurrentActivation.apply(ze(f,m)),o=this.recurrentActivation.apply(ze(g,b));let w=ou(fe(o,r),h);l=this.activation.apply(ze(y,w));let _=ze(fe(a,r),fe(ze(1,Mr(a)),l));return[_,_]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:$d(this.activation),recurrentActivation:$d(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Xr(this.kernelInitializer),recurrentInitializer:Xr(this.recurrentInitializer),biasInitializer:Xr(this.biasInitializer),kernelRegularizer:Er(this.kernelRegularizer),recurrentRegularizer:Er(this.recurrentRegularizer),biasRegularizer:Er(this.biasRegularizer),activityRegularizer:Er(this.activityRegularizer),kernelConstraint:Ri(this.kernelConstraint),recurrentConstraint:Ri(this.recurrentConstraint),biasConstraint:Ri(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}};gM.className="GRUCell";rt.registerClass(gM);var $O=class extends xc{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new gM(t),super(t)}call(t,e){return xe(()=>{this.cell.dropoutMask!=null&&(bn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(bn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:i})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};$O.className="GRU";rt.registerClass($O);var Zw=class extends Yw{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,ji(this.units,"units"),this.activation=zd(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=zd(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Br(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Br(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Br(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Ur(t.kernelRegularizer),this.recurrentRegularizer=Ur(t.recurrentRegularizer),this.biasRegularizer=Ur(t.biasRegularizer),this.kernelConstraint=Fi(t.kernelConstraint),this.recurrentConstraint=Fi(t.recurrentConstraint),this.biasConstraint=Fi(t.biasConstraint),this.dropout=n0([1,Ud([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=n0([1,Ud([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=tr(t);let n=t[t.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){let i=this.biasInitializer,s=this.units;r=new(e=class extends jo{apply(a,o){let l=i.apply([s]),u=new tM().apply([s]),c=i.apply([s*2]);return pV(pV(l,u),c)}},e.className="CustomInit",e)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return xe(()=>{let n=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new be(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let r=t[1],i=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Gd({ones:()=>za(t),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Gd({ones:()=>za(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,a=this.recurrentDropoutMask,o,l,u,c;0<this.dropout&&this.dropout<1&&(t=fe(t,s[0]));let d=ou(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=fe(r,a[0])),d=ze(d,ou(r,this.recurrentKernel.read())),this.useBias&&(d=kl(d,this.bias.read()));let[h,p,f,g]=aa(d,4,d.rank-1);o=this.recurrentActivation.apply(h),l=this.recurrentActivation.apply(p),u=ze(fe(l,i),fe(o,this.activation.apply(f))),c=this.recurrentActivation.apply(g);let y=fe(c,this.activation.apply(u));return[y,y,u]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:$d(this.activation),recurrentActivation:$d(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Xr(this.kernelInitializer),recurrentInitializer:Xr(this.recurrentInitializer),biasInitializer:Xr(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Er(this.kernelRegularizer),recurrentRegularizer:Er(this.recurrentRegularizer),biasRegularizer:Er(this.biasRegularizer),activityRegularizer:Er(this.activityRegularizer),kernelConstraint:Ri(this.kernelConstraint),recurrentConstraint:Ri(this.recurrentConstraint),biasConstraint:Ri(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}};Zw.className="LSTMCell";rt.registerClass(Zw);var zO=class extends xc{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new Zw(t),super(t)}call(t,e){return xe(()=>{this.cell.dropoutMask!=null&&(bn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(bn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:i})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};zO.className="LSTM";rt.registerClass(zO);var yM=class extends Yw{constructor(t){super(t),this.cells=t.cells}get stateSize(){let t=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return xe(()=>{t=t;let n=t.slice(1),r=[];for(let a of this.cells.slice().reverse())Array.isArray(a.stateSize)?r.push(n.splice(0,a.stateSize.length)):r.push(n.splice(0,1));r.reverse();let i=[],s;for(let a=0;a<this.cells.length;++a){let o=this.cells[a];n=r[a],a===0?s=[t[0]].concat(n):s=[s[0]].concat(n),s=o.call(s,e),i.push(s.slice(1))}n=[];for(let a of i.slice().reverse())n.push(...a);return[s[0]].concat(n)})}build(t){CF(t)&&(t=t[0]),t=t;let e;this.cells.forEach((n,r)=>{kp(`RNNCell_${r}`,()=>{n.build(t),Array.isArray(n.stateSize)?e=n.stateSize[0]:e=n.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){let t=super.getConfig(),e=r=>({className:r.getClassName(),config:r.getConfig()}),n={cells:this.cells.map(e)};return Object.assign(Object.assign({},t),n)}static fromConfig(t,e,n={}){let r=[];for(let i of e.cells)r.push(xl(i,n));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let n of this.cells)e.push(...n.trainableWeights);return e.concat(t)}return t}getWeights(){let t=[];for(let e of this.cells)t.push(...e.weights);return MF(t)}setWeights(t){let e=[];for(let n of this.cells){let r=n.weights.length,i=t.splice(r);for(let s=0;s<n.weights.length;++s)e.push([n.weights[s],i[s]])}dO(e)}};yM.className="StackedRNNCells";rt.registerClass(yM);function Gd(t){let{ones:e,rate:n,training:r=!1,count:i=1,dropoutFunc:s}=t,a=()=>s!=null?s(e(),n):qq(e(),n),o=()=>Kw(a,e,r);return!i||i<=1?Ci(o().clone()):Array(i).fill(void 0).map(o).map(l=>Ci(l.clone()))}var xNe=function(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(t!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,r=Object.getOwnPropertySymbols(t);i<r.length;i++)e.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(t,r[i])&&(n[r[i]]=t[r[i]]);return n},KJ=class extends xc{constructor(t){if(t.unroll)throw new Pn("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new Pn("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new gi({ndim:5})]}call(t,e){return xe(()=>{if(this.cell.dropoutMask!=null&&(bn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(bn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new be("ConvRNN2D cell does not support constants");let n=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:i})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return xe(()=>{let{stateSize:e}=this.cell,n=t.shape,r=this.computeSingleOutputShape(n),i=[r[0],...r.slice(2)],s=Vr(i);return Array.isArray(e)?Array(e.length).fill(s):[s]})}resetStates(t,e=!1){xe(()=>{if(!this.stateful)throw new Zc("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),i=[r[0],...r.slice(2)];if(n[0]==null)throw new be("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Vr(i)):this.states_=[Vr(i)];else if(t==null)bn(this.states_),this.keptStates!=null&&(bn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Vr(i)):this.states_[0]=Vr(i);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new be(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):bn(this.states_);for(let s=0;s<this.states_.length;++s){let a=t[s],o=i;if(!P.arraysEqual(a.shape,o))throw new be(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${a.shape}`);this.states_[s]=a}}this.states_=this.states_.map(s=>Ci(s.clone()))})}computeSingleOutputShape(t){let{dataFormat:e,filters:n,kernelSize:r,padding:i,strides:s,dilationRate:a}=this.cell,o=e==="channelsFirst",l=t[o?3:2],u=t[o?4:3],c=bl(l,r[0],i,s[0],a[0]),d=bl(u,r[1],i,s[1],a[1]);return[...t.slice(0,2),...o?[n,c,d]:[c,d,n]]}};KJ.className="ConvRNN2D";var vM=class extends Zw{constructor(t){let{filters:e,kernelSize:n,strides:r,padding:i,dataFormat:s,dilationRate:a}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,ji(this.filters,"filters"),this.kernelSize=Ay(n,2,"kernelSize"),this.kernelSize.forEach(o=>ji(o,"kernelSize")),this.strides=Ay(r||1,2,"strides"),this.strides.forEach(o=>ji(o,"strides")),this.padding=i||"valid",mo(this.padding),this.dataFormat=s||"channelsLast",ci(this.dataFormat),this.dilationRate=Ay(a||1,2,"dilationRate"),this.dilationRate.forEach(o=>ji(o,"dilationRate"))}build(t){var e;t=tr(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new be(`The channel dimension of the input should be defined. Found ${t[n]}`);let r=t[n],i=4,s=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let a=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let o;if(this.unitForgetBias){let l=this.biasInitializer,u=this.filters;o=new(e=class extends jo{apply(c,d){let h=l.apply([u]),p=ra([u]),f=l.apply([u*2]);return rO([h,p,f])}},e.className="CustomInit",e)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return xe(()=>{if(t.length!==3)throw new be(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let n=e.training||!1,r=t[0],i=t[1],s=t[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Gd({ones:()=>za(r),rate:this.dropout,training:n,count:a,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=(j,X,te)=>!X||!X[te]?j:fe(X[te],j),u=l(r,o,0),c=l(r,o,1),d=l(r,o,2),h=l(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Gd({ones:()=>za(i),rate:this.recurrentDropout,training:n,count:a,dropoutFunc:this.dropoutFunc}));let p=this.recurrentDropoutMask,f=l(i,p,0),g=l(i,p,1),y=l(i,p,2),m=l(i,p,3),b=3,[w,_,S,E]=aa(this.kernel.read(),a,b),[C,T,M,k]=this.useBias?aa(this.bias.read(),a):[null,null,null,null];u=this.inputConv(u,w,C,this.padding),c=this.inputConv(c,_,T,this.padding),d=this.inputConv(d,S,M,this.padding),h=this.inputConv(h,E,k,this.padding);let[R,N,B,z]=aa(this.recurrentKernel.read(),a,b);f=this.recurrentConv(f,R),g=this.recurrentConv(g,N),y=this.recurrentConv(y,B),m=this.recurrentConv(m,z);let V=this.recurrentActivation.apply(ze(u,f)),K=this.recurrentActivation.apply(ze(c,g)),Q=ze(fe(K,s),fe(V,this.activation.apply(ze(d,y)))),O=fe(this.recurrentActivation.apply(ze(h,m)),this.activation.apply(Q));return[O,O,Q]})}getConfig(){let t=super.getConfig(),e=xNe(t,["units"]),n={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},e),n)}inputConv(t,e,n,r){let i=zs(t,e,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?kl(i,n,this.dataFormat):i}recurrentConv(t,e){return zs(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};vM.className="ConvLSTM2DCell";rt.registerClass(vM);var GO=class extends KJ{constructor(t){let e=new vM(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}};GO.className="ConvLSTM2D";rt.registerClass(GO);var xM=class extends On{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;let e=t.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(this.noiseShape[r]==null?e[r]:this.noiseShape[r]);return n}call(t,e){return xe(()=>{this.invokeCallHook(t,e);let n=mn(t);if(0<this.rate&&this.rate<1){let r=e.training==null?!1:e.training,i=this.getNoiseShape(n);return Kw(()=>qq(n,this.rate,i,this.seed),()=>n,r)}return t})}getConfig(){let t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}};xM.className="Dropout";rt.registerClass(xM);var HO=class extends xM{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){let e=t.shape;return[e[0],1,e[2]]}};HO.className="SpatialDropout1D";rt.registerClass(HO);var WO=class extends On{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,ji(this.units,"units"),this.activation=zd(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=Br(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Br(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Fi(t.kernelConstraint),this.biasConstraint=Fi(t.biasConstraint),this.kernelRegularizer=Ur(t.kernelRegularizer),this.biasRegularizer=Ur(t.biasRegularizer),this.activityRegularizer=Ur(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=tr(t);let e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=tr(t);let e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return xe(()=>{this.invokeCallHook(t,e);let n=mn(t),r=Gq(this.activation.getClassName()),i;return r!=null?i=ou(n,this.kernel.read(),r,this.bias?this.bias.read():null):(i=ou(n,this.kernel.read()),this.bias!=null&&(i=kl(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){let t={units:this.units,activation:$d(this.activation),useBias:this.useBias,kernelInitializer:Xr(this.kernelInitializer),biasInitializer:Xr(this.biasInitializer),kernelRegularizer:Er(this.kernelRegularizer),biasRegularizer:Er(this.biasRegularizer),activityRegularizer:Er(this.activityRegularizer),kernelConstraint:Ri(this.kernelConstraint),biasConstraint:Ri(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}};WO.className="Dense";rt.registerClass(WO);var VO=class extends On{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=tr(t);for(let e of t.slice(1))if(e==null)throw new be(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],Ed(t,1)]}call(t,e){return xe(()=>{this.invokeCallHook(t,e);let n=mn(t);if(this.dataFormat==="channelsFirst"&&n.rank>1){let r=[0];for(let i=2;i<n.rank;++i)r.push(i);r.push(1),n=Nn(n,r)}return N2e(n)})}getConfig(){let t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);let e=super.getConfig();return Object.assign(t,e),t}};VO.className="Flatten";rt.registerClass(VO);var jO=class extends On{constructor(t){super(t),this.supportsMasking=!0,this.activation=zd(t.activation)}call(t,e){return xe(()=>{this.invokeCallHook(t,e);let n=mn(t);return this.activation.apply(n)})}getConfig(){let t={activation:$d(this.activation)},e=super.getConfig();return Object.assign(t,e),t}};jO.className="Activation";rt.registerClass(jO);var XO=class extends On{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return xe(()=>(t=mn(t),M2e(t,this.n)))}getConfig(){let t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}};XO.className="RepeatVector";rt.registerClass(XO);var KO=class extends On{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){let n="Total size of new array must be unchanged.",r=e.slice(),i=1,s=null;for(let o=0;o<r.length;++o){let l=r[o];if(this.isUnknown(l))if(s===null)s=o;else throw new be("Can only specifiy one unknown dimension.");else i*=l}let a=Ed(t);if(s!==null){if(i===0||a%i!==0)throw new be(n);r[s]=a/i}else if(a!==i)throw new be(n);return r}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return xe(()=>{this.invokeCallHook(t,e);let n=mn(t),r=n.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return ve(n,i)})}getConfig(){let t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}};KO.className="Reshape";rt.registerClass(KO);var qO=class extends On{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);let e=_l(1,t.dims.length+1);if(!P.arraysEqual(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new gi({ndim:this.dims.length+1})]}computeOutputShape(t){t=tr(t);let e=t.slice();return this.dims.forEach((n,r)=>{e[r+1]=t[n]}),e}call(t,e){return Nn(mn(t),this.dimsIncludingBatch)}getConfig(){let t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}};qO.className="Permute";rt.registerClass(qO);var JO=class extends On{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){let n=mn(t);return v1(rf(n,this.maskValue),-1)}call(t,e){return xe(()=>{this.invokeCallHook(t,e);let n=mn(t),r=v1(rf(n,this.maskValue),-1,!0);return fe(n,ft(r,n.dtype))})}};JO.className="Masking";rt.registerClass(JO);var YO=class extends On{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(dr(t.inputLength))}this.inputDim=t.inputDim,ji(this.inputDim,"inputDim"),this.outputDim=t.outputDim,ji(this.outputDim,"outputDim"),this.embeddingsInitializer=Br(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Ur(t.embeddingsRegularizer),this.activityRegularizer=Ur(t.activityRegularizer),this.embeddingsConstraint=Fi(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return xe(()=>this.maskZero?(t=mn(t),rf(t,Kn(t))):null)}computeOutputShape(t){if(t=tr(t),this.inputLength==null)return[...t,this.outputDim];let e=dr(this.inputLength);if(e.length!==t.length-1)throw new be(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let n=0;for(let r=0;r<e.length;++r){let i=e[r],s=t[r+1];if(i!=null&&s!=null&&i!==s)throw new be(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);i==null&&(e[n]=s),n++}}return[t[0],...e,this.outputDim]}call(t,e){return xe(()=>{this.invokeCallHook(t,e);let n=mn(t);n.dtype!=="int32"&&(n=dc(n,"int32"));let r=Kq(this.embeddings.read(),ve(n,[n.size]));return ve(r,tr(this.computeOutputShape(n.shape)))})}getConfig(){let t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Xr(this.embeddingsInitializer),embeddingsRegularizer:Er(this.embeddingsRegularizer),activityRegularizer:Er(this.activityRegularizer),embeddingsConstraint:Ri(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}};YO.className="Embedding";rt.registerClass(YO);var Jm=class extends On{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Pn}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;let n=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){let i=t[t.length-e.length+r],s=e[r];if(i==null||s==null||i<0||s<0)n.push(null);else if(i===1)n.push(s);else if(s===1)n.push(i);else{if(i!==s)throw new be("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(i)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[tr(t)]),t=t,t.length<2)throw new be(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(let i of t)i!=null&&i[0]!==null&&e.push(i[0]);if(e=Ad(e),e.length>1)throw new be(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=t[0]==null?null:t[0].slice(1);for(let i=1;i<t.length;++i){let s=t[i]==null?null:t[i].slice(1);n=this.computeElementwiseOpOutputShape(n,s)}let r=t.map(i=>i.length);t.indexOf(null)===-1&&Ad(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return xe(()=>{if(t=t,this.reshapeRequired){let n=[],r=t.map(i=>i.rank);if(r.indexOf(null)===-1){let i=Ud(r);for(let s of t){let a=s.rank;for(let o=0;o<i-a;++o)s=jw(s,1);n.push(s)}return this.mergeFunction(n)}else{let i=!1;for(let o of t){let l=o.rank;if(l==null){let u=o.shape,c=u[0],d=u.slice(1).concat([c]),h=ve(o,[c].concat(Ed(u.slice(1))));h=Nn(h,[1,0]),h=ve(h,d),n.push(h),i=!0}else if(l>1){let u=_l(1,l).concat([0]);n.push(Nn(o,u)),i=!0}else n.push(o)}let s=this.mergeFunction(n),a=s.rank;if(i){if(a==null){let o=s.shape,l=o.length,u=o[l-1],c=[u].concat(o.slice(0,o.length-1));s=ve(Nn(ve(s,[-1,u]),[1,0]),c)}else if(a>1){let o=[a-1].concat(_l(0,a-1));s=Nn(s,o)}}return s}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let r=1;r<t.length;++r){let i=t[r]==null?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,i)}let n=[];for(let r of t)r!=null&&r[0]!==null&&n.push(r[0]);return n=Ad(n),n.length===1?e=n.concat(e):e=[null].concat(e),e}computeMask(t,e){return xe(()=>{if(e==null)return null;if(!Array.isArray(e))throw new be("`mask` should be an Array");if(!Array.isArray(t))throw new be("`inputs` should be an Array");if(e.length!==t.length)throw new be(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(r=>r==null))return null;e=e.map(r=>r==null?r:Gi(r,0));let n=e[0];for(let r=1;r<e.length-1;++r)n=Go(n,e[r]);return n})}},ZO=class extends Jm{constructor(t){super(t)}mergeFunction(t){return xe(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=ze(e,t[n]);return e})}};ZO.className="Add";rt.registerClass(ZO);var QO=class extends Jm{constructor(t){super(t)}mergeFunction(t){return xe(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=fe(e,t[n]);return e})}};QO.className="Multiply";rt.registerClass(QO);var eB=class extends Jm{constructor(t){super(t)}mergeFunction(t){return xe(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=ze(e,t[n]);return fe(1/t.length,e)})}};eB.className="Average";rt.registerClass(eB);var tB=class extends Jm{constructor(t){super(t)}mergeFunction(t){return xe(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=xu(e,t[n]);return e})}};tB.className="Maximum";rt.registerClass(tB);var nB=class extends Jm{constructor(t){super(t)}mergeFunction(t){return xe(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=Od(e,t[n]);return e})}};nB.className="Minimum";rt.registerClass(nB);var rB=class extends Jm{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new be("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(let r of t)if(r!=null){e=!1;break}if(e)return;let n=[];for(let r=0;r<t.length;++r){let i=t[r].slice();i.splice(this.axis,1);let s=!1;for(let a of n)if(P.arraysEqual(a,i)){s=!0;break}s||n.push(i)}if(n.length>1)throw new be("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return xe(()=>rO(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new be("A `Concatenate` layer should be called on a list of inputs.");let e=t,n=e[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let i of e.slice(1)){if(n[r]==null||i[r]==null){n[r]=null;break}n[r]+=i[r]}return n}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new be("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new be("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new be(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return xe(()=>{let n=!0;if(e.forEach(s=>{if(s!=null){n=!1;return}}),n)return null;let r=[];for(let s=0;s<t.length;++s)e[s]==null?r.push(ft(za(t[s]),"bool")):e[s].rank<t[s].rank?r.push(Gi(e[s],-1)):r.push(e[s]);let i=wr(r,this.axis);return wC(i,-1,!1)})}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}};rB.className="Concatenate";rt.registerClass(rB);function zx(t,e){for(;t<0;)t+=e;return t}function bNe(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new Pn("batchDot is not implemented for tensors of 4D or higher rank yet");if(P.assert(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),P.assert(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof n=="number"&&(n=[n,n]),t.dtype==="complex64"||e.dtype==="complex64")throw new Pn("batchDot is not implemented for complex64-type Tensors yet.");let r=t.shape.length,i=e.shape.length;n==null&&(n=[r-1,i-2]);let s=n;return xe(()=>{let a;if(r>i){a=r-i;let l=[];for(let u=0;u<a;++u)l.push(1);e=ve(e,e.shape.concat(l))}else if(i>r){a=i-r;let l=[];for(let u=0;u<a;++u)l.push(1);t=ve(t,t.shape.concat(l))}else a=0;let o;if(t.shape.length===2&&e.shape.length===2)s[0]===s[1]?o=Xt(fe(t,e),s[0]):o=Xt(fe(Nn(t,[1,0]),e),s[1]);else{let l=s[0]!==t.shape.length-1,u=s[1]===e.shape.length-1;o=kn(t,e,l,u)}if(a>0){let l;r>i?l=r+i-3:l=r-1;let u=[];for(let c=l;c<l+a;++c)u.push(c);o=uh(o,u)}return o.shape.length===1&&(o=Gi(o,1)),o})}var iB=class extends Jm{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){P.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0],n=t[1];if(e.length>3||n.length>3)throw new Pn("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(e,n);if(e[r[0]]!==n[r[1]])throw new be(`Dimension incompatibility: ${e[r[0]]} !== ${n[r[1]]}`)}mergeFunction(t){if(t.length!==2)throw new be(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],n=t[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,s)=>zx(i,t[s].shape.length)):r=[zx(this.axes,e.shape.length),zx(this.axes,n.shape.length)],this.normalize&&(e=OI(e,r[0]),n=OI(n,r[1])),bNe(e,n,r)}interpretAxes(t,e){let n;return Array.isArray(this.axes)?n=this.axes:n=[zx(this.axes,t.length),zx(this.axes,e.length)],n}computeOutputShape(t){P.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new Pn("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(e,n);e.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let i=e.concat(n);return i.length===1&&i.push(1),i}computeMask(t,e){return null}getConfig(){let t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}};iB.className="Dot";rt.registerClass(iB);var sB=class extends On{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return xe(()=>{this.invokeCallHook(t,e);let n=mn(t);return Kw(()=>ze(eM(n.shape,0,this.stddev),n),()=>n,e.training||!1)})}};sB.className="GaussianNoise";rt.registerClass(sB);var aB=class extends On{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return xe(()=>{this.invokeCallHook(t,e);let n=mn(t);return this.rate>0&&this.rate<1?Kw(()=>{let r=Math.sqrt(this.rate/(1-this.rate));return fe(n,eM(n.shape,1,r))},()=>n,e.training||!1):n})}};aB.className="GaussianDropout";rt.registerClass(aB);var oB=class extends On{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||mn(t).shape}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return xe(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(t);return Kw(()=>{let r=mn(t),i=-1.6732632423543772*1.0507009873554805,s=gc(oh(n),this.rate);s=dc(s,"float32");let a=((1-this.rate)*(1+this.rate*i**2))**-.5,o=-a*i*this.rate,l=ze(fe(r,s),fe(ze(s,-1),i));return ze(fe(l,a),o)},()=>mn(t),e.training||!1)}return t})}};oB.className="AlphaDropout";rt.registerClass(oB);function A1(t,e,n,r,i,s=.001){let a;if(t.rank===2)a=q3(t,e,n,r,i,s);else if(t.rank===3)a=J3(t,e,n,r,i,s);else if(t.rank===4)a=Y3(t,e,n,r,i,s);else throw new Pn(`batchNormalization is not implemented for array of rank ${t.rank} yet`);return a}function wNe(t,e,n,r,i=.001){return xe(()=>{let s=Bw(t,r),a=s.mean,o=s.variance;return[A1(t,a,o,n,e,i),a,o]})}function _Ne(t,e,n,r,i=.001){return xe(()=>{let s=Bw(t,r),a=s.mean,o=s.variance,l=[];for(let p of _l(0,t.rank))r.indexOf(p)!==-1?l.push(1):l.push(t.shape[p]);let u=ve(a,l),c=ve(o,l),d=e==null?null:ve(e,l),h=n==null?null:ve(n,l);return[A1(t,u,c,h,d,i),a,o]})}function SNe(t,e,n,r,i=.001){return P.arraysEqual(r.slice().sort(),_l(0,t.rank-1))?wNe(t,e,n,r,i):_Ne(t,e,n,r,i)}var lB=class extends On{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Br(t.betaInitializer||"zeros"),this.gammaInitializer=Br(t.gammaInitializer||"ones"),this.movingMeanInitializer=Br(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Br(t.movingVarianceInitializer||"ones"),this.betaConstraint=Fi(t.betaConstraint),this.gammaConstraint=Fi(t.gammaConstraint),this.betaRegularizer=Ur(t.betaRegularizer),this.gammaRegularizer=Ur(t.gammaRegularizer)}build(t){t=tr(t);let e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(n==null)throw new be(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new gi({ndim:t.length,axes:{[e]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return xe(()=>{let n=e.training==null?!1:e.training,r=mn(t),i=r.shape,s=i.length,a=_l(0,s),o=this.axis>=0?this.axis:this.axis+s;a.splice(o,1);let l=af(1,s);l[o]=i[o];let u=a.slice();u.sort();let c=!P.arraysEqual(u,_l(0,s).slice(0,s-1)),d=()=>{if(c){let y=ve(this.movingMean.read(),l),m=ve(this.movingVariance.read(),l),b=this.center?ve(this.beta.read(),l):null,w=this.scale?ve(this.gamma.read(),l):null;return A1(r,y,m,b,w,this.epsilon)}else return A1(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return d();let[h,p,f]=SNe(r,this.gamma.read(),this.beta.read(),a,this.epsilon),g=(y,m,b)=>{xe(()=>{let w=1-b,_=y.read(),S=fe(Dt(_,m),w);y.write(Dt(_,S))})};return g(this.movingMean,p,this.momentum),g(this.movingVariance,f,this.momentum),h})}getConfig(){let t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Xr(this.betaInitializer),gammaInitializer:Xr(this.gammaInitializer),movingMeanInitializer:Xr(this.movingMeanInitializer),movingVarianceInitializer:Xr(this.movingVarianceInitializer),betaRegularizer:Er(this.betaRegularizer),gammaRegularizer:Er(this.gammaRegularizer),betaConstraint:Ri(this.betaConstraint),gammaConstraint:Ri(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}};lB.className="BatchNormalization";rt.registerClass(lB);var uB=class extends On{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Br(t.betaInitializer||"zeros"),this.gammaInitializer=Br(t.gammaInitializer||"ones"),this.betaRegularizer=Ur(t.betaRegularizer),this.gammaRegularizer=Ur(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=tr(t);let e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=e);for(let i of this.axis)if(i<0||i>=e)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Ad(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(i=>t[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(t,e){let n=mn(t),r=n.shape,i=r.length;return xe(()=>{let{mean:s,variance:a}=Bw(n,this.axis,!0),o=af(1,i);for(let p of this.axis)o[p]=r[p];let l=p=>p!=null&&p.shape.length!==i?ve(p,o):p,u=this.scale?l(this.gamma.read()):null,c=this.center?l(this.beta.read()):null,d=[],h=[];for(let p=0;p<i;++p)this.axis.indexOf(p)!==-1?(d.push(r[p]),h.push(1)):(d.push(1),h.push(r[p]));return s=Na(s,d),a=Na(a,d),u!=null&&(u=Na(u,h)),c!=null&&(c=Na(c,h)),A1(n,s,a,c,u,this.epsilon)})}getConfig(){let t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Xr(this.betaInitializer),gammaInitializer:Xr(this.gammaInitializer),betaRegularizer:Er(this.betaRegularizer),gammaRegularizer:Er(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}};uB.className="LayerNormalization";rt.registerClass(uB);function ANe(t,e,n){return xe(()=>{if(t.rank!==4)throw new be(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new be("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Sl()),n!=="channelsLast"&&n!=="channelsFirst")throw new be(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],e[0],e[1]]:r=[[0,0],e[0],e[1],[0,0]],Ml(t,r)})}var cB=class extends On{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?Sl():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new be(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new be(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new be(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new gi({ndim:4})]}computeOutputShape(t){t=tr(t);let e,n;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?n=t[3]+this.padding[1][0]+this.padding[1][1]:n=null,[t[0],t[1],e,n]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?n=t[2]+this.padding[1][0]+this.padding[1][1]:n=null,[t[0],e,n,t[3]])}call(t,e){return xe(()=>ANe(mn(t),this.padding,this.dataFormat))}getConfig(){let t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};cB.className="ZeroPadding2D";rt.registerClass(cB);function bM(t,e,n,r,i,s){return xe(()=>{ci(i),Wq(s),mo(r),n==null&&(n=[1,1]),r==null&&(r="valid"),i==null&&(i=Sl()),s==null&&(s="max"),t=NO(t,i);let a,o=r==="same"?"same":"valid";return s==="max"?a=Oi(t,e,n,o):a=mc(t,e,n,o),i==="channelsFirst"&&(a=Nn(a,[0,3,1,2])),a})}function qJ(t,e,n,r,i,s){return xe(()=>{ci(i),Wq(s),mo(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),i==null&&(i=Sl()),s==null&&(s="max"),t=OJ(t,i);let a,o=r==="same"?"same":"valid";return s==="max"?a=wL(t,e,n,o):a=K3(t,e,n,o),i==="channelsFirst"&&(a=Nn(a,[0,4,1,2,3])),a})}var JJ=class extends On{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new be(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(ji(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new be(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);ji(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,mo(this.padding),this.inputSpec=[new gi({ndim:3})]}computeOutputShape(t){t=tr(t);let e=bl(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return xe(()=>{this.invokeCallHook(t,e),t=jw(mn(t),2);let n=this.poolingFunction(mn(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return uh(n,[2])})}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}},dB=class extends JJ{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return ci(i),mo(r),bM(t,e,n,r,i,"max")}};dB.className="MaxPooling1D";rt.registerClass(dB);var hB=class extends JJ{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return ci(i),mo(r),bM(t,e,n,r,i,"avg")}};hB.className="AveragePooling1D";rt.registerClass(hB);var YJ=class extends On{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new be(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];ji(this.poolSize,"poolSize"),ji(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ci(this.dataFormat),mo(this.padding),this.inputSpec=[new gi({ndim:4})]}computeOutputShape(t){t=tr(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=bl(e,this.poolSize[0],this.padding,this.strides[0]),n=bl(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return xe(()=>(this.invokeCallHook(t,e),this.poolingFunction(mn(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},pB=class extends YJ{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return ci(i),mo(r),bM(t,e,n,r,i,"max")}};pB.className="MaxPooling2D";rt.registerClass(pB);var fB=class extends YJ{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return ci(i),mo(r),bM(t,e,n,r,i,"avg")}};fB.className="AveragePooling2D";rt.registerClass(fB);var ZJ=class extends On{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new be(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];ji(this.poolSize,"poolSize"),ji(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ci(this.dataFormat),mo(this.padding),this.inputSpec=[new gi({ndim:5})]}computeOutputShape(t){t=tr(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=bl(e,this.poolSize[0],this.padding,this.strides[0]),n=bl(n,this.poolSize[1],this.padding,this.strides[1]),r=bl(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,n,r]:[t[0],e,n,r,t[4]]}call(t,e){return xe(()=>(this.invokeCallHook(t,e),this.poolingFunction(mn(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},mB=class extends ZJ{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return ci(i),mo(r),qJ(t,e,n,r,i,"max")}};mB.className="MaxPooling3D";rt.registerClass(mB);var gB=class extends ZJ{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return ci(i),mo(r),qJ(t,e,n,r,i,"avg")}};gB.className="AveragePooling3D";rt.registerClass(gB);var QJ=class extends On{constructor(t){super(t),this.inputSpec=[new gi({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Pn}},yB=class extends QJ{constructor(t){super(t||{})}call(t,e){return xe(()=>{let n=mn(t);return Wr(n,1)})}};yB.className="GlobalAveragePooling1D";rt.registerClass(yB);var vB=class extends QJ{constructor(t){super(t||{})}call(t,e){return xe(()=>{let n=mn(t);return oo(n,1)})}};vB.className="GlobalMaxPooling1D";rt.registerClass(vB);var eY=class extends On{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ci(this.dataFormat),this.inputSpec=[new gi({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new Pn}getConfig(){let t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},xB=class extends eY{call(t,e){return xe(()=>{let n=mn(t);return this.dataFormat==="channelsLast"?Wr(n,[1,2]):Wr(n,[2,3])})}};xB.className="GlobalAveragePooling2D";rt.registerClass(xB);var bB=class extends eY{call(t,e){return xe(()=>{let n=mn(t);return this.dataFormat==="channelsLast"?oo(n,[1,2]):oo(n,[2,3])})}};bB.className="GlobalMaxPooling2D";rt.registerClass(bB);var tY=class extends On{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){let t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){let r=e.layer,i=xl(r,n);delete e.layer;let s={layer:i};return Object.assign(s,e),new t(s)}},wB=class extends tY{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=tr(t),t.length<3)throw new be(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];let e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=tr(t);let e=[t[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),r=t[1];return[n[0],r].concat(n.slice(1))}call(t,e){return xe(()=>(t=mn(t),jJ((n,r)=>[mn(this.layer.call(n,e)),[]],t,[],!1,null,null,!1,!0)[1]))}};wB.className="TimeDistributed";rt.registerClass(wB);function ENe(t){Km(A2e,"BidirectionalMergeMode",t)}var INe="concat",_B=class extends tY{constructor(t){super(t);let e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=xl(n),e.goBackwards=e.goBackwards!==!0;let r={};if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=xl(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?INe:t.mergeMode,ENe(this.mergeMode),t.weights)throw new Pn("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){let e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let n,r,i;return this.returnState&&(i=e.slice(1)),n=e[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,r=[n]):this.mergeMode==null?r=[n,n.slice()]:r=[n],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[n].concat(i).concat(i.slice()):ea(r)}apply(t,e){let n=e==null?null:e.initialState,r=e==null?null:e.constants;e==null&&(e={});let i=VJ(t,n,r,this.numConstants);if(t=i.inputs,n=i.initialState,r=i.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(n==null||n.length===0)&&r==null)return super.apply(t,e);let s=[],a=[];if(n!=null){let l=n.length;if(l%2>0)throw new be("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,s.push(...n);let u=n.map(c=>new gi({shape:c.shape}));this.forwardLayer.stateSpec=u.slice(0,l/2),this.backwardLayer.stateSpec=u.slice(l/2),a.push(...u)}if(r!=null)throw new Pn("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof Al;for(let l of s)if(l instanceof Al!==o)throw new be("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let l=[t].concat(s),u=this.inputSpec.concat(a),c=this.inputSpec;this.inputSpec=u;let d=super.apply(l,e);return this.inputSpec=c,d}else return super.apply(t,e)}call(t,e){return xe(()=>{let n=e.initialState,r,i;if(n==null)r=this.forwardLayer.call(t,e),i=this.backwardLayer.call(t,e);else{let o=n.slice(0,n.length/2),l=n.slice(n.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:o})),i=this.backwardLayer.call(t,Object.assign(e,{initialState:l}))}let s;this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=ho(i,1));let a;return this.mergeMode==="concat"?a=rO([r,i]):this.mergeMode==="sum"?a=ze(r,i):this.mergeMode==="ave"?a=fe(.5,ze(r,i)):this.mergeMode==="mul"?a=fe(r,i):this.mergeMode==null&&(a=[r,i]),this.returnState?this.mergeMode==null?a.concat(s):[a].concat(s):a})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){kp(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),kp(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[e,e]:n=e:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let r=this.forwardLayer.states.map(i=>null);return Array.isArray(n)?n.concat(r).concat(r):[n].concat(r).concat(r)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){let t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){let n=xl(e.layer);if(delete e.layer,e.numConstants!=null)throw new Pn("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=e;return r.layer=n,new t(r)}};_B.className="Bidirectional";rt.registerClass(_B);var SB=class extends On{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){let t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return xe(()=>(t=mn(t),t.dtype!=="float32"&&(t=dc(t,"float32")),ze(fe(t,this.scale),this.offset)))}};SB.className="Rescaling";rt.registerClass(SB);var{resizeBilinear:TNe,cropAndResize:CNe}=to,AB=class extends On{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,n,r,i,s,a,o){return xe(()=>{let l,u=!1,c=e/s,d=n/a,h=(r+e)/s,p=(i+n)/a,f=[c,d,h,p],g=[];t.rank===3?(u=!0,l=xi([t])):l=t;for(let w=0;w<l.shape[0];w++)g.push(f);let y=Us(g,[g.length,4]),m=sf(0,g.length,1,"int32"),b=CNe(l,y,m,[r,i],"nearest");return dc(u?mn(ii(b)):b,o)})}upsize(t,e,n,r){return xe(()=>{let i=TNe(t,[e,n]);return dc(i,r)})}call(t,e){return xe(()=>{let n=mn(t),r=n.dtype,i=n.shape,s=i[i.length-3],a=i[i.length-2],o=0;s!==this.height&&(o=Math.floor((s-this.height)/2));let l=0;return a!==this.width&&(l=Math.floor((a-this.width)/2),l===0&&(l=1)),o>=0&&l>=0?this.centerCrop(n,o,l,this.height,this.width,s,a,r):this.upsize(t,this.height,this.width,r)})}getConfig(){let t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=tr(t);let e=t.length-3,n=t.length-2;return t[e]=this.height,t[n]=this.width,t}};AB.className="CenterCrop";rt.registerClass(AB);function MNe(t,e,n,r){let i=mn(t);if(i.dtype!=="int32"&&(i=dc(i,"int32")),e==="int")return i;let s=i.shape;if(i.rank===0&&(i=Gi(i,-1)),e==="oneHot"&&i.shape[i.shape.length-1]!==1&&(i=Gi(i,-1)),i.rank>2)throw new be(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${s} which would result in output rank ${i.rank}.`);let a=["multiHot","oneHot"].includes(e),o=i,l;if(typeof r<"u"&&e==="count"?l=NI(o,r,n,a):l=NI(o,[],n,a),e!=="tfIdf")return l;if(r)return fe(l,r);throw new be("When outputMode is 'tfIdf', weights must be provided.")}var EB=class extends On{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){let t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return t=tr(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return xe(()=>{t=mn(t),t.dtype!=="int32"&&(t=dc(t,"int32"));let n;if(typeof e.countWeights<"u"){if(this.outputMode!=="count")throw new be(`countWeights is not used when outputMode !== count.
              Received countWeights=${e.countWeights}`);n=mn(e.countWeights)}let r=oo(t),i=qy(t),s=Xs(this.numTokens,r).bufferSync().get(0),a=gc(i,0).bufferSync().get(0);if(!(s&&a))throw new be(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return MNe(t,this.outputMode,this.numTokens,n)})}};EB.className="CategoryEncoding";rt.registerClass(EB);var kNe=["bilinear","nearest"],kV=new Set(kNe),IB=class extends On{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(kV.has(t.interpolation))this.interpolation=t.interpolation;else throw new be(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!t.cropToAspectRatio}computeOutputShape(t){t=tr(t);let e=t[2];return[this.height,this.width,e]}getConfig(){let t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return xe(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return to.resizeBilinear(t,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return to.resizeNearestNeighbor(t,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...kV]} are supported`)})}};IB.className="Resizing";rt.registerClass(IB);var nY=class{constructor(t){this.seed=t}next(){if(this.seed!==void 0)return this.seed++}};nY.className="RandomSeed";var rY=class extends On{constructor(t){super(t),this.randomGenerator=new nY(t.seed)}getConfig(){let t={seed:this.randomGenerator.seed},e=super.getConfig();return Object.assign(t,e),t}};rY.className="BaseRandomLayer";var NNe=["bilinear","nearest"],NV=new Set(NNe),TB=class extends rY{constructor(t){super(t);let{factor:e,interpolation:n="bilinear"}=t;if(this.factor=e,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new be(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new be(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new be(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(NV.has(n))this.interpolation=n;else throw new be(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let t={factor:this.factor,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=tr(t);let e=t[2];return[this.imgHeight,-1,e]}call(t,e){return xe(()=>{let n=mn(t);this.imgHeight=n.shape[n.shape.length-3];let r=n.shape[n.shape.length-2];this.widthFactor=oh([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*r;i=Math.round(i);let s=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return to.resizeBilinear(t,s);case"nearest":return to.resizeNearestNeighbor(t,s);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...NV]} are supported`)}})}};TB.className="RandomWidth";rt.registerClass(TB);function RNe(t){return new Mv(t)}function FNe(t){return new CO(t)}function DNe(t){return new EO(t)}function PNe(t){return new IO(t)}function LNe(t){return new TO(t)}function ONe(t){return new kO(t)}function BNe(t){return new MO(t)}function UNe(t){return new PO(t)}function $Ne(t){return new pM(t)}function zNe(t){return new RO(t)}function GNe(t){return new fM(t)}function HNe(t){return new FO(t)}function WNe(t){return new DO(t)}function VNe(t){return new LO(t)}function jNe(t){return new OO(t)}function XNe(t){return new BO(t)}function KNe(t){return new jO(t)}function qNe(t){return new WO(t)}function JNe(t){return new xM(t)}function YNe(t){return new HO(t)}function ZNe(t){return new VO(t)}function QNe(t){return new XO(t)}function eRe(t){return new KO(t)}function tRe(t){return new qO(t)}function nRe(t){return new YO(t)}function rRe(t){return new ZO(t)}function iRe(t){return new eB(t)}function sRe(t){return new rB(t)}function aRe(t){return new tB(t)}function oRe(t){return new nB(t)}function lRe(t){return new QO(t)}function uRe(t){return new iB(t)}function cRe(t){return new lB(t)}function dRe(t){return new uB(t)}function hRe(t){return new cB(t)}function CB(t){return new hB(t)}function pRe(t){return CB(t)}function fRe(t){return CB(t)}function MB(t){return new fB(t)}function mRe(t){return MB(t)}function gRe(t){return MB(t)}function kB(t){return new gB(t)}function yRe(t){return kB(t)}function vRe(t){return kB(t)}function xRe(t){return new yB(t)}function bRe(t){return new xB(t)}function iY(t){return new vB(t)}function sY(t){return new bB(t)}function aY(t){return new dB(t)}function oY(t){return new pB(t)}function wRe(t){return new mB(t)}function _Re(t){return new $O(t)}function SRe(t){return new gM(t)}function ARe(t){return new zO(t)}function ERe(t){return new Zw(t)}function IRe(t){return new UO(t)}function TRe(t){return new mM(t)}function CRe(t){return new GO(t)}function MRe(t){return new vM(t)}function kRe(t){return new xc(t)}function NRe(t){return new yM(t)}function RRe(t){return new _B(t)}function FRe(t){return new wB(t)}var DRe=iY,PRe=sY,LRe=aY,ORe=oY;function BRe(t){return new sB(t)}function URe(t){return new aB(t)}function $Re(t){return new oB(t)}function zRe(t){return new JO(t)}function GRe(t){return new SB(t)}function HRe(t){return new AB(t)}function WRe(t){return new IB(t)}function VRe(t){return new EB(t)}function jRe(t){return new TB(t)}var lY={};wn(lY,{MAPE:()=>rFe,MSE:()=>aFe,binaryAccuracy:()=>XRe,binaryCrossentropy:()=>KRe,categoricalAccuracy:()=>JRe,categoricalCrossentropy:()=>YRe,cosineProximity:()=>eFe,mape:()=>iFe,meanAbsoluteError:()=>tFe,meanAbsolutePercentageError:()=>nFe,meanSquaredError:()=>sFe,mse:()=>oFe,precision:()=>ZRe,r2Score:()=>lFe,recall:()=>QRe,sparseCategoricalAccuracy:()=>qRe});function XRe(t,e){return xO(t,e)}function KRe(t,e){return dJ(t,e)}function qRe(t,e){return hJ(t,e)}function JRe(t,e){return bO(t,e)}function YRe(t,e){return wO(t,e)}function ZRe(t,e){return cJ(t,e)}function QRe(t,e){return kke(t,e)}function eFe(t,e){return vO(t,e)}function tFe(t,e){return uM(t,e)}function nFe(t,e){return kv(t,e)}function rFe(t,e){return kv(t,e)}function iFe(t,e){return kv(t,e)}function sFe(t,e){return qm(t,e)}function aFe(t,e){return qm(t,e)}function oFe(t,e){return qm(t,e)}function lFe(t,e){return Nke(t,e)}var uY={};wn(uY,{modelFromJSON:()=>oNe});var cY={};wn(cY,{l1:()=>cFe,l1l2:()=>uFe,l2:()=>dFe});function uFe(t){return new Jw(t)}function cFe(t){return fNe(t)}function dFe(t){return mNe(t)}var dY=class extends r0{constructor(){super(...arguments),this.model=null}setModel(t){if(!(t instanceof ec))throw new Error("model must be a LayersModel, not some other Container");this.model=t}};function _A(t,e){return t<e}function RV(t,e){return t>e}var hY=class extends dY{constructor(t){if(super(),t==null&&(t={}),t.restoreBestWeights)throw new Pn("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=t.monitor||"val_loss",this.minDelta=Math.abs(t.minDelta||0),this.patience=t.patience||0,this.verbose=t.verbose||0,this.mode=t.mode||"auto",this.baseline=t.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=_A:this.mode==="max"?this.monitorFunc=RV:this.monitor.indexOf("acc")!==-1?this.monitorFunc=RV:this.monitorFunc=_A,this.monitorFunc===_A&&(this.minDelta*=-1)}async onTrainBegin(t){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===_A?1/0:-1/0}async onEpochEnd(t,e){await Xc(e);let n=this.getMonitorValue(e);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=t,this.model.stopTraining=!0)))}async onTrainEnd(t){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(t){t==null&&(t={});let e=t[this.monitor];return e==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(t)}`),e}};function hFe(t){return new hY(t)}var pFe={earlyStopping:hFe},fFe=Ie();fFe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var _a;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(_a||(_a={}));var FV;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(FV||(FV={}));var NB={};function mFe(t,e){let n={tfOpName:t,category:"custom",inputs:[],attrs:[],customExecutor:e};NB[t]=n}function pY(t){return NB[t]}function gFe(t){delete NB[t]}function L(t,e,n,r,i){let s=e.inputParams[t];if(s&&s.inputIndexStart!==void 0){let o=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?o+1:s.inputIndexEnd,u=o<0?e.inputNames.length+o:o;if(s.type==="tensor")return os(e.inputNames[u],n,r,i);if(s.type==="tensors"){let h=e.inputs.slice(o,l);return e.inputNames.slice(o,l).filter((p,f)=>{var g;return((g=h[f])===null||g===void 0?void 0:g.op)!=="NoOp"}).map(p=>os(p,n,r,i))}let c=os(e.inputNames[u],n,r,i),d=c.dataSync();return s.type==="number"?d[0]:P.toNestedArray(c.shape,d)}let a=e.attrParams[t];return a&&a.value}function os(t,e,n,r){let[i,s]=Aa(t,n);if(r!=null){let o=r.getHashTableHandleByName(i);if(o!=null)return o}let a=n.currentContextIds.find(o=>!!e[GI(i,o)]);return a!==void 0?e[GI(i,a)][s]:void 0}function DV(t,e,n){return e[GI(t,n.currentContextId)]}function $u(t,e){let[n,r,i]=Aa(t,e);return[GI(n,e&&e.currentContextId),r,i]}function GI(t,e){return e?`${t}-${e}`:t}function Aa(t,e){if(t==="")return["",0,void 0];let n=e!=null&&e.parseNodeNameCache!=null;if(n){let s=e.parseNodeNameCache.get(t);if(s!=null)return s}let r=t.split(":"),i;if(r.length===1)i=[t,0,void 0];else{let s=r[0],a=r.length===3?r[1]:void 0,o=Number(r[r.length-1]);i=[s,o,a]}return n&&e.parseNodeNameCache.set(t,i),i}function QA(t,e,n){let r=L("pad",t,e,n);if(r==="explicit"){r=L("explicitPaddings",t,e,n);let i=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)i[s][0]=r[s*2],i[s][1]=r[s*2+1];return i}return r}function zu(t){return t.kept?t:su(t)}var fY={};wn(fY,{json:()=>yFe});var yFe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],mY={};wn(mY,{json:()=>vFe});var vFe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],gY={};wn(gY,{json:()=>xFe});var xFe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],yY={};wn(yY,{json:()=>bFe});var bFe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],vY={};wn(vY,{json:()=>wFe});var wFe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],xY={};wn(xY,{json:()=>_Fe});var _Fe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],bY={};wn(bY,{json:()=>SFe});var SFe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],wY={};wn(wY,{json:()=>AFe});var AFe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],_Y={};wn(_Y,{json:()=>EFe});var EFe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],SY={};wn(SY,{json:()=>IFe});var IFe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],AY={};wn(AY,{json:()=>TFe});var TFe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],EY={};wn(EY,{json:()=>CFe});var CFe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],IY={};wn(IY,{json:()=>MFe});var MFe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],TY={};wn(TY,{json:()=>kFe});var kFe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],CY={};wn(CY,{json:()=>NFe});var NFe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],MY={};wn(MY,{json:()=>RFe});var RFe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],kY={};wn(kY,{json:()=>FFe});var FFe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],NY={};wn(NY,{json:()=>DFe});var DFe=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],RY={};wn(RY,{json:()=>PFe});var PFe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],PV=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let t=[fY,mY,gY,yY,vY,xY,bY,wY,_Y,SY,AY,EY,IY,TY,CY,MY,kY,NY,RY],e=[].concat(...t.map(n=>n.json));this.opMappers=e.reduce((n,r)=>(n[r.tfOpName]=r,n),{})}transformGraph(t,e={}){let n=t.node,r=[],i=[],s=[],a=n.reduce((f,g)=>(f[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?r.push(f[g.name]):g.op==="Const"?i.push(f[g.name]):(g.input==null||g.input.length===0)&&s.push(f[g.name]),f),{}),o=[],l=[],u={},c={};e!=null&&(u=this.mapSignatureEntries(e.inputs),c=this.mapSignatureEntries(e.outputs));let d=Object.keys(a);d.forEach(f=>{let g=a[f];g.inputNames.forEach((y,m)=>{let[b,,w]=$u(y),_=a[b];if(_.outputs!=null){let S=_.outputs.indexOf(w);if(S!==-1){let E=`${b}:${S}`;g.inputNames[m]=E}}g.inputs.push(_),_.children.push(g)})}),Object.keys(c).length===0?d.forEach(f=>{let g=a[f];g.children.length===0&&l.push(g)}):Object.keys(c).forEach(f=>{let[g]=$u(f),y=a[g];y!=null&&(y.signatureKey=c[f],l.push(y))}),Object.keys(u).length>0?Object.keys(u).forEach(f=>{let[g]=$u(f),y=a[g];y&&(y.signatureKey=u[f],o.push(y))}):o=r;let h={};t.library!=null&&t.library.function!=null&&(h=t.library.function.reduce((f,g)=>(f[g.signature.name]=this.mapFunction(g),f),{}));let p={nodes:a,inputs:o,outputs:l,weights:i,placeholders:r,signature:e,functions:h};return s.length>0&&(p.initNodes=s),p}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,n)=>(e[t[n].name]=n,e),{})}mapNode(t){let e=pY(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});let n={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return e.inputs!=null&&(n.inputParams=e.inputs.reduce((r,i)=>(r[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},r),{})),e.attrs!=null&&(n.attrParams=e.attrs.reduce((r,i)=>{let s=i.type,a;switch(i.type){case"string":a=PF(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=PF(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":a=GF(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=GF(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":a=OF(t.attr,i.tfName,i.defaultValue||0),a===void 0&&i.tfDeprecatedName&&(a=OF(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":a=zF(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=zF(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":a=LF(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=LF(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":a=WF(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=WF(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":a=$F(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=$F(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":a=HF(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=HF(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":a=BF(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=BF(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":a=UF(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=UF(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":a=LV(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=LV(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${t.op}`)}return r[i.name]={value:a,type:s},r},{})),n}mapFunction(t){let e=t.nodeDef,n=[],r=[],i={};e!=null&&(i=e.reduce((u,c)=>(u[c.name]=this.mapNode(c),c.op==="Const"&&r.push(u[c.name]),u),{}));let s=[],a=[];t.signature.inputArg.forEach(u=>{let[c]=$u(u.name),d={name:c,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:RB(u.type),type:"dtype"}},children:[]};d.signatureKey=u.name,s.push(d),i[c]=d}),Object.keys(i).forEach(u=>{let c=i[u];c.inputNames.forEach((d,h)=>{let[p,,f]=$u(d),g=i[p];if(g.outputs!=null){let y=g.outputs.indexOf(f);if(y!==-1){let m=`${p}:${y}`;c.inputNames[h]=m}}c.inputs.push(g),g.children.push(c)})});let o=t.ret;t.signature.outputArg.forEach(u=>{let[c,d]=$u(o[u.name]),h=i[c];h!=null&&(h.defaultOutput=d,a.push(h))});let l=this.mapArgsToSignature(t);return{nodes:i,inputs:s,outputs:a,weights:r,placeholders:n,signature:l}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n),e),{}),outputs:t.signature.outputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n,t.ret),e),{})}}mapArgToTensorInfo(t,e){let n=t.name;return e!=null&&(n=e[n]),{name:n,dtype:t.type}}};function LFe(t){let e=Ie().global;if(typeof e.atob<"u")return e.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function FY(t,e){let n=Array.isArray(t)?String.fromCharCode.apply(null,t):LFe(t);return e?n:n.toLowerCase()}function PF(t,e,n,r=!1){let i=t[e];return i!=null?FY(i.s,r):n}function LF(t,e,n){let r=t[e];return r?r.b:n}function OF(t,e,n){let r=t[e]||{},i=r.i!=null?r.i:r.f!=null?r.f:n;return typeof i=="number"?i:parseInt(i,10)}function RB(t){switch(typeof t=="string"&&(t=_a[t]),t){case _a.DT_FLOAT:case _a.DT_HALF:return"float32";case _a.DT_INT32:case _a.DT_INT64:case _a.DT_INT8:case _a.DT_UINT8:return"int32";case _a.DT_BOOL:return"bool";case _a.DT_DOUBLE:return"float32";case _a.DT_STRING:return"string";case _a.DT_COMPLEX64:case _a.DT_COMPLEX128:return"complex64";default:return null}}function LV(t,e,n){let r=t[e];return r&&r.func?r.func.name:n}function BF(t,e,n){let r=t[e];return r&&r.type?RB(r.type):n}function UF(t,e,n){let r=t[e];return r&&r.list&&r.list.type?r.list.type.map(i=>RB(i)):n}function DY(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function $F(t,e,n){let r=t[e];return r&&r.shape?DY(r.shape):n}function zF(t,e,n){let r=t[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(i=>typeof i=="number"?i:parseInt(i,10)):n}function GF(t,e,n,r=!1){let i=t[e];return i&&i.list&&i.list.s?i.list.s.map(s=>FY(s,r)):n}function HF(t,e,n){let r=t[e];return r&&r.list&&r.list.shape?r.list.shape.map(i=>DY(i)):n}function WF(t,e,n){let r=t[e];return r&&r.list&&r.list.b?r.list.b:n}var OFe=class{constructor(t,e,n){this.node=t,this.tensorMap=e,this.context=n,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(r=>this.getInput(r)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((r,i)=>(r[i]=this.getAttr(i),r),{}))}getInput(t){return os(t,this.tensorMap,this.context)}getAttr(t,e){let n=this.node.rawAttrs[t];if(n.tensor!=null)return os(t,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return OF(this.node.rawAttrs,t,e);if(n.s!=null)return PF(this.node.rawAttrs,t,e);if(n.b!=null)return LF(this.node.rawAttrs,t,e);if(n.shape!=null)return $F(this.node.rawAttrs,t,e);if(n.type!=null)return BF(this.node.rawAttrs,t,e);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return zF(this.node.rawAttrs,t,e);if(n.list.s!=null)return GF(this.node.rawAttrs,t,e);if(n.list.shape!=null)return HF(this.node.rawAttrs,t,e);if(n.list.b!=null)return WF(this.node.rawAttrs,t,e);if(n.list.type!=null)return UF(this.node.rawAttrs,t,e)}return e}},es={};wn(es,{OP_SCOPE_SUFFIX:()=>D3,abs:()=>fi,acos:()=>U3,acosh:()=>$3,add:()=>ze,addN:()=>K7,all:()=>wC,any:()=>v1,argMax:()=>ef,argMin:()=>z3,asin:()=>G3,asinh:()=>H3,atan:()=>W3,atan2:()=>V3,atanh:()=>j3,avgPool:()=>mc,avgPool3d:()=>K3,basicLSTMCell:()=>Z7,batchNorm:()=>Wm,batchNorm2d:()=>q3,batchNorm3d:()=>J3,batchNorm4d:()=>Y3,batchToSpaceND:()=>Nw,bincount:()=>Z3,bitwiseAnd:()=>Q7,booleanMaskAsync:()=>GK,broadcastArgs:()=>eK,broadcastTo:()=>Mp,buffer:()=>Rn,cast:()=>ft,ceil:()=>Q3,clipByValue:()=>bs,clone:()=>su,complex:()=>cc,concat:()=>wr,concat1d:()=>eL,concat2d:()=>tL,concat3d:()=>nL,concat4d:()=>rL,conv1d:()=>_C,conv2d:()=>zs,conv2dTranspose:()=>SC,conv3d:()=>sL,conv3dTranspose:()=>aL,cos:()=>Rw,cosh:()=>AC,cosineWindow:()=>XC,cumprod:()=>w1,cumsum:()=>EC,denseBincount:()=>NI,depthToSpace:()=>oL,depthwiseConv2d:()=>Vm,diag:()=>nK,dilation2d:()=>lL,div:()=>zt,divNoNan:()=>uL,dot:()=>cL,dropout:()=>UL,einsum:()=>ip,elu:()=>_v,enclosingPowerOfTwo:()=>$L,ensureShape:()=>iK,equal:()=>Ua,erf:()=>IC,euclideanNorm:()=>pL,exp:()=>ws,expandDims:()=>Gi,expm1:()=>fL,eye:()=>TC,fft:()=>Gw,fill:()=>Pa,floor:()=>Av,floorDiv:()=>bC,fused:()=>t0,gather:()=>Ev,gatherND:()=>jK,greater:()=>Xs,greaterEqual:()=>gc,ifft:()=>e0,imag:()=>Fw,image:()=>to,inTopKAsync:()=>XK,irfft:()=>$C,isFinite:()=>mL,isInf:()=>gL,isNaN:()=>yL,leakyRelu:()=>Dw,less:()=>Jy,lessEqual:()=>ah,linalg:()=>HL,linspace:()=>uK,localResponseNormalization:()=>vL,log:()=>$a,log1p:()=>Pw,logSigmoid:()=>xL,logSoftmax:()=>MC,logSumExp:()=>Lw,logicalAnd:()=>Go,logicalNot:()=>Ow,logicalOr:()=>kC,logicalXor:()=>bL,losses:()=>sq,lowerBound:()=>dK,matMul:()=>kn,max:()=>oo,maxPool:()=>Oi,maxPool3d:()=>wL,maxPoolWithArgmax:()=>hK,maximum:()=>xu,mean:()=>Wr,meshgrid:()=>pK,min:()=>qy,minimum:()=>Od,mirrorPad:()=>_L,mod:()=>SL,moments:()=>Bw,movingAverage:()=>HK,mul:()=>fe,multiRNNCell:()=>fK,multinomial:()=>mK,neg:()=>Mr,norm:()=>Sv,notEqual:()=>rf,oneHot:()=>Yy,ones:()=>ra,onesLike:()=>za,op:()=>ce,outerProduct:()=>gK,pad:()=>Ml,pad1d:()=>yK,pad2d:()=>vK,pad3d:()=>xK,pad4d:()=>bK,pool:()=>AL,pow:()=>pu,prelu:()=>$w,print:()=>B3,prod:()=>EL,raggedGather:()=>wK,raggedRange:()=>_K,raggedTensorToTensor:()=>SK,rand:()=>AK,randomGamma:()=>CK,randomNormal:()=>RC,randomStandardNormal:()=>MK,randomUniform:()=>oh,randomUniformInt:()=>kK,range:()=>sf,real:()=>Zy,reciprocal:()=>kL,relu:()=>pr,relu6:()=>FC,reshape:()=>ve,reverse:()=>ho,reverse1d:()=>NK,reverse2d:()=>RK,reverse3d:()=>FK,reverse4d:()=>DK,rfft:()=>Hw,round:()=>DC,rsqrt:()=>PC,scalar:()=>rn,scatterND:()=>WK,searchSorted:()=>NC,selu:()=>LC,separableConv2d:()=>Iv,setdiff1dAsync:()=>PK,sigmoid:()=>Uo,sign:()=>NL,signal:()=>iq,sin:()=>OC,sinh:()=>BC,slice:()=>Gn,slice1d:()=>zw,slice2d:()=>UC,slice3d:()=>Tv,slice4d:()=>Qy,softmax:()=>lh,softplus:()=>jm,spaceToBatchND:()=>Uw,sparse:()=>aq,sparseToDense:()=>VK,spectral:()=>rq,split:()=>aa,sqrt:()=>Zi,square:()=>xr,squaredDifference:()=>zC,squeeze:()=>uh,stack:()=>xi,step:()=>Xm,stridedSlice:()=>RL,string:()=>oq,sub:()=>Dt,sum:()=>Xt,tan:()=>FL,tanh:()=>Ld,tensor:()=>Us,tensor1d:()=>cr,tensor2d:()=>au,tensor3d:()=>GC,tensor4d:()=>Bd,tensor5d:()=>LK,tensor6d:()=>OK,tensorScatterUpdate:()=>UK,tile:()=>Na,topk:()=>PL,transpose:()=>Nn,truncatedNormal:()=>VC,unique:()=>LL,unsortedSegmentSum:()=>jC,unstack:()=>ii,upperBound:()=>$K,variable:()=>OL,where:()=>qi,whereAsync:()=>BL,zeros:()=>Vr,zerosLike:()=>Kn});var BFe=(t,e,n,r=es)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(L("a",t,e,n),L("b",t,e,n))];case"AddN":return[r.addN(L("tensors",t,e,n))];case"FloorMod":case"Mod":return[r.mod(L("a",t,e,n),L("b",t,e,n))];case"Mul":return[r.mul(L("a",t,e,n),L("b",t,e,n))];case"RealDiv":case"Div":return[r.div(L("a",t,e,n),L("b",t,e,n))];case"DivNoNan":return[r.divNoNan(L("a",t,e,n),L("b",t,e,n))];case"FloorDiv":return[r.floorDiv(L("a",t,e,n),L("b",t,e,n))];case"Sub":return[r.sub(L("a",t,e,n),L("b",t,e,n))];case"Minimum":return[r.minimum(L("a",t,e,n),L("b",t,e,n))];case"Maximum":return[r.maximum(L("a",t,e,n),L("b",t,e,n))];case"Pow":return[r.pow(L("a",t,e,n),L("b",t,e,n))];case"SquaredDifference":return[r.squaredDifference(L("a",t,e,n),L("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}},UFe=(t,e,n,r=es)=>{switch(t.op){case"Abs":case"ComplexAbs":return[r.abs(L("x",t,e,n))];case"Acos":return[r.acos(L("x",t,e,n))];case"Acosh":return[r.acosh(L("x",t,e,n))];case"Asin":return[r.asin(L("x",t,e,n))];case"Asinh":return[r.asinh(L("x",t,e,n))];case"Atan":return[r.atan(L("x",t,e,n))];case"Atan2":return[r.atan2(L("x",t,e,n),L("y",t,e,n))];case"Atanh":return[r.atanh(L("x",t,e,n))];case"Ceil":return[r.ceil(L("x",t,e,n))];case"Complex":return[r.complex(L("real",t,e,n),L("imag",t,e,n))];case"Cos":return[r.cos(L("x",t,e,n))];case"Cosh":return[r.cosh(L("x",t,e,n))];case"Elu":return[r.elu(L("x",t,e,n))];case"Erf":return[r.erf(L("x",t,e,n))];case"Exp":return[r.exp(L("x",t,e,n))];case"Expm1":return[r.expm1(L("x",t,e,n))];case"Floor":return[r.floor(L("x",t,e,n))];case"Log":return[r.log(L("x",t,e,n))];case"Log1p":return[r.log1p(L("x",t,e,n))];case"Imag":return[r.imag(L("x",t,e,n))];case"Neg":return[r.neg(L("x",t,e,n))];case"Reciprocal":return[r.reciprocal(L("x",t,e,n))];case"Real":return[r.real(L("x",t,e,n))];case"Relu":return[r.relu(L("x",t,e,n))];case"Round":return[r.round(L("x",t,e,n))];case"Selu":return[r.selu(L("x",t,e,n))];case"Sigmoid":return[r.sigmoid(L("x",t,e,n))];case"Sin":return[r.sin(L("x",t,e,n))];case"Sign":return[r.sign(L("x",t,e,n))];case"Sinh":return[r.sinh(L("x",t,e,n))];case"Softplus":return[r.softplus(L("x",t,e,n))];case"Sqrt":return[r.sqrt(L("x",t,e,n))];case"Square":return[r.square(L("x",t,e,n))];case"Tanh":return[r.tanh(L("x",t,e,n))];case"Tan":return[r.tan(L("x",t,e,n))];case"ClipByValue":return[r.clipByValue(L("x",t,e,n),L("clipValueMin",t,e,n),L("clipValueMax",t,e,n))];case"Relu6":return[r.relu6(L("x",t,e,n))];case"Rsqrt":return[r.rsqrt(os(t.inputNames[0],e,n))];case"LeakyRelu":return[r.leakyRelu(L("x",t,e,n),L("alpha",t,e,n))];case"Prelu":return[r.prelu(L("x",t,e,n),L("alpha",t,e,n))];case"IsNan":return[r.isNaN(os(t.inputNames[0],e,n))];case"IsInf":return[r.isInf(os(t.inputNames[0],e,n))];case"IsFinite":return[r.isFinite(os(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function Ro(t,e,n=""){if(!(typeof t=="number"||typeof e=="number")){P.assert(t.length===e.length,()=>n+` Shapes ${t} and ${e} must match`);for(let r=0;r<t.length;r++){let i=t[r],s=e[r];P.assert(i<0||s<0||i===s,()=>n+` Shapes ${t} and ${e} must match`)}}}function OV(t){return!(typeof t=="number"||t.some(e=>e<0))}function Gx(t,e,n){let r=VF(t,n),i=!OV(r);if(i&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(i&&e.forEach(s=>{r=VF(s.shape,r)}),!OV(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function VF(t,e){if(typeof t=="number")return e;if(typeof e=="number")return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);let n=[];for(let r=0;r<t.length;++r){let i=t[r],s=e[r];if(i>=0&&s>=0&&i!==s)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[r]=i>=0?i:s}return n}var $Fe=class{constructor(t,e,n,r,i,s,a){this.name=t,this.dtype=e,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=i,this.dynamicSize=s,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=rn(0),Ci(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);let e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=e.shape),Ro(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);n.tensor=e,Ci(e),n.written=!0,this.tensors[t]=n}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((n,r)=>this.write(n,e[r]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let r=0;r<this.size();r++)t.push(r)}if(t.length===0)return Us([],[0].concat(this.elementShape));let n=this.readMany(t);return Ro(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),xi(n,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return Us([],[0].concat(this.elementShape));let e=[];for(let r=0;r<this.size();r++)e.push(r);let n=this.readMany(e);return Ro(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),wr(n,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let n=Math.max(...t);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(t,ii(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let n=0,r=t.map(o=>(n+=o,n));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);let i=n===0?0:e.size/n,s=[];xe(()=>{e=ve(e,[1,n,i]);for(let o=0;o<t.length;++o){let l=[0,o===0?0:r[o-1],0],u=[1,t[o],i];s[o]=ve(Gn(e,l,u),this.elementShape)}return s});let a=[];for(let o=0;o<t.length;o++)a[o]=o;this.writeMany(a,s)}},wM=class jF{get id(){return this.idTensor.id}constructor(e,n,r,i=-1){this.tensors=e,this.elementShape=n,this.elementDtype=r,e!=null&&e.forEach(s=>{if(r!==s.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);Ro(n,s.shape,"TensorList shape mismatch: "),Ci(s)}),this.idTensor=rn(0),this.maxNumElements=i,Ci(this.idTensor)}copy(){return new jF([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Ro(e,this.elementShape,"TensorList shape mismatch: ");let i=Gx(this.elementShape,this.tensors,e);return xe(()=>{let s=this.tensors.map(a=>ve(a,i));return xi(s,0)})}popBack(e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let r=Gx(this.elementShape,this.tensors,e),i=this.tensors.pop();return i.kept=!1,Ro(i.shape,e,"TensorList shape mismatch: "),ve(i,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Ro(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ci(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);let n=new jF([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)n.tensors[r]=this.tensors[r];return n}getItem(e,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Ro(this.tensors[e].shape,n,"TensorList shape mismatch: ");let i=Gx(this.elementShape,this.tensors,n);return ve(this.tensors[e],i)}setItem(e,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Ro(this.elementShape,n.shape,"TensorList shape mismatch: "),Ci(n),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=n}gather(e,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);Ro(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());let i=Gx(this.elementShape,this.tensors,r);return e.length===0?Us([],[0].concat(i)):xe(()=>{let s=e.map(a=>ve(this.tensors[a],i));return xi(s,0)})}concat(e,n){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Ro(this.elementShape,n,"TensorList shape mismatch: ");let r=Gx(this.elementShape,this.tensors,n);return this.size()===0?Us([],[0].concat(r)):xe(()=>{let i=this.tensors.map(s=>ve(s,r));return wr(i,0)})}};function zFe(t,e,n){let r=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);let i=t.shape.slice(1);Ro(i,e,"TensorList shape mismatch: ");let s=ii(t);return new wM(s,e,r)}function GFe(t,e,n,r){return new wM([],t,e,r)}function HFe(t,e,n,r){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let i=Math.max(...e);if(r!=null&&r!==-1&&i>=r)throw new Error(`Max index must be < array size (${i}  vs. ${r})`);let s=new wM([],n,t.dtype,r),a=ii(t,0);return e.forEach((o,l)=>{s.setItem(o,a[l])}),s}function WFe(t,e,n){let r=0,i=e.map(c=>(r+=c,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);let s=t.shape.slice(1),a=VF(s,n),o=r===0?0:t.size/r,l=xe(()=>{let c=[];t=ve(t,[1,r,o]);for(let d=0;d<e.length;++d){let h=[0,d===0?0:i[d-1],0],p=[1,e[d],o];c[d]=ve(Gn(t,h,p),a)}return t.dispose(),c}),u=new wM([],n,t.dtype,e.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}var VFe=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{let r=L("thenBranch",t,e,n),i=L("elseBranch",t,e,n),s=L("cond",t,e,n),a=L("args",t,e,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap):n.functionMap[i].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=L("body",t,e,n),i=L("cond",t,e,n),s=L("args",t,e,n),a=await n.functionMap[i].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map(c=>c.id),l=await a[0].data();a.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&c.dispose()});let u=s;for(;l[0];){let c=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let d=u.map(p=>p.id);c.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&d.indexOf(p.id)===-1&&p.dispose()});let h=await n.functionMap[i].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await h[0].data(),h.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&d.indexOf(p.id)===-1&&p.dispose()})}return u}case"LoopCond":{let r=L("pred",t,e,n);return[zu(r)]}case"Switch":{let r=L("pred",t,e,n),i=L("data",t,e,n);return i.kept||(i=zu(i)),(await r.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{let r=t.inputNames.find(i=>os(i,e,n)!==void 0);if(r){let i=os(r,e,n);return[zu(i)]}return}case"Enter":{let r=L("frameName",t,e,n),i=L("tensor",t,e,n);return n.enterFrame(r),[zu(i)]}case"Exit":{let r=L("tensor",t,e,n);return n.exitFrame(),[zu(r)]}case"NextIteration":{let r=L("tensor",t,e,n);return n.nextIteration(),[zu(r)]}case"TensorArrayV3":{let r=L("size",t,e,n),i=L("dtype",t,e,n),s=L("elementShape",t,e,n),a=L("dynamicSize",t,e,n),o=L("clearAfterRead",t,e,n),l=L("identicalElementShapes",t,e,n),u=L("name",t,e,n),c=new $Fe(u,i,r,s,l,a,o);return n.addTensorArray(c),[c.idTensor,rn(1)]}case"TensorArrayWriteV3":{let r=L("tensorArrayId",t,e,n),i=L("index",t,e,n),s=L("tensor",t,e,n),a=n.getTensorArray(r.id);return a.write(i,s),[a.idTensor]}case"TensorArrayReadV3":{let r=L("tensorArrayId",t,e,n),i=L("index",t,e,n);return[n.getTensorArray(r.id).read(i)]}case"TensorArrayGatherV3":{let r=L("tensorArrayId",t,e,n),i=L("indices",t,e,n),s=L("dtype",t,e,n);return[n.getTensorArray(r.id).gather(i,s)]}case"TensorArrayScatterV3":{let r=L("tensorArrayId",t,e,n),i=L("indices",t,e,n),s=L("tensor",t,e,n),a=n.getTensorArray(r.id);return a.scatter(i,s),[a.idTensor]}case"TensorArrayConcatV3":{let r=L("tensorArrayId",t,e,n),i=n.getTensorArray(r.id),s=L("dtype",t,e,n);return[i.concat(s)]}case"TensorArraySplitV3":{let r=L("tensorArrayId",t,e,n),i=L("tensor",t,e,n),s=L("lengths",t,e,n),a=n.getTensorArray(r.id);return a.split(s,i),[a.idTensor]}case"TensorArraySizeV3":{let r=L("tensorArrayId",t,e,n),i=n.getTensorArray(r.id);return[rn(i.size(),"int32")]}case"TensorArrayCloseV3":{let r=L("tensorArrayId",t,e,n),i=n.getTensorArray(r.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{let r=L("tensorListId",t,e,n),i=L("index",t,e,n),s=L("tensor",t,e,n),a=n.getTensorList(r.id);return a.setItem(i,s),[a.idTensor]}case"TensorListGetItem":{let r=L("tensorListId",t,e,n),i=L("index",t,e,n),s=L("elementShape",t,e,n),a=L("elementDType",t,e,n);return[n.getTensorList(r.id).getItem(i,s,a)]}case"TensorListScatterV2":case"TensorListScatter":{let r=L("indices",t,e,n),i=L("tensor",t,e,n),s=L("elementShape",t,e,n),a=L("numElements",t,e,n),o=HFe(i,r,s,a);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=L("elementShape",t,e,n),i=L("elementDType",t,e,n),s;t.op==="TensorListReserve"?s="numElements":s="maxNumElements";let a=L(s,t,e,n),o=t.op==="TensorListReserve"?-1:a,l=GFe(r,i,a,o);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{let r=L("tensorListId",t,e,n),i=L("indices",t,e,n),s=L("elementShape",t,e,n),a=L("elementDType",t,e,n);return[n.getTensorList(r.id).gather(i,a,s)]}case"TensorListStack":{let r=L("tensorListId",t,e,n),i=L("elementShape",t,e,n),s=L("elementDType",t,e,n),a=L("numElements",t,e,n);return[n.getTensorList(r.id).stack(i,s,a)]}case"TensorListFromTensor":{let r=L("tensor",t,e,n),i=L("elementShape",t,e,n),s=L("elementDType",t,e,n),a=zFe(r,i,s);return n.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=L("tensorListId",t,e,n),i=n.getTensorList(r.id),s=L("dtype",t,e,n),a=L("elementShape",t,e,n);return[i.concat(s,a)]}case"TensorListPushBack":{let r=L("tensorListId",t,e,n),i=L("tensor",t,e,n),s=n.getTensorList(r.id);return s.pushBack(i),[s.idTensor]}case"TensorListPopBack":{let r=L("tensorListId",t,e,n),i=L("elementShape",t,e,n),s=L("elementDType",t,e,n);return[n.getTensorList(r.id).popBack(i,s)]}case"TensorListSplit":{let r=L("tensor",t,e,n),i=L("elementShape",t,e,n),s=L("lengths",t,e,n),a=WFe(r,s,i);return n.addTensorList(a),[a.idTensor]}case"TensorListLength":{let r=L("tensorListId",t,e,n),i=n.getTensorList(r.id);return[rn(i.size(),"int32")]}case"TensorListResize":{let r=L("tensorListId",t,e,n),i=L("size",t,e,n),s=n.getTensorList(r.id).resize(i);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};function BV(t,e,n){let[r,i]=L("fusedOps",t,e,n),s=r==="biasadd",a=!s,o=i==="prelu",l=r==="fusedbatchnorm",u=L("numArgs",t,e,n);if(s){if(o&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=L("strides",t,e,n),d=QA(t,e,n),h=L("dataFormat",t,e,n).toUpperCase(),p=L("dilations",t,e,n),[f,g]=L("args",t,e,n);a&&(g=f,f=void 0);let y=L("leakyreluAlpha",t,e,n);return{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:g,activationFunc:i,leakyreluAlpha:y}}var jFe=(t,e,n,r=es)=>{switch(t.op){case"Conv1D":{let i=L("stride",t,e,n),s=L("pad",t,e,n),a=L("dataFormat",t,e,n).toUpperCase(),o=L("dilation",t,e,n);return[r.conv1d(L("x",t,e,n),L("filter",t,e,n),i,s,a,o)]}case"Conv2D":{let i=L("strides",t,e,n),s=QA(t,e,n),a=L("dataFormat",t,e,n).toUpperCase(),o=L("dilations",t,e,n);return[r.conv2d(L("x",t,e,n),L("filter",t,e,n),[i[1],i[2]],s,a,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:i,pad:s,dataFormat:a,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=BV(t,e,n);return[r.fused.conv2d({x:L("x",t,e,n),filter:L("filter",t,e,n),strides:[i[1],i[2]],pad:s,dataFormat:a,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{let{stride:i,pad:s,dataFormat:a,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=BV(t,e,n);return[r.fused.depthwiseConv2d({x:L("x",t,e,n),filter:L("filter",t,e,n),strides:[i[1],i[2]],pad:s,dataFormat:a,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let i=L("outputShape",t,e,n),s=L("strides",t,e,n),a=QA(t,e,n);return[r.conv2dTranspose(L("x",t,e,n),L("filter",t,e,n),i,[s[1],s[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let i=L("strides",t,e,n),s=QA(t,e,n),a=L("dilations",t,e,n),o=L("dataFormat",t,e,n).toUpperCase();return[r.depthwiseConv2d(L("input",t,e,n),L("filter",t,e,n),[i[1],i[2]],s,o,[a[1],a[2]])]}case"Conv3D":{let i=L("strides",t,e,n),s=L("pad",t,e,n),a=L("dataFormat",t,e,n).toUpperCase(),o=L("dilations",t,e,n);return[r.conv3d(L("x",t,e,n),L("filter",t,e,n),[i[1],i[2],i[3]],s,a,[o[1],o[2],o[3]])]}case"AvgPool":{let i=L("strides",t,e,n),s=L("pad",t,e,n),a=L("kernelSize",t,e,n);return[r.avgPool(L("x",t,e,n),[a[1],a[2]],[i[1],i[2]],s)]}case"MaxPool":{let i=L("strides",t,e,n),s=L("pad",t,e,n),a=L("kernelSize",t,e,n);return[r.maxPool(L("x",t,e,n),[a[1],a[2]],[i[1],i[2]],s)]}case"MaxPoolWithArgmax":{let i=L("strides",t,e,n),s=L("pad",t,e,n),a=L("kernelSize",t,e,n),o=L("includeBatchInIndex",t,e,n),{result:l,indexes:u}=r.maxPoolWithArgmax(L("x",t,e,n),[a[1],a[2]],[i[1],i[2]],s,o);return[l,u]}case"AvgPool3D":{let i=L("strides",t,e,n),s=L("pad",t,e,n),a=L("kernelSize",t,e,n);return[r.avgPool3d(L("x",t,e,n),[a[1],a[2],a[3]],[i[1],i[2],i[3]],s)]}case"MaxPool3D":{let i=L("strides",t,e,n),s=L("pad",t,e,n),a=L("kernelSize",t,e,n);return[r.maxPool3d(L("x",t,e,n),[a[1],a[2],a[3]],[i[1],i[2],i[3]],s)]}case"Dilation2D":{let i=L("strides",t,e,n),s=L("pad",t,e,n),a=L("dilations",t,e,n),o=i[1],l=i[2],u=a[1],c=a[2];return[r.dilation2d(L("x",t,e,n),L("filter",t,e,n),[o,l],s,[u,c],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}},XFe=(t,e,n,r=es)=>{switch(t.op){case"Fill":{let i=L("shape",t,e,n),s=L("dtype",t,e,n),a=L("value",t,e,n);return[r.fill(i,a,s)]}case"LinSpace":{let i=L("start",t,e,n),s=L("stop",t,e,n),a=L("num",t,e,n);return[r.linspace(i,s,a)]}case"Multinomial":{let i=L("logits",t,e,n),s=L("numSamples",t,e,n),a=L("seed",t,e,n);return[r.multinomial(i,s,a)]}case"OneHot":{let i=L("indices",t,e,n),s=L("depth",t,e,n),a=L("onValue",t,e,n),o=L("offValue",t,e,n),l=L("dtype",t,e,n);return[r.oneHot(i,s,a,o,l)]}case"Ones":return[r.ones(L("shape",t,e,n),L("dtype",t,e,n))];case"OnesLike":return[r.onesLike(L("x",t,e,n))];case"RandomStandardNormal":return[r.randomStandardNormal(L("shape",t,e,n),L("dtype",t,e,n),L("seed",t,e,n))];case"RandomUniform":return[r.randomUniform(L("shape",t,e,n),L("minval",t,e,n),L("maxval",t,e,n),L("dtype",t,e,n))];case"RandomUniformInt":return[r.randomUniformInt(L("shape",t,e,n),L("minval",t,e,n),L("maxval",t,e,n),L("seed",t,e,n))];case"Range":{let i=L("start",t,e,n),s=L("stop",t,e,n),a=L("step",t,e,n);return[r.range(i,s,a,L("dtype",t,e,n))]}case"TruncatedNormal":{let i=L("shape",t,e,n),s=L("mean",t,e,n),a=L("stdDev",t,e,n),o=L("seed",t,e,n);return[r.truncatedNormal(i,s,a,L("dtype",t,e,n),o)]}case"Zeros":return[r.zeros(L("shape",t,e,n),L("dtype",t,e,n))];case"ZerosLike":return[r.zerosLike(L("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function MN(t,e,n){let r=L("boxes",t,e,n),i=L("scores",t,e,n),s=L("maxOutputSize",t,e,n),a=L("iouThreshold",t,e,n),o=L("scoreThreshold",t,e,n),l=L("softNmsSigma",t,e,n);return{boxes:r,scores:i,maxOutputSize:s,iouThreshold:a,scoreThreshold:o,softNmsSigma:l}}var KFe=async(t,e,n,r,i=es)=>{switch(t.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=MN(t,e,n),d=await i.image.nonMaxSuppressionWithScoreAsync(s,a,o,l,u,c);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=MN(t,e,n),c=L("padToMaxOutputSize",t,e,n),d=await i.image.nonMaxSuppressionPaddedAsync(s,a,o,l,u,c);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=MN(t,e,n);return[await i.image.nonMaxSuppressionAsync(s,a,o,l,u)]}case"Where":{let s=i.cast(L("condition",t,e,n),"bool"),a=[await i.whereAsync(s)];return s.dispose(),a}case"ListDiff":return i.setdiff1dAsync(L("x",t,e,n),L("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}},qFe=(t,e,n,r=es)=>{switch(t.op){case"LowerBound":{let i=L("sortedSequence",t,e,n),s=L("values",t,e,n);return[r.lowerBound(i,s)]}case"TopKV2":{let i=L("x",t,e,n),s=L("k",t,e,n),a=L("sorted",t,e,n),o=r.topk(i,s,a);return[o.values,o.indices]}case"UpperBound":{let i=L("sortedSequence",t,e,n),s=L("values",t,e,n);return[r.upperBound(i,s)]}case"Unique":{let i=L("x",t,e,n),s=r.unique(i);return[s.values,s.indices]}case"UniqueV2":{let i=L("x",t,e,n),s=L("axis",t,e,n),a=r.unique(i,s);return[a.values,a.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}},JFe=(t,e,n,r=es)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":let i=L("default",t,e,n);return[os(t.name,e,n)||i];case"Placeholder":return[os(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let c=L("x",t,e,n);return[zu(c)]}case"IdentityN":return L("x",t,e,n).map(c=>zu(c));case"Snapshot":let s=L("x",t,e,n);return[zu(s)];case"Shape":return[r.tensor1d(L("x",t,e,n).shape,"int32")];case"ShapeN":return L("x",t,e,n).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(L("x",t,e,n).size,"int32")];case"Rank":return[r.scalar(L("x",t,e,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let a=L("x",t,e,n),o=L("data",t,e,n),l=L("message",t,e,n),u=L("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<o.length;c++)console.log(Array.prototype.slice.call(o[c].dataSync()).slice(0,u));return[a];default:throw TypeError(`Node type ${t.op} is not implemented`)}},YFe=class{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=rn(0),this.tensorMap=new Map,Ci(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return rn(this.size(),"int32")}async import(t,e){this.checkKeyAndValueTensor(t,e);let n=await t.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),xe(()=>{let r=ii(e),i=n.length,s=r.length;P.assert(i===s,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${s} elements.`);for(let a=0;a<i;a++){let o=n[a],l=r[a];Ci(l),this.tensorMap.set(o,l)}return this.handle})}async find(t,e){this.checkKeyAndValueTensor(t,e);let n=await t.data();return xe(()=>{let r=[];for(let i=0;i<n.length;i++){let s=n[i],a=this.findWithDefault(s,e);r.push(a)}return xi(r)})}findWithDefault(t,e){let n=this.tensorMap.get(t);return n??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}},ZFe=async(t,e,n,r)=>{switch(t.op){case"HashTable":case"HashTableV2":{let i=r.getHashTableHandleByName(t.name);if(i!=null)return[i];{let s=L("keyDType",t,e,n),a=L("valueDType",t,e,n),o=new YFe(s,a);return r.addHashTable(t.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let i=L("tableHandle",t,e,n,r),s=L("keys",t,e,n),a=L("values",t,e,n);return[await r.getHashTableById(i.id).import(s,a)]}case"LookupTableFind":case"LookupTableFindV2":{let i=L("tableHandle",t,e,n,r),s=L("keys",t,e,n),a=L("defaultValue",t,e,n);return[await r.getHashTableById(i.id).find(s,a)]}case"LookupTableSize":case"LookupTableSizeV2":{let i=L("tableHandle",t,e,n,r);return[r.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}},QFe=(t,e,n,r=es)=>{switch(t.op){case"ResizeBilinear":{let i=L("images",t,e,n),s=L("size",t,e,n),a=L("alignCorners",t,e,n),o=L("halfPixelCenters",t,e,n);return[r.image.resizeBilinear(i,[s[0],s[1]],a,o)]}case"ResizeNearestNeighbor":{let i=L("images",t,e,n),s=L("size",t,e,n),a=L("alignCorners",t,e,n),o=L("halfPixelCenters",t,e,n);return[r.image.resizeNearestNeighbor(i,[s[0],s[1]],a,o)]}case"CropAndResize":{let i=L("image",t,e,n),s=L("boxes",t,e,n),a=L("boxInd",t,e,n),o=L("cropSize",t,e,n),l=L("method",t,e,n),u=L("extrapolationValue",t,e,n);return[r.image.cropAndResize(i,s,a,o,l,u)]}case"ImageProjectiveTransformV3":{let i=L("images",t,e,n),s=L("transforms",t,e,n),a=L("outputShape",t,e,n),o=L("fillValue",t,e,n),l=L("interpolation",t,e,n),u=L("fillMode",t,e,n);return[r.image.transform(i,s,l.toLowerCase(),u.toLowerCase(),o,a)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}},eDe=(t,e,n,r=es)=>{switch(t.op){case"Equal":return[r.equal(L("a",t,e,n),L("b",t,e,n))];case"NotEqual":return[r.notEqual(L("a",t,e,n),L("b",t,e,n))];case"Greater":return[r.greater(L("a",t,e,n),L("b",t,e,n))];case"GreaterEqual":return[r.greaterEqual(L("a",t,e,n),L("b",t,e,n))];case"Less":return[r.less(L("a",t,e,n),L("b",t,e,n))];case"LessEqual":return[r.lessEqual(L("a",t,e,n),L("b",t,e,n))];case"LogicalAnd":return[r.logicalAnd(L("a",t,e,n),L("b",t,e,n))];case"LogicalNot":return[r.logicalNot(L("a",t,e,n))];case"LogicalOr":return[r.logicalOr(L("a",t,e,n),L("b",t,e,n))];case"Select":case"SelectV2":return[r.where(L("condition",t,e,n),L("a",t,e,n),L("b",t,e,n))];case"BitwiseAnd":return[r.bitwiseAnd(L("a",t,e,n),L("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}},tDe=(t,e,n,r=es)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(L("a",t,e,n),L("b",t,e,n),L("transposeA",t,e,n),L("transposeB",t,e,n))];case"Einsum":return[r.einsum(L("equation",t,e,n),...L("tensors",t,e,n))];case"Transpose":return[r.transpose(L("x",t,e,n),L("perm",t,e,n))];case"_FusedMatMul":let[i,s]=L("fusedOps",t,e,n),a=i==="biasadd",o=s==="prelu",l=L("numArgs",t,e,n),u=L("leakyreluAlpha",t,e,n);if(a){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,d]=L("args",t,e,n);return[r.fused.matMul({a:L("a",t,e,n),b:L("b",t,e,n),transposeA:L("transposeA",t,e,n),transposeB:L("transposeB",t,e,n),bias:c,activation:s,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(L("a",t,e,n),L("numLower",t,e,n),L("numUpper",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}},nDe=(t,e,n,r=es)=>{switch(t.op){case"EuclideanNorm":return[r.euclideanNorm(L("x",t,e,n),L("axis",t,e,n),L("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(L("x",t,e,n),L("mean",t,e,n),L("variance",t,e,n),L("offset",t,e,n),L("scale",t,e,n),L("epsilon",t,e,n))];case"FusedBatchNormV3":return[r.batchNorm(L("x",t,e,n),L("mean",t,e,n),L("variance",t,e,n),L("offset",t,e,n),L("scale",t,e,n),L("epsilon",t,e,n))];case"LRN":return[r.localResponseNormalization(L("x",t,e,n),L("radius",t,e,n),L("bias",t,e,n),L("alpha",t,e,n),L("beta",t,e,n))];case"Softmax":return[r.softmax(L("x",t,e,n))];case"LogSoftmax":return[r.logSoftmax(L("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}},rDe=(t,e,n,r=es)=>{switch(t.op){case"RaggedGather":{let{outputNestedSplits:i,outputDenseValues:s}=r.raggedGather(L("paramsNestedSplits",t,e,n),L("paramsDenseValues",t,e,n),L("indices",t,e,n),L("outputRaggedRank",t,e,n));return i.concat(s)}case"RaggedRange":{let{rtNestedSplits:i,rtDenseValues:s}=r.raggedRange(L("starts",t,e,n),L("limits",t,e,n),L("splits",t,e,n));return[i,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(L("shape",t,e,n),L("values",t,e,n),L("defaultValue",t,e,n),L("rowPartitionTensors",t,e,n),L("rowPartitionTypes",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}},iDe=(t,e,n,r=es)=>{switch(t.op){case"Max":{let o=L("axis",t,e,n),l=L("keepDims",t,e,n);return[r.max(L("x",t,e,n),o,l)]}case"Mean":{let o=L("axis",t,e,n),l=L("keepDims",t,e,n);return[r.mean(L("x",t,e,n),o,l)]}case"Min":{let o=L("axis",t,e,n),l=L("keepDims",t,e,n);return[r.min(L("x",t,e,n),o,l)]}case"Sum":{let o=L("axis",t,e,n),l=L("keepDims",t,e,n);return[r.sum(L("x",t,e,n),o,l)]}case"All":{let o=L("axis",t,e,n),l=L("keepDims",t,e,n);return[r.all(L("x",t,e,n),o,l)]}case"Any":{let o=L("axis",t,e,n),l=L("keepDims",t,e,n);return[r.any(L("x",t,e,n),o,l)]}case"ArgMax":{let o=L("axis",t,e,n);return[r.argMax(L("x",t,e,n),o)]}case"ArgMin":{let o=L("axis",t,e,n);return[r.argMin(L("x",t,e,n),o)]}case"Prod":{let o=L("axis",t,e,n),l=L("keepDims",t,e,n);return[r.prod(L("x",t,e,n),o,l)]}case"Cumprod":{let o=L("axis",t,e,n),l=L("exclusive",t,e,n),u=L("reverse",t,e,n);return[r.cumprod(L("x",t,e,n),o,l,u)]}case"Cumsum":{let o=L("axis",t,e,n),l=L("exclusive",t,e,n),u=L("reverse",t,e,n);return[r.cumsum(L("x",t,e,n),o,l,u)]}case"Bincount":let i=L("x",t,e,n),s=L("weights",t,e,n),a=L("size",t,e,n);return[r.bincount(i,s,a)];case"DenseBincount":{let o=L("x",t,e,n),l=L("weights",t,e,n),u=L("size",t,e,n),c=L("binaryOutput",t,e,n);return[r.denseBincount(o,l,u,c)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}},sDe=(t,e,n,r=es)=>{switch(t.op){case"ConcatV2":case"Concat":{let i=L("n",t,e,n),s=L("axis",t,e,n),a=L("tensors",t,e,n);return a=a.slice(0,i),[r.concat(a,s)]}case"Gather":{let i=L("x",t,e,n),s=L("indices",t,e,n);return[r.gather(i,r.cast(s,"int32"),0)]}case"GatherV2":{let i=L("axis",t,e,n),s=L("batchDims",t,e,n),a=L("x",t,e,n),o=L("indices",t,e,n);return[r.gather(a,r.cast(o,"int32"),i,s)]}case"Reverse":{let i=L("dims",t,e,n),s=[];for(let o=0;o<i.length;o++)i[o]&&s.push(o);let a=L("x",t,e,n);return[r.reverse(a,s)]}case"ReverseV2":{let i=L("axis",t,e,n),s=L("x",t,e,n);return[r.reverse(s,i)]}case"Slice":{let i=L("begin",t,e,n),s=L("size",t,e,n);return[r.slice(L("x",t,e,n),i,s)]}case"StridedSlice":{let i=L("begin",t,e,n),s=L("end",t,e,n),a=L("strides",t,e,n),o=L("beginMask",t,e,n),l=L("endMask",t,e,n),u=L("ellipsisMask",t,e,n),c=L("newAxisMask",t,e,n),d=L("shrinkAxisMask",t,e,n),h=L("x",t,e,n);return[r.stridedSlice(h,i,s,a,o,l,u,c,d)]}case"Pack":return xe(()=>{let i=L("axis",t,e,n),s=L("tensors",t,e,n),a=s[0].shape,o=r.squeeze(s[0]).shape,l=s.map(u=>{let c=P.arraysEqual(u.shape,a);if(!c&&!P.arraysEqual(r.squeeze(u).shape,o))throw new Error("the input tensors shape does not match");return c?u:r.reshape(u,a)});return[r.stack(l,i)]});case"Unpack":{let i=L("axis",t,e,n),s=L("tensor",t,e,n);return r.unstack(s,i)}case"Tile":{let i=L("reps",t,e,n);return[r.tile(L("x",t,e,n),i)]}case"Split":case"SplitV":{let i=L("axis",t,e,n),s=L("numOrSizeSplits",t,e,n),a=L("x",t,e,n);return r.split(a,s,i)}case"ScatterNd":{let i=L("indices",t,e,n),s=L("values",t,e,n),a=L("shape",t,e,n);return[r.scatterND(i,s,a)]}case"GatherNd":{let i=L("x",t,e,n),s=L("indices",t,e,n);return[r.gatherND(i,s)]}case"SparseToDense":{let i=L("sparseIndices",t,e,n),s=L("outputShape",t,e,n),a=L("sparseValues",t,e,n),o=L("defaultValue",t,e,n);return[r.sparseToDense(i,a,s,a.dtype===o.dtype?o:r.cast(o,a.dtype))]}case"TensorScatterUpdate":{let i=L("indices",t,e,n),s=L("values",t,e,n),a=L("tensor",t,e,n);return[r.tensorScatterUpdate(a,i,s)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}},aDe=(t,e,n,r=es)=>{switch(t.op){case"SparseFillEmptyRows":{let{outputIndices:i,outputValues:s,emptyRowIndicator:a,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(L("indices",t,e,n),L("values",t,e,n),L("denseShape",t,e,n),L("defaultValue",t,e,n));return[i,s,a,o]}case"SparseReshape":{let{outputIndices:i,outputShape:s}=r.sparse.sparseReshape(L("inputIndices",t,e,n),L("inputShape",t,e,n),L("newShape",t,e,n));return[i,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(L("data",t,e,n),L("indices",t,e,n),L("segmentIds",t,e,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(L("data",t,e,n),L("indices",t,e,n),L("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}},oDe=(t,e,n,r=es)=>{switch(t.op){case"FFT":return[r.fft(L("x",t,e,n))];case"IFFT":return[r.ifft(L("x",t,e,n))];case"RFFT":return[r.rfft(L("x",t,e,n))];case"IRFFT":return[r.irfft(L("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}},lDe=(t,e,n,r=es)=>{switch(t.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(L("input",t,e,n),L("pattern",t,e,n),L("rewrite",t,e,n),L("replaceGlobal",t,e,n))];case"StringNGrams":{let{nGrams:i,nGramsSplits:s}=r.string.stringNGrams(L("data",t,e,n),L("dataSplits",t,e,n),L("separator",t,e,n),L("nGramWidths",t,e,n),L("leftPad",t,e,n),L("rightPad",t,e,n),L("padWidth",t,e,n),L("preserveShortSequences",t,e,n));return[i,s]}case"StringSplit":{let{indices:i,values:s,shape:a}=r.string.stringSplit(L("input",t,e,n),L("delimiter",t,e,n),L("skipEmpty",t,e,n));return[i,s,a]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(L("input",t,e,n),L("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}},uDe=(t,e,n,r=es)=>{switch(t.op){case"Cast":return[r.cast(L("x",t,e,n),L("dtype",t,e,n))];case"ExpandDims":{let i=L("axis",t,e,n);return[r.expandDims(L("x",t,e,n),i)]}case"Squeeze":{let i=L("axis",t,e,n);return[r.squeeze(L("x",t,e,n),i)]}case"Reshape":return[r.reshape(L("x",t,e,n),L("shape",t,e,n))];case"EnsureShape":return[r.ensureShape(L("x",t,e,n),L("shape",t,e,n))];case"MirrorPad":return[r.mirrorPad(L("x",t,e,n),L("padding",t,e,n),L("mode",t,e,n))];case"PadV2":case"Pad":return[r.pad(L("x",t,e,n),L("padding",t,e,n),L("constantValue",t,e,n))];case"SpaceToBatchND":{let i=L("blockShape",t,e,n),s=L("paddings",t,e,n);return[r.spaceToBatchND(L("x",t,e,n),i,s)]}case"BatchToSpaceND":{let i=L("blockShape",t,e,n),s=L("crops",t,e,n);return[r.batchToSpaceND(L("x",t,e,n),i,s)]}case"DepthToSpace":{let i=L("blockSize",t,e,n),s=L("dataFormat",t,e,n).toUpperCase();return[r.depthToSpace(L("x",t,e,n),i,s)]}case"BroadcastTo":return[r.broadcastTo(L("x",t,e,n),L("shape",t,e,n))];case"BroadcastArgs":return[r.broadcastArgs(L("s0",t,e,n),L("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function UV(t,e,n,r,i=xe){let s=((a,o,l)=>{switch(a.category){case"arithmetic":return i(()=>BFe(a,o,l));case"basic_math":return i(()=>UFe(a,o,l));case"control":return VFe(a,o,l);case"convolution":return i(()=>jFe(a,o,l));case"creation":return i(()=>XFe(a,o,l));case"dynamic":return KFe(a,o,l);case"evaluation":return i(()=>qFe(a,o,l));case"image":return i(()=>QFe(a,o,l));case"graph":return i(()=>JFe(a,o,l));case"logical":return i(()=>eDe(a,o,l));case"matrices":return i(()=>tDe(a,o,l));case"normalization":return i(()=>nDe(a,o,l));case"ragged":return i(()=>rDe(a,o,l));case"reduction":return i(()=>iDe(a,o,l));case"slice_join":return i(()=>sDe(a,o,l));case"sparse":return i(()=>aDe(a,o,l));case"spectral":return i(()=>oDe(a,o,l));case"string":return i(()=>lDe(a,o,l));case"transformation":return i(()=>uDe(a,o,l));case"hash_table":return ZFe(a,o,l,r);case"custom":let u=pY(a.op);if(u&&u.customExecutor)return u.customExecutor(new OFe(a,o,l));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return P.isPromise(s)?s.then(a=>[].concat(a)):[].concat(s)}var $V=class{constructor(t={},e={},n={},r={},i){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let t=[];for(let e=0;e<this.contexts.length-1;e++){let n=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(n))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(let e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(let e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}};function zV(t,e,n,r){let i=new Set,s=[],a=null,o=null,l=new Set,u=new Set(Object.keys(t).map(h=>Aa(h)[0]));r=r||[];let c=new Set(r.map(h=>Aa(h.name)[0])),d=[...e];for(;d.length>0;){let h=d.pop();if((ap(h)||yDe(h)||vDe(h))&&a==null&&(a=h,o=a.children.map(p=>p.name).filter(p=>i.has(p))),i.add(h.name),n[h.name]==null&&!u.has(h.name)&&!c.has(h.name)){if(h.inputs.length===0){s.push(h.name);continue}h.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),d.push(p))})}}return{inputs:t,outputs:e,usedNodes:i,missingInputs:s,dynamicNode:a,syncInputs:o}}function cDe(t,e){let{usedNodes:n,inputs:r}=e,i=Object.keys(r).map(y=>Aa(y)[0]).map(y=>t.nodes[y]),s=t.initNodes||[],a=y=>n.has(typeof y=="string"?y:y.name);function o(y){return[...new Map(y.map(m=>[m.name,m])).values()]}let l=o([...i,...t.weights,...s]).filter(a),u=o([...l,...Object.values(t.nodes)]).filter(a),c=new Map(u.map(y=>[y.name,y])),d={};for(let y of u){d[y.name]=d[y.name]||0;for(let m of y.children)a(m)||(d[m.name]=Number.POSITIVE_INFINITY),d[m.name]=(d[m.name]||0)+1}let h=Object.entries(d).filter(([,y])=>y===0).map(([y])=>y),p=[...h];for(;h.length>0;){let y=h.pop(),m=c.get(y);for(let b of m.children.filter(a))--d[b.name]===0&&(p.push(b.name),h.push(b.name))}let f=p.map(y=>c.get(y)),g=dDe(f,l);return hDe(g,l),g}function dDe(t,e){let n=new Map(t.map(s=>[s.name,s])),r=e.map(s=>s.name),i=new Set(r);for(;r.length>0;){let s=r.pop(),a=n.get(s);for(let o of a.children)!n.has(o.name)||i.has(o.name)||(i.add(o.name),r.push(o.name))}return t.filter(s=>i.has(s.name))}var SA=class extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}};function hDe(t,e){let n=new Map(t.map((o,l)=>[o.name,l])),r=new Set(e.map(o=>o.name)),i=o=>r.has(typeof o=="string"?o:o.name),s=new Set(t.map(o=>o.name)),a=o=>s.has(typeof o=="string"?o:o.name);for(let o of t){for(let l of o.children.filter(a)){if(!n.has(l.name))throw new SA(`Child ${l.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(l.name))throw new SA(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!i(o))for(let l of o.inputs){if(!n.has(l.name))throw new SA(`Input ${l.name} of node ${o.name} is unreachable.`);if(n.get(l.name)>n.get(o.name))throw new SA(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function pDe(t){let e=new Map(t.map((o,l)=>[o.name,l])),n=Number.MAX_SAFE_INTEGER,r=t.map((o,l)=>ap(o)?n:l),i=o=>{let l=r[e.get(o.name)];return l??-1},s=t.map((o,l)=>o.children.map(i).reduce((u,c)=>Math.max(u,c),r[l])),a=new Map;for(let o=0;o<t.length;++o){let l=s[o];if(l===n)continue;let u=t[o],c=t[l];a.has(c.name)||a.set(c.name,[]),a.get(c.name).push(u)}return a}var fDe=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),mDe=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),gDe=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function ap(t){return fDe.has(t.op)}function yDe(t){return mDe.has(t.op)}function vDe(t){return gDe.has(t.op)}var GV=class PY{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let n=Object.keys(e).map(r=>e[r].map(i=>i.id));this._weightIds=[].concat(...n),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let n=e.signatureKey||e.name;return e.defaultOutput?`${n}:${e.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((e,n)=>(e[n]=this._functions[n].signature,e),{})}constructor(e,n){this.graph=e,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new PY(e.functions[r],this)})}getCompilationKey(e,n){let r=e.map(s=>s.name).sort(),i=n.map(s=>s.name).sort();return r.join(this.SEPARATOR)+"--"+i.join(this.SEPARATOR)}compile(e,n){let r=zV(e,n,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:s,syncInputs:a}=r;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(i.length>0){let u=n.map(d=>d.name),c=Object.keys(e);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${i}]`)}let o=cDe(this.graph,r),l=pDe(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;let n=e.clone();return Ci(n),n}cloneTensorList(e){return e?e.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([n,r])=>[n,this.cloneTensorList(r)]))}execute(e,n){this.disposeIntermediateTensors(),e=this.mapInputs(e);let r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n);let i=r.map(h=>this.graph.nodes[Aa(h)[0]]),s=n.map(h=>Aa(h)[0]),a=new Set(s),o=s.map(h=>this.graph.nodes[h]);o.length===0&&(o=this._outputs);let l=this.getCompilationKey(i,o),u=this.compiledMap.get(l);u==null&&(u=this.compile(e,o),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=Ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}let c={},d={};return xe(()=>{let h=new $V(this.weightMap,c,d,this.functionExecutorMap,this.parseNodeNameCache),p=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(m=>{let[b,w]=Aa(m,h),_=[];_[w]=e[m],p[b]=_,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(_))});let f=this.getFrozenTensorIds(p),{orderedNodes:g,nodeLiveUntilMap:y}=u;for(let m of g){if(p[m.name])continue;let b=UV(m,p,h,this._resourceManager);if(P.isPromise(b))throw new Error(`The execution of the op '${m.op}' returned a promise. Please use model.executeAsync() instead.`);p[m.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[m.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(m,p,h,f,a,y.get(m.name))}return this.parent==null&&h.dispose(f),n.map(m=>os(m,p,h))})}getFrozenTensorIds(e){let n=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(i=>i.id)));return new Set(n)}checkTensorForDisposal(e,n,r,i,s,a,o){if(!(ap(n)||a.has(e))){for(let l of r[e])l!=null&&(o[l.id]=(o[l.id]||0)+n.children.length);for(let l of n.inputs){if(ap(l))continue;let u=DV(l.name,r,i);if(u!=null)for(let c of u){if(!c||c.kept||s.has(c.id))continue;let d=o[c.id];d===1?(c.dispose(),delete o[c.id]):d!=null&&o[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,n,r,i,s,a){function o(l){return ap(l)||s.has(l.name)}if(!(ap(e)||a==null))for(let l of a){if(o(l))continue;let u=DV(l.name,n,r);for(let c of u)!c||c.kept||i.has(c.id)||c.dispose()}}async executeAsync(e,n){return this._executeAsync(e,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(let n of e)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,n,r=!1,i={},s={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=Ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}let a=new $V(this.weightMap,i,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(e,a,n,r),l=n.map(h=>os(h,o,a)),u=l.map(h=>h.id),c=Object.keys(e).map(h=>e[h].id),d=new Set([...u,...c,...this.weightIds]);return Object.values(o).forEach(h=>{h.forEach(p=>{p&&!p.isDisposed&&!d.has(p.id)&&p.dispose()})}),this.parent==null&&a.dispose(d),l}async executeFunctionAsync(e,n,r){let i=e.reduce((s,a,o)=>(s[this.inputs[o].name]=a,s),{});return this._executeAsync(i,this.outputNodes,!0,n,r)}async executeWithControlFlow(e,n,r,i){let s=Object.keys(e),a=s.map(_=>this.graph.nodes[Aa(_)[0]]),o=r.map(_=>Aa(_)[0]),l=new Set(o),u=o.map(_=>this.graph.nodes[_]);u.length===0&&(u=this._outputs);let{usedNodes:c,missingInputs:d,dynamicNode:h,syncInputs:p}=zV(e,u,this.weightMap,this._initNodes),f=[...a,...this.graph.weights,...this._initNodes||[]].map(_=>({node:_,contexts:n.currentContext})),g=Object.assign({},this.weightMap);Object.keys(e).forEach(_=>{let[S,E]=Aa(_),C=[];C[E]=e[_],g[S]=C});let y={},m=this.getFrozenTensorIds(g),b={};for(;f.length>0;){let _=this.processStack(a,f,n,g,b,m,l,y,c);await Promise.all(_)}h==null&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let w=u.filter(_=>!ap(_)&&!os(_.name,g,n)).map(_=>_.name);if(w.length>0){let _="";throw h!=null&&(_=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${w}] from the provided inputs [${s}]. Consider providing the following inputs: [${d}]. ${_}`)}return g}processStack(e,n,r,i,s,a,o,l,u){let c=[];for(;n.length>0;){let d=n.pop();r.currentContext=d.contexts;let h="";if(d.node.op==="Enter"&&L("isConstant",d.node,i,r)&&([h]=$u(d.node.name,r)),i[d.node.name]==null){let p=UV(d.node,i,r,this._resourceManager);h||([h]=$u(d.node.name,r));let f=r.currentContext;P.isPromise(p)?c.push(p.then(g=>(i[h]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(g)),r.currentContext=f,this.checkTensorForDisposal(h,d.node,i,r,a,o,l),this.processChildNodes(d.node,n,r,i,s,u),g))):(i[h]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(p)),this.checkTensorForDisposal(h,d.node,i,r,a,o,l),this.processChildNodes(d.node,n,r,i,s,u))}else this.processChildNodes(d.node,n,r,i,s,u)}return c}processChildNodes(e,n,r,i,s,a){e.children.forEach(o=>{let[l]=$u(o.name,r);s[l]||!a.has(o.name)||(o.op==="Merge"?o.inputNames.some(u=>!!os(u,i,r))&&(s[l]=!0,n.push({contexts:r.currentContext,node:o})):o.inputNames.every(u=>!!os(u,i,r))&&(s[l]=!0,n.push({contexts:r.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(n=>n.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(n=>{let r=e[n],[i]=Aa(n),s=this.graph.nodes[i];if(s.attrParams.shape&&s.attrParams.shape.value){let a=s.attrParams.shape.value,o=a.length===r.shape.length&&r.shape.every((l,u)=>a[u]===-1||a[u]===l);P.assert(o,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${a}], but was [${r.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&P.assert(r.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var n,r;let i={};for(let s in e){let a=(r=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||r===void 0?void 0:r[s];a!=null?i[a.name]=e[s]:i[s]=e[s]}return i}checkInputs(e){let n=Object.keys(e).filter(r=>{let[i]=Aa(r);return this.graph.nodes[i]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(e){return e.map(n=>{var r,i;let s=(i=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||i===void 0?void 0:i[n];return s!=null?s.name:n},{})}checkOutputs(e){e.forEach(n=>{let[r]=Aa(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}},xDe=class{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(let t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(let t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}},bDe="?tfjs-format=file",wDe="model.json",FB=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,e={},n=us){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=n,e==null&&(this.loadOptions={}),this.resourceManager=new xDe}findIOHandler(){let t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{let e=this.io.getLoadHandlers(t,this.loadOptions);if(e.length===0)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let t=this.handler.load();return P.isPromise(t)?t.then(e=>e.getWeightStream==null?this.loadSync(e):this.loadStreaming(e)):this.loadSync(t)}loadSync(t){let e=this.io.decodeWeights(t.weightData,t.weightSpecs);return this.loadWithWeightMap(t,e)}async loadStreaming(t){if(t.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let e=await B7(t.getWeightStream(),t.weightSpecs);return this.loadWithWeightMap(t,e)}loadWithWeightMap(t,e){this.artifacts=t;let n=this.artifacts.modelTopology,r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let i=this.artifacts.userDefinedMetadata;i.signature!=null&&(r=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new GV(PV.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(e),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){let i=PV.Instance.transformGraph(t.modelInitializer);this.initializer=new GV(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}async save(t,e){if(typeof t=="string"){let n=this.io.getSaveHandlers(t);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${t}'`);t=n[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}addStructuredOutputNames(t){if(this.structuredOutputKeys){let e=t instanceof In?[t]:t,n={};return e.forEach((r,i)=>n[this.structuredOutputKeys[i]]=r),n}return t}predict(t,e){let n=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(t,e){let n=await this.executeAsync(t,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(t){var e;if(!(t instanceof In)&&!Array.isArray(t)){let i=(e=this.signature)===null||e===void 0?void 0:e.inputs;if(i!=null)for(let s in i){let a=i[s];a.resourceId!=null&&(t[s]=this.resourceIdToCapturedInput[a.resourceId])}return t}t=Array.isArray(t)?t:[t];let n=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${t.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((i,s)=>{var a,o,l;let u=(l=(o=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||o===void 0?void 0:o[s])===null||l===void 0?void 0:l.resourceId;return u!=null?i[s]=this.resourceIdToCapturedInput[u]:i[s]=t[r++],i},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){let e=this.initializerSignature.outputs,n=Object.keys(e);for(let r=0;r<n.length;r++){let i=n[r],s=e[i];this.resourceIdToCapturedInput[s.resourceId]=t[r]}}}execute(t,e){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let n=this.executor.execute(t,e);return n.length>1?n:n[0]}async executeAsync(t,e){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let n=await this.executor.executeAsync(t,e);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,n)=>(e[n]=[t[n]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&bn(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function _De(t,e={},n=us){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof t=="string"&&(t=ADe(t));let r=new FB(t,e,n);return await r.load(),r}function SDe(t){if(t==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(t instanceof Array){let[r,i]=t;if(!r)throw new Error("modelJSON must be the first element of the array");if(!i||!(i instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");let s=us.getWeightSpecs(r.weightsManifest),a=us.getModelArtifactsForJSONSync(r,s,i);e=us.fromMemorySync(a)}else if("load"in t)e=t;else if("modelTopology"in t&&"weightSpecs"in t&&"weightData"in t)e=us.fromMemorySync(t);else throw new Error("Unknown model format");let n=new FB(e);return n.load(),n}function ADe(t){return t.endsWith("/")||(t=t+"/"),`${t}${wDe}${bDe}`}var EDe="4.22.0",LY={};wn(LY,{CSVDataset:()=>XY,Dataset:()=>Nv,FileDataSource:()=>eZ,TextLineDataset:()=>jY,URLDataSource:()=>tZ,array:()=>KDe,csv:()=>oPe,func:()=>lPe,generator:()=>uPe,microphone:()=>dPe,version_data:()=>hPe,webcam:()=>cPe,zip:()=>qDe});var IDe=eh(eC()),TDe=eh(eC());function CDe(t,e){return HI(t,e)}function HI(t,e,n=new Map,r=new Set){if(t==null)return null;if(typeof Blob=="function"&&t instanceof Blob)return t.slice();if(r.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);let i=e(t);if(i.recurse&&i.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(i.recurse)if(i0(t)){let s=Array.isArray(t)?[]:{};r.add(t);for(let a in t){let o=t[a],l=HI(o,e,n,r);s[a]=l}return r.delete(t),t.__proto__&&(s.__proto__=t.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${t}`);else return n.set(t,i.value),i.value}function MDe(t,e=BY){return OY(t,e)}function OY(t,e,n=new Set){let r=t[0];if(n.has(r))throw new Error("Circular references are not supported.");let i=e(t);if(i.recurse&&i.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(i.recurse)if(i0(r)){let s=Array.isArray(r)?[]:{};n.add(r);for(let a in r){let o=t.map(u=>u[a]),l=OY(o,e,n);s[a]=l}return n.delete(r),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return i.value}function BY(t){return t===null?null:i0(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}async function UY(t,e){let n=new Map;HI(t,e,n);for(let r of Array.from(n.keys())){let i=n.get(r);if(P.isPromise(i)){let s=await i;n.set(r,s)}}return HI(t,e,n)}function i0(t){let e=!1;if(Ie().get("IS_BROWSER"))e=t instanceof TextDecoder;else{let{StringDecoder:n}=i7();e=t instanceof n}return t!=null&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||typeof t=="object"&&!(t instanceof In)&&!(t instanceof Promise)&&!e)}function kDe(t){return t==null||NDe(t)||Array.isArray(t)||typeof t=="object"&&t instanceof In||P.isTypedArray(t)}function NDe(t){return t===null||typeof t!="object"&&typeof t!="function"}function RDe(t){return CDe(t,FDe)}function FDe(t){return t instanceof In?{value:t.clone(),recurse:!1}:i0(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}var $Y=class{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,t==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(let e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}},zY=class GY extends $Y{constructor(){super(GY.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=this.capacity*2,n=new Array(e),r=this.length();for(let i=0;i<r;i++)n[i]=this.get(this.wrap(this.begin+i));this.data=n,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}};zY.INITIAL_CAPACITY=32;function HY(t){return new LDe(t)}function DB(t){return new ODe(t)}function DDe(t,e){return new WY(t,e)}function PDe(t,e=dd.FAIL){return new jDe(t,e)}var Qi=class{async toArray(){let t=[],e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){let t=this.prefetch(100),e=[],n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new WDe(this,t)}filter(t){return new GDe(this,t)}map(t){return new HDe(this,t)}mapAsync(t){return new HV(this,t)}serialMapAsync(t){return new HV(this,t).serial()}flatmap(t){return new VDe(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(e=>e===!0)}rowMajorBatch(t,e=!0){return new zDe(this,t,e)}columnMajorBatch(t,e=!0,n=BY){return this.rowMajorBatch(t,e).map(r=>MDe(r,n))}concatenate(t,e){return new WY(HY([this,t]),e)}take(t){return t<0||t==null?this:new $De(this,t)}skip(t){return t<0||t==null?this:new UDe(this,t)}prefetch(t){return new VY(this,t)}shuffle(t,e){return new XDe(this,t,e)}serial(){return new BDe(this)}},LDe=class extends Qi{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let t=this.items[this.trav];return this.trav++,{value:RDe(t),done:!1}}},ODe=class extends Qi{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}},BDe=class extends Qi{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},UDe=class extends Qi{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let t=await this.upstream.next();if(t.done)return t;bn(t.value)}return this.upstream.next()}},$De=class extends Qi{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},zDe=class extends Qi{constructor(t,e,n=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let t=[];for(;t.length<this.batchSize;){let e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}},GDe=class extends Qi{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;bn(t.value)}}},HDe=class extends Qi{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let e=vl.getTensorsInContainer(t.value),n=this.transform(t.value),r=vl.getTensorsInContainer(n);for(let i of e)vl.isTensorInList(i,r)||i.dispose();return{value:n,done:!1}}},WDe=class extends Qi{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}},HV=class extends Qi{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let e=vl.getTensorsInContainer(t.value),n=await this.transform(t.value),r=vl.getTensorsInContainer(n);for(let i of e)vl.isTensorInList(i,r)||i.dispose();return{value:n,done:!1}}},PB=class extends Qi{constructor(){super(),this.outputQueue=new zY,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},VDe=class extends PB{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let t=await this.upstream.next();if(t.done)return!1;let e=vl.getTensorsInContainer(t.value),n=this.transform(t.value),r=vl.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let i of e)vl.isTensorInList(i,r)||i.dispose();return!0}},WY=class extends Qi{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}},dd;(function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"})(dd||(dd={}));var jDe=class extends Qi{constructor(t,e=dd.FAIL){super(),this.iterators=t,this.mismatchMode=e,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(t){await t;let e=0,n=0;function r(s){return s instanceof Qi?{value:s.next().then(a=>(e++,a.done&&n++,a.value)),recurse:!1}:{value:null,recurse:!0}}let i=await UY(this.iterators,r);if(e===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case dd.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case dd.SHORTEST:return{value:null,done:!0};case dd.LONGEST:}return this.count++,{value:i,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},VY=class extends Qi{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new $Y(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}},XDe=class extends VY{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=TDe.alea(n||P.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(e.done)this.upstreamExhausted=!0;else return this.refill(),e}return{value:null,done:!0}}},Nv=class{constructor(){this.size=null}batch(t,e=!0){let n=this;P.assert(t>0,()=>`batchSize needs to be positive, but it is
      ${t}`);let r;return this.size===1/0||this.size==null?r=this.size:e?r=Math.ceil(this.size/t):r=Math.floor(this.size/t),Sa(async()=>(await n.iterator()).columnMajorBatch(t,e,JDe),r)}concatenate(t){let e=this,n;return this.size===1/0||t.size===1/0?n=1/0:this.size!=null&&t.size!=null?n=this.size+t.size:n=null,Sa(async()=>(await e.iterator()).concatenate(await t.iterator()),n)}filter(t){let e=this,n;return this.size===1/0?n=1/0:n=null,Sa(async()=>(await e.iterator()).filter(r=>xe(()=>t(r))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){let e=this;return Sa(async()=>(await e.iterator()).map(n=>xe(()=>t(n))),this.size)}mapAsync(t){let e=this;return Sa(async()=>(await e.iterator()).mapAsync(t),this.size)}prefetch(t){if(t==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let e=this;return Sa(async()=>(await e.iterator()).prefetch(t),this.size)}repeat(t){let e=this,n;return this.size!=null&&t>0?n=this.size*t:t===0?n=0:this.size!=null&&(t===void 0||t<0)?n=1/0:n=null,Sa(async()=>{let r=DB(async()=>({value:await e.iterator(),done:!1}));return DDe(r.take(t))},n)}skip(t){let e=this,n;return this.size!=null&&t>=0&&this.size>=t?n=this.size-t:this.size!=null&&(this.size<t||t===void 0||t<0)?n=0:n=null,Sa(async()=>(await e.iterator()).skip(t),n)}shuffle(t,e,n=!0){if(t==null||t<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,i=IDe.alea(e||P.now().toString());return Sa(async()=>{let s=i.int32();return n&&(s+=i.int32()),(await r.iterator()).shuffle(t,s.toString())},this.size)}take(t){let e=this,n;return this.size!=null&&this.size>t?n=t:this.size!=null&&this.size<=t?n=this.size:n=null,Sa(async()=>(await e.iterator()).take(t),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};Nv.MAX_BUFFER_SIZE=1e4;function Sa(t,e=null){return new class extends Nv{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function KDe(t){return Sa(async()=>HY(t),t.length)}function qDe(t){if(!i0(t))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(t))for(let n=0;n<t.length;n++)e=e==null?t[n].size:Math.min(e,t[n].size);else if(t instanceof Object)for(let n in t)e=e==null?t[n].size:Math.min(e,t[n].size);return Sa(async()=>{let n=await UY(t,r=>{if(r instanceof Nv)return{value:r.iterator(),recurse:!1};if(i0(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return PDe(n,dd.SHORTEST)},e)}function JDe(t){if(t===null)return null;let e=t[0];return kDe(e)?{value:YDe(t),recurse:!1}:{value:null,recurse:!0}}function YDe(t){if(t.length===0)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof In?xi(t):Us(t)}var jY=class extends Nv{constructor(t){super(),this.input=t}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(t=>(t.endsWith("\r")&&(t=t.slice(0,-1)),t))}},AA='"',Hx=Symbol("out"),WV=Symbol("field"),EA=Symbol("quote"),kN=Symbol("quoteafterquote"),VV=Symbol("quoteinquote"),XY=class extends Nv{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let t=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!t)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&t&&P.assert(t.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+t.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=t);let e=this.fullColumnNames.reduce((r,i)=>(r[i]=r[i]+1||1,r),{}),n=Object.keys(e).filter(r=>e[r]>1);if(P.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let t=await(await this.base.iterator()).next();if(t.done)throw new Error("No data was found for CSV parsing.");let e=t.value;return this.parseRow(e,!1)}else return null}constructor(t,e){super(),this.input=t,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new jY(t),e||(e={}),this.hasHeader=e.hasHeader!==!1,this.fullColumnNames=e.columnNames,this.columnConfigs=e.columnConfigs,this.configuredColumnsOnly=e.configuredColumnsOnly,e.delimWhitespace?(P.assert(e.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=e.delimiter?e.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let t=await this.base.iterator();return this.hasHeader&&(t=t.skip(1)),t.map(e=>this.makeDataElement(e))}makeDataElement(t){let e=this.parseRow(t),n={},r={};for(let i=0;i<this.fullColumnNames.length;i++){let s=this.fullColumnNames[i],a=this.columnConfigs?this.columnConfigs[s]:null;if(!(this.configuredColumnsOnly&&!a)){let o=e[i],l=null;if(o==="")if(a&&a.default!==void 0)l=a.default;else{if(a&&(a.required||a.isLabel))throw new Error(`Required column ${s} is empty in this line: ${t}`);l=void 0}else{let u=Number(o);if(isNaN(u))a&&a.dtype==="bool"?l=this.getBoolean(o):l=o;else if(!a||!a.dtype)l=u;else switch(a.dtype){case"float32":l=u;break;case"int32":l=Math.floor(u);break;case"bool":l=this.getBoolean(o);break;default:l=u}}a&&a.isLabel?r[s]=l:n[s]=l}}return Object.keys(r).length===0?n:{xs:n,ys:r}}getBoolean(t){return t==="1"||t.toLowerCase()==="true"?1:0}parseRow(t,e=!0){let n=[],r=0,i=t.length,s=Hx;for(let a=0;a<i;a++)switch(s){case Hx:switch(t.charAt(a)){case AA:r=a+1,s=EA;break;case this.delimiter:if(r=a+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),s=Hx;break;default:s=WV,r=a;break}break;case WV:switch(t.charAt(a)){case this.delimiter:n.push(t.substring(r,a)),s=Hx,r=a+1;break}break;case EA:switch(t.charAt(a)){case AA:s=kN;break}break;case kN:switch(t.charAt(a)){case this.delimiter:n.push(t.substring(r,a-1)),s=Hx,r=a+1;break;case AA:s=EA;break;default:s=VV;break}break;case VV:switch(t.charAt(a)){case AA:s=EA;break}break}if(s===kN?n.push(t.substring(r,i-1)):n.push(t.substring(r)),e&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},ZDe=class KY extends Qi{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!Ie().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new KY(e);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(r){throw new Error(`Error thrown while initializing video stream: ${r.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,n,r=await this.getAudioData();if(this.includeSpectrogram){let i=this.flattenQueue(r.freqDataQueue);e=this.getTensorFromAudioDataArray(i,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let i=this.flattenQueue(r.timeDataQueue);n=this.getTensorFromAudioDataArray(i,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],n=[],r=0;return new Promise(i=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&i({freqDataQueue:e,timeDataQueue:n}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++r===this.numFrames&&(clearInterval(s),i({freqDataQueue:e,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let n=e[0].length,r=new Float32Array(e.length*n);return e.forEach((i,s)=>r.set(i,s*n)),r}getTensorFromAudioDataArray(e,n){let r=new Float32Array(P.sizeFromShape(n));return r.set(e,r.length-e.length),Us(r,n)}},QDe=class qY extends Qi{constructor(e,n){if(super(),this.webcamVideoElement=e,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=cr([0],"int32"),this.webcamConfig.centerCrop){let r=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,i=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-r)/2,a=(1-i)/2,o=s+r,l=i+a;this.cropBox=au([a,s,l,o],[1,4])}else this.cropBox=au([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,n={}){if(!Ie().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=n.resizeWidth,e.height=n.resizeHeight}let r=new qY(e,n);return await r.start(),r}async start(){this.webcamConfig.facingMode&&P.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=Ww.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return xe(()=>{let n=Gi(ft(e,"float32"),0),r;r=to.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let i=r.shape;return ve(r,i.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},JY=class{},YY=class extends Qi{split(t){return new ePe(this,t)}},ePe=class extends YY{constructor(t,e){super(),this.upstream=t,this.impl=new tPe(t,e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},tPe=class extends PB{constructor(t,e){super(),this.upstream=t,this.separator=e,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let t=await this.upstream.next();if(t.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let e=t.value.split(this.separator);e[0]=this.carryover+e[0];for(let n of e.slice(0,-1))this.outputQueue.push(n);return this.carryover=e[e.length-1],!0}},nPe=class extends Qi{decodeUTF8(){return new rPe(this)}},rPe=class extends YY{constructor(t){super(),this.upstream=t,this.impl=new iPe(t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},iPe=class extends PB{constructor(t){if(super(),this.upstream=t,Ie().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:e}=i7();this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let t=await this.upstream.next(),e;if(t.done)return!1;e=t.value;let n;return Ie().get("IS_BROWSER")?n=this.decoder.decode(e,{stream:!0}):n=this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(n),!0}},ZY=class extends nPe{constructor(t,e={}){super(),this.file=t,this.options=e,P.assert(t instanceof Uint8Array||(Ie().get("IS_BROWSER")?t instanceof File||t instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=e.offset||0,this.chunkSize=e.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((t,e)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)t(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=s=>{let a=r.result;if(a instanceof ArrayBuffer&&(a=new Uint8Array(a)),!(a instanceof Uint8Array))return e(new TypeError("FileReader returned unknown type."));t(a)},r.onabort=s=>e(new Error("Aborted")),r.onerror=s=>e(new Error(s.type));let i=this.file.slice(this.offset,n);r.readAsArrayBuffer(i)}this.offset=n}),done:!1}}};async function sPe(t,e={},n){let r,i;typeof t=="string"?r=t:(r=t.url,i=aPe(t));let s=await(0,P.fetch)(r,i);if(s.ok){let a=new Uint8Array(await s.arrayBuffer());return new ZY(a,e)}else throw new Error(s.statusText)}var aPe=t=>({method:t.method,headers:t.headers,body:t.body,mode:t.mode,credentials:t.credentials,cache:t.cache,redirect:t.redirect,referrer:t.referrer,integrity:t.integrity});function QY(t){return typeof t=="string"&&t.slice(0,7)==="file://"}var eZ=class extends JY{constructor(t,e={}){super(),this.input=t,this.options=e}async iterator(){if(QY(this.input)&&Ie().get("IS_NODE")){let t=I3();this.input=t.readFileSync(this.input.slice(7))}return new ZY(this.input,this.options)}},tZ=class extends JY{constructor(t,e={}){super(),this.url=t,this.fileOptions=e}async iterator(){return QY(this.url)?new eZ(this.url,this.fileOptions).iterator():sPe(this.url,this.fileOptions)}};function oPe(t,e={}){return new XY(new tZ(t),e)}function lPe(t){let e=DB(t);return Sa(async()=>e)}function uPe(t){return Sa(async()=>{let e=await t();return DB(()=>e.next())})}async function cPe(t,e){return QDe.create(t,e)}async function dPe(t){return ZDe.create(t)}var hPe="4.22.0";function Zt(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&P.assert(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}var pPe=bu.whereImpl,LB=class nZ extends nw{nextDataId(){return nZ.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new tC(this,No())}write(e,n,r){this.firstUse&&(this.firstUse=!1,Ie().get("IS_NODE")&&W.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let i={id:this.nextDataId()};return this.data.set(i,{values:e,dtype:r,refCount:1}),i}makeTensorInfo(e,n,r){let i;if(n==="string"&&r!=null&&r.length>0&&P.isString(r[0])){let s=r.map(a=>P.encodeString(a));i=this.write(s,e,n)}else i=this.write(r,e,n);return{dataId:i,shape:e,dtype:n}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let n=this.data.get(e);n.refCount++}decRef(e){if(this.data.has(e)){let n=this.data.get(e);n.refCount--}}move(e,n,r,i,s){this.data.set(e,{values:n,dtype:i,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:n,complexTensorInfos:r}=this.data.get(e);if(n==="complex64"){let i=this.readSync(r.real.dataId),s=this.readSync(r.imag.dataId);return W.mergeRealAndImagArrays(i,s)}return P.convertBackendValuesAndArrayBuffer(this.data.get(e).values,n)}bufferSync(e){let n=this.readSync(e.dataId);if(e.dtype==="string")try{let r=n.map(i=>P.decodeString(i));return Rn(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Rn(e.shape,e.dtype,n)}makeOutput(e,n,r){return No().makeTensorFromTensorInfo(this.makeTensorInfo(n,r,e),this)}disposeData(e,n=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!n&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:r}=this.data.get(e);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let n=P.now();return e(),{kernelMs:P.now()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Zt([e],"where");let n=this.readSync(e.dataId);return pPe(e.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};LB.nextDataId=0;var OB={};wn(OB,{addImpl:()=>sZ,bincountImpl:()=>UB,bincountReduceImpl:()=>aZ,bitwiseAndImpl:()=>oZ,castImpl:()=>iZ,ceilImpl:()=>lZ,concatImpl:()=>$B,equalImpl:()=>uZ,expImpl:()=>dZ,expm1Impl:()=>pZ,floorDivImpl:()=>mZ,floorImpl:()=>fZ,gatherNdImpl:()=>gZ,gatherV2Impl:()=>yZ,greaterEqualImpl:()=>xZ,greaterImpl:()=>vZ,lessEqualImpl:()=>wZ,lessImpl:()=>bZ,linSpaceImpl:()=>_Z,logImpl:()=>SZ,maxImpl:()=>AZ,maximumImpl:()=>EZ,minimumImpl:()=>IZ,multiplyImpl:()=>zB,negImpl:()=>TZ,notEqualImpl:()=>CZ,prodImpl:()=>MZ,raggedGatherImpl:()=>kZ,raggedRangeImpl:()=>NZ,raggedTensorToTensorImpl:()=>RZ,rangeImpl:()=>HB,rsqrtImpl:()=>FZ,scatterImpl:()=>bp,sigmoidImpl:()=>h3e,simpleAbsImpl:()=>rZ,sliceImpl:()=>VI,sparseFillEmptyRowsImpl:()=>PZ,sparseReshapeImpl:()=>LZ,sparseSegmentReductionImpl:()=>WB,sqrtImpl:()=>m3e,squaredDifferenceImpl:()=>OZ,staticRegexReplaceImpl:()=>BZ,stridedSliceImpl:()=>UZ,stringNGramsImpl:()=>VB,stringSplitImpl:()=>jB,stringToHashBucketFastImpl:()=>XB,subImpl:()=>$Z,tileImpl:()=>zZ,topKImpl:()=>HZ,transposeImpl:()=>GB,uniqueImpl:()=>qB});function rZ(t){let e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}var fPe=t=>{let{x:e}=t.inputs,n=t.backend;Zt(e,"abs");let r=new Float32Array(P.sizeFromShape(e.shape)),i=n.data.get(e.dataId).values;return r=rZ(i),n.makeOutput(r,e.shape,e.dtype)},mPe={kernelName:x0,backendName:"cpu",kernelFunc:fPe};function di(t){return(e,n,r,i,s)=>{let a=W.assertAndGetBroadcastShape(e,n),o=a.length,l=P.computeStrides(a),u=P.sizeFromShape(a),c=P.getTypedArrayFromDType(s,u),d=e.length,h=n.length,p=P.computeStrides(e),f=P.computeStrides(n),g=W.getBroadcastDims(e,a),y=W.getBroadcastDims(n,a);if(g.length+y.length===0)for(let m=0;m<c.length;++m)c[m]=t(r[m%r.length],i[m%i.length]);else for(let m=0;m<c.length;++m){let b=P.indexToLoc(m,o,l),w=b.slice(-d);g.forEach(C=>w[C]=0);let _=P.locToIndex(w,d,p),S=b.slice(-h);y.forEach(C=>S[C]=0);let E=P.locToIndex(S,h,f);c[m]=t(r[_],i[E])}return[c,a]}}function Ta(t){let{inputs:e,backend:n}=t,{real:r,imag:i}=e,s=n.data.get(r.dataId).values,a=n.data.get(i.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(i.shape,"float32",a)},o}var gPe={kernelName:iC,backendName:"cpu",kernelFunc:Ta};function WI(t,e,n="float32"){if(n==="complex64"){let i=WI(t,e,"float32"),s=WI(t,e,"float32");return Ta({inputs:{real:i,imag:s},backend:t})}let r=P.makeZerosTypedArray(P.sizeFromShape(e),n);return t.makeTensorInfo(e,n,r)}function mu(t){let{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var yPe={kernelName:tm,backendName:"cpu",kernelFunc:mu};function of(t){let{inputs:e,backend:n}=t,{input:r}=e,i=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(i.dataId).values;return n.makeTensorInfo(i.shape,i.dtype,s)}var vPe={kernelName:gC,backendName:"cpu",kernelFunc:of};function iZ(t,e,n,r){if(r==="int32"){let i=Int32Array.from(t);return[e,"int32",i]}if(r==="bool"){let i=P.toTypedArray([0],n),[s,a]=di((o,l)=>o!==l?1:0)(e,[],t,i,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function Hd(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{dtype:s}=r;if(s==="complex64"){if(i.dtype==="complex64")return mu({inputs:{x:i},backend:n});let c=WI(n,i.shape,i.dtype),d=Hd({inputs:{x:i},backend:n,attrs:{dtype:"float32"}}),h=Ta({inputs:{real:d,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),h}if(i.dtype==="complex64"){let c=of({inputs:{input:i},backend:n}),d=Hd({inputs:{x:c},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(c),d}if(!P.hasEncodingLoss(i.dtype,s)){let c=mu({inputs:{x:i},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:s}}let a=n.data.get(i.dataId).values,[o,l,u]=iZ(a,i.shape,i.dtype,s);return n.makeTensorInfo(o,l,u)}var xPe={kernelName:Lf,backendName:"cpu",kernelFunc:Hd};function Di(t,e,n,r){return n==null?({inputs:i,backend:s})=>{let{a,b:o}=i,l=s;Zt([a,o],t);let u=l.data.get(a.dataId).values,c=l.data.get(o.dataId).values,d=a.dtype==="string"?W.fromUint8ToStringArray(u):u,h=a.dtype==="string"?W.fromUint8ToStringArray(c):c,p=r||a.dtype,[f,g]=e(a.shape,o.shape,d,h,p);return l.makeTensorInfo(g,p,f)}:({inputs:i,backend:s})=>{let{a,b:o}=i,l=s;if(a.dtype==="complex64"||o.dtype==="complex64"){let u=Hd({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),d=c.complexTensorInfos.real,h=c.complexTensorInfos.imag,p=l.data.get(d.dataId).values,f=l.data.get(h.dataId).values,g=Hd({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),y=l.data.get(g.dataId),m=y.complexTensorInfos.real,b=y.complexTensorInfos.imag,w=l.data.get(m.dataId).values,_=l.data.get(b.dataId).values,[S,E,C]=n(a.shape,o.shape,p,f,w,_),T=l.makeTensorInfo(C,"float32",S),M=l.makeTensorInfo(C,"float32",E),k=Ta({inputs:{real:T,imag:M},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(T),l.disposeIntermediateTensorInfo(M),k}else{let u=l.data.get(a.dataId).values,c=l.data.get(o.dataId).values,d=r||a.dtype,[h,p]=e(a.shape,o.shape,u,c,d);return l.makeTensorInfo(p,d,h)}}}function BB(t){return(e,n,r,i,s,a)=>{let o=W.assertAndGetBroadcastShape(e,n),l=P.sizeFromShape(o),u=o.length,c=P.computeStrides(o),d=P.getTypedArrayFromDType("float32",l),h=P.getTypedArrayFromDType("float32",l),p=W.getBroadcastDims(e,o),f=W.getBroadcastDims(n,o),g=W.mergeRealAndImagArrays(r,i),y=W.mergeRealAndImagArrays(s,a),m=e.length,b=P.computeStrides(e),w=n.length,_=P.computeStrides(n);if(p.length+f.length===0)for(let S=0;S<d.length;S++){let E=S%g.length,C=S%y.length,T=t(g[E*2],g[E*2+1],y[C*2],y[C*2+1]);d[S]=T.real,h[S]=T.imag}else for(let S=0;S<d.length;S++){let E=P.indexToLoc(S,u,c),C=E.slice(-m);p.forEach(N=>C[N]=0);let T=P.locToIndex(C,m,b),M=E.slice(-w);f.forEach(N=>M[N]=0);let k=P.locToIndex(M,w,_),R=t(g[T*2],g[T*2+1],y[k*2],y[k*2+1]);d[S]=R.real,h[S]=R.imag}return[d,h,o]}}var sZ=di((t,e)=>t+e),bPe=BB((t,e,n,r)=>({real:t+n,imag:e+r})),s0=Di(th,sZ,bPe),wPe={kernelName:th,backendName:"cpu",kernelFunc:s0};function UB(t,e,n,r,i){let s=P.sizeFromShape(r),a=P.makeZerosTypedArray(i,n);for(let o=0;o<t.length;o++){let l=t[o];if(l<0)throw new Error("Input x must be non-negative!");l>=i||(s>0?a[l]+=e[o]:a[l]+=1)}return a}function aZ(t,e,n,r=!1){let i=t.shape[0],s=t.shape[1],a=Rn([i,n],e.dtype);for(let o=0;o<i;o++)for(let l=0;l<s;l++){let u=t.get(o,l);if(u<0)throw new Error("Input x must be non-negative!");u>=n||(r?a.set(1,o,u):e.size>0?a.set(a.get(o,u)+e.get(o,l),o,u):a.set(a.get(o,u)+1,o,u))}return a}var oZ=di((t,e)=>t&e),_Pe=Di(T0,oZ),SPe={kernelName:T0,backendName:"cpu",kernelFunc:_Pe};function wu(t){return(e,n,r)=>{let i=P.getArrayFromDType(n,e.length);for(let s=0;s<e.length;++s)i[s]=t(e[s],r);return i}}function mr(t,e,n){let r=wu(e);return ch(t,r,n)}function ch(t,e,n){return({inputs:r,attrs:i,backend:s})=>{let{x:a}=r;Zt(a,t);let o=s,l=o.data.get(a.dataId).values,u;if(a.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=W.fromUint8ToStringArray(l)}else u=l;let c=n||a.dtype,d=e(u,c,i);return o.makeTensorInfo(a.shape,c,d)}}var lZ=wu(t=>Math.ceil(t)),APe=ch(Of,lZ),EPe={kernelName:Of,backendName:"cpu",kernelFunc:APe};function $B(t,e,n,r){let i=P.getArrayFromDType(n,P.sizeFromShape(e));if(r&&n!=="string"){let s=0;t.forEach(a=>{let o=P.sizeFromShape(a.shape);i.set(a.vals,s),s+=o})}else{let s=0;t.forEach(a=>{let o=n==="string"?W.fromUint8ToStringArray(a.vals):a.vals,l=0;for(let u=0;u<a.shape[0];++u){let c=u*e[1]+s;for(let d=0;d<a.shape[1];++d)i[c+d]=o[l++]}s+=a.shape[1]})}return i}var uZ=di((t,e)=>t===e?1:0),cZ=Di(P0,uZ,null,"bool"),IPe={kernelName:P0,backendName:"cpu",kernelFunc:cZ},dZ=wu(t=>Math.exp(t)),hZ=ch(qf,dZ,"float32"),TPe={kernelName:qf,backendName:"cpu",kernelFunc:hZ},pZ=wu(t=>Math.expm1(t)),CPe=ch(Jf,pZ),MPe={kernelName:Jf,backendName:"cpu",kernelFunc:CPe},fZ=wu(t=>Math.floor(t)),kPe=ch(Yf,fZ),NPe={kernelName:Yf,backendName:"cpu",kernelFunc:kPe},mZ=di((t,e)=>Math.floor(t/e)),RPe=Di(Zf,mZ,null,"int32"),FPe={kernelName:Zf,backendName:"cpu",kernelFunc:RPe};function gZ(t,e,n,r,i,s,a,o,l){let u=Rn([r,s],n);for(let c=0;c<r;c++){let d=[],h=0;for(let p=0;p<i;p++){let f=t[c*i+p];h+=f*a[p],d.push(f)}if(h<0||h>=l/s)throw new Error(`Invalid indices: ${d} does not index into ${o}`);for(let p=0;p<s;p++)u.values[c*s+p]=e.get(...e.indexToLoc(h*s+p))}return u}function yZ(t,e,n){let r=Rn(n,t.dtype);for(let i=0;i<r.size;++i){let s=r.indexToLoc(i).slice(),a=s[0],o=s[2],l=e.locToIndex([a,o]);s[2]=e.values[l];let u=t.locToIndex(s);0<=u&&u<t.values.length&&(r.values[i]=t.values[u])}return r}var vZ=di((t,e)=>t>e?1:0),DPe=Di($0,vZ,null,"bool"),PPe={kernelName:$0,backendName:"cpu",kernelFunc:DPe},xZ=di((t,e)=>t>=e?1:0),LPe=Di(em,xZ,null,"bool"),OPe={kernelName:em,backendName:"cpu",kernelFunc:LPe},bZ=di((t,e)=>t<e?1:0),BPe=Di(z0,bZ,null,"bool"),UPe={kernelName:z0,backendName:"cpu",kernelFunc:BPe},wZ=di((t,e)=>t<=e?1:0),$Pe=Di(G0,wZ,null,"bool"),zPe={kernelName:G0,backendName:"cpu",kernelFunc:$Pe};function _Z(t,e,n){let r=(e-t)/(n-1),i=P.makeZerosTypedArray(n,"float32");i[0]=t;for(let s=1;s<i.length;s++)i[s]=i[s-1]+r;return i}var SZ=wu(t=>Math.log(t)),GPe=ch(am,SZ),HPe={kernelName:am,backendName:"cpu",kernelFunc:GPe};function AZ(t,e,n,r){let i=P.getTypedArrayFromDType(r,P.sizeFromShape(n));for(let s=0;s<i.length;++s){let a=s*e,o=t[a];for(let l=0;l<e;++l){let u=t[a+l];(Number.isNaN(u)||u>o)&&(o=u)}i[s]=o}return i}var EZ=di((t,e)=>Math.max(t,e)),WPe=Di(cm,EZ),VPe={kernelName:cm,backendName:"cpu",kernelFunc:WPe},IZ=di((t,e)=>Math.min(t,e)),jPe=Di(fm,IZ),XPe={kernelName:fm,backendName:"cpu",kernelFunc:jPe},zB=di((t,e)=>t*e),KPe=BB((t,e,n,r)=>({real:t*n-e*r,imag:t*r+e*n})),_M=Di(ym,zB,KPe),qPe={kernelName:ym,backendName:"cpu",kernelFunc:_M};function TZ(t,e,n){let r=P.createScalarValue(-1,n);return zB([],e,r,t,n)}function JPe(t){let{inputs:e,backend:n}=t,{x:r}=e;Zt(r,"neg");let i=n.data.get(r.dataId).values,[s,a]=TZ(i,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,s)}var YPe={kernelName:J0,backendName:"cpu",kernelFunc:JPe},CZ=di((t,e)=>t!==e?1:0),ZPe=Di(Y0,CZ,null,"bool"),QPe={kernelName:Y0,backendName:"cpu",kernelFunc:ZPe};function GB(t,e,n,r,i){let s=e.length,a=P.sizeFromShape(e),o=P.computeStrides(e),l=P.computeStrides(i),u=P.getTypedArrayFromDType(n,P.sizeFromShape(i));for(let c=0;c<a;++c){let d=P.indexToLoc(c,s,o),h=new Array(d.length);for(let f=0;f<h.length;f++)h[f]=d[r[f]];let p=P.locToIndex(h,s,l);u[p]=t[c]}return u}function ha(t){let{inputs:e,attrs:n,backend:r}=t,{x:i}=e,{perm:s}=n;Zt(i,"transpose");let a=i.shape.length,o=new Array(a);for(let c=0;c<o.length;c++)o[c]=i.shape[s[c]];let l=r.data.get(i.dataId).values,u=GB(l,i.shape,i.dtype,s,o);return{dataId:r.write(u,o,i.dtype),shape:o,dtype:i.dtype}}var e3e={kernelName:Qu,backendName:"cpu",kernelFunc:ha};function MZ(t,e,n,r){let[i,s]=W.computeOutAndReduceShapes(t,r),a=uo(e,"int32"),o=P.makeZerosTypedArray(P.sizeFromShape(i),a),l=P.sizeFromShape(s);for(let u=0;u<o.length;++u){let c=u*l,d=1;for(let h=0;h<l;++h)d*=n[c+h];o[u]=d}return{outVals:o,outShape:i,outDtype:a}}function t3e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r;Zt(i,"prod");let o=i.shape.length,l=P.parseAxisParam(s,i.shape),u=W.getAxesPermutation(l,o),c=l,d=i,h=[];u!=null&&(d=ha({inputs:{x:i},backend:n,attrs:{perm:u}}),h.push(d),c=W.getInnerMostAxes(c.length,o));let p=n.data.get(d.dataId).values,{outVals:f,outShape:g,outDtype:y}=MZ(d.shape,d.dtype,p,c),m=g;return a&&(m=W.expandShapeToKeepDim(g,l)),h.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.makeTensorInfo(m,y,f)}var n3e={kernelName:_m,backendName:"cpu",kernelFunc:t3e};function r3e(t,e,n){t.forEach((r,i)=>{if(r<0||r>=n){let s=P.indexToLoc(i,e.length,P.computeStrides(e)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${n})`)}})}function i3e(t,e){for(let n=0;n<t.length;++n){let r=t[n],i=n===t.length-1?e:t[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>i)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}function s3e(t,e,n,r){let i=[],s=0,a=e.length-1+n.length,o=new Array(a).fill(null).map(()=>[0]);i3e(n,r);let l=1;for(let u=0;u<e.length-1;++u){l*=e[u];let c=e[u+1];for(let d=1;d<l+1;++d)o[u].push(d*c)}for(let u=0;u<t.length;++u){let c=t[u],d=t[u]+1;for(let h=0;h<n.length;++h){let p=n[h],f=h+e.length-1;if(f>=0){let g=o[f],y=g[g.length-1]-p[c];for(let m=c;m<d;++m)o[f].push(p[m+1]+y)}c=p[c],d=p[d]}d!==c&&(i.push([c,d]),s+=d-c)}return{outSplits:o,valueSlices:i,numValues:s}}function a3e(t){let e=[];for(let n=0;n<t.length;++n){let r=t[n].length,i=P.getArrayFromDType("int32",r);e.push(i),t[n].forEach((s,a)=>i[a]=s)}return e}function jV(t,e){let n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let r=e;r<t.length;r++)n[e-1]*=t[r];return n}function o3e(t,e,n,r,i,s){let a=jV(e,2)[1],o=jV(s,2)[1],l=0;for(let u of n)for(let c=u[0];c<u[1];++c){for(let d=0;d<r;++d)i[l*o+d]=t[c*a+d];++l}}function l3e(t,e,n,r,i){let s=e.slice();s[0]=i;let a=P.getArrayFromDType(n,P.sizeFromShape(s)),o=t.length,l=o===0?0:o/e[0];return o3e(t,e,r,l,a,s),[a,s]}function kZ(t,e,n,r,i,s,a,o){if(t.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");let l=e[0][0]-1;if(r3e(s,a,l),r.length===0)throw new Error("params.rank must be nonzero");let u=r[0],{outSplits:c,valueSlices:d,numValues:h}=s3e(s,a,t,u),p=a3e(c),f=l3e(n,r,i,d,h);return[p,f[0],f[1]]}var XV=2147483647;function NZ(t,e,n,r,i,s,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");let o=e.length===0,l=i.length===0,u=a.length===0,c=[];o||c.push(e[0]),l||c.push(i[0]),u||c.push(a[0]);for(let y=1;y<c.length;++y)if(c[y]!==c[y-1])throw new Error("starts, limits, and deltas must have the same shape");let d=c.length===0?1:c[0],h=P.getArrayFromDType("int32",d+1);h[0]=0;for(let y=0;y<d;++y){let m=o?t[0]:t[y],b=l?r[0]:r[y],w=u?s[0]:s[y];if(w===0)throw new Error("Requires delta != 0");let _;if(w>0&&b<m||w<0&&b>m)_=0;else if(_=Math.ceil(Math.abs((b-m)/w)),_>XV)throw new Error(`Requires ((limit - start) / delta) <= ${XV}`);h[y+1]=h[y]+_}let p=h[d],f=P.getArrayFromDType(n,p),g=0;for(let y=0;y<d;++y){let m=h[y+1]-h[y],b=o?t[0]:t[y],w=u?s[0]:s[y];for(let _=0;_<m;++_)f[g++]=b,b+=w}return[h,f]}var Co=W.RowPartitionType,u3e=class XF{constructor(e,n,r,i,s,a,o,l,u,c){this.shape=e,this.shapeShape=n,this.values=r,this.valuesShape=i,this.valuesDType=s,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=W.getRowPartitionTypesHelper(c),this.raggedRank=W.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Co.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Co.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){let n=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Co.VALUE_ROWIDS:return XF.getMaxWidthValueRowID(n);case Co.ROW_SPLITS:return XF.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Co[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){let n=e.length;if(n===0||n===1)return 0;let r=0;for(let i=0;i<n-1;++i){let s=e[i+1]-e[i];s>r&&(r=s)}return r}static getMaxWidthValueRowID(e){let n=e.length;if(n===0)return 0;let r=0,i=e[0],s=0;for(let a=1;a<n;++a){let o=e[a];o!==i&&(i=o,s=Math.max(a-r,s),r=a)}return Math.max(n-r,s)}tensorShapeFromTensor(e,n,r=!0){if(n.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return qV(e,r)}calculateOutputSize(e){let n=this.valuesShape,r=this.defaultValueShape;W.validateDefaultValueShape(r,n);let i=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=W.combineRaggedTensorToTensorShapes(this.raggedRank,i,n);s[0]<0&&(s[0]=e);for(let a=1;a<=this.raggedRank;++a)s[a]<0&&(s[a]=this.getMaxWidth(a));return s}calculateFirstParentOutputIndex(e,n,r){let i=Math.min(e,r),s=[],a=0;for(let o=0;o<i;++o,a+=n)s.push(a);for(let o=i;o<e;++o)s.push(-1);return P.assert(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,n,r,i){let s=e.length,a=[];for(let o=0;o<s-1;++o){let l=e[o+1]-e[o],u=Math.min(i,l),c=n[o];c===-1&&(u=0);for(let d=0;d<u;++d)a.push(c),c+=r;for(let d=0;d<l-u;++d)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,n,r,i){let s=e.length,a=[];if(s===0)return[];let o=0,l=e[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let u=n[l];a.push(u);for(let c=1;c<s;++c){let d=e[c];if(d===l)u>=0&&(++o,o<i?u+=r:u=-1);else{if(o=0,l=d,d>=n.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);u=n[d]}a.push(u)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,n,r,i){let s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case Co.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,n,r,i);case Co.ROW_SPLITS:if(s.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(s,n,r,i);default:throw new Error(`Unsupported partition type: ${Co[a]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let n=this.rowPartitionTypes[0];switch(n){case Co.FIRST_DIM_SIZE:return e[0];case Co.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Co.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Co[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),n=this.calculateOutputSize(e),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let a=r.length-2;a>=0;--a)r[a]=r[a+1]*n[a+1];let i=qV(n,!1),s=P.getArrayFromDType(this.valuesDType,P.sizeFromShape(i));if(r[0]*n[0]>0){let a=this.calculateFirstParentOutputIndex(e,r[0],n[0]);for(let o=1;o<=this.raggedRank;++o)a=this.calculateOutputIndex(o-1,a,r[o],n[o]);this.setOutput(this.raggedRank,a,s,i)}return[i,s]}setOutput(e,n,r,i){if(r.length===0)return;let s=this.values,a=r,o=i.slice();o=o.slice(e+1);let l=P.sizeFromShape(o),u=n.length,c=this.defaultValue;if(c.length!==l&&c.length!==1){let f=this.defaultValueShape;xe(()=>{let g=ve(c,f);c=Mp(g,o).dataSync()})}let d=0,h=0,p=0;for(let f=0;f<=u;++f){let g=f<u?n[f]:-1;if(g===p){++p;continue}if(h<p){let y=s.subarray(d*l),m=a.subarray(h*l),b=(p-h)*l;KV(m,y,b)}if(f>=u){let y=r.length;g=Math.floor(y/l)}if(g>p)if(this.defaultValue.length===1)a.subarray(p*l,g*l).fill(this.defaultValue[0]),p=g;else for(;g>p;){let y=a.slice(p*l);KV(y,c,l),++p}g<0?(d=f+1,h=p):(d=f,h=p,p=h+1)}}};function KV(t,e,n){for(let r=0;r<n;r++)t[r]=e[r]}function qV(t,e){let n=[];for(let r of t){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function RZ(t,e,n,r,i,s,a,o,l,u){return new u3e(t,e,n,r,i,s,a,o,l,u).compute()}function HB(t,e,n,r){let i=t===e,s=t<e&&n<0,a=e<t&&n>1;if(i||s||a)return P.makeZerosTypedArray(0,r);let o=Math.abs(Math.ceil((e-t)/n)),l=P.makeZerosTypedArray(o,r);e<t&&n===1&&(n=-1),l[0]=t;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}var FZ=wu(t=>1/Math.sqrt(t)),c3e=ch(km,FZ),d3e={kernelName:km,backendName:"cpu",kernelFunc:c3e};function bp(t,e,n,r,i,s,a,o,l,u){let c=[r/i,i],d=t.values,h=e.values;if(r===0)return Rn(n,e.dtype);let p=l instanceof vi?l:Rn(c,e.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let f=0;f<s;f++){let g=[],y=0;for(let m=0;m<a;m++){let b=d[f*a+m];g.push(b),y+=b*o[m]}if(y<0||y>=r/i)throw new Error(`Invalid indices: ${g} does not index into ${n}`);for(let m=0;m<i;m++)u?p.values[y*i+m]+=h[f*i+m]:p.values[y*i+m]=e.rank===0?h[0]:h[f*i+m]}return p}var h3e=wu(t=>1/(1+Math.exp(-t))),DZ=mr(Pm,t=>1/(1+Math.exp(-t))),p3e={kernelName:Pm,backendName:"cpu",kernelFunc:DZ};function VI(t,e,n,r,i){let s=Ni.isSliceContinous(r,e,n),a=P.sizeFromShape(n),o=P.computeStrides(r);if(s){let d=Ni.computeFlatOffset(e,o);return i==="string"?t.slice(d,d+a):t.subarray(d,d+a)}let l=i==="string"?W.fromUint8ToStringArray(t):t,u=Rn(r,i,l),c=Rn(n,i);for(let d=0;d<c.size;++d){let h=c.indexToLoc(d),p=h.map((f,g)=>f+e[g]);c.set(u.get(...p),...h)}return i==="string"?W.fromStringArrayToUint8(c.values):c.values}function lf(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{begin:s,size:a}=r;Zt(i,"slice");let[o,l]=Ni.parseSliceParams(i,s,a);Ni.assertParamsValid(i,o,l);let u=n.data.get(i.dataId).values,c=VI(u,o,l,i.shape,i.dtype);return n.makeTensorInfo(l,i.dtype,c)}var f3e={kernelName:cv,backendName:"cpu",kernelFunc:lf};function PZ(t,e,n,r,i,s,a){let o=e[0],l=s[0],u=new Array(l),c=new Array(o),d=e[1];if(l===0){if(o!==0)throw new Error(W.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let y=P.getArrayFromDType(n,0),m=P.getArrayFromDType(i,0);return[y,[0,d],m,u,c]}let h=!0,p=0,f=new Array(l).fill(0);for(let y=0;y<o;++y){let m=t[y*d];if(m<0)throw new Error(W.getSparseFillEmptyRowsNegativeIndexErrorMessage(y,m));if(m>=l)throw new Error(W.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(y,m,l));++f[m],h=h&&m>=p,p=m}let g=!0;for(let y=0;y<l;++y){let m=f[y]===0;u[y]=m,g=g&&!m,f[y]=Math.max(f[y],1),y>0&&(f[y]+=f[y-1])}if(g&&h){let y=t,m=r;for(let b=0;b<o;++b)c[b]=b;return[y,[o,d],m,u,c]}else{let y=f[l-1],m=P.getArrayFromDType(n,y*d),b=P.getArrayFromDType(i,y),w=new Array(l).fill(0);for(let _=0;_<o;++_){let S=t[_*d],E=w[S],C=(S===0?0:f[S-1])+E;w[S]++;for(let T=0;T<d;++T)m[C*d+T]=t[_*d+T];b[C]=r[_],c[_]=C}for(let _=0;_<l;++_)if(w[_]===0){let S=_===0?0:f[_-1];m[S*d+0]=_;for(let E=1;E<d;++E)m[S*d+E]=0;b[S]=a}return[m,[y,d],b,u,c]}}function LZ(t,e,n,r,i){let s=P.sizeFromShape(r),a=e[0],o=i.length,l=[],u=1,c=-1;for(let g=0;g<o;++g){let y=i[g];if(y===-1){if(c!==-1)throw new Error(W.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,g));c=g,l.push(1)}else{if(y<0)throw new Error(W.getSparseReshapeNegativeOutputDimErrorMessage(g,y));u*=y,l.push(y)}}if(c!==-1){if(u<=0)throw new Error(W.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(s/u);if(u*g!==s)throw new Error(W.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[c]=g}if(P.sizeFromShape(l)!==s)throw new Error(W.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let d=r.length,h=[];if(d>0){h[d-1]=1;for(let g=d-2;g>=0;--g)h[g]=h[g+1]*r[g+1]}let p=[];if(o>0){p[o-1]=1;for(let g=o-2;g>=0;--g)p[g]=p[g+1]*l[g+1]}let f=P.getArrayFromDType(n,a*o);for(let g=0;g<a;++g){let y=0;for(let m=0;m<d;++m)y+=t[g*d+m]*h[m];for(let m=0;m<o;++m)f[g*o+m]=Math.trunc(y/p[m]),y%=p[m]}return[f,[a,o],l]}function WB(t,e,n,r,i,s=!1,a=0){let o=r.length,l=[e[0],t.length/e[0]],u=l[1],c=o>0?i[o-1]+1:0;if(c<0)throw new Error(W.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=e.slice();d[0]=c;let h=d.reduce((b,w)=>b*w,1),p=P.getArrayFromDType(n,h);if(o===0)return c>0&&p.fill(a),[p,d];if(c<=0)throw new Error(W.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,g=1,y=0,m=i[f];for(;;){let b=0;if(g<o){if(b=i[g],m===b){++g;continue}if(m>=b)throw new Error(W.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(m<0||m>=c)throw new Error(W.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(m,c));m>y&&p.fill(a,y*u,m*u);for(let w=f;w<g;++w){let _=r[w];if(_<0||_>=l[0])throw new Error(W.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(w,r[w],l[0]));for(let S=0;S<u;S++)p[m*u+S]+=t[_*u+S]}if(s)for(let w=0;w<u;w++)p[m*u+w]/=g-f;if(f=g,++g,y=m+1,m=b,g>o)break}return y<c&&p.fill(a,y*u,c*u),[p,d]}var m3e=wu(t=>Math.sqrt(t)),g3e=mr(Om,t=>Math.sqrt(t)),y3e={kernelName:Om,backendName:"cpu",kernelFunc:g3e},OZ=di((t,e)=>{let n=t-e;return n*n}),v3e=Di($m,OZ),x3e={kernelName:$m,backendName:"cpu",kernelFunc:v3e},BZ=wu((t,e)=>{let{pattern:n,replaceGlobal:r,rewrite:i}=e;return t.replace(new RegExp(n,r?"g":""),i)}),b3e=ch(xw,BZ),w3e={kernelName:xw,backendName:"cpu",kernelFunc:b3e};function UZ(t,e,n,r){let i=Rn(t,e.dtype);for(let s=0;s<i.size;s++){let a=i.indexToLoc(s),o=new Array(a.length);for(let l=0;l<o.length;l++)o[l]=a[l]*n[l]+r[l];i.set(e.get(...o),...a)}return i}var _3e=class{constructor(t,e,n,r,i,s){this.separator=P.encodeString(t),this.nGramWidths=e,this.leftPad=P.encodeString(n),this.rightPad=P.encodeString(r),this.padWidth=i,this.preserveShort=s}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){let n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,r,i,s){for(let a=0;a<i;++a){let o=this.getPadWidth(s),l=Math.max(0,o-a),u=Math.max(0,o-(i-(a+1))),c=s-(l+u),d=e+(l>0?0:a-o),h=0;h+=l*this.leftPad.length;for(let m=0;m<c;++m)h+=t[d+m].length;h+=u*this.rightPad.length;let p=l+u+c-1;h+=p*this.separator.length,n[r+a]=new Uint8Array(h);let f=n[r+a],g=0,y=m=>m.forEach(b=>f[g++]=b);for(let m=0;m<l;++m)y(this.leftPad),y(this.separator);for(let m=0;m<c-1;++m)y(t[d+m]),y(this.separator);if(c>0){y(t[d+c-1]);for(let m=0;m<u;++m)y(this.separator),y(this.rightPad)}else{for(let m=0;m<u-1;++m)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(t,e){let n=t.length,r=e.length;if(r>0){let o=e[0];if(o!==0)throw new Error(`First split value must be 0, got ${o}`);for(let l=1;l<r;++l){let u=e[l]>=o;if(u=u&&e[l]<=n,!u)throw new Error(`Invalid split value ${e[l]}, must be in [${o}, ${n}]`);o=e[l]}if(o!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${o}`)}let i=r-1,s=P.getArrayFromDType("int32",r);if(n===0||r===0){let o=new Array(n);for(let l=0;l<=i;++l)s[l]=0;return[o,s]}s[0]=0;for(let o=1;o<=i;++o){let l=e[o]-e[o-1],u=0;this.nGramWidths.forEach(c=>{u+=this.getNumNGrams(l,c)}),this.preserveShort&&l>0&&u===0&&(u=1),s[o]=s[o-1]+u}let a=new Array(s[i]);for(let o=0;o<i;++o){let l=e[o],u=s[o];if(this.nGramWidths.forEach(c=>{let d=e[o+1]-e[o],h=this.getNumNGrams(d,c);this.createNGrams(t,l,a,u,h,c),u+=h}),this.preserveShort&&u===s[o]){let c=e[o+1]-e[o];if(c===0)continue;let d=c+2*this.padWidth;this.createNGrams(t,l,a,u,1,d)}}return[a,s]}};function VB(t,e,n,r,i,s,a,o){return new _3e(n,r,i,s,a,o).compute(t,e)}function S3e(t,e,n,r){if(!t.length)return;if(e.length===0){for(let s=0;s<t.length;++s)r.push(t.subarray(s,s+1));return}if(e.length===1){let s=e[0],a=t.indexOf(s);for(;a!==-1;){let o=t.subarray(0,a);(!n||o.length!==0)&&r.push(o),t=t.subarray(a+1),a=t.indexOf(s)}(!n||t.length!==0)&&r.push(t);return}let i=0;for(let s=0;s<t.length+1;s++)if(s===t.length||e.indexOf(t[s])!==-1){let a=t.subarray(i,s);(!n||a.length!==0)&&r.push(a),i=s+1}}function jB(t,e,n){let r=t.length,i=[],s=0,a=0,o=new Array(r);for(let h=0;h<r;++h){let p=i.length;S3e(t[h],e,n,i);let f=i.length-p;o[h]=f,s+=f,a=Math.max(a,f)}let l=P.getArrayFromDType("int32",s*2),u=new Array(s),c=[r,a],d=0;for(let h=0;h<r;++h)for(let p=0;p<o[h];++p)l[d*2]=h,l[d*2+1]=p,u[d]=i[d],++d;return[l,u,c]}function XB(t,e){let n=P.getArrayFromDType("int32",t.length);for(let r=0;r<t.length;++r)n[r]=P.fingerPrint64(t[r]).modulo(e).getLowBitsUnsigned();return n}var $Z=di((t,e)=>t-e),A3e=BB((t,e,n,r)=>({real:t-n,imag:e-r})),KB=Di(zm,$Z,A3e),E3e={kernelName:zm,backendName:"cpu",kernelFunc:KB};function zZ(t,e){let n=new Array(t.rank);for(let i=0;i<n.length;i++)n[i]=t.shape[i]*e[i];let r=Rn(n,t.dtype);for(let i=0;i<r.values.length;++i){let s=r.indexToLoc(i),a=new Array(t.rank);for(let l=0;l<a.length;l++)a[l]=s[l]%t.shape[l];let o=t.locToIndex(a);r.values[i]=t.values[o]}return r}var nb=(t,e)=>{let n=e.value-t.value;return n===0?t.index-e.index:n};function GZ(t,e,n=0,r=t.length-1){for(;r>n;){if(r-n>600){let o=r-n+1,l=e-n+1,u=Math.log(o),c=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*c*(o-c)/o)*Math.sign(l-o/2),h=Math.max(n,Math.floor(e-l*c/o+d)),p=Math.min(r,Math.floor(e+(o-l)*c/o+d));GZ(t,e,h,p)}let i=t[e],s=n,a=r;for(P.swap(t,n,e),nb(t[r],i)>0&&P.swap(t,n,r);s<a;){for(P.swap(t,s,a),s++,a--;nb(t[s],i)<0;)s=s+1;for(;nb(t[a],i)>0;)a=a-1}nb(t[n],i)===0?P.swap(t,n,a):(a=a+1,P.swap(t,a,r)),a<=e&&(n=a+1),e<=a&&(r=a-1)}}function HZ(t,e,n,r,i){let s=e[e.length-1],[a,o]=[t.length/s,s],l=P.getTypedArrayFromDType(n,a*r),u=P.getTypedArrayFromDType("int32",a*r);for(let d=0;d<a;d++){let h=d*o,p=t.subarray(h,h+o),f=new Array(p.length);p.forEach((b,w)=>f[w]={value:b,index:w}),r<f.length&&(GZ(f,r),f=f.slice(0,r)),i&&f.sort(nb);let g=d*r,y=l.subarray(g,g+r),m=u.subarray(g,g+r);for(let b=0;b<r;b++)y[b]=f[b].value,m[b]=f[b].index}let c=e.slice();return c[c.length-1]=r,[Rn(c,n,l),Rn(c,"int32",u)]}function qB(t,e,n,r){let i=P.parseAxisParam(e,n)[0],s=[1,n[0],1];for(let f=0;f<i;f++)s[0]*=n[f];s[1]=n[i];for(let f=i+1;f<n.length;f++)s[2]*=n[f];let a=new Map,o=new Int32Array(n[i]),l=new vi(s,r,t),u=[],c=s[0]===1&&s[2]===1;for(let f=0;f<n[i];f++){let g;if(c)g=t[f].toString();else{let m=[];for(let b=0;b<s[0];b++)for(let w=0;w<s[2];w++)m.push(l.get(b,f,w));g=m.join(",")}let y=a.get(g);if(y!=null)o[f]=y;else{let m=a.size;a.set(g,m),o[f]=m,u.push(f)}}let d=s.slice();d[1]=a.size;let h=new vi(d,r);u.forEach((f,g)=>{for(let y=0;y<s[0];y++)for(let m=0;m<s[2];m++)h.set(l.get(y,f,m),y,g,m)});let p=n.slice();return p[i]=d[1],{outputValues:h.values,outputShape:p,indices:o}}var I3e="4.22.0";xC("cpu",()=>new LB,1);var WZ=mr(Xf,t=>t>=0?t:Math.exp(t)-1),T3e={kernelName:Xf,backendName:"cpu",kernelFunc:WZ};function VZ(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{alpha:s}=r;Zt([i],"leakyRelu");let a=P.sizeFromShape(i.shape),o=n.data.get(i.dataId).values,l=P.getTypedArrayFromDType("float32",a);for(let u=0;u<o.length;u++)l[u]=o[u]<0?s*o[u]:o[u];return n.makeTensorInfo(i.shape,"float32",l)}var C3e={kernelName:sm,backendName:"cpu",kernelFunc:VZ},M3e=di((t,e)=>t<0?e*t:t);function jZ(t){let{inputs:e,backend:n}=t,{x:r,alpha:i}=e;Zt([r,i],"prelu");let s=n.data.get(r.dataId).values,a=n.data.get(i.dataId).values,[o,l]=M3e(r.shape,i.shape,s,a,"float32");return n.makeTensorInfo(l,"float32",o)}var k3e={kernelName:wm,backendName:"cpu",kernelFunc:jZ},XZ=mr(Am,t=>Math.max(0,t)),N3e={kernelName:Am,backendName:"cpu",kernelFunc:XZ},KZ=mr(Tm,t=>Math.min(Math.max(0,t),6)),R3e={kernelName:Tm,backendName:"cpu",kernelFunc:KZ};function jI(t,e,n,r,i){if(n==="linear")return mu({inputs:{x:e},backend:t});if(n==="relu")return XZ({inputs:{x:e},backend:t});if(n==="elu")return WZ({inputs:{x:e},backend:t});if(n==="relu6")return KZ({inputs:{x:e},backend:t});if(n==="prelu")return jZ({inputs:{x:e,alpha:r},backend:t});if(n==="leakyrelu")return VZ({inputs:{x:e},backend:t,attrs:{alpha:i}});if(n==="sigmoid")return DZ({inputs:{x:e},backend:t});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function kr(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{shape:s}=r,a=P.sizeFromShape(i.shape),o=P.inferFromImplicitShape(s,a),l=P.sizeFromShape(o);P.assert(a===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),n.incRef(i.dataId);let u=n.data.get(i.dataId);if(u.complexTensorInfos!=null){let c=u.complexTensorInfos.real,d=u.complexTensorInfos.imag;c.shape=o,d.shape=o}return{dataId:i.dataId,shape:o,dtype:i.dtype}}var F3e={kernelName:rv,backendName:"cpu",kernelFunc:kr};function qZ(t){let{inputs:e,backend:n,attrs:r}=t,{a:i,b:s}=e,{transposeA:a,transposeB:o}=r;Zt([i,s],"matMul");let l=i.shape.length,u=s.shape.length,c=a?i.shape[l-2]:i.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],h=a?i.shape[l-1]:i.shape[l-2],p=o?s.shape[u-2]:s.shape[u-1],f=i.shape.slice(0,-2),g=s.shape.slice(0,-2),y=P.sizeFromShape(f),m=P.sizeFromShape(g),b=wv.assertAndGetBroadcastShape(i.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,p]);P.assert(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${i.shape} and ${s.shape} and transposeA=${a} and transposeB=${o} must match.`);let w=a?[y,c,h]:[y,h,c],_=o?[m,p,d]:[m,d,p],S=kr({inputs:{x:i},backend:n,attrs:{shape:w}}),E=kr({inputs:{x:s},backend:n,attrs:{shape:_}}),C=a?S.shape[1]:S.shape[2],T=a?S.shape[2]:S.shape[1],M=o?E.shape[1]:E.shape[2],k=Math.max(y,m),R=n.data.get(S.dataId).values,N=n.data.get(E.dataId).values,B=P.computeStrides(S.shape),z=P.computeStrides(E.shape),[V,K,Q]=a?[B[0],1,B[1]]:[B[0],B[1],1],[O,j,X]=o?[1,z[1],z[0]]:[z[1],1,z[0]],te=T*M,le=Rn([k,T,M],S.dtype),ge=le.values,ie=n.blockSize;for(let we=0;we<k;we++){let Ce=we%y,Re=we%m;for(let Le=0;Le<T;Le+=ie){let lt=Math.min(Le+ie,T);for(let st=0;st<M;st+=ie){let Et=Math.min(st+ie,M);for(let Tt=0;Tt<C;Tt+=ie){let xt=Math.min(Tt+ie,C);for(let J=Le;J<lt;J++)for(let Ye=st;Ye<Et;Ye++){let Be=0;for(let tt=Tt;tt<xt;tt++){let Ue=R[Ce*V+J*K+tt*Q],St=N[tt*O+Ye*j+Re*X];Be+=Ue*St}ge[we*te+(J*M+Ye)]+=Be}}}}}return n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(E),n.makeTensorInfo(b,le.dtype,le.values)}var D3e={kernelName:Pf,backendName:"cpu",kernelFunc:qZ};function P3e(t){let{inputs:e,backend:n,attrs:r}=t,{a:i,b:s,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r,h,p,f,g=[];h=qZ({inputs:{a:i,b:s},attrs:{transposeA:l,transposeB:u},backend:n}),a&&(p=s0({inputs:{a:h,b:a},backend:n}),g.push(h),h=p),c&&(f=jI(n,h,c,o,d),g.push(h),h=f);for(let y of g)n.disposeIntermediateTensorInfo(y);return h}var L3e={kernelName:Xp,backendName:"cpu",kernelFunc:P3e},O3e=mr(If,t=>Math.acos(t)),B3e={kernelName:If,backendName:"cpu",kernelFunc:O3e},U3e=mr(Tf,t=>Math.acosh(t)),$3e={kernelName:Tf,backendName:"cpu",kernelFunc:U3e};function z3e(t){let{inputs:e,backend:n}=t,r=e;Zt(e,"addN");let i=r.map(o=>n.data.get(o.dataId).values),s=Rn(r[0].shape,r[0].dtype),a=s.values;for(let o=0;o<r.length;o++){let l=i[o];for(let u=0;u<a.length;u++)a[u]+=l[u]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}var G3e={kernelName:Cf,backendName:"cpu",kernelFunc:z3e};function H3e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r;Zt(i,"all");let o=P.parseAxisParam(s,i.shape),l=o,u=W.getAxesPermutation(l,i.shape.length),c=i;u!=null&&(c=ha({inputs:{x:i},backend:n,attrs:{perm:u}}),l=W.getInnerMostAxes(l.length,i.shape.length)),W.assertAxesAreInnerMostDims("all",l,c.shape.length);let[d,h]=W.computeOutAndReduceShapes(c.shape,l),p=P.sizeFromShape(h),f=P.makeZerosTypedArray(P.sizeFromShape(d),c.dtype),g=n.data.get(c.dataId).values;for(let m=0;m<f.length;++m){let b=m*p,w=g[b];for(let _=0;_<p;++_){let S=g[b+_];w=w&&S}f[m]=w}u!=null&&n.disposeIntermediateTensorInfo(c);let y=n.makeTensorInfo(d,c.dtype,f);if(a){let m=W.expandShapeToKeepDim(d,o),b=kr({inputs:{x:y},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(y),b}return y}var W3e={kernelName:b0,backendName:"cpu",kernelFunc:H3e};function V3e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r;Zt(i,"any");let o=P.parseAxisParam(s,i.shape),l=o,u=W.getAxesPermutation(l,i.shape.length),c=i;u!=null&&(c=ha({inputs:{x:i},backend:n,attrs:{perm:u}}),l=W.getInnerMostAxes(l.length,i.shape.length)),W.assertAxesAreInnerMostDims("any",l,c.shape.length);let[d,h]=W.computeOutAndReduceShapes(c.shape,l),p=P.sizeFromShape(h),f=P.makeZerosTypedArray(P.sizeFromShape(d),c.dtype),g=n.data.get(c.dataId).values;for(let m=0;m<f.length;++m){let b=m*p,w=g[b];for(let _=0;_<p;++_){let S=g[b+_];w=w||S}f[m]=w}u!=null&&n.disposeIntermediateTensorInfo(c);let y=n.makeTensorInfo(d,c.dtype,f);if(a){let m=W.expandShapeToKeepDim(d,o),b=kr({inputs:{x:y},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(y),b}return y}var j3e={kernelName:w0,backendName:"cpu",kernelFunc:V3e};function X3e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s}=r;Zt(i,"argMax");let a=P.parseAxisParam(s,i.shape),o=W.getAxesPermutation(a,i.shape.length),l=i,u=[];o!=null&&(l=ha({inputs:{x:i},backend:n,attrs:{perm:o}}),u.push(l),a=W.getInnerMostAxes(a.length,l.shape.length)),a=[a[0]],W.assertAxesAreInnerMostDims("argMax",a,l.shape.length);let[c,d]=W.computeOutAndReduceShapes(l.shape,a),h=P.sizeFromShape(c),p=P.makeZerosTypedArray(h,"int32"),f=P.sizeFromShape(d),g=n.data.get(l.dataId).values;for(let y=0;y<p.length;++y){let m=y*f,b=g[m],w=0;for(let _=0;_<f;++_){let S=g[m+_];S>b&&(b=S,w=_)}p[y]=w}return u.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(c,"int32",p)}var K3e={kernelName:_0,backendName:"cpu",kernelFunc:X3e};function q3e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s}=r;Zt(i,"argMin");let a=P.parseAxisParam(s,i.shape),o=W.getAxesPermutation(a,i.shape.length),l=i,u=[];o!=null&&(l=ha({inputs:{x:i},backend:n,attrs:{perm:o}}),u.push(l),a=W.getInnerMostAxes(a.length,l.shape.length)),a=[a[0]],W.assertAxesAreInnerMostDims("argMin",a,l.shape.length);let[c,d]=W.computeOutAndReduceShapes(l.shape,a),h=P.sizeFromShape(c),p=P.makeZerosTypedArray(h,"int32"),f=P.sizeFromShape(d),g=n.data.get(l.dataId).values;for(let y=0;y<p.length;++y){let m=y*f,b=g[m],w=0;for(let _=0;_<f;++_){let S=g[m+_];S<b&&(b=S,w=_)}p[y]=w}return u.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(c,"int32",p)}var J3e={kernelName:S0,backendName:"cpu",kernelFunc:q3e},Y3e=mr(Mf,t=>Math.asin(t)),Z3e={kernelName:Mf,backendName:"cpu",kernelFunc:Y3e},Q3e=mr(kf,t=>Math.asinh(t)),eLe={kernelName:kf,backendName:"cpu",kernelFunc:Q3e},tLe=mr(Nf,t=>Math.atan(t)),nLe={kernelName:Nf,backendName:"cpu",kernelFunc:tLe},rLe=di((t,e)=>Math.atan2(t,e)),iLe=Di(Ff,rLe),sLe={kernelName:Ff,backendName:"cpu",kernelFunc:iLe},aLe=mr(Rf,t=>Math.atanh(t)),oLe={kernelName:Rf,backendName:"cpu",kernelFunc:aLe};function JB(t,e,n,r,i,s){let a=i.strideHeight,o=i.strideWidth,l=i.dilationHeight,u=i.dilationWidth,c=i.effectiveFilterHeight,d=i.effectiveFilterWidth,h=i.padInfo.top,p=i.padInfo.left,f=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=Rn(i.outShape,n),y=g.values,m=i.outShape[1]*i.outShape[2]*i.outShape[3],b=i.outShape[2]*i.outShape[3],w=i.outShape[3];for(let _=0;_<i.batchSize;++_){let S=_*m,E=_*r[0];for(let C=0;C<i.inChannels;++C)for(let T=0;T<i.outHeight;++T){let M=T*a-h,k=Math.max(0,M),R=Math.min(i.inHeight,c+M),N=S+T*b;for(let B=0;B<i.outWidth;++B){let z=B*o-p,V=Math.max(0,z),K=Math.min(i.inWidth,d+z),Q=f,O=0,j=0;for(let te=k;te<R;te+=l){let le=E+te*r[1];for(let ge=V;ge<K;ge+=u){let ie=le+ge*r[2],we=t[ie+C];s==="max"&&we>Q?Q=we:s==="avg"&&(O+=we,j++)}if(isNaN(Q))break}let X=N+B*w+C;y[X]=s==="avg"?O/j:Q}}}return g}function JZ(t,e,n,r,i=!1,s=!1){let a=Rn(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,g=Rn(e,n,t);for(let y=0;y<r.batchSize;++y)for(let m=0;m<r.inChannels;++m)for(let b=0;b<r.outHeight;++b){let w=b*o-p,_=w;for(;_<0;)_+=u;let S=Math.min(r.inHeight,d+w);for(let E=0;E<r.outWidth;++E){let C=E*l-f,T=C;for(;T<0;)T+=c;let M=Math.min(r.inWidth,h+C),k=Number.NEGATIVE_INFINITY,R=-1;for(let N=_;N<S;N+=u){let B=N-w;for(let z=T;z<M;z+=c){let V=z-C,K=g.get(y,N,z,m);K>k&&(k=K,i?R=s?((y*r.inHeight+N)*r.inWidth+z)*r.inChannels+m:(N*r.inWidth+z)*r.inChannels+m:R=B*h+V)}}a.set(R,y,b,E,m)}}return a}function YZ(t,e,n,r,i,s){let a=i.strideDepth,o=i.strideHeight,l=i.strideWidth,u=i.dilationDepth,c=i.dilationHeight,d=i.dilationWidth,h=i.effectiveFilterDepth,p=i.effectiveFilterHeight,f=i.effectiveFilterWidth,g=i.padInfo.front,y=i.padInfo.top,m=i.padInfo.left,b=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=Rn(i.outShape,n),_=w.values,S=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],E=i.outShape[2]*i.outShape[3]*i.outShape[4],C=i.outShape[3]*i.outShape[4],T=i.outShape[4];for(let M=0;M<i.batchSize;++M){let k=M*S,R=M*r[0];for(let N=0;N<i.inChannels;++N)for(let B=0;B<i.outDepth;++B){let z=B*a-g,V=z;for(;V<0;)V+=u;let K=Math.min(i.inDepth,h+z),Q=k+B*E;for(let O=0;O<i.outHeight;++O){let j=O*o-y,X=j;for(;X<0;)X+=c;let te=Math.min(i.inHeight,p+j),le=Q+O*C;for(let ge=0;ge<i.outWidth;++ge){let ie=ge*l-m,we=ie;for(;we<0;)we+=d;let Ce=Math.min(i.inWidth,f+ie),Re=le+ge*T,Le=b,lt=0,st=0;for(let Tt=V;Tt<K;Tt+=u){let xt=R+Tt*r[1];for(let J=X;J<te;J+=c){let Ye=xt+J*r[2];for(let Be=we;Be<Ce;Be+=d){let tt=Ye+Be*r[3],Ue=t[tt+N];if(s==="max"&&Ue>Le?Le=Ue:s==="avg"&&(lt+=Ue,st++),isNaN(Le))break}if(isNaN(Le))break}if(isNaN(Le))break}let Et=Re+N;_[Et]=s==="avg"?lt/Math.max(st,1):Le}}}}return w}function lLe(t,e){let n=Rn(e.outShape,"int32"),r=e.strideDepth,i=e.strideHeight,s=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let g=0;g<e.batchSize;++g)for(let y=0;y<e.inChannels;++y)for(let m=0;m<e.outDepth;++m){let b=m*r-h,w=b;for(;w<0;)w+=a;let _=Math.min(e.inDepth,u+b);for(let S=0;S<e.outHeight;++S){let E=S*i-p,C=E;for(;C<0;)C+=o;let T=Math.min(e.inHeight,c+E);for(let M=0;M<e.outWidth;++M){let k=M*s-f,R=k;for(;R<0;)R+=l;let N=Math.min(e.inWidth,d+k),B=Number.NEGATIVE_INFINITY,z=-1;for(let V=w;V<_;V+=a){let K=V-b;for(let Q=C;Q<T;Q+=o){let O=Q-E;for(let j=R;j<N;j+=l){let X=j-k,te=t.get(g,V,Q,j,y);te>=B&&(B=te,z=K*c*d+O*c+X)}}}n.set(z,g,m,S,M,y)}}}return n}function uLe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e;Zt(i,"avgPool");let{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=r,u=1;P.assert(W.eitherStridesOrDilationsAreOne(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=W.computePool2DInfo(i.shape,s,a,u,o,l),d;if(c.filterWidth===1&&c.filterHeight===1&&P.arraysEqual(c.inShape,c.outShape))d=mu({inputs:{x:i},backend:n});else{let h=n.data.get(i.dataId).values,p=P.computeStrides(i.shape),f=JB(h,i.shape,i.dtype,p,c,"avg");d=n.makeTensorInfo(c.outShape,i.dtype,f.values)}return d}var cLe={kernelName:Df,backendName:"cpu",kernelFunc:uLe};function dLe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{filterSize:s,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=r;Zt(i,"avgPool3d");let c=W.computePool3DInfo(i.shape,s,a,1,o,l,u),d=n.data.get(i.dataId).values,h=YZ(d,i.shape,i.dtype,P.computeStrides(i.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}var hLe={kernelName:A0,backendName:"cpu",kernelFunc:dLe};function pLe(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=r;Zt([i,s],"avgPool3DGrad");let c=W.computePool3DInfo(s.shape,a,o,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,g=c.filterHeight,y=c.filterWidth,m=c.dilationDepth,b=c.dilationHeight,w=c.dilationWidth,_=c.effectiveFilterDepth,S=c.effectiveFilterHeight,E=c.effectiveFilterWidth,C=_-1-c.padInfo.front,T=E-1-c.padInfo.left,M=S-1-c.padInfo.top,k=Rn(s.shape,"float32"),R=1/(f*g*y),N=n.bufferSync(i);for(let B=0;B<c.batchSize;++B)for(let z=0;z<c.inChannels;++z)for(let V=0;V<c.inDepth;++V)for(let K=0;K<c.inHeight;++K)for(let Q=0;Q<c.inWidth;++Q){let O=V-C,j=K-M,X=Q-T,te=0;for(let le=0;le<_;le+=m){let ge=(O+le)/d;if(!(ge<0||ge>=c.outDepth||Math.floor(ge)!==ge))for(let ie=0;ie<S;ie+=b){let we=(j+ie)/h;if(!(we<0||we>=c.outHeight||Math.floor(we)!==we))for(let Ce=0;Ce<E;Ce+=w){let Re=(X+Ce)/p;if(Re<0||Re>=c.outWidth||Math.floor(Re)!==Re)continue;let Le=N.get(B,ge,we,Re,z);te+=Le}}}k.set(te*R,B,V,K,Q,z)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var fLe={kernelName:sw,backendName:"cpu",kernelFunc:pLe};function mLe(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,a=s;Zt([i,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=W.computePool2DInfo(a.shape,o,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,g=c.dilationHeight,y=c.dilationWidth,m=c.effectiveFilterHeight,b=c.effectiveFilterWidth,w=b-1-c.padInfo.left,_=m-1-c.padInfo.top,S=Rn(a.shape,"float32"),E=1/(p*f),C=n.data.get(i.dataId).values,T=Rn(i.shape,"float32",C);for(let M=0;M<c.batchSize;++M)for(let k=0;k<c.inChannels;++k)for(let R=0;R<c.inHeight;++R)for(let N=0;N<c.inWidth;++N){let B=R-_,z=N-w,V=0;for(let K=0;K<m;K+=g){let Q=(B+K)/d;if(!(Q<0||Q>=c.outHeight||Math.floor(Q)!==Q))for(let O=0;O<b;O+=y){let j=(z+O)/h;if(j<0||j>=c.outWidth||Math.floor(j)!==j)continue;let X=T.get(M,Q,j,k);V+=X}}S.set(V*E,M,R,N,k)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}var gLe={kernelName:iw,backendName:"cpu",kernelFunc:mLe};function yLe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,scale:s,offset:a,mean:o,variance:l}=e;P.assert(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),P.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),P.assert(s==null||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Zt([i,o,l,s,a],"batchNorm");let{varianceEpsilon:u}=r;u==null&&(u=.001);let c=n.data.get(i.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(l.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=a?n.data.get(a.dataId).values:new Float32Array([0]),g=new Float32Array(c.length),y=f.length,m=p.length,b=h.length,w=d.length,_=0,S=0,E=0,C=0;for(let T=0;T<c.length;++T)g[T]=f[_++]+(c[T]-d[S++])*p[E++]/Math.sqrt(h[C++]+u),_>=y&&(_=0),S>=w&&(S=0),E>=m&&(E=0),C>=b&&(C=0);return n.makeTensorInfo(i.shape,i.dtype,g)}var vLe={kernelName:Qf,backendName:"cpu",kernelFunc:yLe};function xLe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:s,crops:a}=r;Zt([i],"batchToSpaceND");let o=s.reduce((m,b)=>m*b),l=W.getReshaped(i.shape,s,o),u=W.getPermuted(l.length,s.length),c=W.getReshapedPermuted(i.shape,s,o),d=W.getSliceBeginCoords(a,s.length),h=W.getSliceSize(c,a,s.length),p=kr({inputs:{x:i},backend:n,attrs:{shape:l}}),f=ha({inputs:{x:p},backend:n,attrs:{perm:u}}),g=kr({inputs:{x:f},backend:n,attrs:{shape:c}}),y=lf({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),y}var bLe={kernelName:E0,backendName:"cpu",kernelFunc:xLe};function wLe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,weights:s}=e,{size:a}=r,o=n.data.get(i.dataId).values,l=n.data.get(s.dataId).values,u=UB(o,l,s.dtype,s.shape,a);return n.makeTensorInfo([a],s.dtype,u)}var _Le={kernelName:I0,backendName:"cpu",kernelFunc:wLe};function SLe(t){let{inputs:e,backend:n}=t,{s0:r,s1:i}=e,s=n.data.get(r.dataId).values,a=n.data.get(i.dataId).values,o=W.assertAndGetBroadcastShape(Array.from(s),Array.from(a));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var ALe={kernelName:aw,backendName:"cpu",kernelFunc:SLe},ELe=mr(nh,(t,e)=>{let n=e;return t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t}),ILe={kernelName:nh,backendName:"cpu",kernelFunc:ELe},TLe=t=>{let{x:e}=t.inputs,n=t.backend,r=new Float32Array(P.sizeFromShape(e.shape)),i=n.data.get(e.dataId),s=i.complexTensorInfos.real,a=i.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values;for(let u=0;u<o.length;u++){let c=o[u],d=l[u];r[u]=Math.hypot(c,d)}return n.makeOutput(r,e.shape,"float32")},CLe={kernelName:ow,backendName:"cpu",kernelFunc:TLe};function a0(t){let{inputs:e,backend:n}=t,{input:r}=e,i=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(i.dataId).values;return n.makeTensorInfo(i.shape,i.dtype,s)}var MLe={kernelName:hC,backendName:"cpu",kernelFunc:a0};function o0(t){let{inputs:e,backend:n,attrs:r}=t,{axis:i}=r,s=P.parseAxisParam(i,e[0].shape)[0],a=e.map(g=>g.shape);W.assertParamsConsistent(a,s);let o=W.computeOutShape(e.map(g=>g.shape),s);if(P.sizeFromShape(o)===0)return n.makeTensorInfo(o,e[0].dtype,[]);let l=e.filter(g=>P.sizeFromShape(g.shape)>0);if(l.length===1)return mu({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){let g=l.map(_=>of({inputs:{input:_},backend:n})),y=l.map(_=>a0({inputs:{input:_},backend:n})),m=o0({inputs:g,backend:n,attrs:{axis:s}}),b=o0({inputs:y,backend:n,attrs:{axis:s}}),w=Ta({inputs:{real:m,imag:b},backend:n});return g.forEach(_=>n.disposeIntermediateTensorInfo(_)),y.forEach(_=>n.disposeIntermediateTensorInfo(_)),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),w}let u=l.map(g=>{let y=[-1,P.sizeFromShape(g.shape.slice(s))];return kr({inputs:{x:g},backend:n,attrs:{shape:y}})}),c=u.map(g=>({vals:n.data.get(g.dataId).values,shape:g.shape}));o=W.computeOutShape(u.map(g=>g.shape),1);let d=u[0].shape[0]===1,h=$B(c,o,e[0].dtype,d),p=W.computeOutShape(l.map(g=>g.shape),s),f=n.makeTensorInfo(p,e[0].dtype,h);return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),f}var kLe={kernelName:C0,backendName:"cpu",kernelFunc:o0};function ZZ(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:a,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;Zt([i,s],"conv2d");let d=W.convertConv2DDataFormat(l),h=W.computeConv2DInfo(i.shape,s.shape,a,u,o,c,!1,d),p=h.filterHeight,f=h.filterWidth,g=h.dilationHeight,y=h.dilationWidth,m=h.padInfo.left,b=h.padInfo.top,w=h.dataFormat==="channelsLast",_=new vi(h.outShape,i.dtype),S=P.computeStrides(i.shape),E=P.computeStrides(s.shape),C=S[0],T=w?S[1]:S[2],M=w?S[2]:1,k=w?1:S[1],R=_.strides[0],N=w?_.strides[1]:_.strides[2],B=w?_.strides[2]:1,z=w?1:_.strides[1],V=n.data.get(i.dataId).values,K=n.data.get(s.dataId).values,Q=_.values;for(let O=0;O<h.batchSize;++O){let j=O*C,X=O*R;for(let te=0;te<h.outHeight;++te){let le=X+te*N,ge=te*h.strideHeight-b;for(let ie=0;ie<p;++ie){let we=ge+ie*g;if(we<0||we>=h.inHeight)continue;let Ce=ie*E[0],Re=j+we*T;for(let Le=0;Le<h.outWidth;++Le){let lt=le+Le*B,st=Le*h.strideWidth-m;for(let Et=0;Et<f;++Et){let Tt=st+Et*y;if(Tt<0||Tt>=h.inWidth)continue;let xt=Ce+Et*E[1],J=Re+Tt*M,Ye=xt;for(let Be=0;Be<h.inChannels;++Be){let tt=V[J+Be*k];for(let Ue=0;Ue<h.outChannels;++Ue)Q[lt+Ue*z]+=tt*K[Ye+Ue];Ye+=h.outChannels}}}}}}return n.makeTensorInfo(_.shape,_.dtype,Q)}var NLe={kernelName:Bf,backendName:"cpu",kernelFunc:ZZ};function RLe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,dy:s}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;Zt([i,s],"conv2dBackpropFilter");let d=W.convertConv2DDataFormat(l),h=W.computeConv2DInfo(i.shape,c,a,1,o,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:g,filterWidth:y}=h,m=h.dataFormat==="channelsLast",b=new vi(h.filterShape,"float32"),w=h.padInfo.left,_=h.padInfo.top,S=n.data.get(i.dataId).values,E=n.data.get(s.dataId).values,C=new vi(i.shape,i.dtype,S),T=new vi(s.shape,s.dtype,E);for(let M=0;M<g;++M){let k=Math.max(0,Math.ceil((_-M)/p)),R=Math.min(h.outHeight,(h.inHeight+_-M)/p);for(let N=0;N<y;++N){let B=Math.max(0,Math.ceil((w-N)/f)),z=Math.min(h.outWidth,(h.inWidth+w-N)/f);for(let V=0;V<h.inChannels;++V)for(let K=0;K<h.outChannels;++K){let Q=0;for(let O=0;O<h.batchSize;++O)for(let j=k;j<R;++j){let X=M+j*p-_;for(let te=B;te<z;++te){let le=N+te*f-w;m?Q+=C.get(O,X,le,V)*T.get(O,j,te,K):Q+=C.get(O,V,X,le)*T.get(O,K,j,te)}}b.set(Q,M,N,V,K)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var FLe={kernelName:sC,backendName:"cpu",kernelFunc:RLe};function DLe(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:s}=e,{inputShape:a,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;Zt([i,s],"conv2dBackpropInput");let d=P.computeStrides(s.shape),h=P.computeStrides(i.shape),p=W.convertConv2DDataFormat(u),f=W.computeConv2DInfo(a,s.shape,o,1,l,c,!1,p),g=new vi(f.inShape,"float32"),y=g.values,m=n.data.get(i.dataId).values,b=n.data.get(s.dataId).values,[w,_,S]=d,{batchSize:E,filterHeight:C,filterWidth:T,inChannels:M,inHeight:k,inWidth:R,outChannels:N,outHeight:B,outWidth:z,strideHeight:V,strideWidth:K}=f;p=f.dataFormat;let Q=C-1-f.padInfo.top,O=T-1-f.padInfo.left,j=p==="channelsLast",X=g.strides[0],te=j?g.strides[1]:g.strides[2],le=j?g.strides[2]:1,ge=j?1:g.strides[1],ie=h[0],we=j?h[1]:h[2],Ce=j?h[2]:1,Re=j?1:h[1];for(let Le=0;Le<E;++Le)for(let lt=0;lt<M;++lt)for(let st=0;st<k;++st){let Et=st-Q,Tt=Math.max(0,Math.ceil(Et/V)),xt=Math.min(B,(C+Et)/V);for(let J=0;J<R;++J){let Ye=J-O,Be=Math.max(0,Math.ceil(Ye/K)),tt=Math.min(z,(T+Ye)/K),Ue=0;for(let Je=Tt;Je<xt;++Je){let At=Je*V-Et;for(let Vt=Be;Vt<tt;++Vt){let re=Vt*K-Ye,H=ie*Le+we*Je+Ce*Vt,Ee=w*(C-1-At)+_*(T-1-re)+S*lt;for(let Oe=0;Oe<N;++Oe){let Xe=m[H+Re*Oe],$e=b[Ee+Oe];Ue+=Xe*$e}}}let St=X*Le+te*st+le*J+ge*lt;y[St]=Ue}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var PLe={kernelName:Uf,backendName:"cpu",kernelFunc:DLe};function LLe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:a,pad:o,dilations:l}=r;Zt([i,s],"conv3d");let u=W.computeConv3DInfo(i.shape,s.shape,a,l,o),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:g,padInfo:y}=u,m=y.front,b=y.left,w=y.top,_=new vi(u.outShape,i.dtype),S=n.data.get(i.dataId).values,E=n.data.get(s.dataId).values,C=_.values,T=P.computeStrides(i.shape),M=P.computeStrides(s.shape);for(let k=0;k<u.batchSize;++k){let R=k*T[0],N=k*_.strides[0];for(let B=0;B<u.outDepth;++B){let z=N+B*_.strides[1],V=B*u.strideDepth-m;for(let K=0;K<c;++K){let Q=V+K*p;if(Q<0||Q>=u.inDepth)continue;let O=K*M[0],j=R+Q*T[1];for(let X=0;X<u.outHeight;++X){let te=z+X*_.strides[2],le=X*u.strideHeight-w;for(let ge=0;ge<d;++ge){let ie=le+ge*f;if(ie<0||ie>=u.inHeight)continue;let we=O+ge*M[1],Ce=j+ie*T[2];for(let Re=0;Re<u.outWidth;++Re){let Le=te+Re*u.outChannels,lt=Re*u.strideWidth-b;for(let st=0;st<h;++st){let Et=lt+st*g;if(Et<0||Et>=u.inWidth)continue;let Tt=we+st*M[2],xt=Ce+Et*u.inChannels,J=Tt;for(let Ye=0;Ye<u.inChannels;++Ye){let Be=S[xt+Ye];for(let tt=0;tt<u.outChannels;++tt)C[Le+tt]+=Be*E[J+tt];J+=u.outChannels}}}}}}}}return n.makeTensorInfo(_.shape,_.dtype,_.values)}var OLe={kernelName:$f,backendName:"cpu",kernelFunc:LLe};function BLe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,dy:s}=e,{strides:a,pad:o,filterShape:l}=r;Zt([i,s],"conv3dBackpropFilterV2");let u=P.computeStrides(i.shape),c=P.computeStrides(s.shape),d=W.computeConv3DInfo(i.shape,l,a,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,g=d.filterDepth,y=d.filterHeight,m=d.filterWidth,b=new vi(d.filterShape,"float32"),w=b.values,[_,S,E,C]=b.strides,T=n.data.get(s.dataId).values,[M,k,R,N]=c,B=n.data.get(i.dataId).values,[z,V,K,Q]=u,O=d.padInfo.front,j=d.padInfo.left,X=d.padInfo.top;for(let te=0;te<g;++te){let le=Math.max(0,Math.ceil((O-te)/h)),ge=Math.min(d.outDepth,(d.inDepth+O-te)/h),ie=te*_;for(let we=0;we<y;++we){let Ce=Math.max(0,Math.ceil((X-we)/p)),Re=Math.min(d.outHeight,(d.inHeight+X-we)/p),Le=we*S+ie;for(let lt=0;lt<m;++lt){let st=Math.max(0,Math.ceil((j-lt)/f)),Et=Math.min(d.outWidth,(d.inWidth+j-lt)/f),Tt=lt*E+Le;for(let xt=0;xt<d.inChannels;++xt){let J=xt*C+Tt;for(let Ye=0;Ye<d.outChannels;++Ye){let Be=0;for(let tt=0;tt<d.batchSize;++tt){let Ue=tt*z,St=tt*M;for(let Je=le;Je<ge;++Je){let At=(te+Je*h-O)*V+Ue,Vt=Je*k+St;for(let re=Ce;re<Re;++re){let H=(we+re*p-X)*K+At,Ee=re*R+Vt;for(let Oe=st;Oe<Et;++Oe){let Xe=(lt+Oe*f-j)*Q+H,$e=Oe*N+Ee;Be+=B[Xe+xt]*T[$e+Ye]}}}}w[J+Ye]=Be}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var ULe={kernelName:M0,backendName:"cpu",kernelFunc:BLe};function $Le(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:s}=e,{pad:a,strides:o,inputShape:l}=r;Zt([i],"conv3dBackpropInputV2");let u=P.computeStrides(i.shape),c=P.computeStrides(s.shape),d=W.computeConv3DInfo(l,s.shape,o,1,a),h=new vi(d.inShape,"float32"),p=h.values,[f,g,y,m]=h.strides,b=n.data.get(i.dataId).values,[w,_,S,E]=u,C=n.data.get(s.dataId).values,[T,M,k,R]=c,{batchSize:N,filterDepth:B,filterHeight:z,filterWidth:V,inChannels:K,inDepth:Q,inHeight:O,inWidth:j,outChannels:X,outDepth:te,outHeight:le,outWidth:ge,strideDepth:ie,strideHeight:we,strideWidth:Ce}=d,Re=B-1-d.padInfo.front,Le=z-1-d.padInfo.top,lt=V-1-d.padInfo.left;for(let st=0;st<N;++st)for(let Et=0;Et<K;++Et)for(let Tt=0;Tt<Q;++Tt){let xt=Tt-Re,J=Math.max(0,Math.ceil(xt/ie)),Ye=Math.min(te,(B+xt)/ie);for(let Be=0;Be<O;++Be){let tt=Be-Le,Ue=Math.max(0,Math.ceil(tt/we)),St=Math.min(le,(z+tt)/we);for(let Je=0;Je<j;++Je){let At=Je-lt,Vt=Math.max(0,Math.ceil(At/Ce)),re=Math.min(ge,(V+At)/Ce),H=0;for(let Ee=J;Ee<Ye;++Ee){let Oe=Ee*ie-xt;for(let Xe=Ue;Xe<St;++Xe){let $e=Xe*we-tt;for(let Lt=Vt;Lt<re;++Lt){let wt=Lt*Ce-At,Pt=w*st+_*Ee+S*Xe+E*Lt,Ht=T*(B-1-Oe)+M*(z-1-$e)+k*(V-1-wt)+R*Et;for(let et=0;et<X;++et){let mt=b[Pt+et],Ot=C[Ht+et];H+=mt*Ot}}}}p[f*st+g*Tt+y*Be+m*Je+Et]=H}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}var zLe={kernelName:k0,backendName:"cpu",kernelFunc:$Le},GLe=mr(zf,t=>Math.cos(t)),HLe={kernelName:zf,backendName:"cpu",kernelFunc:GLe},WLe=mr(Gf,t=>Math.cosh(t)),VLe={kernelName:Gf,backendName:"cpu",kernelFunc:WLe};function jLe(t){let{inputs:e,backend:n,attrs:r}=t,{image:i,boxes:s,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:u}=r,[c,d,h,p]=i.shape,f=s.shape[0],[g,y]=o,m=Rn([f,g,y,p],"float32"),b=n.data.get(s.dataId).values,w=n.data.get(a.dataId).values,_=n.data.get(i.dataId).values,S=P.computeStrides(i.shape),E=P.computeStrides(m.shape);for(let C=0;C<f;C++){let T=C*4,M=b[T],k=b[T+1],R=b[T+2],N=b[T+3],B=w[C];if(B>=c)continue;let z=g>1?(R-M)*(d-1)/(g-1):0,V=y>1?(N-k)*(h-1)/(y-1):0;for(let K=0;K<g;K++){let Q=g>1?M*(d-1)+K*z:.5*(M+R)*(d-1);if(Q<0||Q>d-1){for(let O=0;O<y;O++)for(let j=0;j<p;j++){let X=j+O*E[2]+K*E[1]+C*E[0];m.values[X]=u}continue}if(l==="bilinear"){let O=Math.floor(Q),j=Math.ceil(Q),X=Q-O;for(let te=0;te<y;te++){let le=y>1?k*(h-1)+te*V:.5*(k+N)*(h-1);if(le<0||le>h-1){for(let Ce=0;Ce<p;Ce++){let Re=Ce+te*E[2]+K*E[1]+C*E[0];m.values[Re]=u}continue}let ge=Math.floor(le),ie=Math.ceil(le),we=le-ge;for(let Ce=0;Ce<p;Ce++){let Re=Ce+ge*S[2]+O*S[1]+B*S[0],Le=_[Re];Re=Ce+ie*S[2]+O*S[1]+B*S[0];let lt=_[Re];Re=Ce+ge*S[2]+j*S[1]+B*S[0];let st=_[Re];Re=Ce+ie*S[2]+j*S[1]+B*S[0];let Et=_[Re],Tt=Le+(lt-Le)*we,xt=st+(Et-st)*we;Re=Ce+te*E[2]+K*E[1]+C*E[0],m.values[Re]=Tt+(xt-Tt)*X}}}else for(let O=0;O<y;++O){let j=y>1?k*(h-1)+O*V:.5*(k+N)*(h-1);if(j<0||j>h-1){for(let le=0;le<p;le++){let ge=le+O*E[2]+K*E[1]+C*E[0];m.values[ge]=u}continue}let X=Math.round(j),te=Math.round(Q);for(let le=0;le<p;le++){let ge=le+X*S[2]+te*S[1]+B*S[0],ie=le+O*E[2]+K*E[1]+C*E[0];m.values[ie]=_[ge]}}}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var XLe={kernelName:R0,backendName:"cpu",kernelFunc:jLe};function KLe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,exclusive:a,reverse:o}=r;Zt(i,"cumprod");let l=W.getAxesPermutation([s],i.shape.length),u=i;l!=null&&(u=ha({inputs:{x:i},backend:n,attrs:{perm:l}}));let c=W.getInnerMostAxes(1,i.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let d=uo(u.dtype,"int32"),h=P.makeOnesTypedArray(P.sizeFromShape(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],g=o?(m,b)=>m+f-b-1:(m,b)=>m+b;for(let m=0;m<p.length;m+=f)for(let b=0;b<f;b++){let w=g(m,b);if(b===0)h[w]=a?1:p[w];else{let _=g(m,b-1);h[w]=a?p[_]*h[_]:p[w]*h[_]}}let y=n.makeTensorInfo(u.shape,d,h);if(l!=null){let m=W.getUndoAxesPermutation(l),b=ha({inputs:{x:y},backend:n,attrs:{perm:m}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(u),b}return y}var qLe={kernelName:N0,backendName:"cpu",kernelFunc:KLe};function JLe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,exclusive:a,reverse:o}=r;Zt(i,"cumsum");let l=W.getAxesPermutation([s],i.shape.length),u=i;l!=null&&(u=ha({inputs:{x:i},backend:n,attrs:{perm:l}}));let c=W.getInnerMostAxes(1,i.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let d=uo(u.dtype,"int32"),h=P.makeZerosTypedArray(P.sizeFromShape(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],g=o?(m,b)=>m+f-b-1:(m,b)=>m+b;for(let m=0;m<p.length;m+=f)for(let b=0;b<f;b++){let w=g(m,b);if(b===0)h[w]=a?0:p[w];else{let _=g(m,b-1);h[w]=a?p[_]+h[_]:p[w]+h[_]}}let y=n.makeTensorInfo(u.shape,d,h);if(l!=null){let m=W.getUndoAxesPermutation(l),b=ha({inputs:{x:y},backend:n,attrs:{perm:m}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(u),b}return y}var YLe={kernelName:Hf,backendName:"cpu",kernelFunc:JLe};function ZLe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,weights:s}=e,{size:a,binaryOutput:o}=r;if(i.shape.length===1){let l=n.data.get(i.dataId).values,u=n.data.get(s.dataId).values,c=UB(l,u,s.dtype,s.shape,a);return n.makeTensorInfo([a],s.dtype,c)}else if(i.shape.length===2){let l=n.bufferSync(i),u=n.bufferSync(s),c=aZ(l,u,a,o);return n.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}var QLe={kernelName:lw,backendName:"cpu",kernelFunc:ZLe};function eOe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockSize:s,dataFormat:a}=r;P.assert(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);let o=i.shape[0],l=i.shape[1],u=i.shape[2],c=i.shape[3],d=l*s,h=u*s,p=c/(s*s),f=n.data.get(i.dataId).values,g=new Float32Array(o*d*h*p),y=0;for(let m=0;m<o;++m)for(let b=0;b<d;++b){let w=Math.floor(b/s),_=b%s;for(let S=0;S<h;++S){let E=Math.floor(S/s),C=S%s,T=(_*s+C)*p;for(let M=0;M<p;++M){let k=M+T+c*(E+u*(w+l*m));g[y++]=f[k]}}}return n.makeTensorInfo([o,d,h,p],i.dtype,g)}var tOe={kernelName:F0,backendName:"cpu",kernelFunc:eOe};function QZ(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:a,pad:o,dilations:l,dimRoundingMode:u}=r;Zt([i,s],"depthwiseConv2DNative");let c=P.computeStrides(i.shape),d=P.computeStrides(s.shape),h=l;h==null&&(h=[1,1]),P.assert(W.eitherStridesOrDilationsAreOne(a,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${h}'`);let p=W.computeConv2DInfo(i.shape,s.shape,a,h,o,u,!0),{filterHeight:f,filterWidth:g,dilationHeight:y,dilationWidth:m,padInfo:b}=p,w=b.left,_=b.top,S=p.outChannels/p.inChannels,E=new vi(p.outShape,i.dtype),C=n.data.get(i.dataId).values,T=n.data.get(s.dataId).values,M=E.values;for(let k=0;k<p.batchSize;++k){let R=k*c[0],N=k*E.strides[0];for(let B=0;B<p.outHeight;++B){let z=N+B*E.strides[1],V=B*p.strideHeight-_;for(let K=0;K<f;++K){let Q=V+K*y;if(Q<0||Q>=p.inHeight)continue;let O=K*d[0],j=R+Q*c[1];for(let X=0;X<p.outWidth;++X){let te=z+X*E.strides[2],le=X*p.strideWidth-w;for(let ge=0;ge<g;++ge){let ie=le+ge*m;if(ie<0||ie>=p.inWidth)continue;let we=O+ge*d[1],Ce=j+ie*p.inChannels,Re=te,Le=we;for(let lt=0;lt<p.inChannels;++lt){let st=C[Ce+lt];for(let Et=0;Et<S;++Et)M[Re+Et]+=st*T[Le+Et];Re+=S,Le+=S}}}}}}return n.makeTensorInfo(E.shape,E.dtype,E.values)}var nOe={kernelName:Wf,backendName:"cpu",kernelFunc:QZ};function rOe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,dy:s}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;Zt([i,s],"depthwiseConv2dNativeBackpropFilter");let d=W.computeConv2DInfo(i.shape,c,a,o,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:g}=d,y=new vi(d.filterShape,"float32"),m=d.padInfo.left,b=d.padInfo.top,w=d.outChannels/d.inChannels,_=n.data.get(i.dataId).values,S=new vi(i.shape,i.dtype,_),E=n.data.get(s.dataId).values,C=new vi(s.shape,s.dtype,E);for(let T=0;T<f;++T){let M=Math.max(0,Math.ceil((b-T)/h)),k=Math.min(d.outHeight,(d.inHeight+b-T)/h);for(let R=0;R<g;++R){let N=Math.max(0,Math.ceil((m-R)/p)),B=Math.min(d.outWidth,(d.inWidth+m-R)/p);for(let z=0;z<d.outChannels;++z){let V=Math.trunc(z/w),K=z%w,Q=0;for(let O=0;O<d.batchSize;++O)for(let j=M;j<k;++j){let X=T+j*h-b;for(let te=N;te<B;++te){let le=R+te*p-m;Q+=S.get(O,X,le,V)*C.get(O,j,te,z)}}y.set(Q,T,R,V,K)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var iOe={kernelName:aC,backendName:"cpu",kernelFunc:rOe};function sOe(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:s}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;Zt([i,s],"depthwiseConv2DNativeBackpropInput");let d=P.computeStrides(i.shape),h=P.computeStrides(s.shape),p=W.computeConv2DInfo(c,s.shape,a,o,l,u,!0),f=new vi(p.inShape,"float32"),g=f.values,[y,m,b]=f.strides,w=n.data.get(i.dataId).values,[_,S,E]=d,C=n.data.get(s.dataId).values,[T,M,k]=h,{batchSize:R,filterHeight:N,filterWidth:B,inChannels:z,inHeight:V,inWidth:K,outChannels:Q,outHeight:O,outWidth:j,strideHeight:X,strideWidth:te}=p,le=N-1-p.padInfo.top,ge=B-1-p.padInfo.left,ie=Q/z;for(let we=0;we<R;++we)for(let Ce=0;Ce<z;++Ce)for(let Re=0;Re<V;++Re){let Le=Re-le,lt=Math.max(0,Math.ceil(Le/X)),st=Math.min(O,(N+Le)/X);for(let Et=0;Et<K;++Et){let Tt=Et-ge,xt=Math.max(0,Math.ceil(Tt/te)),J=Math.min(j,(B+Tt)/te),Ye=0;for(let Be=lt;Be<st;++Be){let tt=Be*X-Le;for(let Ue=xt;Ue<J;++Ue){let St=Ue*te-Tt,Je=_*we+S*Be+E*Ue,At=T*(N-1-tt)+M*(B-1-St)+k*Ce;for(let Vt=0;Vt<ie;++Vt){let re=Ce*ie+Vt,H=w[Je+re],Ee=C[At+Vt];Ye+=H*Ee}}}g[y*we+m*Re+b*Et+Ce]=Ye}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var aOe={kernelName:oC,backendName:"cpu",kernelFunc:sOe};function oOe(t){let{inputs:e,backend:n}=t,{x:r}=e,i=P.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,a=Rn([i,i],r.dtype),o=a.values;for(let u=0;u<s.length;u++)o[u*i+u]=s[u];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,a.dtype,a.values)}var lOe={kernelName:uw,backendName:"cpu",kernelFunc:oOe},uOe={kernelName:Vf,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{let{x:r,filter:i}=t,{strides:s,pad:a,dilations:o}=n,l=e,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(i.dataId).values,h=i.shape.length,{batchSize:p,inHeight:f,inWidth:g,inChannels:y,outHeight:m,outWidth:b,padInfo:w,strideHeight:_,strideWidth:S,filterHeight:E,filterWidth:C,dilationHeight:T,dilationWidth:M,outShape:k}=W.computeDilation2DInfo(r.shape,i.shape,s,a,"NHWC",o),R=P.sizeFromShape(k),N=k.length,B=P.getArrayFromDType(r.dtype,R);for(let z=0;z<p;++z)for(let V=0;V<m;++V){let K=V*_-w.top;for(let Q=0;Q<b;++Q){let O=Q*S-w.left;for(let j=0;j<y;++j){let X=Number.MIN_SAFE_INTEGER;for(let le=0;le<E;++le){let ge=K+le*T;if(ge>=0&&ge<f)for(let ie=0;ie<C;++ie){let we=O+ie*M;if(we>=0&&we<g){let Ce=P.locToIndex([z,ge,we,j],c,P.computeStrides(r.shape)),Re=P.locToIndex([le,ie,j],h,P.computeStrides(i.shape)),Le=u[Ce]+d[Re];Le>X&&(X=Le)}}}let te=P.locToIndex([z,V,Q,j],N,P.computeStrides(k));B[te]=X}}}return{dataId:l.write(P.toTypedArray(B,r.dtype),k,r.dtype),shape:k,dtype:r.dtype}}},cOe={kernelName:Xy,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{let{x:r,filter:i,dy:s}=t,{strides:a,pad:o,dilations:l}=n,u=e,c=P.toNestedArray(r.shape,u.data.get(r.dataId).values),d=P.toNestedArray(i.shape,u.data.get(i.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:g,outHeight:y,outWidth:m,padInfo:b,strideHeight:w,strideWidth:_,filterHeight:S,filterWidth:E,dilationHeight:C,dilationWidth:T,outShape:M}=W.computeDilation2DInfo(r.shape,i.shape,a,o,"NHWC",l);P.assert(s.rank===M.length,()=>`Error in ${Xy}, dy must have the same rank as output ${M.length}, but got ${s.rank}`);let k=P.toNestedArray(M,u.data.get(s.dataId).values),R=P.makeZerosNestedTypedArray(i.shape,i.dtype);for(let N=0;N<h;++N)for(let B=0;B<y;++B){let z=B*w-b.top;for(let V=0;V<m;++V){let K=V*_-b.left;for(let Q=0;Q<g;++Q){let O=Number.MIN_SAFE_INTEGER,j=0,X=0;for(let te=0;te<S;++te){let le=z+te*C;if(le>=0&&le<p)for(let ge=0;ge<E;++ge){let ie=K+ge*T;if(ie>=0&&ie<f){let we=c[N][le][ie][Q]+d[te][ge][Q];we>O&&(O=we,j=te,X=ge)}}}R[j][X][Q]+=k[N][B][V][Q]}}}return{dataId:u.write(P.toTypedArray(R,r.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},dOe={kernelName:jy,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{let{x:r,filter:i,dy:s}=t,{strides:a,pad:o,dilations:l}=n,u=e,c=P.toNestedArray(r.shape,u.data.get(r.dataId).values),d=P.toNestedArray(i.shape,u.data.get(i.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:g,outHeight:y,outWidth:m,padInfo:b,strideHeight:w,strideWidth:_,filterHeight:S,filterWidth:E,dilationHeight:C,dilationWidth:T,outShape:M}=W.computeDilation2DInfo(r.shape,i.shape,a,o,"NHWC",l);P.assert(s.rank===M.length,()=>`Error in ${jy}, dy must have the same rank as output ${M.length}, but got ${s.rank}`);let k=P.toNestedArray(M,u.data.get(s.dataId).values),R=P.makeZerosNestedTypedArray(r.shape,r.dtype);for(let N=0;N<h;++N)for(let B=0;B<y;++B){let z=B*w-b.top;for(let V=0;V<m;++V){let K=V*_-b.left;for(let Q=0;Q<g;++Q){let O=Number.MIN_SAFE_INTEGER,j=z<0?0:z,X=K<0?0:K;for(let te=0;te<S;++te){let le=z+te*C;if(le>=0&&le<p)for(let ge=0;ge<E;++ge){let ie=K+ge*T;if(ie>=0&&ie<f){let we=c[N][le][ie][Q]+d[te][ge][Q];we>O&&(O=we,j=le,X=ie)}}}R[N][j][X][Q]+=k[N][B][V][Q]}}}return{dataId:u.write(P.toTypedArray(R,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function hOe(t){let{inputs:e,backend:n,attrs:r}=t,{image:i}=e,{canvas:s,options:a}=r,{contextOptions:o,imageOptions:l}=a||{},u=(l==null?void 0:l.alpha)||1,c=(o==null?void 0:o.contextType)||"2d";if(c!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let d=s.getContext(c,(o==null?void 0:o.contextAttributes)||{});if(d==null)throw new Error(`Could not get the context with ${c} type.`);let[h,p]=i.shape.slice(0,2),f=i.shape.length===2?1:i.shape[2],g=n.data.get(i.dataId).values,y=i.dtype==="float32"?255:1,m=new Uint8ClampedArray(p*h*4);for(let w=0;w<h*p;++w){let _=[0,0,0,255*u];for(let E=0;E<f;E++){let C=g[w*f+E];if(i.dtype==="float32"){if(C<0||C>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${C}.`)}else if(i.dtype==="int32"&&(C<0||C>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${C}.`);f===1?(_[0]=C*y,_[1]=C*y,_[2]=C*y):_[E]=C*y}let S=w*4;m[S+0]=Math.round(_[0]),m[S+1]=Math.round(_[1]),m[S+2]=Math.round(_[2]),m[S+3]=Math.round(_[3])}s.width=p,s.height=h;let b=new ImageData(m,p,h);return d.putImageData(b,0,0),i}var pOe={kernelName:lC,backendName:"cpu",kernelFunc:hOe};function Qw(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r;Zt(i,"sum");let o;i.dtype==="bool"?o=Hd({inputs:{x:i},backend:n,attrs:{dtype:"int32"}}):o=mu({inputs:{x:i},backend:n});let l=o.shape.length,u=P.parseAxisParam(s,o.shape),c=W.getAxesPermutation(u,l),d=u,h=o;c!=null&&(h=ha({inputs:{x:o},backend:n,attrs:{perm:c}}),d=W.getInnerMostAxes(d.length,l)),W.assertAxesAreInnerMostDims("sum",d,h.shape.length);let[p,f]=W.computeOutAndReduceShapes(h.shape,d),g=W.upcastType(h.dtype,"int32"),y=WI(n,p,g),m=P.sizeFromShape(f),b=n.data.get(y.dataId).values,w=n.data.get(h.dataId).values;for(let _=0;_<b.length;++_){let S=_*m,E=0;for(let C=0;C<m;++C)E+=w[S+C];b[_]=E}if(a){let _=W.expandShapeToKeepDim(y.shape,u),S=y;y=kr({inputs:{x:y},backend:n,attrs:{shape:_}}),n.disposeIntermediateTensorInfo(S)}return n.disposeIntermediateTensorInfo(o),c!=null&&n.disposeIntermediateTensorInfo(h),y}var fOe={kernelName:Bm,backendName:"cpu",kernelFunc:Qw};function mOe(t){let{inputs:e,backend:n,attrs:r}=t,{equation:i}=r,s=e,{allDims:a,summedDims:o,idDims:l}=W.decodeEinsumEquation(i,s.length);W.checkEinsumDimSizes(a.length,l,s);let{path:u,steps:c}=W.getEinsumComputePath(o,l),d=c.length,h=null,p=a.length,f=[];for(let g=0;g<d;++g){for(let y of c[g]){let{permutationIndices:m,expandDims:b}=W.getEinsumPermutation(p,l[y]),w;W.isIdentityPermutation(m)?w=s[y]:(w=ha({inputs:{x:s[y]},backend:n,attrs:{perm:m}}),f.push(w));let _=w.shape.slice();for(let S=0;S<b.length;++S)_.splice(b[S],0,1);P.arraysEqual(w.shape,_)||(w=kr({inputs:{x:w},backend:n,attrs:{shape:_}}),f.push(w)),h===null?h=w:(h=_M({inputs:{a:w,b:h},backend:n}),f.push(h))}g<d-1&&(u[g]>=0&&(h=Qw({inputs:{x:h},backend:n,attrs:{axis:u[g]-(a.length-p),keepDims:!1}}),f.push(h)),p--)}for(let g of f)g!==h&&n.disposeIntermediateTensorInfo(g);return h}var gOe={kernelName:uC,backendName:"cpu",kernelFunc:mOe};function yOe(t){let{inputs:e,backend:n}=t,{dy:r,y:i}=e;Zt([r,i],"eluGrad");let s=new Float32Array(P.sizeFromShape(i.shape)),a=n.data.get(i.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<a.length;++l){let u=a[l];u>=0?s[l]=o[l]:s[l]=o[l]*(u+1)}return n.makeTensorInfo(i.shape,"float32",s)}var vOe={kernelName:D0,backendName:"cpu",kernelFunc:yOe},xOe=W.ERF_P,bOe=W.ERF_A1,wOe=W.ERF_A2,_Oe=W.ERF_A3,SOe=W.ERF_A4,AOe=W.ERF_A5,EOe=mr(Kf,t=>{let e=Math.sign(t),n=Math.abs(t),r=1/(1+xOe*n);return e*(1-((((AOe*r+SOe)*r+_Oe)*r+wOe)*r+bOe)*r*Math.exp(-n*n))}),IOe={kernelName:Kf,backendName:"cpu",kernelFunc:EOe};function XI(t){let{inputs:e,backend:n,attrs:r}=t,{input:i}=e,{dim:s}=r,a=i.shape.length,o=i.shape.slice(),l=s;return s<0&&(P.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+s+1),o.splice(l,0,1),kr({inputs:{x:i},backend:n,attrs:{shape:o}})}var TOe={kernelName:L0,backendName:"cpu",kernelFunc:XI},COe=di((t,e)=>t/e),YB=Di(jf,COe),KF={kernelName:jf,backendName:"cpu",kernelFunc:YB};function eQ(t,e,n){let r=t.shape,i=r[0],s=r[1],a=n.data.get(t.dataId),o=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,u=[i,s],c=P.sizeFromShape(u),d=P.getTypedArrayFromDType("float32",c),h=P.getTypedArrayFromDType("float32",c);for(let y=0;y<i;y++){let m=lf({inputs:{x:o},backend:n,attrs:{begin:[y,0],size:[1,s]}}),b=lf({inputs:{x:l},backend:n,attrs:{begin:[y,0],size:[1,s]}}),w=Ta({inputs:{real:m,imag:b},backend:n}),{real:_,imag:S}=MOe(w,e,n),E=W.mergeRealAndImagArrays(_,S);for(let C=0;C<s;C++){let T=W.getComplexWithIndex(E,C);d[y*s+C]=T.real,h[y*s+C]=T.imag}n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(w)}let p=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",h),g=Ta({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),g}function MOe(t,e,n){let r=P.sizeFromShape(t.shape),i=n.data.get(t.dataId),s=n.data.get(i.complexTensorInfos.real.dataId).values,a=n.data.get(i.complexTensorInfos.imag.dataId).values;if(kOe(r)){let o=qF(s,a,r,e,n),l=[t.shape[0],t.shape[1]];if(e){let u=n.makeTensorInfo(l,"float32",o.real),c=n.makeTensorInfo(l,"float32",o.imag),d=n.makeTensorInfo([],"float32",P.createScalarValue(r,"float32")),h=mu({inputs:{x:d},backend:n}),p=KF.kernelFunc({inputs:{a:u,b:d},backend:n}),f=KF.kernelFunc({inputs:{a:c,b:h},backend:n}),g=n.data.get(p.dataId).values,y=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),{real:g,imag:y}}return o}else{let o=W.mergeRealAndImagArrays(s,a),l=NOe(o,r,e);return W.splitRealAndImagArrays(l)}}function kOe(t){return(t&t-1)===0}function qF(t,e,n,r,i){if(n===1)return{real:t,imag:e};let s=W.mergeRealAndImagArrays(t,e),a=n/2,o=W.complexWithEvenIndex(s),l=o.real,u=o.imag,c=[l.length],d=i.makeTensorInfo(c,"float32",l),h=i.makeTensorInfo(c,"float32",u),p=Ta({inputs:{real:d,imag:h},backend:i}),f=W.complexWithOddIndex(s),g=f.real,y=f.imag,m=[g.length],b=i.makeTensorInfo(m,"float32",g),w=i.makeTensorInfo(m,"float32",y),_=Ta({inputs:{real:b,imag:w},backend:i}),S=qF(l,u,a,r,i),E=S.real,C=S.imag,T=[E.length],M=i.makeTensorInfo(T,"float32",E),k=i.makeTensorInfo(T,"float32",C),R=Ta({inputs:{real:M,imag:k},backend:i}),N=qF(g,y,a,r,i),B=N.real,z=N.imag,V=[B.length],K=i.makeTensorInfo(V,"float32",B),Q=i.makeTensorInfo(V,"float32",z),O=Ta({inputs:{real:K,imag:Q},backend:i}),j=W.exponents(n,r),X=[j.real.length],te=i.makeTensorInfo(X,"float32",j.real),le=i.makeTensorInfo(X,"float32",j.imag),ge=Ta({inputs:{real:te,imag:le},backend:i}),ie=_M({inputs:{a:ge,b:O},backend:i}),we=s0({inputs:{a:R,b:ie},backend:i}),Ce=KB({inputs:{a:R,b:ie},backend:i}),Re=of({inputs:{input:we},backend:i}),Le=of({inputs:{input:Ce},backend:i}),lt=a0({inputs:{input:we},backend:i}),st=a0({inputs:{input:Ce},backend:i}),Et=o0({inputs:[Re,Le],backend:i,attrs:{axis:0}}),Tt=o0({inputs:[lt,st],backend:i,attrs:{axis:0}}),xt=i.data.get(Et.dataId).values,J=i.data.get(Tt.dataId).values;return i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(p),i.disposeIntermediateTensorInfo(b),i.disposeIntermediateTensorInfo(w),i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(M),i.disposeIntermediateTensorInfo(k),i.disposeIntermediateTensorInfo(R),i.disposeIntermediateTensorInfo(K),i.disposeIntermediateTensorInfo(Q),i.disposeIntermediateTensorInfo(O),i.disposeIntermediateTensorInfo(te),i.disposeIntermediateTensorInfo(le),i.disposeIntermediateTensorInfo(ge),i.disposeIntermediateTensorInfo(ie),i.disposeIntermediateTensorInfo(we),i.disposeIntermediateTensorInfo(Ce),i.disposeIntermediateTensorInfo(Re),i.disposeIntermediateTensorInfo(lt),i.disposeIntermediateTensorInfo(Le),i.disposeIntermediateTensorInfo(st),i.disposeIntermediateTensorInfo(Et),i.disposeIntermediateTensorInfo(Tt),{real:xt,imag:J}}function NOe(t,e,n){let r=new Float32Array(e*2);for(let i=0;i<e;i++){let s=0,a=0;for(let o=0;o<e;o++){let l=W.exponent(i*o,e,n),u=W.getComplexWithIndex(t,o);s+=u.real*l.real-u.imag*l.imag,a+=u.real*l.imag+u.imag*l.real}n&&(s/=e,a/=e),W.assignToTypedArray(r,s,a,i)}return r}function ROe(t){let{inputs:e,backend:n}=t,{input:r}=e,i=P.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],a=i/s,o=kr({inputs:{x:r},backend:n,attrs:{shape:[a,s]}}),l=eQ(o,!1,n),u=kr({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var FOe={kernelName:cC,backendName:"cpu",kernelFunc:ROe};function ZB(t){let{backend:e,attrs:n}=t,{shape:r,value:i,dtype:s}=n,a=s||P.inferDtype(i),o=P.getArrayFromDType(a,P.sizeFromShape(r));return POe(o,i),e.makeTensorInfo(r,a,o)}var DOe={kernelName:cw,backendName:"cpu",kernelFunc:ZB};function POe(t,e,n){t.fill(e)}var LOe={kernelName:O0,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{let{image:r}=t,i=n,s=P.getTypedArrayFromDType(r.dtype,P.sizeFromShape(r.shape)),[a,o,l,u]=r.shape,c=i.data.get(r.dataId).values;for(let d=0;d<a;d++){let h=d*l*o*u;for(let p=0;p<o;p++){let f=p*(l*u);for(let g=0;g<l;g++){let y=g*u;for(let m=0;m<u;m++){let b=Math.round(l-g-1),w=h+f+y+m,_=c[w];if(b>=0&&b<l){let S=b*u,E=h+f+S+m;_=c[E]}s[w]=_}}}}return{dataId:i.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function OOe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,g=ZZ({inputs:{x:i,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(a){let y=g;if(c==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){let m=kr({inputs:{x:a},backend:n,attrs:{shape:[a.shape[0],1,1]}});g=s0({inputs:{a:g,b:m},backend:n}),n.disposeIntermediateTensorInfo(m)}else g=s0({inputs:{a:g,b:a},backend:n});n.disposeIntermediateTensorInfo(y)}if(p){let y=g;if(c==="NCHW"&&p==="prelu"&&o.shape.length===1&&o.shape[0]!==1){let m=kr({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});g=jI(n,g,p,m,f),n.disposeIntermediateTensorInfo(m)}else g=jI(n,g,p,o,f);n.disposeIntermediateTensorInfo(y)}return g}var BOe={kernelName:Kp,backendName:"cpu",kernelFunc:OOe};function UOe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,g=QZ({inputs:{x:i,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(a){let y=g;g=s0({inputs:{a:g,b:a},backend:n}),n.disposeIntermediateTensorInfo(y)}if(p){let y=g;g=jI(n,g,p,o,f),n.disposeIntermediateTensorInfo(y)}return g}var $Oe={kernelName:qp,backendName:"cpu",kernelFunc:UOe};function zOe(t){let{inputs:e,backend:n}=t,{params:r,indices:i}=e,s=P.sizeFromShape(r.shape),a=i.shape,o=a[a.length-1],[l,u,c,d]=W.prepareAndValidate(r,i);if(u===0)return n.makeTensorInfo(l,r.dtype,[]);let h=n.data.get(i.dataId).values,p=n.bufferSync(r),f=gZ(h,p,r.dtype,u,o,c,d,r.shape,s);return n.makeTensorInfo(l,r.dtype,f.values)}var GOe={kernelName:U0,backendName:"cpu",kernelFunc:zOe};function HOe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,indices:s}=e,{axis:a,batchDims:o}=r;Zt([i,s],"gatherV2");let l=P.parseAxisParam(a,i.shape)[0],u=n.data.get(s.dataId).values,c=i.shape[l];for(let _=0;_<u.length;++_){let S=u[_];P.assert(S<=c-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${c-1}]`)}let d=o;o==null&&(d=0);let h=P.sizeFromShape(s.shape),p=W.segment_util.collectGatherOpShapeInfo(i,s,l,d),f=kr({inputs:{x:i},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=kr({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),y=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],m=n.bufferSync(g),b=n.bufferSync(f),w=yZ(b,m,y);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.makeTensorInfo(p.outputShape,w.dtype,w.values)}var WOe={kernelName:B0,backendName:"cpu",kernelFunc:HOe};function VOe(t){let{inputs:e,backend:n}=t,{input:r}=e,i=P.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],a=i/s,o=kr({inputs:{x:r},backend:n,attrs:{shape:[a,s]}}),l=eQ(o,!0,n),u=kr({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var jOe={kernelName:dC,backendName:"cpu",kernelFunc:VOe},XOe=mr(nm,t=>Number.isFinite(t)?1:0,"bool"),KOe={kernelName:nm,backendName:"cpu",kernelFunc:XOe},qOe=mr(rm,t=>Math.abs(t)===1/0?1:0,"bool"),JOe={kernelName:rm,backendName:"cpu",kernelFunc:qOe},YOe=mr(im,t=>Number.isNaN(t)?1:0,"bool"),ZOe={kernelName:im,backendName:"cpu",kernelFunc:YOe};function QOe(t){let{backend:e,attrs:n}=t,{start:r,stop:i,num:s}=n,a=_Z(r,i,s);return e.makeTensorInfo([a.length],"float32",a)}var eBe={kernelName:H0,backendName:"cpu",kernelFunc:QOe},tBe=mr(om,t=>Math.log1p(t)),nBe={kernelName:om,backendName:"cpu",kernelFunc:tBe},rBe=di((t,e)=>t&&e),iBe=Di(W0,rBe,null,"bool"),sBe={kernelName:W0,backendName:"cpu",kernelFunc:iBe},aBe=mr(V0,t=>t?0:1,"bool"),oBe={kernelName:V0,backendName:"cpu",kernelFunc:aBe},lBe=di((t,e)=>t||e),uBe=Di(j0,lBe,null,"bool"),cBe={kernelName:j0,backendName:"cpu",kernelFunc:uBe};function dBe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{depthRadius:s,bias:a,alpha:o,beta:l}=r;Zt(i,"LRN");let u=i.shape[3],c=u-1,d=n.data.get(i.dataId).values,h=P.sizeFromShape(i.shape),p=new Float32Array(h);function f(g){let y=g%u,m=g-y+Math.max(0,y-s),b=g-y+Math.min(y+s,c),w=0;for(;m<=b;m++){let _=d[m];w+=_*_}return w}for(let g=0;g<h;g++){let y=f(g),m=d[g]*Math.pow(a+o*y,-l);p[g]=m}return n.makeTensorInfo(i.shape,i.dtype,p)}var hBe={kernelName:lm,backendName:"cpu",kernelFunc:dBe};function pBe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,y:s,dy:a}=e,{depthRadius:o,bias:l,alpha:u,beta:c}=r;Zt(a,"LRNGrad");let d=P.sizeFromShape(a.shape),h=a.shape[3],p=n.data.get(a.dataId).values,f=n.data.get(i.dataId).values,g=n.data.get(s.dataId).values,y=new Float32Array(d),m=d;for(let b=0;b<m;b++){let w=b%h,_=b-w+Math.max(0,w-o),S=b-w+Math.min(h,w+o+1),E=0;for(let C=_;C<S;C++)E+=Math.pow(f[C],2);E=u*E+l;for(let C=_;C<S;C++){let T=-2*u*c*f[C]*g[b]/E;b===C&&(T+=Math.pow(E,-c)),T*=p[b],y[C]+=T}}return n.makeTensorInfo(a.shape,i.dtype,y)}var fBe={kernelName:X0,backendName:"cpu",kernelFunc:pBe};function tQ(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{reductionIndices:s,keepDims:a}=r,o=n,l=i.shape,u=l.length,c=P.parseAxisParam(s,l),d=c,h=W.getAxesPermutation(d,u),p=o.data.get(i.dataId).values;if(h!=null){let _=new Array(u);for(let S=0;S<_.length;S++)_[S]=l[h[S]];p=GB(p,l,i.dtype,h,_),d=W.getInnerMostAxes(d.length,u),l=_}Zt(i,"max"),W.assertAxesAreInnerMostDims("max",d,u);let[f,g]=W.computeOutAndReduceShapes(l,d),y=P.sizeFromShape(g),m=AZ(p,y,f,i.dtype),b=o.write(m,f,i.dtype),w=f;return a&&(w=W.expandShapeToKeepDim(f,c)),{dataId:b,shape:w,dtype:i.dtype}}var mBe={kernelName:um,backendName:"cpu",kernelFunc:tQ};function gBe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e;Zt(i,"maxPool");let{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=r,u=1;P.assert(W.eitherStridesOrDilationsAreOne(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=W.computePool2DInfo(i.shape,s,a,u,o,l),d;if(c.filterWidth===1&&c.filterHeight===1&&P.arraysEqual(c.inShape,c.outShape))d=mu({inputs:{x:i},backend:n});else{let h=n.data.get(i.dataId).values,p=P.computeStrides(i.shape),f=JB(h,i.shape,i.dtype,p,c,"max");d=n.makeTensorInfo(c.outShape,i.dtype,f.values)}return d}var yBe={kernelName:dm,backendName:"cpu",kernelFunc:gBe};function vBe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{filterSize:s,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=r;Zt(i,"maxPool3d");let c=W.computePool3DInfo(i.shape,s,a,1,o,l,u),d=n.data.get(i.dataId).values,h=YZ(d,i.shape,i.dtype,P.computeStrides(i.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}var xBe={kernelName:K0,backendName:"cpu",kernelFunc:vBe};function bBe(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=r;Zt([i,s],"maxPool3DGrad");let c=W.computePool3DInfo(s.shape,a,o,1,l,u),d=n.bufferSync(s),h=lLe(d,c),p=c.strideDepth,f=c.strideHeight,g=c.strideWidth,y=c.dilationDepth,m=c.dilationHeight,b=c.dilationWidth,w=c.effectiveFilterDepth,_=c.effectiveFilterHeight,S=c.effectiveFilterWidth,E=w-1-c.padInfo.front,C=S-1-c.padInfo.left,T=_-1-c.padInfo.top,M=Rn(s.shape,"float32"),k=n.bufferSync(i);for(let R=0;R<c.batchSize;++R)for(let N=0;N<c.inChannels;++N)for(let B=0;B<c.inDepth;++B)for(let z=0;z<c.inHeight;++z)for(let V=0;V<c.inWidth;++V){let K=B-E,Q=z-T,O=V-C,j=0;for(let X=0;X<w;X+=y){let te=(K+X)/p;if(!(te<0||te>=c.outDepth||Math.floor(te)!==te))for(let le=0;le<_;le+=m){let ge=(Q+le)/f;if(!(ge<0||ge>=c.outHeight||Math.floor(ge)!==ge))for(let ie=0;ie<S;ie+=b){let we=(O+ie)/g;if(we<0||we>=c.outWidth||Math.floor(we)!==we)continue;let Ce=w*_*S-1-h.get(R,te,ge,we,N),Re=X*_*S+le*S+ie,Le=Ce===Re?1:0;if(Le===0)continue;let lt=k.get(R,te,ge,we,N);j+=lt*Le}}}M.set(j,R,B,z,V,N)}return n.makeTensorInfo(M.shape,M.dtype,M.values)}var wBe={kernelName:hw,backendName:"cpu",kernelFunc:bBe};function _Be(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s,output:a}=e,o=s;Zt([s,a],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=W.computePool2DInfo(o.shape,l,u,1,c,d),p=n.data.get(o.dataId).values,f=Rn(h.outShape,o.dtype,JZ(p,o.shape,o.dtype,h).values),g=h.strideHeight,y=h.strideWidth,m=h.dilationHeight,b=h.dilationWidth,w=h.effectiveFilterHeight,_=h.effectiveFilterWidth,S=_-1-h.padInfo.left,E=w-1-h.padInfo.top,C=Rn(o.shape,"float32"),T=n.data.get(i.dataId).values,M=Rn(i.shape,"float32",T);for(let k=0;k<h.batchSize;++k)for(let R=0;R<h.inChannels;++R)for(let N=0;N<h.inHeight;++N)for(let B=0;B<h.inWidth;++B){let z=N-E,V=B-S,K=0;for(let Q=0;Q<w;Q+=m){let O=(z+Q)/g;if(!(O<0||O>=h.outHeight||Math.floor(O)!==O))for(let j=0;j<_;j+=b){let X=(V+j)/y;if(X<0||X>=h.outWidth||Math.floor(X)!==X)continue;let te=w*_-1-f.get(k,O,X,R),le=Q*_+j,ge=te===le?1:0;if(ge===0)continue;let ie=M.get(k,O,X,R);K+=ie*ge}}C.set(K,k,N,B,R)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}var SBe={kernelName:dw,backendName:"cpu",kernelFunc:_Be};function ABe(t,e,n,r,i){let s=P.computeStrides(e),a=JB(t,e,n,s,i,"max"),o=JZ(t,e,n,i,!0,r);return[a.values,o.values]}var EBe={kernelName:pw,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{let{x:r}=t,{filterSize:i,strides:s,pad:a,includeBatchInIndex:o}=e,l=n;Zt(r,"MaxPoolWithArgmax");let u=l.data.get(r.dataId).values,c=W.computePool2DInfo(r.shape,i,s,[1,1],a),[d,h]=ABe(u,r.shape,r.dtype,o,c),p=l.write(d,c.outShape,r.dtype),f=l.write(h,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};function IBe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r,o=P.parseAxisParam(s,i.shape),l=W.computeOutAndReduceShapes(i.shape,o)[1],u=P.sizeFromShape(l),c=[],d=n.makeTensorInfo([],"float32",new Float32Array([u]));c.push(d);let h=Hd({inputs:{x:i},backend:n,attrs:{dtype:"float32"}});c.push(h);let p=YB({inputs:{a:h,b:d},backend:n});c.push(p);let f=Qw({inputs:{x:p},backend:n,attrs:{axis:s,keepDims:a}});return c.forEach(g=>n.disposeIntermediateTensorInfo(g)),f}var TBe={kernelName:hm,backendName:"cpu",kernelFunc:IBe};function CBe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r;Zt(i,"min");let o=P.parseAxisParam(s,i.shape),l=o,u=W.getAxesPermutation(l,i.shape.length),c=i;u!=null&&(c=ha({inputs:{x:i},backend:n,attrs:{perm:u}}),l=W.getInnerMostAxes(l.length,i.shape.length)),W.assertAxesAreInnerMostDims("min",l,c.shape.length);let[d,h]=W.computeOutAndReduceShapes(c.shape,l),p=P.sizeFromShape(h),f=P.makeZerosTypedArray(P.sizeFromShape(d),c.dtype),g=n.data.get(c.dataId).values;for(let m=0;m<f.length;++m){let b=m*p,w=g[b];for(let _=0;_<p;++_){let S=g[b+_];(Number.isNaN(S)||S<w)&&(w=S)}f[m]=w}u!=null&&n.disposeIntermediateTensorInfo(c);let y=n.makeTensorInfo(d,c.dtype,f);if(a){let m=W.expandShapeToKeepDim(d,o),b=kr({inputs:{x:y},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(y),b}return y}var MBe={kernelName:pm,backendName:"cpu",kernelFunc:CBe};function kBe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{paddings:s,mode:a}=r;Zt(i,"mirrorPad");let o=s.map((b,w)=>b[0]+i.shape[w]+b[1]),l=s.map(b=>b[0]),u=s.map((b,w)=>b[0]+i.shape[w]),c=a==="reflect"?0:1,d=n.data.get(i.dataId).values,h=i.shape.length,p=P.computeStrides(i.shape),f=P.sizeFromShape(o),g=o.length,y=P.computeStrides(o),m=P.getTypedArrayFromDType(i.dtype,f);for(let b=0;b<f;b++){let w=P.indexToLoc(b,g,y);for(let S=0;S<g;S++)w[S]<l[S]?w[S]=l[S]*2-w[S]-c:w[S]>=u[S]&&(w[S]=(u[S]-1)*2-w[S]+c);w=w.map((S,E)=>S-l[E]);let _=P.locToIndex(w,h,p);m[b]=d[_]}return{dataId:n.write(m,o,i.dtype),shape:o,dtype:i.dtype}}var NBe={kernelName:mm,backendName:"cpu",kernelFunc:kBe},RBe=di((t,e)=>{let n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e}),FBe=Di(gm,RBe),DBe={kernelName:gm,backendName:"cpu",kernelFunc:FBe},PBe=eh(eC());function nQ(t){let{inputs:e,backend:n,attrs:r}=t,{logits:i}=e,{dim:s}=r,a=i.shape.length,o=s;if(o===-1&&(o=a-1),o!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${o}`);let l=P.parseAxisParam([o],i.shape),u=tQ({inputs:{x:i},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=W.expandShapeToKeepDim(u.shape,l),d=kr({inputs:{x:u},backend:n,attrs:{shape:c}}),h=KB({inputs:{a:i,b:d},backend:n}),p=hZ({inputs:{x:h},backend:n}),f=Qw({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),g=kr({inputs:{x:f},backend:n,attrs:{shape:c}}),y=YB({inputs:{a:p,b:g},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),y}var LBe={kernelName:Um,backendName:"cpu",kernelFunc:nQ};function OBe(t){let{inputs:e,backend:n,attrs:r}=t,{logits:i}=e,{numSamples:s,seed:a,normalized:o}=r;Zt(i,"multinomial");let l=o?i:nQ({inputs:{logits:i},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,h=[u,s],p=P.makeZerosTypedArray(P.sizeFromShape(h),"int32");for(let f=0;f<u;++f){let g=f*c,y=new Float32Array(c-1);y[0]=d[g];for(let w=1;w<y.length;++w)y[w]=y[w-1]+d[g+w];let m=PBe.alea(a.toString()),b=f*s;for(let w=0;w<s;++w){let _=m();p[b+w]=y.length;for(let S=0;S<y.length;S++)if(_<y[S]){p[b+w]=S;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",p)}var BBe={kernelName:q0,backendName:"cpu",kernelFunc:OBe},UBe=bu.nonMaxSuppressionV3Impl;function $Be(t){let{inputs:e,backend:n,attrs:r}=t,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=r;Zt(i,"NonMaxSuppression");let u=n.data.get(i.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:d}=UBe(u,c,a,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var zBe={kernelName:Z0,backendName:"cpu",kernelFunc:$Be},GBe=bu.nonMaxSuppressionV4Impl;function HBe(t){let{inputs:e,backend:n,attrs:r}=t,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;Zt(i,"NonMaxSuppressionPadded");let c=n.data.get(i.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:h,validOutputs:p}=GBe(c,d,a,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}var WBe={kernelName:Q0,backendName:"cpu",kernelFunc:HBe},VBe=bu.nonMaxSuppressionV5Impl;function jBe(t){let{inputs:e,backend:n,attrs:r}=t,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;Zt(i,"NonMaxSuppressionWithScore");let c=n.data.get(i.dataId).values,d=n.data.get(s.dataId).values,h=a,p=o,f=l,g=u,{selectedIndices:y,selectedScores:m}=VBe(c,d,h,p,f,g);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([m.length],"float32",new Float32Array(m))]}var XBe={kernelName:ev,backendName:"cpu",kernelFunc:jBe};function KBe(t){let{inputs:e,backend:n,attrs:r}=t,{indices:i}=e,{dtype:s,depth:a,onValue:o,offValue:l}=r;Zt(i,"oneHot");let u=P.sizeFromShape(i.shape),c=new Float32Array(u*a);c.fill(l);let d=n.data.get(i.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<a&&(c[h*a+d[h]]=o);return n.makeTensorInfo([...i.shape,a],s,c)}var qBe={kernelName:vm,backendName:"cpu",kernelFunc:KBe};function KI(t){let{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let i=of({inputs:{input:r},backend:n}),s=KI({inputs:{x:i},backend:n}),a=a0({inputs:{input:r},backend:n}),o=KI({inputs:{x:a},backend:n}),l=Ta({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),l}else return ZB({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var JBe={kernelName:xv,backendName:"cpu",kernelFunc:KI};function rQ(t){let{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let i=of({inputs:{input:r},backend:n}),s=rQ({inputs:{x:i},backend:n}),a=a0({inputs:{input:r},backend:n}),o=KI({inputs:{x:a},backend:n}),l=Ta({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),l}else return ZB({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var YBe={kernelName:tv,backendName:"cpu",kernelFunc:rQ};function iQ(t){let{inputs:e,backend:n,attrs:r}=t,{axis:i}=r;if(e.length===1)return XI({inputs:{input:e[0]},backend:n,attrs:{dim:i}});let s=e[0].shape,a=e[0].dtype;e.forEach(c=>{P.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),P.assert(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=e.map(c=>{let d=XI({inputs:{input:c},backend:n,attrs:{dim:i}});return o.push(d),d}),u=o0({inputs:l,backend:n,attrs:{axis:i}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}var ZBe={kernelName:nv,backendName:"cpu",kernelFunc:iQ};function QBe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{paddings:s,constantValue:a}=r;Zt(i,"pad");let o=s.map((m,b)=>m[0]+i.shape[b]+m[1]),l=s.map(m=>m[0]),u=n.data.get(i.dataId).values,c=P.sizeFromShape(i.shape),d=i.shape.length,h=P.computeStrides(i.shape),p=P.sizeFromShape(o),f=o.length,g=P.computeStrides(o),y=P.getTypedArrayFromDType(i.dtype,p);a!==0&&y.fill(a);for(let m=0;m<c;m++){let b=P.indexToLoc(m,d,h).map((_,S)=>_+l[S]),w=P.locToIndex(b,f,g);y[w]=u[m]}return{dataId:n.write(y,o,i.dtype),shape:o,dtype:i.dtype}}var sQ={kernelName:xm,backendName:"cpu",kernelFunc:QBe},eUe=di((t,e)=>Math.pow(t,e)),tUe=Di(bm,eUe),nUe={kernelName:bm,backendName:"cpu",kernelFunc:tUe};function rUe(t){let{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:i,paramsDenseValues:s,indices:a}=e,o=i.map(y=>n.data.get(y.dataId).values),l=i.map(y=>y.shape),u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,[d,h,p]=kZ(o,l,u,s.shape,s.dtype,c,a.shape),f=d.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(p,s.dtype,h);return f.concat([g])}var iUe={kernelName:pC,backendName:"cpu",kernelFunc:rUe};function sUe(t){let{inputs:e,backend:n}=t,{starts:r,limits:i,deltas:s}=e,a=n.data.get(r.dataId).values,o=n.data.get(i.dataId).values,l=n.data.get(s.dataId).values,[u,c]=NZ(a,r.shape,r.dtype,o,i.shape,l,s.shape),d=n.makeTensorInfo([u.length],"int32",u),h=n.makeTensorInfo([c.length],r.dtype,c);return[d,h]}var aUe={kernelName:fC,backendName:"cpu",kernelFunc:sUe};function oUe(t){let{inputs:e,backend:n,attrs:r}=t,{shape:i,values:s,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=r,u=n.data.get(i.dataId).values,c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,h=o.map(y=>n.data.get(y.dataId).values),p=o.map(y=>y.shape),[f,g]=RZ(u,i.shape,c,s.shape,s.dtype,d,a.shape,h,p,l);return n.makeTensorInfo(f,s.dtype,g)}var lUe={kernelName:mC,backendName:"cpu",kernelFunc:oUe};function uUe(t){let{backend:e,attrs:n}=t,{start:r,stop:i,dtype:s,step:a}=n,o=HB(r,i,a,s);return e.makeTensorInfo([o.length],s,o)}var cUe={kernelName:fw,backendName:"cpu",kernelFunc:uUe},dUe=mr(Sm,t=>1/t),hUe={kernelName:Sm,backendName:"cpu",kernelFunc:dUe};function pUe(t){let{inputs:e,backend:n,attrs:r}=t,{images:i}=e,{alignCorners:s,halfPixelCenters:a,size:o}=r;Zt(i,"resizeBilinear");let l=P.computeStrides(i.shape),[u,c]=o,[d,h,p,f]=i.shape,g=n.data.get(i.dataId).values,y=new Float32Array(P.sizeFromShape([d,u,c,f])),m=[s&&u>1?h-1:h,s&&c>1?p-1:p],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],w=0,_=m[0]/b[0],S=m[1]/b[1];for(let E=0;E<d;E++)for(let C=0;C<u;C++){let T;a?T=_*(C+.5)-.5:T=_*C;let M=Math.max(0,Math.floor(T)),k=T-M,R=Math.min(h-1,Math.ceil(T)),N=E*l[0]+M*l[1],B=E*l[0]+R*l[1];for(let z=0;z<c;z++){let V;a?V=S*(z+.5)-.5:V=S*z;let K=Math.max(0,Math.floor(V)),Q=V-K,O=Math.min(p-1,Math.ceil(V)),j=N+K*l[2],X=B+K*l[2],te=N+O*l[2],le=B+O*l[2];for(let ge=0;ge<f;ge++){let ie=g[j+ge],we=g[X+ge],Ce=g[te+ge],Re=g[le+ge],Le=ie+(Ce-ie)*Q,lt=we+(Re-we)*Q,st=Le+(lt-Le)*k;y[w++]=st}}}return n.makeTensorInfo([d,u,c,f],"float32",y)}var fUe={kernelName:Im,backendName:"cpu",kernelFunc:pUe};function mUe(t){let{inputs:e,backend:n,attrs:r}=t,{images:i,dy:s}=e,{alignCorners:a}=r;Zt([s,i],"resizeBilinearGrad");let o=P.computeStrides(i.shape),[l,u,c,d]=i.shape,[,h,p]=s.shape,f=new Float32Array(l*u*c*d),g=[a&&h>1?u-1:u,a&&p>1?c-1:c],y=[a&&h>1?h-1:h,a&&p>1?p-1:p],m=g[0]/y[0],b=g[1]/y[1],w=n.data.get(s.dataId).values,_=0;for(let S=0;S<l;S++){let E=S*o[0];for(let C=0;C<h;C++){let T=C*m,M=Math.floor(T),k=Math.min(Math.ceil(T),u-1),R=E+M*o[1],N=E+k*o[1],B=T-M,z=1-B;for(let V=0;V<p;V++){let K=V*b,Q=Math.floor(K),O=Math.min(Math.ceil(K),c-1),j=K-Q,X=1-j,te=R+Q*o[2],le=R+O*o[2],ge=N+Q*o[2],ie=N+O*o[2],we=z*X,Ce=z*j,Re=B*X,Le=B*j;for(let lt=0;lt<d;lt++){let st=w[_++];f[te+lt]+=st*we,f[le+lt]+=st*Ce,f[ge+lt]+=st*Re,f[ie+lt]+=st*Le}}}}return n.makeTensorInfo([l,c,u,d],"float32",f)}var gUe={kernelName:sv,backendName:"cpu",kernelFunc:mUe};function yUe(t){let{inputs:e,backend:n,attrs:r}=t,{images:i}=e,{alignCorners:s,halfPixelCenters:a,size:o}=r;Zt(i,"resizeNearestNeighbor");let l=P.computeStrides(i.shape),[u,c]=o,[d,h,p,f]=i.shape,g=n.data.get(i.dataId).values,y=new Float32Array(d*u*c*f),m=[s&&u>1?h-1:h,s&&c>1?p-1:p],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],w=m[0]/b[0],_=m[1]/b[1],S=0;for(let E=0;E<d;E++){let C=E*l[0];for(let T=0;T<u;T++){let M=a?w*(T+.5):w*T,k=Math.min(h-1,s?Math.round(M):Math.floor(M));a&&(k=Math.max(0,k));let R=C+k*l[1];for(let N=0;N<c;N++){let B=a?_*(N+.5):_*N,z=Math.min(p-1,s?Math.round(B):Math.floor(B));a&&(z=Math.max(0,z));let V=R+z*l[2];for(let K=0;K<f;K++){let Q=g[V+K];y[S++]=Q}}}}return n.makeTensorInfo([d,u,c,f],i.dtype,y)}var vUe={kernelName:Em,backendName:"cpu",kernelFunc:yUe};function xUe(t){let{inputs:e,backend:n,attrs:r}=t,{images:i,dy:s}=e,{alignCorners:a}=r;Zt([s,i],"resizeNearestNeighborGrad");let o=P.computeStrides(i.shape),l=P.computeStrides(s.shape),[u,c,d,h]=i.shape,[,p,f]=s.shape,g=new Float32Array(u*c*d*h),y=n.data.get(s.dataId).values,m=[a&&p>1?c-1:c,a&&f>1?d-1:d],b=[a&&p>1?p-1:p,a&&f>1?f-1:f],w=m[0]/b[0],_=m[1]/b[1],S=1/w,E=1/_,C=Math.ceil(S)*2+2,T=Math.ceil(E)*2+2;for(let M=0;M<u;M++){let k=M*o[0];for(let R=0;R<c;R++){let N=k+R*o[1],B=Math.floor(R*S),z=Math.floor(B-C/2);for(let V=0;V<d;V++){let K=N+V*o[2],Q=Math.floor(V*E),O=Math.floor(Q-T/2);for(let j=0;j<h;j++){let X=0;for(let te=0;te<C;te++){let le=te+z;if(le<0||le>=p)continue;let ge=k+le*l[1],ie=le*w,we=Math.min(c-1,a?Math.round(ie):Math.floor(ie));if(R===we)for(let Ce=0;Ce<T;Ce++){let Re=Ce+O;if(Re<0||Re>=f)continue;let Le=ge+Re*l[2],lt=Re*_,st=Math.min(d-1,a?Math.round(lt):Math.floor(lt));V===st&&(X+=y[Le+j])}}g[K+j]=X}}}}return n.makeTensorInfo(i.shape,i.dtype,g)}var bUe={kernelName:iv,backendName:"cpu",kernelFunc:xUe};function wUe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{dims:s}=r;Zt(i,"reverse");let a=i.shape.length,o=P.parseAxisParam(s,i.shape);if(a===0)return mu({inputs:{x:i},backend:n});let l=new vi(i.shape,i.dtype),u=n.bufferSync(i);for(let c=0;c<l.size;c++){let d=l.indexToLoc(c),h=d.slice();o.forEach(p=>h[p]=i.shape[p]-1-h[p]),l.set(u.get(...h),...d)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var _Ue={kernelName:Cm,backendName:"cpu",kernelFunc:wUe},SUe={kernelName:bv,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{let{image:r}=t,{radians:i,fillValue:s,center:a}=e,o=n,l=P.getTypedArrayFromDType(r.dtype,P.sizeFromShape(r.shape)),[u,c,d,h]=r.shape,[p,f]=W.getImageCenter(a,c,d),g=255,y=Math.sin(i),m=Math.cos(i),b=o.data.get(r.dataId).values;for(let w=0;w<u;w++){let _=w*d*c*h;for(let S=0;S<c;S++){let E=S*(d*h);for(let C=0;C<d;C++){let T=C*h;for(let M=0;M<h;M++){let k=[u,S,C,M],R=k[2],N=k[1],B=(R-p)*m-(N-f)*y,z=(R-p)*y+(N-f)*m;B=Math.round(B+p),z=Math.round(z+f);let V=s;if(typeof s!="number"&&(M===3?V=g:V=s[M]),B>=0&&B<d&&z>=0&&z<c){let Q=z*(d*h),O=B*h,j=_+Q+O+M;V=b[j]}let K=_+E+T+M;l[K]=V}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},AUe=mr(Mm,t=>{let e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2===0?e:e+1}),EUe={kernelName:Mm,backendName:"cpu",kernelFunc:AUe};function IUe(t){let{inputs:e,backend:n,attrs:r}=t,{indices:i,updates:s}=e,{shape:a}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=W.calculateShapes(s,i,a),h=!0,p=n.bufferSync(i),f=n.bufferSync(s),g=bp(p,f,a,d,u,l,o,c,0,h);return n.makeTensorInfo(a,g.dtype,g.values)}var TUe={kernelName:av,backendName:"cpu",kernelFunc:IUe};function CUe(t,e){let n=0,r=t.length,i=0;for(;n<r;)i=Math.floor((n+r)/2),t[i]<e?n=i+1:r=i;return r}function MUe(t,e){let n=0,r=t.length,i=0;for(;n<r;)i=Math.floor((n+r)/2),t[i]<=e?n=i+1:r=i;return r}function kUe(t,e,n,r,i,s){let a=P.getArrayFromDType("int32",n*i);for(let o=0;o<n;++o){let l=t.slice(o*r,(o+1)*r),u=o*i;for(let c=0;c<i;++c)a[u+c]=s==="left"?CUe(l,e[c+u]):MUe(l,e[c+u])}return a}function NUe(t){let{inputs:e,backend:n,attrs:r}=t,{sortedSequence:i,values:s}=e,{side:a}=r,o=n.data.get(i.dataId).values,l=n.data.get(s.dataId).values,u=kUe(o,l,i.shape[0],i.shape[1],s.shape[1],a);return n.makeTensorInfo(s.shape,"int32",u)}var RUe={kernelName:lv,backendName:"cpu",kernelFunc:NUe};function FUe(t){let{inputs:e,backend:n}=t,{condition:r,t:i,e:s}=e;Zt([r,i,s],"select");let a=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,u=n.data.get(s.dataId).values,c=uo(i.dtype,s.dtype),d=P.makeZerosTypedArray(P.sizeFromShape(i.shape),c),h=0,p=a===0||a>1||i.shape.length===1?1:P.sizeFromShape(i.shape.slice(1));for(let f=0;f<o.length;f++)for(let g=0;g<p;g++)o[f]===1?d[h++]=l[f]:d[h++]=u[f];return n.makeTensorInfo(i.shape,c,d)}var DUe={kernelName:uv,backendName:"cpu",kernelFunc:FUe},PUe=W.SELU_SCALEALPHA,LUe=W.SELU_SCALE,OUe=mr(Nm,t=>t>=0?LUe*t:PUe*(Math.exp(t)-1)),BUe={kernelName:Nm,backendName:"cpu",kernelFunc:OUe},UUe=mr(Dm,t=>t<0?-1:t>0?1:0),$Ue={kernelName:Dm,backendName:"cpu",kernelFunc:UUe},zUe=mr(Rm,t=>Math.sin(t)),GUe={kernelName:Rm,backendName:"cpu",kernelFunc:zUe},HUe=mr(Fm,t=>Math.sinh(t)),WUe={kernelName:Fm,backendName:"cpu",kernelFunc:HUe},VUe=11920928955078125e-23,JV=Math.log(VUe)+2,jUe=mr(Lm,t=>{let e=t>-JV,n=t<JV,r=Math.exp(t),i;return n?i=r:e?i=t:i=Math.log(1+r),i}),XUe={kernelName:Lm,backendName:"cpu",kernelFunc:jUe};function KUe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:s,paddings:a}=r;Zt([i],"spaceToBatchND");let o=P.sizeFromShape(s),l=[[0,0]];l.push(...a);for(let y=1+s.length;y<i.shape.length;++y)l.push([0,0]);let u=sQ.kernelFunc({inputs:{x:i},backend:n,attrs:{paddings:l,constantValue:0}}),c=W.getReshaped(u.shape,s,o,!1),d=W.getPermuted(c.length,s.length,!1),h=W.getReshapedPermuted(u.shape,s,o,!1),p=kr({inputs:{x:u},backend:n,attrs:{shape:c}}),f=ha({inputs:{x:p},backend:n,attrs:{perm:d}}),g=kr({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),g}var qUe={kernelName:dv,backendName:"cpu",kernelFunc:KUe};function JUe(t){let{inputs:e,backend:n}=t,{indices:r,values:i,denseShape:s,defaultValue:a}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${i.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values[0],[d,h,p,f,g]=PZ(o,r.shape,r.dtype,l,i.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],i.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(y=>Number(y)))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}var YUe={kernelName:mw,backendName:"cpu",kernelFunc:JUe};function ZUe(t){let{inputs:e,backend:n}=t,{inputIndices:r,inputShape:i,newShape:s}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=Array.from(n.data.get(i.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,c,d]=LZ(o,r.shape,r.dtype,a,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}var QUe={kernelName:pv,backendName:"cpu",kernelFunc:ZUe};function e$e(t){let{inputs:e,backend:n}=t,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${i.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(i.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let a=n.data.get(r.dataId).values,o=n.data.get(i.dataId).values,l=n.data.get(s.dataId).values,[u,c]=WB(a,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}var t$e={kernelName:gw,backendName:"cpu",kernelFunc:e$e};function n$e(t){let{inputs:e,backend:n}=t,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${i.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(i.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let a=n.data.get(r.dataId).values,o=n.data.get(i.dataId).values,l=n.data.get(s.dataId).values,[u,c]=WB(a,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}var r$e={kernelName:yw,backendName:"cpu",kernelFunc:n$e};function i$e(t){let{inputs:e,backend:n,attrs:r}=t,{sparseIndices:i,sparseValues:s,defaultValue:a}=e,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=W.calculateShapes(s,i,o),p=!1,f=n.bufferSync(i),g;switch(s.dtype){case"bool":{let y=n.bufferSync(s),m=!!n.data.get(a.dataId).values[0];g=bp(f,y,o,h,c,u,l,d,m,p);break}case"float32":{let y=n.bufferSync(s),m=n.data.get(a.dataId).values[0];g=bp(f,y,o,h,c,u,l,d,m,p);break}case"int32":{let y=n.bufferSync(s),m=n.data.get(a.dataId).values[0];g=bp(f,y,o,h,c,u,l,d,m,p);break}case"string":{let y=n.bufferSync(s),m=P.decodeString(n.data.get(a.dataId).values[0]);g=bp(f,y,o,h,c,u,l,d,m,p);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,g.dtype,g.values)}var s$e={kernelName:fv,backendName:"cpu",kernelFunc:i$e};function a$e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{numOrSizeSplits:s,axis:a}=r,o=P.parseAxisParam(a,i.shape)[0],l=W.prepareSplitSize(i,s,o),u=new Array(i.shape.length).fill(0),c=i.shape.slice();return l.map(d=>{let h=[...c];h[o]=d;let p=lf({inputs:{x:i},backend:n,attrs:{begin:u,size:h}});return u[o]+=d,p})}var o$e={kernelName:hv,backendName:"cpu",kernelFunc:a$e},l$e={kernelName:vw,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{let{x:n}=t,r=e;Zt(n,"square");let i=r.data.get(n.dataId).values,s=new Float32Array(i.length);for(let a=0;a<i.length;++a){let o=i[a];s[a]=o*o}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},u$e=mr(ih,(t,e)=>{let n=e;return isNaN(t)?NaN:t>0?1:n.alpha}),c$e={kernelName:ih,backendName:"cpu",kernelFunc:u$e};function d$e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{begin:s,end:a,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;Zt(i,"stridedSlice");let{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:y,isSimpleSlice:m,begin:b,end:w,strides:_}=Ni.sliceInfo(i.shape,s,a,o,l,u,c,d,h),S;if(g)S=kr({inputs:{x:i},backend:n,attrs:{shape:f}});else if(y||m){P.assert(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);let E=Ni.computeOutShape(b,w,_),C=lf({inputs:{x:i},backend:n,attrs:{begin:b,size:E}});S=kr({inputs:{x:C},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(C)}else{let E=n.bufferSync(i),C=UZ(p,E,_,b);S=n.makeTensorInfo(f,C.dtype,C.values)}return S}var h$e={kernelName:mv,backendName:"cpu",kernelFunc:d$e};function p$e(t){let{inputs:e,backend:n,attrs:r}=t,{separator:i,nGramWidths:s,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=e,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,g]=VB(h,p,i,s,a,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",g)]}var f$e={kernelName:bw,backendName:"cpu",kernelFunc:p$e};function m$e(t){let{inputs:e,backend:n,attrs:r}=t,{skipEmpty:i}=r,{input:s,delimiter:a}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);let o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values[0],[u,c,d]=jB(o,l,i),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var g$e={kernelName:ww,backendName:"cpu",kernelFunc:m$e};function y$e(t){let{inputs:e,backend:n,attrs:r}=t,{numBuckets:i}=r,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");let a=n.data.get(s.dataId).values,o=XB(a,i);return n.makeTensorInfo(s.shape,"int32",o)}var v$e={kernelName:_w,backendName:"cpu",kernelFunc:y$e},x$e=mr(Gm,t=>Math.tan(t)),b$e={kernelName:Gm,backendName:"cpu",kernelFunc:x$e},w$e=mr(Hm,t=>Math.tanh(t)),_$e={kernelName:Hm,backendName:"cpu",kernelFunc:w$e};function S$e(t){let{inputs:e,backend:n}=t,{tensor:r,indices:i,updates:s}=e,{sliceRank:a,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=W.calculateShapes(s,i,r.shape),d=!1,h=n.bufferSync(i),p=n.bufferSync(s),f=n.bufferSync(r),g=bp(h,p,r.shape,c,l,o,a,u,f,d);return n.makeTensorInfo(r.shape,g.dtype,g.values)}var A$e={kernelName:ov,backendName:"cpu",kernelFunc:S$e};function E$e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{reps:s}=r;Zt(i,"tile");let a=zZ(n.bufferSync(i),s);return n.makeTensorInfo(a.shape,a.dtype,a.values)}var I$e={kernelName:rh,backendName:"cpu",kernelFunc:E$e};function T$e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{k:s,sorted:a}=r;Zt(i,"topk");let o=n.data.get(i.dataId).values,[l,u]=HZ(o,i.shape,i.dtype,s,a);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}var C$e={kernelName:gv,backendName:"cpu",kernelFunc:T$e};function M$e(t){let{inputs:e,attrs:n,backend:r}=t,{image:i,transforms:s}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:u}=n,[c,d,h,p]=i.shape,[f,g]=u??[d,h],y=[c,f,g,p],m=P.computeStrides(i.shape),b=m[0],w=m[1],_=m[2],S=P.computeStrides(y),E=S[0],C=S[1],T=S[2],M=P.getTypedArrayFromDType(i.dtype,P.sizeFromShape(y));M.fill(l);let k=r.data.get(i.dataId).values,R=r.data.get(s.dataId).values;for(let N=0;N<c;++N){let B=s.shape[0]===1?R:R.subarray(N*8,N*8+8);for(let z=0;z<f;++z)for(let V=0;V<g;++V)for(let K=0;K<p;++K){let Q,O=B[6]*V+B[7]*z+1;if(O===0)continue;let j=(B[0]*V+B[1]*z+B[2])/O,X=(B[3]*V+B[4]*z+B[5])/O,te=YV(j,h,o),le=YV(X,d,o);switch(a){case"nearest":Q=P$e(k,d,h,b,w,_,N,le,te,K,l);break;case"bilinear":Q=L$e(k,d,h,b,w,_,N,le,te,K,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}let ge=N*E+z*C+V*T+K;M[ge]=Q}return r.makeTensorInfo(y,i.dtype,M)}return{dataId:r.write(M,y,i.dtype),shape:i.shape,dtype:i.dtype}}var k$e={kernelName:yv,backendName:"cpu",kernelFunc:M$e};function YV(t,e,n){switch(n){case"reflect":return N$e(t,e);case"wrap":return R$e(t,e);case"nearest":return D$e(t,e);case"constant":default:return F$e(t)}}function N$e(t,e){let n=t;if(n<0)if(e<=1)n=0;else{let r=2*e;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-e?n+r:-n-1}else if(n>e-1)if(e<=1)n=0;else{let r=2*e;n-=r*Math.trunc(n/r),n>=e&&(n=r-n-1)}return P.clamp(0,n,e-1)}function R$e(t,e){let n=t;if(n<0)if(e<=1)n=0;else{let r=e-1;n+=e*(Math.trunc(-n/r)+1)}else if(n>e-1)if(e<=1)n=0;else{let r=e-1;n-=e*Math.trunc(n/r)}return P.clamp(0,n,e-1)}function F$e(t,e){return t}function D$e(t,e){return P.clamp(0,t,e-1)}function rb(t,e,n,r,i,s,a,o,l,u,c){let d=a*r+o*i+l*s+u;return 0<=o&&o<e&&0<=l&&l<n?t[d]:c}function P$e(t,e,n,r,i,s,a,o,l,u,c){let d=Math.round(o),h=Math.round(l);return rb(t,e,n,r,i,s,a,d,h,u,c)}function L$e(t,e,n,r,i,s,a,o,l,u,c){let d=Math.floor(o),h=Math.floor(l),p=d+1,f=h+1,g=(f-l)*rb(t,e,n,r,i,s,a,d,h,u,c)+(l-h)*rb(t,e,n,r,i,s,a,d,f,u,c),y=(f-l)*rb(t,e,n,r,i,s,a,p,h,u,c)+(l-h)*rb(t,e,n,r,i,s,a,p,f,u,c);return(p-o)*g+(o-d)*y}function O$e(t){let{inputs:e,attrs:n,backend:r}=t,{axis:i}=n,{x:s}=e;Zt(s,"unique");let a=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=qB(a,i,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}var B$e={kernelName:Sw,backendName:"cpu",kernelFunc:O$e};function U$e(t){let{inputs:e,backend:n,attrs:r}=t,{value:i}=e,{axis:s}=r;s<0&&(s+=i.shape.length);let a=i.shape.length,o=i.shape[s],l=new Array(a-1),u=0;for(let p=0;p<a;p++)p!==s&&(l[u++]=i.shape[p]);let c=new Array(a).fill(0),d=i.shape.slice();d[s]=1;let h=new Array(o);for(let p=0;p<h.length;p++){c[s]=p;let f=lf({inputs:{x:i},backend:n,attrs:{begin:c,size:d}});h[p]=kr({inputs:{x:f},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(f)}return h}var $$e={kernelName:vv,backendName:"cpu",kernelFunc:U$e};function z$e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,segmentIds:s}=e,{numSegments:a}=r;Zt(i,"unsortedSegmentSum");let o=i.shape.length,l=s.shape.length,u=[],c=[],d=o-l,h=s;for(let f=0;f<d;++f){let g=XI({inputs:{input:h},backend:n,attrs:{dim:f+1}});h=g,c.push(g)}for(let f=0;f<a;++f){let g=P.createScalarValue(f,"int32"),y=n.makeTensorInfo([],"int32",g),m=cZ({inputs:{a:y,b:h},backend:n}),b=Hd({inputs:{x:m},backend:n,attrs:{dtype:"float32"}}),w=_M({inputs:{a:b,b:i},backend:n}),_=Qw({inputs:{x:w},backend:n,attrs:{axis:0,keepDims:!1}});u.push(_),c.push(y),c.push(m),c.push(b),c.push(w),c.push(_)}let p=iQ({inputs:u,backend:n,attrs:{axis:0}});return c.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}var G$e={kernelName:Aw,backendName:"cpu",kernelFunc:z$e},H$e=[L3e,mPe,B3e,$3e,wPe,G3e,W3e,j3e,K3e,J3e,Z3e,eLe,nLe,sLe,oLe,cLe,hLe,fLe,gLe,D3e,vLe,bLe,_Le,SPe,ALe,xPe,EPe,ILe,gPe,CLe,kLe,NLe,FLe,PLe,OLe,ULe,zLe,HLe,VLe,XLe,qLe,YLe,QLe,tOe,nOe,iOe,aOe,lOe,uOe,cOe,dOe,pOe,gOe,T3e,vOe,IPe,IOe,TPe,TOe,MPe,FOe,DOe,LOe,NPe,FPe,BOe,$Oe,GOe,WOe,PPe,OPe,yPe,jOe,MLe,KOe,JOe,ZOe,C3e,UPe,zPe,eBe,HPe,nBe,sBe,oBe,cBe,hBe,fBe,mBe,VPe,yBe,xBe,wBe,SBe,EBe,TBe,MBe,XPe,NBe,DBe,BBe,qPe,YPe,zBe,WBe,XBe,QPe,qBe,YBe,ZBe,sQ,nUe,k3e,n3e,iUe,aUe,lUe,cUe,vPe,KF,hUe,N3e,R3e,F3e,fUe,gUe,vUe,bUe,_Ue,SUe,EUe,d3e,TUe,RUe,DUe,BUe,p3e,$Ue,GUe,WUe,f3e,LBe,XUe,qUe,YUe,QUe,t$e,r$e,s$e,o$e,y3e,l$e,x3e,w3e,c$e,h$e,f$e,g$e,v$e,E3e,fOe,b$e,_$e,A$e,I$e,C$e,k$e,e3e,B$e,$$e,G$e,JBe];for(let t of H$e)Ew(t);var aQ={};wn(aQ,{assertNotComplex:()=>Fv,bindCanvasToFramebuffer:()=>eze,bindColorTextureToFramebuffer:()=>tE,bindTextureToProgramUniformSampler:()=>_Q,bindTextureUnit:()=>xQ,bindVertexBufferToProgramAttribute:()=>JF,callAndCheck:()=>Ft,canBeRepresented:()=>lQ,createFragmentShader:()=>dQ,createFramebuffer:()=>vQ,createProgram:()=>hQ,createStaticIndexBuffer:()=>mQ,createStaticVertexBuffer:()=>fQ,createTexture:()=>gQ,createVertexShader:()=>cQ,getBatchDim:()=>uf,getExtensionOrThrow:()=>ib,getFramebufferErrorMessage:()=>SQ,getMaxTexturesInShader:()=>TQ,getNumChannels:()=>Z$e,getProgramUniformLocation:()=>wQ,getProgramUniformLocationOrThrow:()=>bQ,getRowsCols:()=>cf,getShapeAs3D:()=>ab,getTextureShapeFromLogicalShape:()=>EQ,getWebGLDisjointQueryTimerVersion:()=>CQ,getWebGLErrorMessage:()=>uQ,getWebGLMaxTextureSize:()=>IQ,hasExtension:()=>ro,isCapableOfRenderingToFloatTexture:()=>MQ,isDownloadFloatTextureEnabled:()=>kQ,isReshapeFree:()=>I1,isWebGLFenceEnabled:()=>NQ,isWebGLVersionEnabled:()=>ZF,linkProgram:()=>pQ,logShaderSourceAndInfoLog:()=>eU,resetMaxTextureSize:()=>tze,resetMaxTexturesInShader:()=>nze,unbindColorTextureFromFramebuffer:()=>YF,unbindTextureUnit:()=>Q$e,validateFramebuffer:()=>sb,validateProgram:()=>eE,validateTextureSize:()=>yQ});var op={},IA={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function oQ(t,e){op[t]=e}function El(t,e){if(!(t in op)||e!=null){let r=V$e(t,e);if(r!==null)op[t]=r;else return console.log("Could not get context for WebGL version",t),null}let n=op[t];return n==null||n.isContextLost()?(delete op[t],El(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),op[t])}function W$e(t){if(!Ie().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&t===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function V$e(t,e){if(t!==1&&t!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=e??W$e(t);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete op[t]},!1),Ie().getBool("SOFTWARE_WEBGL_ENABLED")&&(IA.failIfMajorPerformanceCaveat=!1),t===1?n.getContext("webgl",IA)||n.getContext("experimental-webgl",IA):n.getContext("webgl2",IA)}var E1;(function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"})(E1||(E1={}));var no;(function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"})(no||(no={}));var ls;(function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(ls||(ls={}));function e_(t,e){return[e,t]}function j$e(t,e){return t*e}function TA(t){let e=P.sizeFromShape(t),n=Math.ceil(e/4);return P.sizeToSquarishShape(n)}function Rv(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function X$e(t,e){let[n,r]=Rv(t,e);return n*r*4}function QB(t,e){let n=t,r,i,s,a,o,l,u,c,d,h;return Ie().getNumber("WEBGL_VERSION")===2?(r=n.R32F,i=n.R16F,s=n.RGBA16F,a=n.RGBA32F,o=n.RED,u=4,c=1,d=n.HALF_FLOAT,h=n.FLOAT,l=n.RGBA8):(r=t.RGBA,i=t.RGBA,s=t.RGBA,a=n.RGBA,o=t.RGBA,u=4,c=4,d=e!=null?e.HALF_FLOAT_OES:null,h=t.FLOAT,l=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function Ft(t,e){let n=e();return Ie().getBool("DEBUG")&&K$e(t),n}function K$e(t){let e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+uQ(t,e))}var q$e=596e-10,J$e=65504;function lQ(t){return!!(Ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||q$e<Math.abs(t)&&Math.abs(t)<J$e)}function uQ(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function ib(t,e){return bc(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function cQ(t,e){let n=bc(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ft(t,()=>t.shaderSource(n,e)),Ft(t,()=>t.compileShader(n)),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function dQ(t,e){let n=bc(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ft(t,()=>t.shaderSource(n,e)),Ft(t,()=>t.compileShader(n)),Ie().get("ENGINE_COMPILE_ONLY"))return n;if(t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw eU(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var Y$e=/ERROR: [0-9]+:([0-9]+):/g;function eU(t,e){let n=Y$e.exec(e);if(n==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(t);return}let r=+n[1],i=t.split(`
`),s=i.length.toString().length+2,a=i.map((d,h)=>P.rightPad((h+1).toString(),s)+d),o=0;for(let d=0;d<a.length;d++)o=Math.max(a[d].length,o);let l=a.slice(0,r-1),u=a.slice(r-1,r),c=a.slice(r);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${P.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function hQ(t){return bc(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}function pQ(t,e){if(Ft(t,()=>t.linkProgram(e)),!Ie().get("ENGINE_COMPILE_ONLY")&&t.getProgramParameter(e,t.LINK_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function eE(t,e){if(Ft(t,()=>t.validateProgram(e)),t.getProgramParameter(e,t.VALIDATE_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function fQ(t,e){let n=bc(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Ft(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),Ft(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function mQ(t,e){let n=bc(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Ft(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),Ft(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function Z$e(){return Ie().getNumber("WEBGL_VERSION")===2?1:4}function gQ(t){return bc(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}function yQ(t,e){let n=Ie().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){let r=`[${t}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(t>n||e>n){let r=`[${t}x${e}]`,i=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+i+".")}}function vQ(t){return bc(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function JF(t,e,n,r,i,s,a){let o=t.getAttribLocation(e,n);return o===-1?!1:(Ft(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),Ft(t,()=>t.vertexAttribPointer(o,i,t.FLOAT,!1,s,a)),Ft(t,()=>t.enableVertexAttribArray(o)),!0)}function xQ(t,e,n){AQ(t,n),Ft(t,()=>t.activeTexture(t.TEXTURE0+n)),Ft(t,()=>t.bindTexture(t.TEXTURE_2D,e))}function Q$e(t,e){AQ(t,e),Ft(t,()=>t.activeTexture(t.TEXTURE0+e)),Ft(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function bQ(t,e,n){return bc(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}function wQ(t,e,n){return t.getUniformLocation(e,n)}function _Q(t,e,n,r){Ft(t,()=>xQ(t,e,r)),Ft(t,()=>t.uniform1i(n,r))}function eze(t){Ft(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),Ft(t,()=>t.viewport(0,0,t.canvas.width,t.canvas.height)),Ft(t,()=>t.scissor(0,0,t.canvas.width,t.canvas.height))}function tE(t,e,n){Ft(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),Ft(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function YF(t,e){Ft(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),Ft(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function sb(t){let e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+SQ(t,e))}function SQ(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function bc(t,e,n){let r=Ft(t,()=>e());if(r==null)throw new Error(n);return r}function AQ(t,e){let n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n){let i=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${i}.`)}}function uf(t,e=2){return P.sizeFromShape(t.slice(0,t.length-e))}function cf(t){if(t.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function ab(t){let e=[1,1,1];return t.length===0||t.length===1&&t[0]===1||(e=[uf(t),...cf(t)]),e}function EQ(t,e=!1){let n=Ie().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Ie().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&Ie().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),e&&(n=n*2,r=r*2,t=t.map((o,l)=>l>=t.length-2?P.nearestLargerEven(t[l]):t[l]),t.length===1&&(t=[2,t[0]])),t.length!==2&&(t=P.squeezeShape(t).newShape);let i=P.sizeFromShape(t),s=null;t.length<=1&&i<=n?s=[1,i]:t.length===2&&t[0]<=n&&t[1]<=n?s=t:t.length===3&&t[0]*t[1]<=n&&t[2]<=n?s=[t[0]*t[1],t[2]]:t.length===3&&t[0]<=n&&t[1]*t[2]<=n?s=[t[0],t[1]*t[2]]:t.length===4&&t[0]*t[1]*t[2]<=n&&t[3]<=n?s=[t[0]*t[1]*t[2],t[3]]:t.length===4&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(s=[t[0],t[1]*t[2]*t[3]]);let a=s!=null&&Math.max(...s)>r&&Math.min(...s)<=(e?2:1)&&Math.min(...s)>0;if(s==null||a)if(e){let o=uf(t),l=2,u=2;t.length&&([l,u]=cf(t)),i=o*(l/2)*(u/2),s=P.sizeToSquarishShape(i).map(c=>c*2)}else s=P.sizeToSquarishShape(i);return s}function CA(t){return t%2===0}function I1(t,e){if(t=t.slice(-2),e=e.slice(-2),P.arraysEqual(t,e)||!t.length||!e.length||t[0]===0||t[1]===0||e[0]===0||e[1]===0)return!0;if(t.length!==e.length){let n=t[t.length-1],r=e[e.length-1];if(n===r||CA(n)&&CA(r)&&(t[0]===1||e[0]===1))return!0}return t[1]===e[1]&&CA(t[0])&&CA(e[0])}var nE,rE;function IQ(t){if(nE==null){let e=El(t);nE=e.getParameter(e.MAX_TEXTURE_SIZE)}return nE}function tze(){nE=null}function nze(){rE=null}function TQ(t){if(rE==null){let e=El(t);rE=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,rE)}function CQ(t){if(t===0)return 0;let e,n=El(t);return ro(n,"EXT_disjoint_timer_query_webgl2")&&t===2?e=2:ro(n,"EXT_disjoint_timer_query")?e=1:e=0,e}function ro(t,e){return t.getExtension(e)!=null}function ZF(t){try{if(El(t)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function MQ(t){if(t===0)return!1;let e=El(t);if(t===1){if(!ro(e,"OES_texture_float"))return!1}else if(!ro(e,"EXT_color_buffer_float"))return!1;return QF(e)}function kQ(t){if(t===0)return!1;let e=El(t);if(t===1){if(!ro(e,"OES_texture_float")||!ro(e,"WEBGL_color_buffer_float"))return!1}else{if(ro(e,"EXT_color_buffer_float"))return QF(e);let n="EXT_color_buffer_half_float";if(ro(e,n)){let r=e.getExtension(n);return rze(e,r)}return!1}return QF(e)}function QF(t){let e=QB(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);let r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);let i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(r),i}function rze(t,e){let n=QB(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);let s=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(i),s}function NQ(t){return t!==2?!1:El(t).fenceSync!=null}function Fv(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&P.assert(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}var Qt=Ie();Qt.registerFlag("HAS_WEBGL",()=>Qt.getNumber("WEBGL_VERSION")>0);Qt.registerFlag("WEBGL_VERSION",()=>ZF(2)?2:ZF(1)?1:0);Qt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Qt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Qt.get("WEBGL_VERSION")===2);Qt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Qt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Qt.registerFlag("WEBGL_PACK",()=>Qt.getBool("HAS_WEBGL"));Qt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_CLIP",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_REDUCE",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_LAZILY_UNPACK",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_CONV_IM2COL",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>IQ(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>TQ(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let t=Qt.getNumber("WEBGL_VERSION");return t===0?0:CQ(t)});Qt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Qt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Cw.isMobile());Qt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>MQ(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Qt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Qt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Qt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>kQ(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>NQ(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Qt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Qt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});Qt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Cw.isMobile()?1:-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});Qt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Qt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Qt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Qt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Qt.registerFlag("WEBGL_EXP_CONV",()=>!1);Qt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Qt.getBool("IS_TEST"));Qt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Qt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Qt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Qt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Ks(){let t,e,n,r,i,s,a,o,l,u;return Ie().getNumber("WEBGL_VERSION")===2?(t="#version 300 es",e="in",n="out",r="in",i="texture",s="outputColor",a="out vec4 outputColor;",o=Ie().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(t="",e="attribute",n="varying",r="varying",i="texture2D",s="gl_FragColor",a="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:i,output:s,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function Ym(t,e,n="index"){let r=P.computeStrides(e);return r.map((i,s)=>{let a=`int ${t[s]} = ${n} / ${i}`,o=s===r.length-1?`int ${t[s+1]} = ${n} - ${t[s]} * ${i}`:`index -= ${t[s]} * ${i}`;return`${a}; ${o};`}).join("")}function SM(t,e,n="index"){let r=P.computeStrides(e);return r.map((i,s)=>{let a=`int ${t[s]} = ${n} / outShapeStrides[${s}]`,o=s===r.length-1?`int ${t[s+1]} = ${n} - ${t[s]} * outShapeStrides[${s}]`:`index -= ${t[s]} * outShapeStrides[${s}]`;return`${a}; ${o};`}).join("")}function ize(t,e){let n=t.length,r=t.map(s=>`${e}[${s}]`),i=new Array(n-1);i[n-2]=r[n-1];for(let s=n-3;s>=0;--s)i[s]=`(${i[s+1]} * ${r[s+1]})`;return i}function sze(t,e,n="index"){let r=t.map((s,a)=>a),i=ize(r,e);return i.map((s,a)=>{let o=`int ${t[a]} = ${n} / ${i[a]}`,l=a===i.length-1?`int ${t[a+1]} = ${n} - ${t[a]} * ${i[a]}`:`index -= ${t[a]} * ${i[a]}`;return`${o}; ${l};`}).join("")}function tU(t){let e=P.computeStrides(t).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function nU(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var RQ=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:FQ}=W;function aze(t,e,n){let r=[];if(t.forEach(h=>{let p=P.sizeFromShape(h.shapeInfo.logicalShape);if(h.shapeInfo.isUniform?r.push(`uniform float ${h.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${h.name};`),r.push(`uniform int offset${h.name};`)),n.enableShapeUniforms){let{uniformShape:f}=rU(n.packedInputs,h.shapeInfo.logicalShape,h.shapeInfo.texShape);switch(f.length){case 1:r.push(`uniform int ${h.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${h.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${h.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${h.name}Shape;`);break}r.push(`uniform ivec2 ${h.name}TexShape;`)}}),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(h=>{r.push(`uniform ${h.type} ${h.name}${h.arrayIndex?`[${h.arrayIndex}]`:""};`)});let i=r.join(`
`),s=t.map(h=>oze(h,e,n.packedInputs,n.enableShapeUniforms)).join(`
`),a=e.texShape,o=Ks(),l=cze(o),u,c,d=pze(o);return e.isPacked?(u=lze(e.logicalShape,a,n.enableShapeUniforms),c=hze(o)):(u=uze(e.logicalShape,a,n.enableShapeUniforms),c=dze(o)),n.packedInputs&&(d+=yze),[d,l,c,i,u,s,n.userCode].join(`
`)}function Dv(t,e=!1){let n=t.shapeInfo.logicalShape;switch(n.length){case 0:return Mze(t,e);case 1:return Nze(t,e);case 2:return Fze(t,e);case 3:return Pze(t,e);case 4:return Oze(t,e);case 5:return Bze(t);case 6:return Uze(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function DQ(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return Cze(t);case 1:return kze(t,e);case 2:return Rze(t,e);case 3:return Dze(t,e);default:return Lze(t,e)}}function oze(t,e,n=!1,r){let i="";n?i+=DQ(t,r):i+=Dv(t,r);let s=t.shapeInfo.logicalShape,a=e.logicalShape;return s.length<=a.length&&(n?i+=$ze(t,e):i+=zze(t,e)),i}function lze(t,e,n){switch(t.length){case 0:return PQ();case 1:return vze(t,e,n);case 2:return Ize(t,e,n);case 3:return bze(t,e,n);default:return _ze(t,e,n)}}function uze(t,e,n){switch(t.length){case 0:return PQ();case 1:return xze(t,e,n);case 2:return Tze(t,e,n);case 3:return wze(t,e,n);case 4:return Sze(t,e,n);case 5:return Aze(t,e);case 6:return Eze(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function cze(t){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `}function dze(t){return`
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `}function hze(t){return`
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `}function pze(t){return`${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${fze}
    ${mze}
    ${gze}
  `}var fze=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,mze=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,gze=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,yze=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function PQ(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function vze(t,e,n){let r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function xze(t,e,n){return e[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function bze(t,e,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(t[2]/2),s=i*Math.ceil(t[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `}function wze(t,e,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${SM(["r","c","d"],t)}
    return ivec3(r, c, d);
  }
`;let r=Ym(["r","c","d"],t);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function _ze(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(t[t.length-1]/2),s=i*Math.ceil(t[t.length-2]/2),a=s,o="",l="b, r, c";for(let u=2;u<t.length-1;u++)a*=t[t.length-u-1],o=`
      int b${u} = index / ${a};
      index -= b${u} * ${a};
    `+o,l=`b${u}, `+l;return`
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${t.length}(${l});
    }
  `}function Sze(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${SM(["r","c","d","d2"],t)}
      return ivec4(r, c, d, d2);
    }
  `;let r=Ym(["r","c","d","d2"],t);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function Aze(t,e){let n=Ym(["r","c","d","d2","d3"],t);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Eze(t,e){let n=Ym(["r","c","d","d2","d3","d4"],t);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Ize(t,e,n){let r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(P.arraysEqual(t,e))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let i=Math.ceil(t[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `}function Tze(t,e,n){return P.arraysEqual(t,e)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:t[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:t[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `}function Zm(t){return`offset${t}`}function Cze(t){let e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=Ks();return`
    vec4 ${n}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function Mze(t,e){let n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[i,s]=t.shapeInfo.texShape;if(i===1&&s===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let a=Zm(n);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${a});
      return sampleTexture(${n}, uv);
    }
  `;let[o,l]=t.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${a});
      return sampleTexture(${n}, uv);
    }
  `}function kze(t,e){let n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=t.shapeInfo.texShape,s=Ks();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${n}, uv);
    }
  `;let a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${s.texture2D}(${n}, uv);
    }
  `}function Nze(t,e){let n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Pv(t)}
      }
    `;let i=t.shapeInfo.texShape,s=i[0],a=i[1];if(a===1&&s===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=Zm(n);return a===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);
        return sampleTexture(${n}, uv);
      }
    `:s===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${s}, ${a}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function Rze(t,e){let n=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,a=s[0],o=s[1],l=Ks();if(s!=null&&P.arraysEqual(n,s))return e?`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function Fze(t,e){let n=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape;if(s!=null&&P.arraysEqual(n,s)){if(e)return`
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let h=s[0],p=s[1];return`
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:a,keptDims:o}=P.squeezeShape(n),l=a;if(l.length<n.length){let h=Lv(t,l),p=["row","col"];return`
      ${Dv(h,e)}
      float ${i}(int row, int col) {
        return ${i}(${Ov(p,o)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Pv(t)}
      }
    `;let u=s[0],c=s[1],d=Zm(r);return c===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  `:u===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`}function Dze(t,e){let n=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(n[0]===1){let h=n.slice(1),p=[1,2],f=Lv(t,h),g=["b","row","col"];return`
        ${DQ(f,e)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${Ov(g,p)});
        }
      `}let o=Ks();if(e)return`
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;let l=a[0],u=a[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${d}, ${c}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `}function Pze(t,e){let n=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],a=n[2],{newShape:o,keptDims:l}=P.squeezeShape(n),u=o;if(u.length<n.length){let g=Lv(t,u),y=["row","col","depth"];return`
        ${Dv(g,e)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${Ov(y,l)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${a}, 1)));
        ${Pv(t)}
      }
    `;let c=t.shapeInfo.texShape,d=c[0],h=c[1],p=t.shapeInfo.flatOffset;if(h===s&&p==null)return e?`
      float ${i}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${h}.0, ${d}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(h===a&&p==null)return e?`
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `;let f=Zm(r);return e?`
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${a} + depth + ${f};
        vec2 uv = uvFromFlat(${d}, ${h}, index);
        return sampleTexture(${r}, uv);
      }
  `}function Lze(t,e){let n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=Ks();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${n}, uv);
    }
  `;let s=t.shapeInfo.logicalShape,a=s.length,o=t.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(s[a-1]/2),h=d*Math.ceil(s[a-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let g=2;g<a-1;g++)p=`int b${g}, `+p,h*=s[a-g-1],f=`b${g} * ${h} + `+f;return`
    vec4 ${r}(${p}) {
      int index = ${f};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${i.texture2D}(${n}, uv);
    }
  `}function Oze(t,e){let n=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],a=n[2]*s,o=n[1]*a,{newShape:l,keptDims:u}=P.squeezeShape(n);if(l.length<n.length){let b=Lv(t,l),w=["row","col","depth","depth2"];return`
      ${Dv(b,e)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${Ov(w,u)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${a}, ${s}, 1)));
        ${Pv(t)}
      }
    `;let c=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,y=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&c==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        ${f}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(p===s&&c==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;let m=Zm(r);return e?`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${g}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${m});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${h}, ${p}, index + ${m});
      return sampleTexture(${r}, uv);
    }
  `}function Bze(t){let e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=e[4],s=e[3]*i,a=e[2]*s,o=e[1]*a,{newShape:l,keptDims:u}=P.squeezeShape(e);if(l.length<e.length){let g=Lv(t,l),y=["row","col","depth","depth2","depth3"];return`
      ${Dv(g)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Ov(y,u)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${a}, ${s}, ${i})) +
          depth3;
        ${Pv(t)}
      }
    `;let c=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${s}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===i&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;let f=Zm(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} + depth * ${s} +
          depth2 * ${i} + depth3 + ${f};
      vec2 uv = uvFromFlat(${h}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Uze(t){let e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:i,keptDims:s}=P.squeezeShape(e);if(i.length<e.length){let y=Lv(t,i),m=["row","col","depth","depth2","depth3","depth4"];return`
      ${Dv(y)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Ov(m,s)});
      }
    `}let a=e[5],o=e[4]*a,l=e[3]*o,u=e[2]*l,c=e[1]*u;if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${Pv(t)}
      }
    `;let d=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${o}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===a&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;let g=Zm(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${o} + depth3 * ${a} + depth4 + ${g};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Pv(t){let e=t.name,n=P.sizeFromShape(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function $ze(t,e){let n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),i="get"+r+"AtOutCoords",s=t.shapeInfo.logicalShape.length,a=e.logicalShape.length,o=FQ(t.shapeInfo.logicalShape,e.logicalShape),l=Sr(a),u=a-s,c,d=["x","y","z","w","u","v"];s===0?c="":a<2&&o.length>=1?c="coords = 0;":c=o.map(y=>`coords.${d[y+u]} = 0;`).join(`
`);let h="";a<2&&s>0?h="coords":h=t.shapeInfo.logicalShape.map((y,m)=>`coords.${d[m+u]}`).join(", ");let p="return outputValue;",f=P.sizeFromShape(t.shapeInfo.logicalShape)===1,g=P.sizeFromShape(e.logicalShape)===1;if(s===1&&!f&&!g)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(f&&!g)a===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(o.length){let y=s-2,m=s-1;o.indexOf(y)>-1&&o.indexOf(m)>-1?p="return vec4(outputValue.x);":o.indexOf(y)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(m)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${i}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${h});
      ${p}
    }
  `}function zze(t,e){let n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),i="get"+r+"AtOutCoords",s=e.texShape,a=t.shapeInfo.texShape,o=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&o===l&&t.shapeInfo.flatOffset==null&&P.arraysEqual(a,s))return`
      float ${i}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let u=Sr(l),c=FQ(t.shapeInfo.logicalShape,e.logicalShape),d=l-o,h,p=["x","y","z","w","u","v"];o===0?h="":l<2&&c.length>=1?h="coords = 0;":h=c.map(g=>`coords.${p[g+d]} = 0;`).join(`
`);let f="";return l<2&&o>0?f="coords":f=t.shapeInfo.logicalShape.map((g,y)=>`coords.${p[y+d]}`).join(", "),`
    float ${i}() {
      ${u} coords = getOutputCoords();
      ${h}
      return get${r}(${f});
    }
  `}function Sr(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function rU(t,e,n){let{newShape:r,keptDims:i}=P.squeezeShape(e),s=e.length,a=t&&s===3&&e[0]===1,o=a?e.slice(1):r,l=!t&&s>1&&!P.arraysEqual(e,n)&&r.length<s||a;return{useSqueezeShape:l,uniformShape:l?o:e,keptDims:i}}function Lv(t,e){let n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function Ov(t,e){return e.map(n=>t[n]).join(", ")}function Gze(t,e,n,r){let i=n.map((c,d)=>{let h={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(h.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[d],shapeInfo:h}}),s=i.map(c=>c.shapeInfo),a={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=aze(i,a,e),l=dQ(t.gl,o),u=t.createProgram(l);return Ie().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(u),Object.assign({program:e,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:a},LQ(t,e,u)))}function LQ(t,e,n){let r=[],i=[],s,a,o,l=null,u=null;u=t.getUniformLocation(n,"NAN",!1),Ie().getNumber("WEBGL_VERSION")===1&&(l=t.getUniformLocation(n,"INFINITY",!1));let c=!1;for(let d of e.variableNames){let h={name:d,uniform:t.getUniformLocation(n,d,c),offset:t.getUniformLocation(n,`offset${d}`,c)};e.enableShapeUniforms&&(h.shape=t.getUniformLocation(n,`${d}Shape`,c),h.texShape=t.getUniformLocation(n,`${d}TexShape`,c)),r.push(h)}if(e.enableShapeUniforms&&(s=t.getUniformLocation(n,"outShape",c),o=t.getUniformLocation(n,"outShapeStrides",c),a=t.getUniformLocation(n,"outTexShape",c)),e.customUniforms)for(let d of e.customUniforms)i.push(t.getUniformLocation(n,d.name,c));return{variablesLocations:r,customUniformLocations:i,infLoc:l,nanLoc:u,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:a}}function ZV(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((n,r)=>{let i=n.logicalShape,s=e[r],a=s.shape;if(!P.arraysEqual(i,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${a} must match`);if(n.isUniform&&s.isUniform)return;let o=n.texShape,l=s.isUniform?null:s.texData.texShape;if(!P.arraysEqual(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function Hze(t,e,n,r,i){e.program.enableShapeUniforms||(ZV(e.inShapeInfos,n),ZV([e.outShapeInfo],[r]));let s=r.texData.texture,a=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(s.texture,a[0],a[1]):t.setOutputMatrixTexture(s.texture,a[0],a[1]),t.setProgram(e.webGLProgram),t.bindVertexArray(e.webGLProgram.vao),Ie().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&t.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&t.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<n.length;++l){let u=n[l],{uniform:c,offset:d,shape:h,texShape:p}=e.variablesLocations[l];if(h){let{uniformShape:f}=rU(e.program.packedInputs,u.shape,u.texData.texShape);switch(f.length){case 1:t.gl.uniform1iv(h,new Int32Array(f));break;case 2:t.gl.uniform2iv(h,new Int32Array(f));break;case 3:t.gl.uniform3iv(h,new Int32Array(f));break;case 4:t.gl.uniform4iv(h,new Int32Array(f));break}}if(p&&t.gl.uniform2i(p,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(P.sizeFromShape(u.shape)<2)t.gl.uniform1f(c,u.uniformValues[0]);else{let f=u.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),t.gl.uniform1fv(c,f)}continue}u.texData.slice!=null&&d!=null&&t.gl.uniform1i(d,u.texData.slice.flatOffset),t.setInputMatrixTexture(u.texData.texture.texture,c,l)}}let o=e.outShapeLocation;if(o)switch(r.shape.length){case 1:t.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(o,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){let l=P.computeStrides(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&i)for(let l=0;l<e.program.customUniforms.length;++l){let u=e.program.customUniforms[l],c=e.customUniformLocations[l],d=i[l];if(u.type==="float")t.gl.uniform1fv(c,d);else if(u.type==="vec2")t.gl.uniform2fv(c,d);else if(u.type==="vec3")t.gl.uniform3fv(c,d);else if(u.type==="vec4")t.gl.uniform4fv(c,d);else if(u.type==="int")t.gl.uniform1iv(c,d);else if(u.type==="ivec2")t.gl.uniform2iv(c,d);else if(u.type==="ivec3")t.gl.uniform3iv(c,d);else if(u.type==="ivec4")t.gl.uniform4iv(c,d);else throw Error(`uniform type ${u.type} is not supported yet.`)}t.executeProgram()}function Wze(t,e,n){let r="";e.concat(n).forEach(a=>{let o=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!a.isUniform){let l=a.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:d}=rU(t.packedInputs,a.shape,l),h="",p="",f="";if(c.length===1&&t.packedInputs){let S=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${S[0]>1}_${S[1]>1}`}else if(c.length===2&&!t.packedInputs)p=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!t.packedInputs){let S=P.computeStrides(c);f=`${S[0]===l[1]}_${S[S.length-1]===l[1]}`}let g=a.shape.length,y=c.length===2&&P.arraysEqual(a.shape,l),m=P.sizeFromShape(a.shape)===1,b=W.getBroadcastDims(a.shape,n.shape),w=!t.packedInputs&&g===n.shape.length&&P.arraysEqual(l,n.texData.texShape),_=t.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${g}_${w}_${u?d:""}_${c.length}_${m}_${b}_${y}_${h}_${p}_${f}_${_}_${o}`}else{let l=a.isUniform?"uniform":a.texData.texShape;r+=`${a.shape}_${l}_${o}`}});let i=t.userCode,s=t.constructor.name;return s+="_"+r+"_"+i+`${Ie().getNumber("WEBGL_VERSION")}`,s}function As(t){return Ie().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}var Vze=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=E1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=Ks();this.outputShape=t,this.enableShapeUniforms=As(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?SM(["r","c","d"],t):Ym(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}},jze=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=E1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=Ks();this.outputShape=t,this.enableShapeUniforms=As(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?SM(["r","c","d"],t):Ym(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}},Xze=class{constructor(t){this.variableNames=["A"],this.outTexUsage=no.DOWNLOAD;let e=Ks();this.outputShape=t,this.userCode=`
      ${RQ}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}},Kze=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=no.DOWNLOAD;let e=Ks();this.outputShape=t,this.userCode=`
      ${RQ}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}},qze={R:0,G:1,B:2,A:3},QV=class{constructor(t,e=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=Ks();this.outputShape=t,this.enableShapeUniforms=As(this.outputShape.length);let i="result";e&&(i="floor(result * 255. + 0.5)");let s="";for(let a=0;a<n.length;a++){let o=n[a];s+=`
          if(offset == ${a}) {
            result = values[${qze[o]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?nU():tU(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${s}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}},Jze=class{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Ks();this.outputShape=t,this.enableShapeUniforms=As(this.outputShape.length);let r="",i="result";e&&(i="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let a=0;a<=1;a++){let o=s*2+a;r+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${s};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${o}] = values[0];
            } else if (offset == 1) {
              result[${o}] = values[1];
            } else if (offset == 2) {
              result[${o}] = values[2];
            } else {
              result[${o}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?nU():tU(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${n.output} = ${i};
        }
    `}},OQ={};wn(OQ,{bindVertexProgramAttributeStreams:()=>jQ,createBufferFromOutputTexture:()=>qQ,createFloat16MatrixTexture:()=>GQ,createFloat16PackedMatrixTexture:()=>VQ,createFloat32MatrixTexture:()=>zQ,createIndexBuffer:()=>$Q,createPackedMatrixTexture:()=>WQ,createUnsignedBytesMatrixTexture:()=>HQ,createVertexBuffer:()=>UQ,createVertexShader:()=>BQ,downloadByteEncodedFloatMatrixFromOutputTexture:()=>YQ,downloadFloat32MatrixFromBuffer:()=>JQ,downloadMatrixFromPackedOutputTexture:()=>QQ,downloadPackedMatrixFromBuffer:()=>ZQ,getInternalFormatForFloat16MatrixTexture:()=>sU,getInternalFormatForFloat16PackedMatrixTexture:()=>lU,getInternalFormatForFloat32MatrixTexture:()=>iU,getInternalFormatForPackedMatrixTexture:()=>oU,getInternalFormatForUnsignedBytesMatrixTexture:()=>aU,uploadDenseMatrixToTexture:()=>XQ,uploadPixelDataToTexture:()=>KQ});function BQ(t){let e=Ks(),n=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return cQ(t,n)}function UQ(t){let e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return fQ(t,e)}function $Q(t){let e=new Uint16Array([0,1,2,2,1,3]);return mQ(t,e)}function t_(t,e,n,r,i,s){yQ(e,n);let a=gQ(t),o=t.TEXTURE_2D;return Ft(t,()=>t.bindTexture(o,a)),Ft(t,()=>t.texParameteri(o,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),Ft(t,()=>t.texParameteri(o,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),Ft(t,()=>t.texParameteri(o,t.TEXTURE_MIN_FILTER,t.NEAREST)),Ft(t,()=>t.texParameteri(o,t.TEXTURE_MAG_FILTER,t.NEAREST)),Ie().getNumber("WEBGL_VERSION")===1?Ft(t,()=>t.texImage2D(o,0,r,e,n,0,i,s,null)):Ft(t,()=>t.texStorage2D(o,1,r,e,n)),Ft(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:a,texShape:[n,e]}}function iU(t){return t.internalFormatFloat}function zQ(t,e,n,r){let[i,s]=e_(e,n);return t_(t,i,s,iU(r),r.textureFormatFloat,t.FLOAT)}function sU(t){return t.internalFormatHalfFloat}function GQ(t,e,n,r){let[i,s]=e_(e,n);return t_(t,i,s,sU(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function aU(t){return t.downloadTextureFormat}function HQ(t,e,n,r){let[i,s]=e_(e,n);return t_(t,i,s,aU(r),t.RGBA,t.UNSIGNED_BYTE)}function oU(t){return t.internalFormatPackedFloat}function WQ(t,e,n,r){let[i,s]=Rv(e,n);return t_(t,i,s,oU(r),t.RGBA,t.FLOAT)}function lU(t){return t.internalFormatPackedHalfFloat}function VQ(t,e,n,r){let[i,s]=Rv(e,n);return t_(t,i,s,lU(r),t.RGBA,r.textureTypeHalfFloat)}function jQ(t,e,n){return Ft(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),JF(t,e,"clipSpacePos",n,3,20,0)&&JF(t,e,"uv",n,2,20,12)}function XQ(t,e,n,r,i,s){Ft(t,()=>t.bindTexture(t.TEXTURE_2D,e));let a,o,l;i instanceof Uint8Array?(a=new Uint8Array(n*r*4),o=t.UNSIGNED_BYTE,l=t.RGBA):(a=new Float32Array(n*r*4),o=t.FLOAT,l=s.internalFormatPackedFloat),a.set(i),Ie().getNumber("WEBGL_VERSION")===2?Ft(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,r,t.RGBA,o,a)):Ft(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,t.RGBA,o,a)),Ft(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function KQ(t,e,n){Ft(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?Ie().getNumber("WEBGL_VERSION")===2?Ft(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data)):Ft(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):Ie().getNumber("WEBGL_VERSION")===2?Ft(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n)):Ft(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),Ft(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function qQ(t,e,n,r){let i=t.createBuffer();Ft(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,i));let s=4*4*e*n;return Ft(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,s,t.STREAM_READ)),Ft(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),Ft(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),i}function JQ(t,e,n){let r=t,i=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,i),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),i}function YQ(t,e,n,r){let[i,s]=e_(e,n),a=4,o=new Uint8Array(j$e(e*n,a));return Ft(t,()=>t.readPixels(0,0,i,s,r.downloadTextureFormat,t.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function ZQ(t,e,n,r,i,s,a,o){let l=t,u=new Float32Array(X$e(s,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function QQ(t,e,n){let r=new Float32Array(e*n*4);return Ft(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r)),r}var iE=class{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let e=Ie().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,oQ(e,t)):this.gl=El(e),t=this.gl,Ie().getNumber("WEBGL_VERSION")===2){let i=t;this.createVertexArray=()=>Ft(i,()=>i.createVertexArray()),this.bindVertexArray=s=>Ft(i,()=>i.bindVertexArray(s)),this.deleteVertexArray=s=>Ft(i,()=>i.deleteVertexArray(s)),this.getVertexArray=()=>Ft(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(t!=null){let i=t.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ft(t,()=>i.createVertexArrayOES()),this.bindVertexArray=s=>Ft(t,()=>i.bindVertexArrayOES(s)),this.deleteVertexArray=s=>Ft(t,()=>i.deleteVertexArrayOES(s)),this.getVertexArray=()=>Ft(t,()=>t.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Ie().getNumber("WEBGL_VERSION")===1){let i="OES_texture_float",s="OES_texture_half_float";if(this.textureFloatExtension=ib(this.gl,i),ro(this.gl,s))this.textureHalfFloatExtension=ib(this.gl,s);else if(Ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),ro(this.gl,r))this.colorBufferHalfFloatExtension=ib(this.gl,r);else if(Ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",ro(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(ro(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=UQ(this.gl),this.indexBuffer=$Q(this.gl),this.framebuffer=vQ(this.gl),this.textureConfig=QB(this.gl,this.textureHalfFloatExtension)}get debug(){return Ie().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let t=this.gl;Ft(t,()=>t.finish()),Ft(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),Ft(t,()=>t.deleteFramebuffer(this.framebuffer)),Ft(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),Ft(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),Ft(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),zQ(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),GQ(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),HQ(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),KQ(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,r){this.throwIfDisposed(),XQ(this.gl,t,e,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),VQ(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),WQ(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(YF(this.gl,this.framebuffer),this.outputTexture=null),Ft(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>YQ(this.gl,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,r,i,s){return ZQ(this.gl,t,e,n,r,i,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return JQ(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);let r=qQ(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(Ie().getBool("WEBGL_FENCE_API_ENABLED")){let r=t,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{let s=r.clientWaitSync(i,0,0);return s===r.ALREADY_SIGNALED||s===r.CONDITION_SATISFIED},e=i}else Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>QQ(this.gl,e,n))}createProgram(t){this.throwIfDisposed();let e=this.gl;this.vertexShader==null&&(this.vertexShader=BQ(e));let n=hQ(e);Ft(e,()=>e.attachShader(n,this.vertexShader)),Ft(e,()=>e.attachShader(n,t)),pQ(e,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&eE(e,r),r}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);let e=this.gl;Ft(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),jQ(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(Ft(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&eE(this.gl,this.program),Ft(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?bQ(this.gl,t,e):wQ(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),Ft(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),_Q(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();let[r,i]=Rv(e,n);this.setOutputMatrixTextureDriver(t,r,i)}setOutputMatrixWriteRegion(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&eE(this.gl,this.program),sb(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let t=this.gl;if(this.debug){let e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ft(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ft(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=ib(this.gl,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=n.createQuery();return n.beginQuery(r.TIME_ELAPSED_EXT,i),i}let t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let e=this.gl,n=this.getQueryTimerExtensionWebGL2();e.endQuery(n.TIME_ELAPSED_EXT);return}let t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await P.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){let n=this.gl;return n.getQueryParameter(t,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(t,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=n.getQueryParameter(t,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),r=n.getQueryObjectEXT(t,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){let t=Yze(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){let{resolveFn:n}=this.itemsToPoll[e];n()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Ie().platform&&(n=Ie().platform.setTimeoutCustom.bind(Ie().platform)),P.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),tE(this.gl,t,this.framebuffer),this.debug&&sb(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(tE(this.gl,this.outputTexture,this.framebuffer),this.debug&&sb(this.gl)):YF(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);let n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();let r=this.gl;tE(r,t,this.framebuffer),this.debug&&sb(r),this.outputTexture=t,Ft(r,()=>r.viewport(0,0,e,n)),Ft(r,()=>r.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,r){this.throwIfDisposed(),Ft(this.gl,()=>this.gl.scissor(t,e,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function Yze(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}var{addImpl:Zze,bincountImpl:eee,bincountReduceImpl:Qze,bitwiseAndImpl:e4e,castImpl:t4e,ceilImpl:n4e,concatImpl:r4e,equalImpl:i4e,expImpl:s4e,expm1Impl:a4e,floorImpl:o4e,gatherNdImpl:l4e,gatherV2Impl:u4e,greaterImpl:c4e,greaterEqualImpl:d4e,lessImpl:h4e,lessEqualImpl:p4e,linSpaceImpl:f4e,logImpl:m4e,maxImpl:g4e,maximumImpl:y4e,minimumImpl:v4e,multiplyImpl:x4e,negImpl:b4e,notEqualImpl:w4e,prodImpl:_4e,raggedGatherImpl:S4e,raggedRangeImpl:A4e,raggedTensorToTensorImpl:E4e,rangeImpl:I4e,rsqrtImpl:T4e,scatterImpl:C4e,sigmoidImpl:M4e,simpleAbsImpl:tee,sliceImpl:k4e,sparseFillEmptyRowsImpl:N4e,sparseReshapeImpl:R4e,sparseSegmentReductionImpl:nee,sqrtImpl:F4e,staticRegexReplaceImpl:D4e,stridedSliceImpl:P4e,stringNGramsImpl:L4e,stringSplitImpl:O4e,stringToHashBucketFastImpl:B4e,subImpl:U4e,tileImpl:$4e,topKImpl:z4e,transposeImpl:uU,uniqueImpl:G4e}=OB;function ree(t,e){return["x","y","z","w","u","v"].slice(0,e).map(n=>`${t}.${n}`)}function Bs(t,e){return e===1?[t]:ree(t,e)}function H4e(t,e){if(t===1)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}var W4e=class{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=As(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let e=Bs("rc",this.rank),n=Sr(this.rank),r=this.getOutOfBoundsCondition(e),i=this.getSetup(e),s=this.getOutput(e);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${s}));
          }
        }
      `}}getSourceCoordsArr(t){let e=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let i=`${n===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let s=2;s<this.rank;s++)i=`${t[t.length-1-s]},`+i;e.push(i)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let n=this.rank-2;n<this.rank;n++)e+=`${t[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";let e=t.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${r};
    `}getOutput(t){let e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}},iee=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=As(this.outputShape.length);let n="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2===1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),n+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${V4e(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?nU():tU(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${n}

        setOutput(result);
      }
    `}};function V4e(t,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?sze(["r","c","d"],"inputShape"):Ym(["r","c","d"],t)}
      return ivec3(r, c, d);
    }
  `}var j4e=class{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,n){let r=t5(e,n),i=n5(t,r,n);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);let s=e5(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();let o=this.freeTextures[i].pop();return this.usedTextures[i].push(o),o}let a;return r===ls.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===ls.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===ls.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===ls.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===ls.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),a}releaseTexture(t,e,n,r){if(this.freeTextures==null)return;let i=t5(n,r),s=n5(e,i,r);s in this.freeTextures||(this.freeTextures[s]=[]);let a=e5(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=Ie().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[s].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;let l=this.usedTextures[s],u=l&&l.indexOf(t);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);let e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(let t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function X4e(t,e){let n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F||e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function e5(t,e,n,r,i){let s=K4e(e,r),a;if(i){let[l,u]=Rv(t[0],t[1]);a=l*u}else{let[l,u]=e_(t[0],t[1]);a=l*u}let o=X4e(n,s);return a*o}function K4e(t,e){switch(t){case ls.PACKED_2X2_FLOAT32:return oU(e);case ls.PACKED_2X2_FLOAT16:return lU(e);case ls.UNPACKED_FLOAT32:return iU(e);case ls.UNPACKED_FLOAT16:return sU(e);case ls.PACKED_4X1_UNSIGNED_BYTE:return aU(e);default:throw new Error(`Unknown physical texture type ${t}`)}}function q4e(t){return Ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?ls.PACKED_2X2_FLOAT32:ls.UNPACKED_FLOAT32:t?ls.PACKED_2X2_FLOAT16:ls.UNPACKED_FLOAT16}function t5(t,e){if(t===no.UPLOAD)return ls.PACKED_2X2_FLOAT32;if(t===no.RENDER||t==null)return q4e(e);if(t===no.DOWNLOAD||t===no.PIXELS)return ls.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function n5(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}var Ql=class{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=As(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Xo="if (isnan(x)) return x;",J4e="return x;",r5="return abs(x);",Y4e="return (x >= 0.0) ? x : (exp(x) - 1.0);",Z4e=Xo+`
  return (x < 0.0) ? 0.0 : x;
`,Q4e=Xo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Qc="return x;",eGe="return 1.0 / (1.0 + exp(-1.0 * x));",tGe="return x;",nGe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,rGe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,iGe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,sGe="return 1.0 / (1.0 + exp(-1.0 * x));",hd=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=As(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},aGe=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=As(this.outputShape.length);let e=t.length,n=Bs("rc",e),r=Sr(e),i=H4e(e,n),s=n.slice(-2),a=e<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}},oGe=bu.whereImpl,lGe=1e-7,uGe=1e-4,NN={};function cGe(t){return t in NN||(NN[t]={}),NN[t]}var dGe=Ie().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),hGe=600;function pGe(){return Ie().global.screen==null?1024:Ie().global.screen.height*Ie().global.screen.width*window.devicePixelRatio*hGe/1024/1024}var cU=class see extends nw{nextDataId(){return see.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Ie().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(e!=null){if(e instanceof iE)n=e;else{let r=El(Ie().getNumber("WEBGL_VERSION"),e);n=new iE(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let r=El(Ie().getNumber("WEBGL_VERSION"));n=new iE(r),this.binaryCache=cGe(Ie().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new j4e(this.gpgpu),this.numMBBeforeWarning=pGe(),this.texData=new tC(this,No())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,n,r,i,s,a){let o=this.makeTensorInfo(n,r),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[i,s]},l.texShape=[i,s];let u=ab(n),c=new QV(u,!1,a),d=this.runWebGLProgram(c,[o],r,[[i,s]]);return d.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(o),d.dataId}write(e,n,r){if((Ie().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ie().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let i={id:this.nextDataId()};return this.texData.set(i,{shape:n,dtype:r,values:e,usage:no.UPLOAD,refCount:1}),i}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let n=this.texData.get(e);n.refCount++}decRef(e){if(this.texData.has(e)){let n=this.texData.get(e);n.refCount--}}move(e,n,r,i,s){if(Ie().getBool("DEBUG")&&this.checkNumericalProblems(n),i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:i,values:n,usage:no.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let n=this.texData.get(e),{values:r,dtype:i,complexTensorInfos:s,slice:a,shape:o,isPacked:l}=n;if(a!=null){let h;l?h=new hd(o,Qc):h=new Ql(o,Qc);let p=this.runWebGLProgram(h,[{dataId:e,shape:o,dtype:i}],i),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(r!=null)return this.convertAndCacheOnCPU(e);if(i==="string")return r;let u=this.activeTimers!=null,c;u&&(c=P.now());let d;if(i==="complex64"){let h=this.readSync(s.real.dataId),p=this.readSync(s.imag.dataId);d=W.mergeRealAndImagArrays(h,p)}else d=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=P.now()-c),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){let f=this.pendingRead.get(e);return new Promise(g=>f.push(g))}let n=this.texData.get(e),{values:r,shape:i,slice:s,dtype:a,complexTensorInfos:o,isPacked:l}=n;if(s!=null){let f;l?f=new hd(i,Qc):f=new Ql(i,Qc);let g=this.runWebGLProgram(f,[{dataId:e,shape:i,dtype:a}],a),y=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(r!=null)return this.convertAndCacheOnCPU(e);if(Ie().getBool("DEBUG")&&!Ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Ie().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(a!=="complex64"&&Ie().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);let f=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(f.texture.texture,...TA(i))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(a==="complex64"){let f=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),g=f[0],y=f[1];d=W.mergeRealAndImagArrays(g,y)}else if(u==null)d=this.getValuesFromTexture(e);else{let f=P.sizeFromShape(i);d=this.gpgpu.downloadFloat32MatrixFromBuffer(u,f)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){let f=this.gpgpu.gl;Ft(f,()=>f.deleteBuffer(u))}let h=this.convertAndCacheOnCPU(e,d),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(f=>f(h)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&No().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e,n={}){let r=this.texData.get(e),{values:i,shape:s,slice:a,dtype:o,isPacked:l,texture:u}=r;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let p;l?p=new hd(s,Qc):p=new Ql(s,Qc);let f=this.runWebGLProgram(p,[{dataId:e,shape:s,dtype:o}],o),g=this.readToGPU(f,n);return this.disposeIntermediateTensorInfo(f),g}if(u==null)throw i!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let c=this.decode(e,n.customTexShape),d=No().makeTensorFromTensorInfo(c),h=this.texData.get(c.dataId);return Object.assign({tensorRef:d},h.texture)}bufferSync(e){let n=this.readSync(e.dataId);if(e.dtype==="string")try{let r=n.map(i=>P.decodeString(i));return Rn(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Rn(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let n=0;n<e.length;n++){let r=e[n];if(!lQ(r))throw Ie().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:n,dtype:r,isPacked:i}=this.texData.get(e),s=P.sizeFromShape(n);if(Ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let h=this.decode(e),p=this.texData.get(h.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...TA(n)).subarray(0,s);return this.disposeIntermediateTensorInfo(h),f}let a=Ie().getBool("WEBGL_PACK")&&i===!0,o=a?ab(n):n,l=a?new Kze(o):new Xze(o),u=this.runWebGLProgram(l,[{shape:o,dtype:r,dataId:e}],"float32"),c=this.texData.get(u.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),d}timerAvailable(){return Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let n=this.activeTimers,r=[],i=!1;this.programTimersStack==null?(this.programTimersStack=r,i=!0):this.activeTimers.push(r),this.activeTimers=r,e();let s=P.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=P.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,i&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=await Promise.all(s);o.kernelMs=P.sum(l),o.getExtraProfileInfo=()=>l.map((u,c)=>({name:a[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:P.now(),endMs:null}}endTimer(e){return Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=P.now(),e)}async getQueryTime(e){if(Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let n=e;return n.endMs-n.startMs}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:n,dtype:r,texShape:i,usage:s,isPacked:a,slice:o}=this.texData.get(e),l=o&&o.origDataId||e,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(i,r),this.textureManager.releaseTexture(n,i,s,a)));let c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=dGe){return Ie().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&P.sizeFromShape(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(e){W.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let n=e.dataSync();return oGe(e.shape,n)}packedUnaryOp(e,n,r){let i=new hd(e.shape,n),s=this.compileAndRun(i,[e],r);return No().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let i=tee(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,i)}if(Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,r5,e.dtype);let n=new Ql(e.shape,r5),r=this.compileAndRun(n,[e]);return No().makeTensorFromTensorInfo(r)}makeTensorInfo(e,n,r){let i;if(n==="string"&&r!=null&&r.length>0&&P.isString(r[0])){let s=r.map(a=>P.encodeString(a));i=this.write(s,e,n)}else i=this.write(r,e,n);return this.texData.get(i).usage=null,{dataId:i,shape:e,dtype:n}}makeOutput(e,n,r){return No().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,r),this)}unpackTensor(e){let n=new aGe(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){let n=new W4e(e.shape);return this.runWebGLProgram(n,[e],e.dtype,null,!0)}packedReshape(e,n){let r=[uf(e.shape),...cf(e.shape)],i={dtype:e.dtype,shape:r,dataId:e.dataId},s=[uf(n),...cf(n)],a=new iee(s,r),o=!0,l=[r],u=this.runWebGLProgram(a,[i],e.dtype,l,o);return{dataId:u.dataId,shape:n,dtype:u.dtype}}decode(e,n){let r=this.texData.get(e),{isPacked:i,shape:s,dtype:a}=r;if(n!=null){let h=P.sizeFromShape(s),p=n[0]*n[1]*4;P.assert(h<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let o=ab(s),l;i?l=new jze(o):l=new Vze(o);let u=!0,c=[n??TA(o)],d=this.runWebGLProgram(l,[{shape:o,dtype:a,dataId:e}],a,c,u,n);return{dtype:a,shape:s,dataId:d.dataId}}runWebGLProgram(e,n,r,i,s=!1,a){let o=this.makeTensorInfo(e.outputShape,r),l=this.texData.get(o.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===E1.DENSE){let m=a??TA(e.outputShape);l.texShape=m.map(b=>b*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),P.sizeFromShape(o.shape)===0)return l.values=P.getTypedArrayFromDType(o.dtype,0),o;let u=[],c=n.map(m=>{if(m.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(m.dataId);if(b.texture==null){if(!e.packedInputs&&P.sizeFromShape(m.shape)<=Ie().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:m.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=m.shape)}if(this.uploadToGPU(m.dataId),!!b.isPacked!=!!e.packedInputs)m=b.isPacked?this.unpackTensor(m):this.packTensor(m),u.push(m),b=this.texData.get(m.dataId);else if(b.isPacked&&!I1(b.shape,m.shape)){let w=m,_=m.shape;m.shape=b.shape,m=this.packedReshape(m,_),u.push(m),b=this.texData.get(m.dataId),w.shape=_}return{shape:m.shape,texData:b,isUniform:!1}});this.uploadToGPU(o.dataId);let d={shape:o.shape,texData:l,isUniform:!1},h=Wze(e,c,d),p=this.getAndSaveBinary(h,()=>Gze(this.gpgpu,e,c,d)),f=this.activeTimers!=null,g;f&&(g=this.startTimer()),Ie().get("ENGINE_COMPILE_ONLY")||Hze(this.gpgpu,p,c,d,i),u.forEach(m=>this.disposeIntermediateTensorInfo(m)),f&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));let y=Ie().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){let m=P.now();m-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=m)}if(!Ie().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&s===!1){let m=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),m}return o}compileAndRun(e,n,r,i,s=!1){return r=r||n[0].dtype,this.runWebGLProgram(e,n,r,i,s)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Ie().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=xe(()=>{if(!Ie().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=Ie().getBool("DEBUG");Ie().set("DEBUG",!1);let n=this.abs(rn(1e-8)).dataSync()[0];if(Ie().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?lGe:uGe}uploadToGPU(e){let n=this.texData.get(e),{shape:r,dtype:i,values:s,texture:a,usage:o,isPacked:l}=n;if(a!=null)return;let u=this.activeTimers!=null,c;u&&(c=P.now());let d=n.texShape;if(d==null&&(d=EQ(r,l),n.texShape=d),s!=null){let h=ab(r),p,f=d[1],g=d[0],y=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!y)&&([f,g]=Rv(d[0],d[1])),l?p=new Jze(h,y):p=new QV(h,y);let m=y?[g,f]:d,b=this.makeTensorInfo(m,i),w=this.texData.get(b.dataId);y?w.usage=no.PIXELS:w.usage=no.UPLOAD,w.texShape=m,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),f,g,s);let _=[[g,f]],S=this.runWebGLProgram(p,[b],i,_,!0),E=this.texData.get(S.dataId);n.texShape=E.texShape,n.isPacked=E.isPacked,n.usage=E.usage,Ie().get("ENGINE_COMPILE_ONLY")?this.disposeData(S.dataId):(n.texture=E.texture,n.values=null,this.texData.delete(S.dataId)),this.disposeIntermediateTensorInfo(b),u&&(this.uploadWaitMs+=P.now()-c)}else{let h=this.acquireTexture(d,o,i,l);n.texture=h}}convertAndCacheOnCPU(e,n){let r=this.texData.get(e),{dtype:i}=r;return n!=null&&(r.values=fGe(n,i)),r.values}acquireTexture(e,n,r,i){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,i)}computeBytes(e,n){return e[0]*e[1]*P.bytesPerElement(n)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,n]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(n));return Promise.all(e)}else{for(let[,n]of Object.entries(this.binaryCache)){let r=new Promise(i=>{try{this.checkCompletion_(n),i(!0)}catch(s){throw s}});e.push(r)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await QL(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(eU(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:n,customUniformLocations:r,infLoc:i,nanLoc:s,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:l}=LQ(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=n,e.customUniformLocations=r,e.infLoc=i,e.nanLoc=s,e.outShapeLocation=a,e.outShapeStridesLocation=o,e.outTexShapeLocation=l}}createTensorFromGPUData(e,n,r){e.channels=e.channels||"RGBA";let{texture:i,height:s,width:a,channels:o}=e,l=No().backend;if(!l.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let u=l.writeTexture(i,n,r,s,a,o);return No().makeTensorFromDataId(u,n,r,l)}};cU.nextDataId=0;function fGe(t,e){if(e==="float32"||e==="complex64")return t;if(e==="int32"||e==="bool"){let n=e==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<n.length;++r)n[r]=Math.round(t[r]);return n}else throw new Error(`Unknown dtype ${e}`)}var mGe="4.22.0";function aee(){Ie().set("WEBGL_FORCE_F16_TEXTURES",!0)}Cw.isBrowser()&&xC("webgl",()=>new cU,2);var gGe={forceHalfFloat:aee},dU=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,df=class{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=W.assertAndGetBroadcastShape(e,n),this.enableShapeUniforms=As(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},Qm=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,Bv=class{constructor(t,e,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=W.assertAndGetBroadcastShape(e,n);let i=this.outputShape.length;this.enableShapeUniforms=As(i);let s="";if(r)if(i===0||P.sizeFromShape(this.outputShape)===1)s=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(s=`
          ${Sr(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?s+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:s+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let a=Bs("coords",i);this.enableShapeUniforms?s+=`
            bool nextRowOutOfBounds =
              (${a[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${a[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:s+=`
            bool nextRowOutOfBounds =
              (${a[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${a[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${s}

        setOutput(result);
      }
    `}};function Ga(t){let{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var yGe={kernelName:tm,backendName:"webgl",kernelFunc:Ga};function dh(t){let{inputs:e,backend:n}=t,{real:r,imag:i}=e,s=n.makeTensorInfo(r.shape,"complex64"),a=n.texData.get(s.dataId),o=Ga({inputs:{x:r},backend:n}),l=Ga({inputs:{x:i},backend:n});return a.complexTensorInfos={real:o,imag:l},s}var vGe={kernelName:iC,backendName:"webgl",kernelFunc:dh},oee="return (a < 0.) ? b * a : a;",lee=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function xGe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{alpha:s}=r,a=n.makeTensorInfo([],"float32",P.createScalarValue(s,"float32")),o=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Bv(lee,i.shape,a.shape):new df(oee,i.shape,a.shape),l=n.runWebGLProgram(o,[i,a],"float32");return n.disposeIntermediateTensorInfo(a),l}var bGe={kernelName:sm,backendName:"webgl",kernelFunc:xGe},uee="return (a < 0.) ? b * a : a;",cee=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function wGe(t){let{inputs:e,backend:n}=t,{x:r,alpha:i}=e,s=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Bv(cee,r.shape,i.shape):new df(uee,r.shape,i.shape);return n.runWebGLProgram(s,[r,i],"float32")}var _Ge={kernelName:wm,backendName:"webgl",kernelFunc:wGe},Uv="if (isnan(x)) return x;";function Zn({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:r}){return({inputs:i,backend:s})=>{let{x:a}=i,o=s,l=r||a.dtype;if(o.shouldExecuteOnCPU([a])&&n!=null){let d=o.texData.get(a.dataId),h=n(d.values,l);return o.makeTensorInfo(a.shape,l,h)}let u=Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null,c;return u?c=new hd(a.shape,e):c=new Ql(a.shape,t),o.runWebGLProgram(c,[a],l)}}function hs({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:i,dtype:s}){return({inputs:a,backend:o})=>{let{a:l,b:u}=a,c=o;if(r&&l.dtype==="complex64"){let f=c.texData.get(l.dataId),g=c.texData.get(u.dataId),[y,m]=[[f.complexTensorInfos.real,g.complexTensorInfos.real],[f.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(w=>{let[_,S]=w,E={dataId:_.dataId,dtype:_.dtype,shape:l.shape},C={dataId:S.dataId,dtype:S.dtype,shape:u.shape},T=new df(t,l.shape,u.shape);return c.runWebGLProgram(T,[E,C],uo(_.dtype,S.dtype))}),b=dh({inputs:{real:y,imag:m},backend:c});return c.disposeIntermediateTensorInfo(y),c.disposeIntermediateTensorInfo(m),b}let d=s||uo(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&i!=null){let f=c.texData.get(l.dataId).values,g=c.texData.get(u.dataId).values,y=l.dtype==="string"?W.fromUint8ToStringArray(f):f,m=l.dtype==="string"?W.fromUint8ToStringArray(g):g,[b,w]=i(l.shape,u.shape,y,m,d),_=c.makeTensorInfo(w,d),S=c.texData.get(_.dataId);return S.values=b,_}let h=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null,p;return h?p=new Bv(e,l.shape,u.shape,n):p=new df(t,l.shape,u.shape),c.runWebGLProgram(p,[l,u],d)}}function T1(t,e=!1){if(t==="linear")return e?tGe:J4e;if(t==="relu")return e?rGe:Z4e;if(t==="elu")return e?nGe:Y4e;if(t==="relu6")return e?iGe:Q4e;if(t==="prelu")return e?cee:uee;if(t==="leakyrelu")return e?lee:oee;if(t==="sigmoid")return e?sGe:eGe;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}var dee=class{constructor(t,e,n,r=!1,i=!1,s=!1,a=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=As(this.outputShape.length);let u=r?t[1]:t[2],c=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=i?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",y="";a&&(o?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");let m=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",w="rc.x";t[0]<e[0]?b=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(w=`imod(rc.x, ${e[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${c}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${b};
        int batchB = ${w};
        for (int i = 0; i < ${c}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${h});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${f[0]});
          result += (${p[1]} * ${f[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${m}

        ${y}

        setOutput(result);
      }
    `}},i5={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},s5=class{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=W.assertAndGetBroadcastShape(e,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},a5="return a * b;";function hU(t){let{inputs:e,backend:n}=t,{a:r,b:i}=e,s=W.upcastType(r.dtype,i.dtype);if(r.dtype==="complex64"){let o=n.texData.get(r.dataId),l=n.texData.get(i.dataId),u=new s5(i5.REAL,r.shape,i.shape),c=new s5(i5.IMAG,r.shape,i.shape),d=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:i.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:i.shape}],h=n.runWebGLProgram(u,d,"float32"),p=n.runWebGLProgram(c,d,"float32"),f=dh({inputs:{real:h,imag:p},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}if(n.shouldExecuteOnCPU([r,i])){let o=n.texData.get(r.dataId),l=n.texData.get(i.dataId),[u,c]=x4e(r.shape,i.shape,o.values,l.values,s),d=n.makeTensorInfo(c,s),h=n.texData.get(d.dataId);return h.values=u,d}let a;return Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new Bv(a5,r.shape,i.shape):a=new df(a5,r.shape,i.shape),n.runWebGLProgram(a,[r,i],s)}var SGe={kernelName:ym,backendName:"webgl",kernelFunc:hU};function AGe(t,e,n){let r=[uf(t.shape),...cf(t.shape)],i={dtype:t.dtype,shape:r,dataId:t.dataId},s=[uf(e),...cf(e)],a=new iee(s,r),o=!0,l=[r],u=n.runWebGLProgram(a,[i],t.dtype,l,o);return{dataId:u.dataId,shape:e,dtype:u.dtype}}function Nt(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{shape:s}=r,a=n,o=P.sizeFromShape(i.shape),l=P.inferFromImplicitShape(s,o),u=P.sizeFromShape(l);P.assert(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let c=a.texData.get(i.dataId);return c.isPacked&&!I1(i.shape,l)&&!(c.texture!==null&&I1(c.shape,l))?AGe(i,l,a):(a.incRef(i.dataId),{dataId:i.dataId,shape:l,dtype:i.dtype})}var EGe={kernelName:rv,backendName:"webgl",kernelFunc:Nt},o5=class{constructor(t,e){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:i,outSize:s}=t;this.outputShape=[r,s];let a=Math.floor(n/4)*4,o=n%4,l="sumValue += dot(values, ones);";if(e!=null){let c=1/e;l=`sumValue += dot(values * ${P.isInt(c)?c.toPrecision(2):c}, ones);`}let u="";i%n>0&&(u=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${a};
        if (${o===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${o===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${o===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}},IGe=class{constructor(t,e){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:i,outSize:s}=t;this.outputShape=[r,s];let a="0.0",o="";e==="prod"?a="1.0":e==="min"?(a="1.0 / 1e-20",o="min"):e==="max"&&(a="-1.0 / 1e-20",o="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?l="sumValue":e==="prod"?l="prodValue":e==="all"?l="allValue":e==="any"&&(l="anyValue");let u=Math.floor(n/4)*4,c=n%4,d=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,h="vec4";e==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,h="bvec4"):e==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,h="bvec4");let p="";i%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${c===1}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${c===2}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${c===3}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function TGe(t){let e=[];for(;e.length===0||e[e.length-1].outSize!==1;){let n=e.length?e[e.length-1].outSize:t[1],r=W.computeOptimalWindowSize(n);e.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return e}function eg(t,e,n,r){let i=TGe(t.shape),s=t;for(let a=0;a<i.length;a++){let{inSize:o,windowSize:l,outSize:u}=i[a],c,d;n==="mean"?c=a===0?new o5({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u},o):new o5({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u}):c=new IGe({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u},n),d=s,s=r.runWebGLProgram(c,[s],e),d.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(d)}return s}var CGe=class{constructor(t,e){this.variableNames=["A"];let n=new Array(t.length);for(let s=0;s<n.length;s++)n[s]=t[e[s]];this.outputShape=n,this.rank=n.length;let r=Sr(this.rank),i=MGe(e);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}};function MGe(t){let e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let i=0;i<t.length;i++)r[t[i]]=n[i];return r.join()}var kGe=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(t.length);for(let u=0;u<n.length;u++)n[u]=t[e[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=Sr(this.rank),i=ree("rc",this.rank),s=new Array(this.rank);for(let u=0;u<e.length;u++)s[e[u]]=i[u];let a=`vec2(${s.slice(-2).join()})`,o=`++${i[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${a})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${o}) {
        result[1] = ${l};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${o}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function AM(t,e,n){let r=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kGe(t.shape,e):new CGe(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}function NGe(t,e,n,r){let i=e,s=t.shape.length,a=P.parseAxisParam(i,t.shape),o=a,l=W.getAxesPermutation(o,s),u=l!=null,c=t;u&&(c=AM(t,l,r),o=W.getInnerMostAxes(o.length,s)),W.assertAxesAreInnerMostDims("sum",o,s);let[d,h]=W.computeOutAndReduceShapes(c.shape,o),p=d;n&&(p=W.expandShapeToKeepDim(d,a));let f=P.sizeFromShape(h),g=P.sizeFromShape(t.shape)/f,y=Nt({inputs:{x:c},attrs:{shape:[g,f]},backend:r}),m=vC(t.dtype),b=eg(y,m,"sum",r),w=Nt({inputs:{x:b},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(b),u&&r.disposeIntermediateTensorInfo(c),w}function EM(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r;return NGe(i,s,a,n)}var RGe={kernelName:Bm,backendName:"webgl",kernelFunc:EM};function Gs(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{perm:s}=r,a=n,o=i.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=i.shape[s[c]];let u;if(a.shouldExecuteOnCPU([i])){let c=a.texData.get(i.dataId).values,d=uU(c,i.shape,i.dtype,s,l);u=a.makeTensorInfo(l,i.dtype);let h=a.texData.get(u.dataId);h.values=d}else u=AM(i,s,a);return u}var FGe={kernelName:Qu,backendName:"webgl",kernelFunc:Gs},hee=1e3;function qI({a:t,b:e,transposeA:n,transposeB:r,backend:i,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}){let u=t.shape.length,c=e.shape.length,d=n?t.shape[u-2]:t.shape[u-1],h=r?e.shape[c-1]:e.shape[c-2],p=n?t.shape[u-1]:t.shape[u-2],f=r?e.shape[c-2]:e.shape[c-1],g=t.shape.slice(0,-2),y=e.shape.slice(0,-2),m=P.sizeFromShape(g),b=P.sizeFromShape(y),w=wv.assertAndGetBroadcastShape(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);P.assert(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);let _=n?[m,d,p]:[m,p,d],S=r?[b,f,h]:[b,h,f],E=Nt({inputs:{x:t},backend:i,attrs:{shape:_}}),C=Nt({inputs:{x:e},backend:i,attrs:{shape:S}}),T=[E,C],M=Math.max(m,b),k=n?E.shape[1]:E.shape[2],R=s!=null,N=a!=null,B=l==="leakyrelu",z=l!=null?T1(l,!0):null,V=R||N||B||z!=null,K;if((p===1||f===1)&&k>hee&&V===!1){let O=E,j=C;n&&(O=Gs({inputs:{x:E},backend:i,attrs:{perm:[0,2,1]}}),T.push(O)),r&&(j=Gs({inputs:{x:C},backend:i,attrs:{perm:[0,2,1]}}),T.push(j));let X=f!==1,te=f===1,le=O;X&&(le=Nt({inputs:{x:O},backend:i,attrs:{shape:[M,k,1]}}),T.push(le));let ge=f===1?2:1,ie=j;te&&(ie=Nt({inputs:{x:j},backend:i,attrs:{shape:[M,1,k]}}),T.push(ie));let we=hU({inputs:{a:le,b:ie},backend:i});K=EM({inputs:{x:we},backend:i,attrs:{axis:ge,keepDims:!0}}),T.push(we)}else{let O=uo(t.dtype,e.dtype),j=new dee(_,S,[M,p,f],n,r,R,z,N,B),X=[E,C];if(s!=null&&X.push(s),N&&X.push(a),B){let te=i.makeTensorInfo([],"float32",P.createScalarValue(o,"float32"));X.push(te),T.push(te)}K=i.runWebGLProgram(j,X,O)}let Q=Nt({inputs:{x:K},backend:i,attrs:{shape:w}});T.push(K);for(let O of T)i.disposeIntermediateTensorInfo(O);return Q}function DGe(t){let{inputs:e,backend:n,attrs:r}=t,{a:i,b:s,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return qI({a:i,b:s,transposeA:l,transposeB:u,backend:n,bias:a,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}var PGe={kernelName:Xp,backendName:"webgl",kernelFunc:DGe},l5="return abs(x);";function LGe(t){let{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let s=n.texData.get(r.dataId),a=tee(s.values);return n.makeTensorInfo(r.shape,r.dtype,a)}let i;return Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new hd(r.shape,l5):i=new Ql(r.shape,l5),n.runWebGLProgram(i,[r],r.dtype)}var OGe={kernelName:x0,backendName:"webgl",kernelFunc:LGe},BGe=Xo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,UGe=Zn({opSnippet:BGe}),$Ge={kernelName:If,backendName:"webgl",kernelFunc:UGe},zGe=Xo+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,GGe=Zn({opSnippet:zGe}),HGe={kernelName:Tf,backendName:"webgl",kernelFunc:GGe},u5="return a + b;",WGe=hs({opSnippet:u5,packedOpSnippet:u5,supportsComplex:!0,cpuKernelImpl:Zze}),VGe={kernelName:th,backendName:"webgl",kernelFunc:WGe},jGe=class{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((i,s)=>`T${s}`);let n=[];this.variableNames.forEach(i=>{n.push(`float v${i} = get${i}AtOutCoords();`)});let r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}},XGe=class{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((i,s)=>`T${s}`);let n=[];this.variableNames.forEach(i=>{n.push(`vec4 v${i} = get${i}AtOutCoords();`)});let r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}};function sE(t){let{inputs:e,backend:n}=t,r=e;if(r.length===1)return Ga({inputs:{x:r[0]},backend:n});if(r.length>Ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let o=Math.floor(r.length/2),l=sE({inputs:r.slice(0,o),backend:n}),u=sE({inputs:r.slice(o),backend:n});return sE({inputs:[l,u],backend:n})}let i=r.map(o=>o.dtype).reduce((o,l)=>uo(o,l)),s=r.map(o=>o.shape),a=Ie().getBool("WEBGL_PACK")?new XGe(r[0].shape,s):new jGe(r[0].shape,s);return n.runWebGLProgram(a,r,i)}var KGe={kernelName:Cf,backendName:"webgl",kernelFunc:sE};function qGe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r,o=i.shape.length,l=P.parseAxisParam(s,i.shape),u=l,c=W.getAxesPermutation(u,o),d=i;c!=null&&(d=Gs({inputs:{x:i},backend:n,attrs:{perm:c}}),u=W.getInnerMostAxes(u.length,o)),W.assertAxesAreInnerMostDims("all",u,o);let[h,p]=W.computeOutAndReduceShapes(d.shape,u),f=P.sizeFromShape(p),g=Nt({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),y=eg(g,g.dtype,"all",n),m;if(a){let b=W.expandShapeToKeepDim(h,l);m=Nt({inputs:{x:y},backend:n,attrs:{shape:b}})}else m=Nt({inputs:{x:y},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),c!=null&&n.disposeIntermediateTensorInfo(d),m}var JGe={kernelName:b0,backendName:"webgl",kernelFunc:qGe};function YGe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r,o=i.shape.length,l=P.parseAxisParam(s,i.shape),u=l,c=W.getAxesPermutation(u,o),d=i;c!=null&&(d=Gs({inputs:{x:i},backend:n,attrs:{perm:c}}),u=W.getInnerMostAxes(u.length,o)),W.assertAxesAreInnerMostDims("any",u,o);let[h,p]=W.computeOutAndReduceShapes(d.shape,u),f=P.sizeFromShape(p),g=Nt({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),y=eg(g,g.dtype,"any",n),m;if(a){let b=W.expandShapeToKeepDim(h,l);m=Nt({inputs:{x:y},backend:n,attrs:{shape:b}})}else m=Nt({inputs:{x:y},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),c!=null&&n.disposeIntermediateTensorInfo(d),m}var ZGe={kernelName:w0,backendName:"webgl",kernelFunc:YGe},QGe=class{constructor(t,e,n){this.variableNames=["A"];let{windowSize:r,batchSize:i,outSize:s}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[i,s];let a=e==="max"?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${o};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},eHe=class{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,P.assert(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let i=t[t.length-1],s=Math.ceil(i/e);this.outputShape=t.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");let a=this.outputShape,o=a.length,l=Sr(o),u=Bs("coords",o),c,d;if(s===1){d=o+1;let C=Sr(d);c=`
        ${C} sourceLocR = ${C}(${u.join()}, 0);
        ++${u[o-1]};
        ${C} sourceLocG = ${C}(${u.join()}, 0);
        ++${u[o-2]};
        ${C} sourceLocA = ${C}(${u.join()}, 0);
        --${u[o-1]};
        ${C} sourceLocB = ${C}(${u.join()}, 0);
        --${u[o-2]};`}else d=o,c=`
        ${l} sourceLocR = coords;
        ++${u[o-1]};
        ${l} sourceLocG = coords;
        ++${u[o-2]};
        ${l} sourceLocA = coords;
        --${u[o-1]};
        ${l} sourceLocB = coords;
        --${u[o-2]};`;let h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],f=h.map(C=>"int "+C),g=Bs("sourceLocR",d-1).concat("inIdx.r"),y=Bs("sourceLocG",d-1).concat("inIdx.g"),m=Bs("sourceLocB",d-1).concat("inIdx.b"),b=Bs("sourceLocA",d-1).concat("inIdx.a"),w=n==="max"?"greaterThan":"lessThan",_=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${b.join()})));`,S=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${m.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,E=r?"":`
      float getBestIndicesAChannel(${f.join()}) {
        return getChannel(getBestIndicesA(${h.join()}),
                                          vec2(${h.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${f.join()}) {
        return getChannel(getA(${h.join()}),
                               vec2(${h.slice(-2).join()}));
      }
      ${E}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${u[o-1]} < ${a[o-1]-1};
        bool hasNextRow = ${u[o-2]} < ${a[o-2]-1};
        ${c}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${S};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${_}
          vec4 candidate = ${S};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function pee(t,e,n,r=null){let i=e.shape[0],s=e.shape[1];r!=null&&(i=r.shape[0],s=r.shape[1]);let a=W.computeOptimalWindowSize(s),o={windowSize:a,inSize:s,batchSize:i,outSize:Math.ceil(s/a)},l=new QGe(o,n,r==null),u=[e];r!=null&&u.push(r);let c=t.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;let d=pee(t,e,n,c);return t.disposeIntermediateTensorInfo(c),d}function fee(t,e,n,r=null){let i=r!=null?r.shape:e.shape,s=i[i.length-1],a=W.computeOptimalWindowSize(s),o=new eHe(i,a,n,r==null),l=r==null?[e]:[e,r],u=t.runWebGLProgram(o,l,"int32");if(u.shape.length===e.shape.length){let c=fee(t,e,n,u);return t.disposeIntermediateTensorInfo(u),c}return u}function mee(t,e,n,r){let i=[n];if(W.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),i,e.shape.length),!Ie().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){let s=[],a=t.texData.get(e.dataId),o=a!==null&&a.isPacked,l=e;o&&(l=t.unpackTensor(e),s.push(l));let[u,c]=W.computeOutAndReduceShapes(l.shape,i),d=P.sizeFromShape(c),h=Nt({inputs:{x:l},backend:t,attrs:{shape:[-1,d]}});s.push(h);let p=pee(t,h,r);s.push(p);let f=Nt({inputs:{x:p},backend:t,attrs:{shape:u}});return s.forEach(g=>t.disposeIntermediateTensorInfo(g)),f}return fee(t,e,r)}function tHe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s}=r,a=P.parseAxisParam(s,i.shape),o=W.getAxesPermutation(a,i.shape.length),l=i,u=[];o!=null&&(l=Gs({inputs:{x:i},backend:n,attrs:{perm:o}}),u.push(l),a=W.getInnerMostAxes(a.length,l.shape.length)),W.assertAxesAreInnerMostDims("argMax",[a[0]],l.shape.length);let c=mee(n,l,a[0],"max");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}var nHe={kernelName:_0,backendName:"webgl",kernelFunc:tHe};function rHe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s}=r,a=P.parseAxisParam(s,i.shape),o=W.getAxesPermutation(a,i.shape.length),l=i,u=[];o!=null&&(l=Gs({inputs:{x:i},backend:n,attrs:{perm:o}}),u.push(l),a=W.getInnerMostAxes(a.length,l.shape.length)),W.assertAxesAreInnerMostDims("argMin",[a[0]],l.shape.length);let c=mee(n,l,a[0],"min");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}var iHe={kernelName:S0,backendName:"webgl",kernelFunc:rHe},sHe=Xo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,aHe=Zn({opSnippet:sHe}),oHe={kernelName:Mf,backendName:"webgl",kernelFunc:aHe},lHe=Xo+"return log(x + sqrt(x * x + 1.0));",uHe=Zn({opSnippet:lHe}),cHe={kernelName:kf,backendName:"webgl",kernelFunc:uHe},dHe=Xo+`
  return atan(x);
`,hHe=Zn({opSnippet:dHe}),pHe={kernelName:Nf,backendName:"webgl",kernelFunc:hHe},fHe=dU+`
  return atan(a, b);
`,mHe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Qm+`
  return result;
`,gHe=hs({opSnippet:fHe,packedOpSnippet:mHe}),yHe={kernelName:Ff,backendName:"webgl",kernelFunc:gHe},vHe=Xo+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,xHe=Zn({opSnippet:vHe}),bHe={kernelName:Rf,backendName:"webgl",kernelFunc:xHe},C1=class{constructor(t,e,n,r=!1,i=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=t.filterWidth,a=t.strideHeight,o=t.strideWidth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;let f=e==="avg",g=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,y=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`,m="0.0";if(f||(m="-1.0 / 1e-20"),n){let C=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${o});
        const ivec2 pads = ivec2(${h}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${c};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${C} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?g:y:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let b="max",w=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(w="avgValue / max(count, 1.0)");let _=Math.floor(s/4)*4,S=s%4,E=`
      if (${f}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${b}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${o});
      const ivec2 pads = ivec2(${h}, ${p});
      const float initializationValue = ${m};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${m});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${c};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${_}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${E}
          }

          int xC = xCCorner + ${_};
          if (${S===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${E}
          } else if (${S===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${E}
          } else if (${S===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${E}
          }
        }
        setOutput(${w});
      }
    `}},pU=class{constructor(t,e,n,r=!1,i=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=t.filterWidth,a=t.strideDepth,o=t.strideHeight,l=t.strideWidth,u=t.dilationDepth,c=t.dilationHeight,d=t.dilationWidth,h=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,g=t.padInfo.front,y=t.padInfo.top,m=t.padInfo.left;this.outputShape=t.outShape;let b=e==="avg",w="0.0";if(b||(w="-1.0 / 1e-20"),n){let M=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${o}, ${l});
        const ivec3 pads = ivec3(${g}, ${y}, ${m});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${h};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${c}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${M} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${f} +
                      wR * ${f} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let _="max",S=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(S="avgValue / max(count, 1.0)");let E=Math.floor(s/4)*4,C=s%4,T=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${_}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${o}, ${l});
      const ivec3 pads = ivec3(${g}, ${y}, ${m});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${E}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${T}
            }

            int xC = xCCorner + ${E};
            if (${C===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${T}
            } else if (${C===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${T}
            } else if (${C===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${T}
            }
          }
        }
        setOutput(${S});
      }
    `}};function wHe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e;Fv(i,"avgPool");let{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=r,u=1;P.assert(W.eitherStridesOrDilationsAreOne(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=W.computePool2DInfo(i.shape,s,a,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&P.arraysEqual(c.inShape,c.outShape))return Ga({inputs:{x:i},backend:n});let d=new C1(c,"avg",!1);return n.runWebGLProgram(d,[i],"float32")}var _He={kernelName:Df,backendName:"webgl",kernelFunc:wHe};function SHe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{filterSize:s,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=[1,1,1],d=W.computePool3DInfo(i.shape,s,a,c,o,l,u),h=new pU(d,"avg",!1);return n.runWebGLProgram(h,[i],"float32")}var AHe={kernelName:A0,backendName:"webgl",kernelFunc:SHe},EHe=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,i=t.strideWidth,s=t.dilationHeight,a=t.dilationWidth,o=t.effectiveFilterHeight,l=t.effectiveFilterWidth,u=o-1-t.padInfo.top,c=l-1-t.padInfo.left,d=1/(e*n);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${c});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},IHe=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,i=t.strideDepth,s=t.strideHeight,a=t.strideWidth,o=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterDepth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,p=c-1-t.padInfo.front,f=d-1-t.padInfo.top,g=h-1-t.padInfo.left,y=1/(e*n*r);this.userCode=`
      const ivec3 pads = ivec3(${p}, ${f}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function THe(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,a=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=[1,1,1],h=W.computePool3DInfo(a.shape,o,l,d,u,c),p=new IHe(h);return n.runWebGLProgram(p,[i],a.dtype)}var CHe={kernelName:sw,backendName:"webgl",kernelFunc:THe};function MHe(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,a=s;Fv([i,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=W.computePool2DInfo(a.shape,o,l,1,u),d=new EHe(c);return n.runWebGLProgram(d,[i],a.dtype)}var kHe={kernelName:iw,backendName:"webgl",kernelFunc:MHe};function NHe(t){let{inputs:e,backend:n,attrs:r}=t,{a:i,b:s}=e,{transposeA:a,transposeB:o}=r;return qI({a:i,b:s,transposeA:a,transposeB:o,backend:n})}var RHe={kernelName:Pf,backendName:"webgl",kernelFunc:NHe},FHe=class{constructor(t,e,n,r,i,s){this.outputShape=[],this.variableNames=["x","mean","variance"],W.assertAndGetBroadcastShape(t,e),W.assertAndGetBroadcastShape(t,n);let a="0.0";r!=null&&(W.assertAndGetBroadcastShape(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="1.0";i!=null&&(W.assertAndGetBroadcastShape(t,i),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${s}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},DHe=class{constructor(t,e,n,r,i,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],W.assertAndGetBroadcastShape(t,e),W.assertAndGetBroadcastShape(t,n);let a="vec4(0.0)";r!=null&&(W.assertAndGetBroadcastShape(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="vec4(1.0)";i!=null&&(W.assertAndGetBroadcastShape(t,i),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${o};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${s}));

        setOutput((x - mean) * inv + offset);
      }
    `}},PHe=({inputs:t,backend:e,attrs:n})=>{let{x:r,mean:i,variance:s,offset:a,scale:o}=t;P.assert(i.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),P.assert(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),P.assert(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);let u=[r,i,s],c=null;a!=null&&(c=a.shape,u.push(a));let d=null;o!=null&&(d=o.shape,u.push(o));let h=Ie().getBool("WEBGL_PACK_NORMALIZATION")?new DHe(r.shape,i.shape,s.shape,c,d,l):new FHe(r.shape,i.shape,s.shape,c,d,l);return e.runWebGLProgram(h,u,u[0].dtype)},LHe={kernelName:Qf,backendName:"webgl",kernelFunc:PHe},OHe=class{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;let e=Sr(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=BHe(this.rank),r,i=t.map((s,a)=>`sourceLoc.${eD[a]} = start[${a}] + coords.${eD[a]};`);r=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${n}));
      }
    `}},eD=["x","y","z","w","u","v"];function BHe(t){if(t===1)return"sourceLoc";if(t<=6)return eD.slice(0,t).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}var UHe=class{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let e=Sr(this.rank),n=Bs("coords",this.rank),r=Bs("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${i})`,a=`
      result.x = ${s};
      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${s};
        --${r[this.rank-1]};
      }
    `,o=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${s};
        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${s};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((u,c)=>`start[${c}]`).join()});`:t.map((u,c)=>`${r[c]} = ${n[c]} + start[${c}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${a}
        ${o}
        setOutput(result);
      }
    `}};function $He(t,e,n,r){let i=r.texData.get(t.dataId),s=r.makeTensorInfo(n,t.dtype),a=r.texData.get(s.dataId);Object.assign(a,i),a.refCount=1,a.shape=n,a.dtype=t.dtype;let o=Ni.computeFlatOffset(e,P.computeStrides(t.shape));i.slice&&(o+=i.slice.flatOffset),a.slice={flatOffset:o,origDataId:i.slice&&i.slice.origDataId||t.dataId};let l=r.dataRefCount.get(a.slice.origDataId)||1;return r.dataRefCount.set(a.slice.origDataId,l+1),s}function $v(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{begin:s,size:a}=r,[o,l]=Ni.parseSliceParams(i,s,a);if(Ni.assertParamsValid(i,o,l),P.sizeFromShape(l)===0)return n.makeTensorInfo(l,i.dtype,[]);if(n.shouldExecuteOnCPU([i])||i.dtype==="string"){let d=n.texData.get(i.dataId),h=k4e(d.values,o,l,i.shape,i.dtype);return n.makeTensorInfo(l,i.dtype,h)}let{isPacked:u}=n.texData.get(i.dataId),c=Ni.isSliceContinous(i.shape,o,l);if(u||!c){let d=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new UHe(l):new OHe(l),h=[o];return n.runWebGLProgram(d,[i],i.dtype,h)}return n.uploadToGPU(i.dataId),$He(i,o,l,n)}var zHe={kernelName:cv,backendName:"webgl",kernelFunc:$v},GHe=t=>{let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:s,crops:a}=r;P.assert(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((b,w)=>b*w),l=W.getReshaped(i.shape,s,o),u=W.getPermuted(l.length,s.length),c=W.getReshapedPermuted(i.shape,s,o),d=W.getSliceBeginCoords(a,s.length),h=W.getSliceSize(c,a,s.length),p=[],f=Nt({inputs:{x:i},backend:n,attrs:{shape:l}}),g=Gs({inputs:{x:f},backend:n,attrs:{perm:u}}),y=Nt({inputs:{x:g},backend:n,attrs:{shape:c}}),m=$v({inputs:{x:y},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(g),p.push(y),p.forEach(b=>n.disposeIntermediateTensorInfo(b)),m},HHe={kernelName:E0,backendName:"webgl",kernelFunc:GHe};function WHe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,weights:s}=e,{size:a}=r,o=n.readSync(i.dataId),l=n.readSync(s.dataId),u=eee(o,l,s.dtype,s.shape,a);return n.makeTensorInfo([a],s.dtype,u)}var VHe={kernelName:I0,backendName:"webgl",kernelFunc:WHe},jHe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,XHe=`
  return float(int(a.r) & int(b.r));
`;function KHe(t){let{inputs:e,backend:n}=t,{a:r,b:i}=e,s=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS"),a=Ie().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,i])||a===1){let l=n.texData.get(r.dataId).values,u=n.texData.get(i.dataId).values,[c,d]=e4e(r.shape,i.shape,l,u,r.dtype),h=n.makeTensorInfo(d,r.dtype),p=n.texData.get(h.dataId);return p.values=c,h}let o;return s?o=new Bv(jHe,r.shape,i.shape,!1):o=new df(XHe,r.shape,i.shape),n.runWebGLProgram(o,[r,i],r.dtype)}var qHe={kernelName:T0,backendName:"webgl",kernelFunc:KHe};function JHe(t){let{inputs:e,backend:n}=t,{s0:r,s1:i}=e,s=n.readSync(r.dataId),a=n.readSync(i.dataId),o=W.assertAndGetBroadcastShape(Array.from(s),Array.from(a));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var YHe={kernelName:aw,backendName:"webgl",kernelFunc:JHe},ZHe="return float(a != b);",gee=hs({opSnippet:ZHe,cpuKernelImpl:w4e,dtype:"bool"}),QHe={kernelName:Y0,backendName:"webgl",kernelFunc:gee};function n_(t){let{inputs:e,backend:n}=t,{input:r}=e,i=n.texData.get(r.dataId);return Ga({inputs:{x:i.complexTensorInfos.real},backend:n})}var eWe={kernelName:gC,backendName:"webgl",kernelFunc:n_},tWe="return float(int(x));";function nWe(t,e){let n=new Ql(t.shape,tWe),r=e.runWebGLProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function tD(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{dtype:s}=r;if(s==="complex64"){if(i.dtype==="complex64")return Ga({inputs:{x:i},backend:n});let a=Vr(i.shape),o=tD({inputs:{x:i},backend:n,attrs:{dtype:"float32"}}),l=dh({inputs:{real:o,imag:a},backend:n});return a.dispose(),n.disposeIntermediateTensorInfo(o),l}if(i.dtype==="complex64"){let a=n_({inputs:{input:i},backend:n}),o=tD({inputs:{x:a},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(a),o}if(!P.hasEncodingLoss(i.dtype,s)){let a=Ga({inputs:{x:i},backend:n});return{dataId:a.dataId,shape:a.shape,dtype:s}}if(n.shouldExecuteOnCPU([i])){let a=n.texData.get(i.dataId).values,[o,l,u]=t4e(a,i.shape,i.dtype,s);return n.makeTensorInfo(o,l,u)}if(s==="int32")return nWe(i,n);if(s==="bool"){let a=n.makeTensorInfo([],"bool",P.getTypedArrayFromDType("bool",1)),o=gee({inputs:{a:i,b:a},backend:n});return n.disposeIntermediateTensorInfo(a),o}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${s}`)}var rWe={kernelName:Lf,backendName:"webgl",kernelFunc:tD},c5="return ceil(x);",iWe=Zn({opSnippet:c5,packedOpSnippet:c5,cpuKernelImpl:n4e}),sWe={kernelName:Of,backendName:"webgl",kernelFunc:iWe},aWe=class{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},oWe=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function lWe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{clipValueMin:s,clipValueMax:a}=r,o;Ie().getBool("WEBGL_PACK_CLIP")?o=new oWe(i.shape):o=new aWe(i.shape);let l=[[s],[a]];return n.runWebGLProgram(o,[i],i.dtype,l)}var uWe={kernelName:nh,backendName:"webgl",kernelFunc:lWe},cWe=class{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function d5(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function dWe(t){let{inputs:e,backend:n}=t,{x:r}=e,i=n.texData.get(r.dataId),s=new cWe(r.shape),a=[d5(r,i.complexTensorInfos.real),d5(r,i.complexTensorInfos.imag)];return n.runWebGLProgram(s,a,a[0].dtype)}var hWe={kernelName:ow,backendName:"webgl",kernelFunc:dWe},pWe=class{constructor(t){this.outputShape=[],this.outputShape=W.computeOutShape(t,1),this.variableNames=t.map((s,a)=>`T${a}`);let e=new Array(t.length-1);e[0]=t[0][1];for(let s=1;s<e.length;s++)e[s]=e[s-1]+t[s][1];let n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<e.length;s++){let a=e[s-1];n.push(`else if (yC < ${e[s]}) setOutput(getT${s}(yR, yC-${a}));`)}let r=e.length,i=e[e.length-1];n.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},fWe=class{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=W.computeOutShape(t,e);let n=this.outputShape,r=n.length,i=Sr(r),s=Bs("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((f,g)=>`T${g}`);let o=new Array(t.length-1);o[0]=t[0][e];for(let f=1;f<o.length;f++)o[f]=o[f-1]+t[f][e];let l=a[e],u=a.slice(-2),c=a.join(),d=`if (${l} < ${o[0]}) {
        return getChannel(
            getT0(${c}), vec2(${u.join()}));
        }`;for(let f=1;f<o.length;f++){let g=o[f-1];d+=`
        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {
          return getChannel(
            getT${f}(${MA(a,l,g)}),
            vec2(${MA(u,l,g)}));
        }`}let h=o.length,p=o[o.length-1];d+=`
        return getChannel(
          getT${h}(${MA(a,l,p)}),
          vec2(${MA(u,l,p)}));`,this.userCode=`
      float getValue(${a.map(f=>"int "+f)}) {
        ${d}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${s}), 0., 0., 0.);

        ${s[r-1]} = ${s[r-1]} + 1;
        if (${s[r-1]} < ${n[r-1]}) {
          result.g = getValue(${s});
        }

        ${s[r-2]} = ${s[r-2]} + 1;
        if (${s[r-2]} < ${n[r-2]}) {
          result.a = getValue(${s});
        }

        ${s[r-1]} = ${s[r-1]} - 1;
        if (${s[r-2]} < ${n[r-2]} &&
            ${s[r-1]} < ${n[r-1]}) {
          result.b = getValue(${s});
        }
        setOutput(result);
      }
    `}};function MA(t,e,n){let r=t.indexOf(e);return t.map((i,s)=>s===r?`${i} - ${n}`:i).join()}function IM(t){let{inputs:e,backend:n}=t,{input:r}=e,i=n.texData.get(r.dataId);return Ga({inputs:{x:i.complexTensorInfos.imag},backend:n})}var mWe={kernelName:hC,backendName:"webgl",kernelFunc:IM};function ob(t,e,n){let r=t[0].dtype;if(r==="complex64"){let p=t.map(b=>n_({inputs:{input:b},backend:n})),f=t.map(b=>IM({inputs:{input:b},backend:n})),g=ob(p,e,n),y=ob(f,e,n),m=dh({inputs:{real:g,imag:y},backend:n});return p.forEach(b=>n.disposeIntermediateTensorInfo(b)),f.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),m}let i=n.shouldExecuteOnCPU(t);if(r==="string"&&(i=!0),i){let p=t.map(_=>{let S=[-1,P.sizeFromShape(_.shape.slice(e))];return Nt({inputs:{x:_},backend:n,attrs:{shape:S}})}),f=p.map(_=>({vals:n.readSync(_.dataId),shape:_.shape})),g=W.computeOutShape(p.map(_=>_.shape),1),y=p[0].shape[0]===1,m=r4e(f,g,r,y),b=W.computeOutShape(t.map(_=>_.shape),e),w=n.makeTensorInfo(b,r,m);return p.forEach(_=>n.disposeIntermediateTensorInfo(_)),w}let s=t.filter(p=>P.sizeFromShape(p.shape)>0),a=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let p=a?new Ql(t[0].shape,Qc):new hd(t[0].shape,Qc);return n.runWebGLProgram(p,t,r)}let o=Ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){let p=[];for(let g=0;g<s.length;g+=o){let y=s.slice(g,g+o);p.push(ob(y,e,n))}let f=ob(p,e,n);for(let g of p)n.disposeIntermediateTensorInfo(g);return f}if(a){let p=new fWe(s.map(f=>f.shape),e);return n.runWebGLProgram(p,s,r)}let{tensors2D:l,outShape:u}=gWe(s,e,n),c=new pWe(l.map(p=>p.shape)),d=n.runWebGLProgram(c,l,r);l.forEach(p=>n.disposeIntermediateTensorInfo(p));let h=Nt({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),h}function gWe(t,e,n){let r=W.computeOutShape(t.map(i=>i.shape),e);return{tensors2D:t.map(i=>Nt({inputs:{x:i},attrs:{shape:[-1,P.sizeFromShape(i.shape.slice(e))]},backend:n})),outShape:r}}function yee(t){let{inputs:e,backend:n,attrs:r}=t,{axis:i}=r,s=P.parseAxisParam(i,e[0].shape)[0],a=e.map(u=>u.shape);W.assertParamsConsistent(a,s);let o=W.computeOutShape(e.map(u=>u.shape),s);if(P.sizeFromShape(o)===0)return n.makeTensorInfo(o,e[0].dtype,[]);let l=e.filter(u=>P.sizeFromShape(u.shape)>0);return l.length===1?Ga({inputs:{x:l[0]},backend:n}):ob(l,s,n)}var yWe={kernelName:C0,backendName:"webgl",kernelFunc:yee},vee=class{constructor(t,e=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;let s=t.padInfo.top,a=t.padInfo.left,o=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,d=t.filterHeight,h=t.filterWidth,p=Math.floor(t.inChannels/4)*4,f=t.inChannels%4,g=t.dataFormat==="channelsLast",y=g?1:2,m=g?2:3,b=g?3:1,w="",_="";n&&(r?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:i?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:w=`
          float activation(float x) {
            ${n}
          }
        `,_="result = activation(result);");let S=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${s}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${b}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${m}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${h}; wC++) {
            int xC = xCCorner + wC * ${c};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${f===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${f===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${f===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${S}
        ${_}
        setOutput(result);
      }
    `}},vWe=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,i=t.strideDepth,s=t.strideHeight,a=t.strideWidth,o=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,c=t.filterDepth,d=t.filterHeight,h=t.filterWidth,p=Math.floor(t.inChannels/4)*4,f=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${s}, ${a});
      const ivec3 pads = ivec3(${e}, ${n}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${c}; wF++) {
          int xF = xFCorner + wF * ${o};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${f===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${f===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${f===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},xee=class{constructor(t,e=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=As(this.outputShape.length);let s=t.padInfo.left,a=t.strideWidth,o=t.dilationWidth,l=t.filterHeight,u=t.filterWidth,c=u,d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<u;g++)d+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;d+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let g=0;g<u;g++)d+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(c+1)/2;g++){let y=g*2;if(d+=`
           xC = xCCorner + ${y*o};
           `,a===1){if(y<u&&(s%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,o===1&&y>0?d+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<u)){let m=s%2===0?P.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${m};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,o>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:d+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):m===1?d+=`
                     xC${y+1} = xTexelC${y};
                     `:d+=`
                     xCOffset = xC + ${m};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<u&&(s%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<u&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<u&&(d+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<u&&(d+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<u&&(d+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let h="",p="";n&&(r?h=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:i?h=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:h=`vec4 activation(vec4 x) {
           ${n}
         }`,p="result = activation(result);");let f=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${h}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${f}
         ${p}
         setOutput(result);
       }
     `}},xWe=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=As(this.outputShape.length);let{dataFormat:n}=e,r=Ks(),i=n==="channelsLast",s=i?1:2,a=i?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`,l="";for(let u=0;u<=1;u++)for(let c=0;c<=1;c++)l+=`
          blockIndex = rc.z + ${c};
          pos = rc.y + ${u};

          ${o}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${s}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+c}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+c}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${r.output} = result;
      }
    `}};function JI(t,e){let n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function bee({x:t,filter:e,convInfo:n,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:o=null}){let l=t.shape,u=r.texData.get(t.dataId),c=n.inChannels,d=l[0]*l[1]*l[2],h=n.outChannels,p=n.dataFormat==="channelsLast",f=!1,g=!1,y,m=[];if(s!=null){let b=JI(s.shape,p);b!=null&&(s=Nt({inputs:{x:s},backend:r,attrs:{shape:b}}),m.push(s))}if(i!=null){let b=JI(i.shape,p);b!=null&&(i=Nt({inputs:{x:i},backend:r,attrs:{shape:b}}),m.push(i))}if(!((d===1||h===1)&&c>hee)&&u.isPacked&&p&&u.texture!=null&&l[2]%2!==0&&P.arraysEqual(u.shape.slice(-3),l.slice(-3))){let b=l[0]*l[1]*(l[2]+1),w={dataId:t.dataId,shape:[1,b,n.inChannels],dtype:t.dtype},_=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,P.assert(I1(u.shape,w.shape),()=>`packed reshape ${u.shape} to ${w.shape} isn't free`);let S=Nt({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});m.push(S);let E=qI({a:w,b:S,backend:r,transposeA:f,transposeB:g,bias:i,activation:o,preluActivationWeights:s,leakyreluAlpha:a}),C=r.texData.get(E.dataId);P.assert(C.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=_,C.shape=n.outShape,y=Ga({inputs:{x:E},backend:r}),y.shape=n.outShape,m.push(E)}else{let b=n.outHeight*n.outWidth,w=Nt({inputs:{x:t},backend:r,attrs:{shape:p?[n.batchSize,b,n.inChannels]:[n.batchSize,n.inChannels,b]}}),_=Nt({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),S=qI({a:p?w:_,b:p?_:w,transposeA:!p,transposeB:g,backend:r,bias:i,activation:o,preluActivationWeights:s,leakyreluAlpha:a});y=Nt({inputs:{x:S},backend:r,attrs:{shape:n.outShape}}),m.push(w),m.push(_),m.push(S)}for(let b of m)r.disposeIntermediateTensorInfo(b);return y}function wee({x:t,filter:e,convInfo:n,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:o=null}){let{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:h,dataFormat:p}=n,f=p==="channelsLast",g=l*u*c,y=h*d,m=[n.batchSize,g,y],b=!0,w=!1,_=[];if(s!=null){let O=JI(s.shape,f);O!=null&&(s=Nt({inputs:{x:s},backend:r,attrs:{shape:O}}),_.push(s))}if(i!=null){let O=JI(i.shape,f);O!=null&&(i=Nt({inputs:{x:i},backend:r,attrs:{shape:O}}),_.push(i))}let S=Nt({inputs:{x:e},backend:r,attrs:{shape:[1,g,P.sizeFromShape(e.shape)/g]}});_.push(S);let E=new xWe(m,n),C=[t.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],T=r.runWebGLProgram(E,[t],"float32",C),M=Nt({inputs:{x:T},backend:r,attrs:{shape:m}});_.push(T),_.push(M);let k=i!=null,R=s!=null,N=o==="leakyrelu",B=o?T1(o,!0):null,z=new dee(f?M.shape:S.shape,f?S.shape:M.shape,f?[n.batchSize,y,n.outChannels]:[n.batchSize,n.outChannels,y],b,w,k,B,R,N),V=f?[M,S]:[S,M];if(i&&V.push(i),R&&V.push(s),N){let O=r.makeTensorInfo([],"float32",P.createScalarValue(a,"float32"));V.push(O),_.push(O)}let K=r.runWebGLProgram(z,V,"float32"),Q=Nt({inputs:{x:K},backend:r,attrs:{shape:n.outShape}});_.push(K);for(let O of _)r.disposeIntermediateTensorInfo(O);return Q}function bWe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:a,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=W.convertConv2DDataFormat(l),h=W.computeConv2DInfo(i.shape,s.shape,a,u,o,c,!1,d),p;if(h.filterHeight===1&&h.filterWidth===1&&h.dilationHeight===1&&h.dilationWidth===1&&h.strideHeight===1&&h.strideWidth===1&&(h.padInfo.type==="SAME"||h.padInfo.type==="VALID"))p=bee({x:i,filter:s,convInfo:h,backend:n});else if(h.strideWidth<=2&&d==="channelsLast"&&Ie().getBool("WEBGL_EXP_CONV")){let g=new xee(h),y=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(g,[i,s],"float32",y)}else if(Ie().getBool("WEBGL_CONV_IM2COL"))p=wee({x:i,filter:s,convInfo:h,backend:n});else{let g=new vee(h);p=n.runWebGLProgram(g,[i,s],"float32")}let f=Nt({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}var wWe={kernelName:Bf,backendName:"webgl",kernelFunc:bWe},_We=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,i=t.padInfo.left,s=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${s?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},SWe=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,i=t.strideWidth,s=t.dataFormat==="channelsLast",a=e-1-t.padInfo.top,o=n-1-t.padInfo.left,l=s?1:2,u=s?2:3,c=s?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${c}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${s}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},AWe=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,i=t.padInfo.front,s=t.padInfo.top,a=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${i};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${s};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${a};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},EWe=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,i=t.strideDepth,s=t.strideHeight,a=t.strideWidth,o=e-1-t.padInfo.front,l=n-1-t.padInfo.top,u=r-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${l}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function IWe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,dy:s}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=W.convertConv2DDataFormat(l),h=W.computeConv2DInfo(i.shape,c,a,1,o,u,!1,d),p=new _We(h);return n.runWebGLProgram(p,[i,s],"float32")}var TWe={kernelName:sC,backendName:"webgl",kernelFunc:IWe},CWe=class{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=As(this.outputShape.length);let e=t.filterHeight,n=t.filterWidth,r=e-1-t.padInfo.top,i=n-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function MWe(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:s}=e,{inputShape:a,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=W.convertConv2DDataFormat(u),h=W.computeConv2DInfo(a,s.shape,o,1,l,c,!1,d);if(Ie().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){let p=[[h.strideHeight,h.strideWidth]],f=new CWe(h);return n.runWebGLProgram(f,[i,s],"float32",p)}else{let p=new SWe(h);return n.runWebGLProgram(p,[i,s],"float32")}}var kWe={kernelName:Uf,backendName:"webgl",kernelFunc:MWe};function NWe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:a,pad:o,dilations:l}=r,u=W.computeConv3DInfo(i.shape,s.shape,a,l,o),c=new vWe(u);return n.runWebGLProgram(c,[i,s],"float32")}var RWe={kernelName:$f,backendName:"webgl",kernelFunc:NWe};function FWe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,dy:s}=e,{strides:a,pad:o,filterShape:l}=r,u=W.computeConv3DInfo(i.shape,l,a,1,o),c=new AWe(u);return n.runWebGLProgram(c,[i,s],"float32")}var DWe={kernelName:M0,backendName:"webgl",kernelFunc:FWe};function PWe(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:s}=e,{pad:a,strides:o,inputShape:l}=r,u=W.computeConv3DInfo(l,s.shape,o,1,a),c=new EWe(u);return n.runWebGLProgram(c,[i,s],"float32")}var LWe={kernelName:k0,backendName:"webgl",kernelFunc:PWe},OWe=Uv+`
  return cos(x);
`,BWe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Qm}
  return result;
`,UWe=Zn({opSnippet:OWe,packedOpSnippet:BWe}),$We={kernelName:zf,backendName:"webgl",kernelFunc:UWe},zWe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,GWe=Zn({opSnippet:zWe}),HWe={kernelName:Gf,backendName:"webgl",kernelFunc:GWe},WWe=class{constructor(t,e,n,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,a,o,l]=t,[u]=e,[c,d]=n;this.outputShape=[u,c,d,l];let h=r==="bilinear"?1:0,[p,f]=[`${a-1}.0`,`${o-1}.0`],[g,y,m]=c>1?[`${(a-1)/(c-1)}`,"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,w,_]=d>1?[`${(o-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${b});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${s}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${w};

        float in_y = ${m};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${_};
        if( in_x < 0.0 || in_x > ${f} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${h} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},VWe=t=>{let{inputs:e,backend:n,attrs:r}=t,{image:i,boxes:s,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:u}=r,c=new WWe(i.shape,s.shape,o,l,u);return n.runWebGLProgram(c,[i,s,a],"float32")},jWe={kernelName:R0,backendName:"webgl",kernelFunc:VWe},M1;(function(t){t.Prod="*",t.Sum="+"})(M1||(M1={}));var h5=class{constructor(t,e,n,r){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let i=this.outputShape.length,s=this.op===M1.Prod?"1.0":"0.0",a=n?s:`getX(${p5(i,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",u="";n?(l=r?`end != ${o-1}`:"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Sr(i)} coords = getOutputCoords();
        int end = ${f5(i,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${u};
          ${f5(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${p5(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function p5(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function f5(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function _ee(t,e,n,r,i,s){let a=e.shape.length,o=W.getAxesPermutation([r],a),l=e;o!=null&&(l=Gs({inputs:{x:e},backend:n,attrs:{perm:o}}));let u=W.getInnerMostAxes(1,a)[0];if(u!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);let c=l.shape[u],d=Ga({inputs:{x:l},backend:n});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){let p=new h5(t,l.shape,!1,s),f=[[h]],g=d;d=n.runWebGLProgram(p,[d],d.dtype,f),n.disposeIntermediateTensorInfo(g)}if(i){let h=new h5(t,l.shape,i,s),p=d;d=n.runWebGLProgram(h,[d],d.dtype),n.disposeIntermediateTensorInfo(p)}if(o!=null){let h=W.getUndoAxesPermutation(o),p=Gs({inputs:{x:d},backend:n,attrs:{perm:h}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),p}return d}function XWe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,exclusive:a,reverse:o}=r;return _ee(M1.Prod,i,n,s,a,o)}var KWe={kernelName:N0,backendName:"webgl",kernelFunc:XWe};function qWe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,exclusive:a,reverse:o}=r;return _ee(M1.Sum,i,n,s,a,o)}var JWe={kernelName:Hf,backendName:"webgl",kernelFunc:qWe};function YWe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,weights:s}=e,{size:a,binaryOutput:o}=r;if(i.shape.length===1){let l=n.readSync(i.dataId),u=n.readSync(s.dataId),c=eee(l,u,s.dtype,s.shape,a);return n.makeTensorInfo([a],s.dtype,c)}else if(i.shape.length===2){let l=n.bufferSync(i),u=n.bufferSync(s),c=Qze(l,u,a,o);return n.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}var ZWe={kernelName:lw,backendName:"webgl",kernelFunc:YWe},QWe=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function eVe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockSize:s,dataFormat:a}=r,o=i.shape[0],l=a==="NHWC"?i.shape[1]:i.shape[2],u=a==="NHWC"?i.shape[2]:i.shape[3],c=a==="NHWC"?i.shape[3]:i.shape[1],d=l*s,h=u*s,p=c/(s*s),f=a==="NHWC"?[o,d,h,p]:[o,p,d,h],g=new QWe(f,s,a);return n.runWebGLProgram(g,[i],i.dtype)}var tVe={kernelName:F0,backendName:"webgl",kernelFunc:eVe},See=class{constructor(t,e=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=As(this.outputShape.length);let s=t.filterHeight,a=t.filterWidth,o=t.outChannels/t.inChannels,l="",u="";n&&(r?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:i?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,u="result = activation(result);");let c=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${s}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${c}
        ${u}
        setOutput(result);
      }
    `}},Aee=class{constructor(t,e=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=As(this.outputShape.length);let s=t.outChannels/t.inChannels,a=t.padInfo.left,o=t.strideWidth,l=t.dilationWidth,u=t.filterHeight,c=t.filterWidth,d=c,h=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<c;y++)h+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;h+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let y=0;y<c;y++)h+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;h+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(d+1)/2;y++){let m=y*2;if(h+=`
          xC = xCCorner + ${m*l};
          `,o===1){if(m<c&&(a%2===1?(h+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m}Ready == 0) {
                  xTexelC${m} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${m}.zw = vec2(0.0);
                  }
                  xTexelC${m}Ready = 1;
                }
              `,l===1&&m>0?h+=`
                xC${m} = vec4(xTexelC${m-2}.zw, xTexelC${m}.xy);
                `:h+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${m} = vec4(previous.zw, xTexelC${m}.xy);
                  } else {
                    xC${m} = vec4(0.0, 0.0, xTexelC${m}.xy);
                  }
                  `):h+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${m}Ready == 0) {
                  xTexelC${m} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${m}.zw = vec2(0.0);
                  }
                  xTexelC${m}Ready = 1;
                }

                xC${m} = xTexelC${m};
                `,m+1<c)){let b=a%2===0?P.nearestLargerEven(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(h+=`
                  xCOffset = xC + imod(pads[1], 2) + ${b};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m+1}Ready == 0) {
                    xTexelC${m+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${m+1}.zw = vec2(0.0);
                    }
                    xTexelC${m+1}Ready = 1;
                  }
                  `,l>1?h+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${m+1} = vec4(previous.zw, xTexelC${m+1}.xy);
                    } else {
                     xC${m+1} = vec4(0.0, 0.0, xTexelC${m+1}.xy);
                    }
                    `:h+=`
                    xC${m+1} = vec4(xTexelC${m}.zw, xTexelC${m+1}.xy);
                    `):b===1?h+=`
                    xC${m+1} = xTexelC${m};
                    `:h+=`
                    xCOffset = xC + ${b};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m+1}Ready == 0) {
                      xTexelC${m+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${m+1}.zw = vec2(0.0);
                      }
                      xTexelC${m+1}Ready = 1;
                    }

                    xC${m+1} = xTexelC${m+1};
                    `}}else m<c&&(a%2===1?(h+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m}Ready == 0) {
                  xTexelC${m} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${m}.zw = vec2(0.0);
                  }
                  xTexelC${m}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${m+1}Ready == 0) {
                  xTexelC${m+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${m+1}.zw = vec2(0.0);
                  }
                  xTexelC${m+1}Ready = 1;
                }

                xC${m} = vec4(xTexelC${m}.zw, xTexelC${m+1}.zw);
              `,m+1<c&&(h+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${m+1} = vec4(xTexelC${m+1}.xy, final.xy);
                `)):(h+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${m}Ready == 0) {
                  xTexelC${m} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${m}.zw = vec2(0.0);
                  }
                  xTexelC${m}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m+1}Ready == 0) {
                  xTexelC${m+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${m+1}.zw = vec2(0.);
                  }
                  xTexelC${m+1}Ready = 1;
                }

                xC${m} = vec4(
                  xTexelC${m}.xy, xTexelC${m+1}.xy);
              `,m+1<c&&(h+=`
                  xC${m+1} = vec4(xTexelC${m}.zw, xTexelC${m+1}.zw);
                `)));m<c&&(h+=`
            wTexel = getW(r, ${m}, d1, q);
            dotProd += xC${m} * vec4(wTexel.xz, wTexel.xz);
          `,m+1<c&&(h+=`
              wTexel = getW(r, ${m+1}, d1, q);
              dotProd += xC${m+1} * vec4(wTexel.xz, wTexel.xz);
            `))}h+=`
    }
  `,h+=`
      }
    `;let p="",f="";n&&(r?p=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:i?p=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:p=`vec4 activation(vec4 x) {
          ${n}
        }`,f="result = activation(result);");let g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${s};
        int q = d2 - d1 * ${s};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${h}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${f}
        setOutput(result);
      }
    `}};function nVe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:a,pad:o,dilations:l,dimRoundingMode:u}=r,c=l;c==null&&(c=[1,1]),P.assert(W.eitherStridesOrDilationsAreOne(a,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);let d=W.computeConv2DInfo(i.shape,s.shape,a,c,o,u,!0),h;Ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?h=new Aee(d):h=new See(d);let p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[i,s],"float32",p)}var rVe={kernelName:Wf,backendName:"webgl",kernelFunc:nVe},iVe=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,i=t.padInfo.left,s=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${s} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},sVe=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,i=t.strideWidth,s=e-1-t.padInfo.top,a=n-1-t.padInfo.left,o=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function aVe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,dy:s}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,d=W.computeConv2DInfo(i.shape,c,a,o,l,u,!0),h=new iVe(d);return n.runWebGLProgram(h,[i,s],"float32")}var oVe={kernelName:aC,backendName:"webgl",kernelFunc:aVe};function lVe(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:s}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,d=W.computeConv2DInfo(c,s.shape,a,o,l,u,!0),h=new sVe(d);return n.runWebGLProgram(h,[i,s],"float32")}var uVe={kernelName:oC,backendName:"webgl",kernelFunc:lVe},cVe=class{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function dVe(t){let{inputs:e,backend:n}=t,{x:r}=e,i=[...r.shape,...r.shape],s=P.sizeFromShape(r.shape),a=Nt({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new cVe(s),l=n.runWebGLProgram(o,[a],a.dtype),u=Nt({inputs:{x:l},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),u}var hVe={kernelName:uw,backendName:"webgl",kernelFunc:dVe},pVe=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let{inHeight:e,inWidth:n,padInfo:r,strideHeight:i,strideWidth:s,filterHeight:a,filterWidth:o,dilationHeight:l,dilationWidth:u}=t,{top:c,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${s});
      const ivec2 pads = ivec2(${c}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function fVe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:a,pad:o,dilations:l}=r,u=W.computeDilation2DInfo(i.shape,s.shape,a,o,"NHWC",l),c,d=new pVe(u);c=n.runWebGLProgram(d,[i,s],"float32");let h=Nt({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),h}var mVe={kernelName:Vf,backendName:"webgl",kernelFunc:fVe};function gVe(t){let{inputs:e,backend:n,attrs:r}=t,{equation:i}=r,s=e,{allDims:a,summedDims:o,idDims:l}=W.decodeEinsumEquation(i,s.length);W.checkEinsumDimSizes(a.length,l,s);let{path:u,steps:c}=W.getEinsumComputePath(o,l),d=c.length,h=null,p=a.length,f=[];for(let g=0;g<d;++g){for(let y of c[g]){let{permutationIndices:m,expandDims:b}=W.getEinsumPermutation(p,l[y]),w;W.isIdentityPermutation(m)?w=s[y]:(w=Gs({inputs:{x:s[y]},backend:n,attrs:{perm:m}}),f.push(w));let _=w.shape.slice();for(let S=0;S<b.length;++S)_.splice(b[S],0,1);P.arraysEqual(w.shape,_)||(w=Nt({inputs:{x:w},backend:n,attrs:{shape:_}}),f.push(w)),h===null?h=w:(h=hU({inputs:{a:w,b:h},backend:n}),f.push(h))}g<d-1&&(u[g]>=0&&(h=EM({inputs:{x:h},backend:n,attrs:{axis:u[g]-(a.length-p),keepDims:!1}}),f.push(h)),p--)}for(let g of f)g!==h&&n.disposeIntermediateTensorInfo(g);return h}var yVe={kernelName:uC,backendName:"webgl",kernelFunc:gVe},vVe="return (x >= 0.0) ? x : (exp(x) - 1.0);",xVe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,bVe=Zn({opSnippet:vVe,packedOpSnippet:xVe}),wVe={kernelName:Xf,backendName:"webgl",kernelFunc:bVe},_Ve="return (b >= 0.0) ? a : a * (b + 1.0);",SVe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,AVe=t=>{let{inputs:e,backend:n}=t,{dy:r,y:i}=e,s=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Bv(SVe,r.shape,i.shape):new df(_Ve,r.shape,i.shape);return n.runWebGLProgram(s,[r,i],r.dtype)},EVe={kernelName:D0,backendName:"webgl",kernelFunc:AVe},IVe=`
  return vec4(equal(a, b));
`,TVe="return float(a == b);",CVe=hs({opSnippet:TVe,packedOpSnippet:IVe,dtype:"bool",cpuKernelImpl:i4e}),MVe={kernelName:P0,backendName:"webgl",kernelFunc:CVe},kVe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${W.ERF_P};
  float a1 = ${W.ERF_A1};
  float a2 = ${W.ERF_A2};
  float a3 = ${W.ERF_A3};
  float a4 = ${W.ERF_A4};
  float a5 = ${W.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,NVe=Zn({opSnippet:kVe}),RVe={kernelName:Kf,backendName:"webgl",kernelFunc:NVe},FVe=Uv+`
  return exp(x);
`,DVe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Eee=Zn({opSnippet:FVe,packedOpSnippet:DVe,cpuKernelImpl:s4e,dtype:"float32"}),PVe={kernelName:qf,backendName:"webgl",kernelFunc:Eee};function nD(t){let{inputs:e,attrs:n,backend:r}=t,{dim:i}=n,{input:s}=e,a=s.shape.length,o=s.shape.slice(),l=i;return i<0&&(P.assert(-(a+1)<=i,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+i+1),o.splice(l,0,1),Nt({inputs:{x:s},backend:r,attrs:{shape:o}})}var LVe={kernelName:L0,backendName:"webgl",kernelFunc:nD},m5="return exp(x) - 1.0;",OVe=Zn({opSnippet:m5,packedOpSnippet:m5,cpuKernelImpl:a4e}),BVe={kernelName:Jf,backendName:"webgl",kernelFunc:OVe},g5=class{constructor(t,e,n){this.variableNames=["real","imag"];let r=e[1];this.outputShape=e;let i=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${r}.0`:"1.0",a;if(t==="real")a="return real * expR - imag * expI;";else if(t==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${s};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function Iee(t,e,n){let r=n.texData.get(t.dataId),i=P.sizeFromShape(t.shape),s=t.shape[t.shape.length-1],a=i/s,o=Nt({inputs:{x:t},backend:n,attrs:{shape:[a,s]}}),l=o.shape,u=new g5("real",l,e),c=new g5("imag",l,e),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=n.runWebGLProgram(u,d,"float32"),p=n.runWebGLProgram(c,d,"float32"),f=dh({inputs:{real:h,imag:p},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p);let g=Nt({inputs:{x:f},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),g}function UVe(t){let{inputs:e,backend:n}=t,{input:r}=e;return Iee(r,!1,n)}var $Ve={kernelName:cC,backendName:"webgl",kernelFunc:UVe},zVe=class{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function r_(t){let{backend:e,attrs:n}=t,{shape:r,value:i}=n,{dtype:s}=n;if(s=s||P.inferDtype(i),s==="string"){let a=P.getArrayFromDType(s,P.sizeFromShape(r));return a.fill(i),e.makeTensorInfo(r,s,a)}else{let a=new zVe(r,i),o=[[i]];return e.runWebGLProgram(a,[],s,o)}}var GVe={kernelName:cw,backendName:"webgl",kernelFunc:r_},HVe=class{constructor(t){this.variableNames=["Image"],this.outputShape=[];let e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},WVe={kernelName:O0,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{let{image:n}=t,r=e,i=new HVe(n.shape);return r.runWebGLProgram(i,[n],n.dtype)}},y5="return floor(x);",VVe=Zn({opSnippet:y5,packedOpSnippet:y5,cpuKernelImpl:o4e}),jVe={kernelName:Yf,backendName:"webgl",kernelFunc:VVe},XVe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,KVe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,qVe=hs({opSnippet:XVe,packedOpSnippet:KVe,dtype:"int32"}),JVe={kernelName:Zf,backendName:"webgl",kernelFunc:qVe},YVe=class{constructor(t){this.variableNames=["A"];let e=Ks(),[n,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},ZVe=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let e=Ks(),[n,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${n}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}},QVe={kernelName:CI,backendName:"webgl",kernelFunc:e5e},$g,RN=Ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function e5e(t){let{inputs:e,backend:n,attrs:r}=t,{pixels:i}=e,{numChannels:s}=r,a=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[l,u]=a?[i.videoWidth,i.videoHeight]:[i.width,i.height],c=[u,l],d=[u,l,s];if(o||a){let g=Ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");($g==null||g!==RN)&&(RN=g,$g=document.createElement("canvas").getContext("2d",{willReadFrequently:RN})),$g.canvas.width=l,$g.canvas.height=u,$g.drawImage(i,0,0,l,u),i=$g.canvas}let h=n.makeTensorInfo(c,"int32");n.texData.get(h.dataId).usage=no.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),i);let p=Ie().getBool("WEBGL_PACK")?new ZVe(d):new YVe(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}function t5e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,g=W.convertConv2DDataFormat(c),y=W.computeConv2DInfo(i.shape,s.shape,l,d,u,h,!1,g),m,b=[],w=a!=null,_=o!=null,S=p==="leakyrelu",E=()=>{let T=[i,s],M=(k,R)=>{if(R==="NCHW"&&k.shape.length===1&&k.shape[0]!==1){let N=Nt({inputs:{x:k},backend:n,attrs:{shape:[k.shape[0],1,1]}});return b.push(N),N}return k};if(w&&T.push(M(a,c)),_&&T.push(M(o,c)),S){let k=n.makeTensorInfo([],"float32",P.createScalarValue(f,"float32"));T.push(k),b.push(k)}return T};if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))m=bee({x:i,filter:s,convInfo:y,backend:n,bias:a,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else if(y.strideWidth<=2&&g==="channelsLast"&&Ie().getBool("WEBGL_EXP_CONV")){let T=p?T1(p,!0):null,M=new xee(y,w,T,_,S),k=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],R=E();m=n.runWebGLProgram(M,R,"float32",k)}else if(Ie().getBool("WEBGL_CONV_IM2COL"))m=wee({x:i,filter:s,convInfo:y,backend:n,bias:a,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{let T=p?T1(p,!1):null,M=new vee(y,w,T,_,S),k=E();m=n.runWebGLProgram(M,k,"float32")}let C=Nt({inputs:{x:m},backend:n,attrs:{shape:y.outShape}});return b.push(m),b.forEach(T=>n.disposeIntermediateTensorInfo(T)),C}var n5e={kernelName:Kp,backendName:"webgl",kernelFunc:t5e};function r5e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[],g=c;g==null&&(g=[1,1]),P.assert(W.eitherStridesOrDilationsAreOne(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);let y=W.computeConv2DInfo(i.shape,s.shape,l,g,u,d,!0),m=Ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,b=h?T1(h,m):null,w=[i,s],_=a!=null,S=o!=null,E=h==="leakyrelu";if(_&&w.push(a),S&&w.push(o),E){let k=n.makeTensorInfo([],"float32",P.createScalarValue(p,"float32"));w.push(k),f.push(k)}let C;m?C=new Aee(y,_,b,S,E):C=new See(y,_,b,S,E);let T=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],M=n.runWebGLProgram(C,w,"float32",T);return f.forEach(k=>n.disposeIntermediateTensorInfo(k)),M}var i5e={kernelName:qp,backendName:"webgl",kernelFunc:r5e},s5e=class{constructor(t,e,n,r){this.sliceDim=t,this.strides=e,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let i=Sr(n.length),s=`
    int index;`;for(let a=0;a<this.sliceDim;a++)s+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${s}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function a5e(t){let{inputs:e,backend:n}=t,{params:r,indices:i}=e,s=i.shape,a=s[s.length-1],o=P.sizeFromShape(r.shape),[l,u,c,d]=W.prepareAndValidate(r,i),h=Nt({inputs:{x:i},backend:n,attrs:{shape:[u,a]}}),p=Nt({inputs:{x:r},backend:n,attrs:{shape:[P.sizeFromShape(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,i])||r.dtype==="string"){let m=n.readSync(i.dataId),b=n.bufferSync(r),w=l4e(m,b,r.dtype,u,a,c,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,w.values)}let f=new s5e(a,d,[u,c],r.shape),g=n.runWebGLProgram(f,[p,h],p.dtype),y=Nt({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),y}var o5e={kernelName:U0,backendName:"webgl",kernelFunc:a5e},l5e=class{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;let n=Sr(this.rank),r=u5e(t);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}};function u5e(t,e){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<t.length;i++)i===2?r.push("index"):r.push(`${n[i]}`);return r.join()}function Tee(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,indices:s}=e,{axis:a,batchDims:o}=r,l=P.parseAxisParam(a,i.shape)[0];if(Ie().get("DEBUG")){let b=n.readSync(s.dataId),w=i.shape[l];for(let _=0;_<b.length;++_){let S=b[_];P.assert(S<=w-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${w-1}]`)}}let u=W.segment_util.collectGatherOpShapeInfo(i,s,l,o),c=P.sizeFromShape(s.shape),d=[],h=Nt({inputs:{x:i},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=Nt({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);let f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([i,s])||i.dtype==="string"){let b=n.bufferSync(p),w=n.bufferSync(h),_=u4e(w,b,f);return d.forEach(S=>n.disposeIntermediateTensorInfo(S)),n.makeTensorInfo(u.outputShape,_.dtype,_.values)}let g=new l5e(h.shape,f),y=n.runWebGLProgram(g,[h,p],h.dtype);d.push(y);let m=Nt({inputs:{x:y},backend:n,attrs:{shape:u.outputShape}});return d.forEach(b=>n.disposeIntermediateTensorInfo(b)),m}var c5e={kernelName:B0,backendName:"webgl",kernelFunc:Tee},d5e="return float(a > b);",h5e=`
  return vec4(greaterThan(a, b));
`,p5e=hs({opSnippet:d5e,packedOpSnippet:h5e,cpuKernelImpl:c4e,dtype:"bool"}),f5e={kernelName:$0,backendName:"webgl",kernelFunc:p5e},m5e="return float(a >= b);",g5e=`
  return vec4(greaterThanEqual(a, b));
`,y5e=hs({opSnippet:m5e,packedOpSnippet:g5e,dtype:"bool",cpuKernelImpl:d4e}),v5e={kernelName:em,backendName:"webgl",kernelFunc:y5e};function x5e(t){let{inputs:e,backend:n}=t,{input:r}=e;return Iee(r,!0,n)}var b5e={kernelName:dC,backendName:"webgl",kernelFunc:x5e},w5e="return float(!isnan(x) && !isinf(x));",_5e=Zn({opSnippet:w5e,dtype:"bool"}),S5e={kernelName:nm,backendName:"webgl",kernelFunc:_5e},A5e="return float(isinf(x));",E5e=Zn({opSnippet:A5e,dtype:"bool"}),I5e={kernelName:rm,backendName:"webgl",kernelFunc:E5e},T5e="return float(isnan(x));",C5e=Zn({opSnippet:T5e,dtype:"bool"}),M5e={kernelName:im,backendName:"webgl",kernelFunc:C5e},k5e="return float(a < b);",N5e=`
  return vec4(lessThan(a, b));
`,R5e=hs({opSnippet:k5e,packedOpSnippet:N5e,cpuKernelImpl:h4e,dtype:"bool"}),F5e={kernelName:z0,backendName:"webgl",kernelFunc:R5e},D5e="return float(a <= b);",P5e=`
  return vec4(lessThanEqual(a, b));
`,L5e=hs({opSnippet:D5e,packedOpSnippet:P5e,cpuKernelImpl:p4e,dtype:"bool"}),O5e={kernelName:G0,backendName:"webgl",kernelFunc:L5e};function B5e(t){let{backend:e,attrs:n}=t,{start:r,stop:i,num:s}=n,a=f4e(r,i,s);return e.makeTensorInfo([a.length],"float32",a)}var U5e={kernelName:H0,backendName:"webgl",kernelFunc:B5e},$5e=Uv+`
  return x < 0.0 ? 0./0. : log(x);
`,z5e=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,G5e=Zn({opSnippet:$5e,packedOpSnippet:z5e,cpuKernelImpl:m4e}),H5e={kernelName:am,backendName:"webgl",kernelFunc:G5e},W5e=Uv+`
  return log(1.0 + x);
`,V5e=Zn({opSnippet:W5e}),j5e={kernelName:om,backendName:"webgl",kernelFunc:V5e},X5e="return float(a >= 1.0 && b >= 1.0);",K5e=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,q5e=hs({opSnippet:X5e,packedOpSnippet:K5e,dtype:"bool"}),J5e={kernelName:W0,backendName:"webgl",kernelFunc:q5e},Y5e="return float(!(x >= 1.0));",Z5e=Zn({opSnippet:Y5e}),Q5e={kernelName:V0,backendName:"webgl",kernelFunc:Z5e},e6e="return float(a >= 1.0 || b >= 1.0);",t6e=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,n6e=hs({opSnippet:e6e,packedOpSnippet:t6e,dtype:"bool"}),r6e={kernelName:j0,backendName:"webgl",kernelFunc:n6e},i6e=class{constructor(t,e,n,r,i){this.variableNames=["x"],this.outputShape=[];let s=e,a=t[3]-1;this.outputShape=t;let o,l=`float(${n}) + float(${r}) * sum`;i===.5?o=`inversesqrt(${l})`:i===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${s}; j <= ${s}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o};
        setOutput(val);
      }
    `}},s6e=class{constructor(t,e,n,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=e,a=t[3]-1;this.outputShape=t;let o,l=`float(${n}) + float(${r}) * sum`;i===.5?o=`inversesqrt(${l})`:i===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${s};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${s}; j <= ${s}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o};
        setOutput(result);
      }
    `}},a6e=t=>{let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{depthRadius:s,bias:a,alpha:o,beta:l}=r,u=Ie().getBool("WEBGL_PACK_NORMALIZATION")?new s6e(i.shape,s,a,o,l):new i6e(i.shape,s,a,o,l);return n.runWebGLProgram(u,[i],i.dtype)},o6e={kernelName:lm,backendName:"webgl",kernelFunc:a6e},l6e=class{constructor(t,e,n,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},u6e=t=>{let{inputs:e,backend:n,attrs:r}=t,{x:i,y:s,dy:a}=e,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new l6e(i.shape,o,l,u,c);return n.runWebGLProgram(d,[i,s,a],i.dtype)},c6e={kernelName:X0,backendName:"webgl",kernelFunc:u6e};function d6e(t,e,n,r){let i=P.sizeFromShape(e),s=P.sizeFromShape(t.shape)/i,a=Nt({inputs:{x:t},attrs:{shape:[s,i]},backend:r}),o=eg(a,t.dtype,"max",r),l=Nt({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(o),l}function Cee(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{reductionIndices:s,keepDims:a}=r,o=i.shape.length,l=P.parseAxisParam(s,i.shape),u=l,c=W.getAxesPermutation(u,o),d=c!=null,h=n.shouldExecuteOnCPU([i]),p=i;if(d){if(h){let b=n.texData.get(p.dataId).values,w=new Array(o);for(let E=0;E<w.length;E++)w[E]=i.shape[c[E]];let _=uU(b,i.shape,i.dtype,c,w);p=n.makeTensorInfo(w,i.dtype);let S=n.texData.get(p.dataId);S.values=_}else p=AM(i,c,n);u=W.getInnerMostAxes(u.length,o)}W.assertAxesAreInnerMostDims("max",u,o);let[f,g]=W.computeOutAndReduceShapes(p.shape,u),y=f;a&&(y=W.expandShapeToKeepDim(f,l));let m;if(h){let b=n.texData.get(p.dataId).values,w=g4e(b,P.sizeFromShape(g),y,i.dtype);m=n.makeTensorInfo(y,i.dtype);let _=n.texData.get(m.dataId);_.values=w}else m=d6e(p,g,y,n);return d&&n.disposeIntermediateTensorInfo(p),m}var h6e={kernelName:um,backendName:"webgl",kernelFunc:Cee},p6e=dU+`
  return max(a, b);
`,f6e=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Qm+`
  return result;
`,m6e=hs({opSnippet:p6e,packedOpSnippet:f6e,cpuKernelImpl:y4e}),g6e={kernelName:cm,backendName:"webgl",kernelFunc:m6e};function y6e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e;Fv(i,"maxPool");let{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=r,u=1;P.assert(W.eitherStridesOrDilationsAreOne(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=W.computePool2DInfo(i.shape,s,a,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&P.arraysEqual(c.inShape,c.outShape))return Ga({inputs:{x:i},backend:n});let d=new C1(c,"max",!1);return n.runWebGLProgram(d,[i],i.dtype)}var v6e={kernelName:dm,backendName:"webgl",kernelFunc:y6e};function x6e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{filterSize:s,strides:a,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=[1,1,1],d=W.computePool3DInfo(i.shape,s,a,c,o,u,l),h=new pU(d,"max",!1);return n.runWebGLProgram(h,[i],i.dtype)}var b6e={kernelName:K0,backendName:"webgl",kernelFunc:x6e},w6e=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideHeight,n=t.strideWidth,r=t.dilationHeight,i=t.effectiveFilterHeight,s=t.effectiveFilterWidth,a=i-1-t.padInfo.top,o=s-1-t.padInfo.left,l=i*s-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${s} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},_6e=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,i=t.dilationDepth,s=t.dilationHeight,a=t.dilationWidth,o=t.effectiveFilterDepth,l=t.effectiveFilterHeight,u=t.effectiveFilterWidth,c=o-1-t.padInfo.front,d=l-1-t.padInfo.top,h=u-1-t.padInfo.left,p=o*l*u-1;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${d}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${s}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function S6e(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,a=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=[1,1,1],h=W.computePool3DInfo(a.shape,o,l,d,u,c),p=new pU(h,"max",!0),f=n.runWebGLProgram(p,[a],a.dtype),g=new _6e(h),y=n.runWebGLProgram(g,[i,f],a.dtype);return n.disposeIntermediateTensorInfo(f),y}var A6e={kernelName:hw,backendName:"webgl",kernelFunc:S6e};function E6e(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s,output:a}=e,o=s;Fv([s,a],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=W.computePool2DInfo(o.shape,l,u,1,c,d),p=!0,f=new C1(h,"max",p),g=n.runWebGLProgram(f,[o],o.dtype),y=new w6e(h),m=n.runWebGLProgram(y,[i,g],o.dtype);return n.disposeIntermediateTensorInfo(g),m}var I6e={kernelName:dw,backendName:"webgl",kernelFunc:E6e};function T6e(t,e,n,r){let i=new C1(n,"max",!1),s=r.runWebGLProgram(i,[t],"float32");i=new C1(n,"max",!0,!0,e);let a=r.runWebGLProgram(i,[t],"float32");return[s,a]}var C6e={kernelName:pw,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{let{x:r}=t,{filterSize:i,strides:s,pad:a,includeBatchInIndex:o}=e,l=n;P.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let u=[1,1];P.assert(W.eitherStridesOrDilationsAreOne(s,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);let c=W.computePool2DInfo(r.shape,i,s,u,a),[d,h]=T6e(r,o,c,l);return[d,h]}};function M6e(t,e,n,r){let i=P.sizeFromShape(e),s=P.sizeFromShape(t.shape)/i,a=Nt({inputs:{x:t},attrs:{shape:[s,i]},backend:r}),o=eg(a,"float32","mean",r),l=Nt({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(o),l}var k6e={kernelName:hm,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{let{x:r}=t,{keepDims:i,axis:s}=e,a=n,o=r.shape.length,l=P.parseAxisParam(s,r.shape),u=l,c=W.getAxesPermutation(u,o),d=c!=null,h=a.shouldExecuteOnCPU([r]),p=[],f=r;if(d){if(h){let w=a.texData.get(f.dataId).values,_=new Array(o);for(let C=0;C<_.length;C++)_[C]=r.shape[c[C]];let S=uU(w,r.shape,r.dtype,c,_);f=a.makeTensorInfo(_,r.dtype);let E=a.texData.get(f.dataId);E.values=S}else f=AM(r,c,a);p.push(f),u=W.getInnerMostAxes(u.length,o)}W.assertAxesAreInnerMostDims("sum",u,o);let[g,y]=W.computeOutAndReduceShapes(f.shape,u),m=g;i&&(m=W.expandShapeToKeepDim(g,l));let b=M6e(f,y,m,a);for(let w of p)a.disposeIntermediateTensorInfo(w);return b}};function N6e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r,o=i.shape.length,l=P.parseAxisParam(s,i.shape),u=l,c=W.getAxesPermutation(u,o),d=i;c!=null&&(d=Gs({inputs:{x:i},backend:n,attrs:{perm:c}}),u=W.getInnerMostAxes(u.length,i.shape.length)),W.assertAxesAreInnerMostDims("min",u,o);let[h,p]=W.computeOutAndReduceShapes(d.shape,u),f=P.sizeFromShape(p),g=Nt({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),y=eg(g,g.dtype,"min",n),m;if(a){let b=W.expandShapeToKeepDim(h,l);m=Nt({inputs:{x:y},backend:n,attrs:{shape:b}})}else m=Nt({inputs:{x:y},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),c!=null&&n.disposeIntermediateTensorInfo(d),m}var R6e={kernelName:pm,backendName:"webgl",kernelFunc:N6e},F6e=dU+`
  return min(a, b);
`,D6e=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Qm+`
  return result;
`,P6e=hs({opSnippet:F6e,packedOpSnippet:D6e,cpuKernelImpl:v4e}),L6e={kernelName:fm,backendName:"webgl",kernelFunc:P6e},O6e=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((u,c)=>u[0]+t[c]+u[1]);let r=t.length,i=Sr(r),s=e.map(u=>u[0]).join(","),a=e.map((u,c)=>u[0]+t[c]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l=n==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${s};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${s});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}},B6e=class{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((p,f)=>p[0]+t[f]+p[1]);let r=t.length,i=Sr(r),s=e.map(p=>p[0]).join(","),a=e.map((p,f)=>p[0]+t[f]).join(","),o=Bs("rc",r),l=Bs("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=r===1?"source":`vec2(${l.slice(-2).join()})`,d=n==="reflect"?0:1,h="";if(r===1){let p=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;h=`
        ${i} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${o[r-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
      `}else{let p=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;h=`
        ${i} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${o[r-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
        rc = outputLoc;
        ${o[r-2]} += 1;
        if(${o[r-2]} < ${this.outputShape[r-2]}) {
          ${p}
          result[2] = getChannel(getX(${l.join()}), ${c});
          ${o[r-1]} += 1;
          if(${u}) {
            ${p}
            result[3] = getChannel(getX(${l.join()}), ${c});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${s});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}},U6e=({inputs:t,backend:e,attrs:n})=>{let{x:r}=t,{paddings:i,mode:s}=n,a=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new B6e(r.shape,i,s):new O6e(r.shape,i,s);return e.runWebGLProgram(a,[r],r.dtype)},$6e={kernelName:mm,backendName:"webgl",kernelFunc:U6e},z6e=`if (b == 0.0) return NAN;
  return mod(a, b);`,G6e=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Qm+`
  return result;
`,H6e=hs({opSnippet:z6e,packedOpSnippet:G6e}),W6e={kernelName:gm,backendName:"webgl",kernelFunc:H6e},V6e=class{constructor(t,e,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}},j6e=`
if (a == b) {
  return 1.0;
};
return a / b;`,X6e=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Mee=hs({opSnippet:j6e,packedOpSnippet:X6e,checkOutOfBounds:!0}),K6e={kernelName:jf,backendName:"webgl",kernelFunc:Mee},v5="return a - b;",kee=hs({opSnippet:v5,packedOpSnippet:v5,supportsComplex:!0,cpuKernelImpl:U4e}),q6e={kernelName:zm,backendName:"webgl",kernelFunc:kee};function Nee(t){let{inputs:e,backend:n,attrs:r}=t,{logits:i}=e,{dim:s}=r,a=P.parseAxisParam([s],i.shape),o=Cee({inputs:{x:i},backend:n,attrs:{reductionIndices:a,keepDims:!1}}),l=W.expandShapeToKeepDim(o.shape,a),u=Nt({inputs:{x:o},backend:n,attrs:{shape:l}}),c=kee({inputs:{a:i,b:u},backend:n}),d=Eee({inputs:{x:c},backend:n}),h=EM({inputs:{x:d},backend:n,attrs:{axis:a,keepDims:!1}}),p=Nt({inputs:{x:h},backend:n,attrs:{shape:l}}),f=Mee({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}var J6e={kernelName:Um,backendName:"webgl",kernelFunc:Nee};function Y6e(t){let{inputs:e,backend:n,attrs:r}=t,{logits:i}=e,{numSamples:s,seed:a,normalized:o}=r,l=o?i:Nee({inputs:{logits:i},backend:n,attrs:{dim:i.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new V6e(u,c,s),h=[[a]],p=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),p}var Z6e={kernelName:q0,backendName:"webgl",kernelFunc:Y6e},Q6e=Xo+`
  return -x;
`,e8e=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function t8e(t){let{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){let s=n.texData.get(r.dataId),[a,o]=b4e(s.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,a)}let i;return Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new hd(r.shape,e8e):i=new Ql(r.shape,Q6e),n.runWebGLProgram(i,[r],r.dtype)}var n8e={kernelName:J0,backendName:"webgl",kernelFunc:t8e},r8e=bu.nonMaxSuppressionV3Impl;function i8e(t){W.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:n,attrs:r}=t,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(i.dataId),c=n.readSync(s.dataId),{selectedIndices:d}=r8e(u,c,a,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var s8e={kernelName:Z0,backendName:"webgl",kernelFunc:i8e},a8e=bu.nonMaxSuppressionV4Impl;function o8e(t){W.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:n,attrs:r}=t,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(i.dataId),d=n.readSync(s.dataId),{selectedIndices:h,validOutputs:p}=a8e(c,d,a,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}var l8e={kernelName:Q0,backendName:"webgl",kernelFunc:o8e},u8e=bu.nonMaxSuppressionV5Impl;function c8e(t){W.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:n,attrs:r}=t,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(i.dataId),d=n.readSync(s.dataId),h=a,p=o,f=l,g=u,{selectedIndices:y,selectedScores:m}=u8e(c,d,h,p,f,g);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([m.length],"float32",new Float32Array(m))]}var d8e={kernelName:ev,backendName:"webgl",kernelFunc:c8e},h8e=class{constructor(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}},p8e=t=>{let{inputs:e,backend:n,attrs:r}=t,{indices:i}=e,{dtype:s,depth:a,onValue:o,offValue:l}=r,u=P.sizeFromShape(i.shape),c=new h8e(u,a,o,l),d=Nt({inputs:{x:i},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(c,[d],s);n.disposeIntermediateTensorInfo(d);let p=[...i.shape,a],f=Nt({inputs:{x:h},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(h),f},f8e={kernelName:vm,backendName:"webgl",kernelFunc:p8e};function YI(t){let{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="complex64"){let i=n_({inputs:{input:r},backend:n}),s=YI({inputs:{x:i},backend:n}),a=IM({inputs:{input:r},backend:n}),o=YI({inputs:{x:a},backend:n}),l=dh({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),l}else return r_({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}var m8e={kernelName:xv,backendName:"webgl",kernelFunc:YI};function Ree(t){let{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let i=n_({inputs:{input:r},backend:n}),s=Ree({inputs:{x:i},backend:n}),a=IM({inputs:{input:r},backend:n}),o=YI({inputs:{x:a},backend:n}),l=dh({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),l}else return r_({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var g8e={kernelName:tv,backendName:"webgl",kernelFunc:Ree};function y8e(t){let{inputs:e,backend:n,attrs:r}=t,{axis:i}=r;if(e.length===1)return nD({inputs:{input:e[0]},backend:n,attrs:{dim:i}});let s=e[0].shape,a=e[0].dtype;e.forEach(c=>{P.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),P.assert(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=e.map(c=>{let d=nD({inputs:{input:c},backend:n,attrs:{dim:i}});return o.push(d),d}),u=yee({inputs:l,backend:n,attrs:{axis:i}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}var v8e={kernelName:nv,backendName:"webgl",kernelFunc:y8e},x8e=class{constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((l,u)=>l[0]+t[u]+l[1]);let r=t.length,i=Sr(r),s=e.map(l=>l[0]).join(","),a=e.map((l,u)=>l[0]+t[u]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${s};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${s});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}},b8e=class{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((f,g)=>f[0]+t[g]+f[1]);let r=t.length,i=Sr(r),s=e.map(f=>f[0]).join(","),a=e.map((f,g)=>f[0]+t[g]).join(","),o=Bs("rc",r),l=Bs("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=r===1?"source":`vec2(${l.slice(-2).join()})`,d=[`${i} rc = outputLoc;`,`${o[r-1]} += 1;
       if(${u}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${o[r-2]} += 1;
       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${o[r-1]} += 1;
         if(${u}) {`],h=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",p="";for(let f=0,g=r===1?2:4;f<g;f++)p+=`
        ${d[f]}
        if (${h}) {
          result[${f}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${f}] = getChannel(getX(${l.join()}), ${c});
        }
      `;p+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${s});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}},Fee=t=>{let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{paddings:s,constantValue:a}=r;if(P.sizeFromShape(i.shape)===0){let u=s.map((c,d)=>c[0]+i.shape[d]+c[1]);return r_({backend:n,attrs:{shape:u,value:a,dtype:i.dtype}})}let o=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new b8e(i.shape,s,a):new x8e(i.shape,s,a),l=[[a]];return n.runWebGLProgram(o,[i],i.dtype,l)},w8e={kernelName:xm,backendName:"webgl",kernelFunc:Fee},_8e=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,S8e=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Qm+`
  return result;
`,A8e=hs({opSnippet:_8e,packedOpSnippet:S8e}),E8e={kernelName:bm,backendName:"webgl",kernelFunc:A8e};function I8e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r,o=i.shape.length,l=[],u=P.parseAxisParam(s,i.shape),c=u,d=W.getAxesPermutation(c,o),h=i;d!=null&&(h=Gs({inputs:{x:i},backend:n,attrs:{perm:d}}),c=W.getInnerMostAxes(c.length,o),l.push(h)),W.assertAxesAreInnerMostDims("prod",c,o);let p;if(n.shouldExecuteOnCPU([h])){let f=n.texData.get(h.dataId).values,{outVals:g,outShape:y,outDtype:m}=_4e(h.shape,h.dtype,f,c);p=n.makeTensorInfo(y,m,g)}else{let[f,g]=W.computeOutAndReduceShapes(h.shape,c),y=P.sizeFromShape(g),m=Nt({inputs:{x:h},backend:n,attrs:{shape:[-1,y]}}),b=vC(i.dtype),w=eg(m,b,"prod",n);p=Nt({inputs:{x:w},backend:n,attrs:{shape:f}}),l.push(m),l.push(w)}if(a){l.push(p);let f=W.expandShapeToKeepDim(p.shape,u);p=Nt({inputs:{x:p},backend:n,attrs:{shape:f}})}return l.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}var T8e={kernelName:_m,backendName:"webgl",kernelFunc:I8e};function C8e(t){let{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:i,paramsDenseValues:s,indices:a}=e,{outputRaggedRank:o}=r,l=i.map(m=>n.readSync(m.dataId)),u=i.map(m=>m.shape),c=n.readSync(s.dataId),d=n.readSync(a.dataId),[h,p,f]=S4e(l,u,c,s.shape,s.dtype,d,a.shape,o),g=h.map(m=>n.makeTensorInfo([m.length],"int32",m)),y=n.makeTensorInfo(f,s.dtype,p);return g.concat([y])}var M8e={kernelName:pC,backendName:"webgl",kernelFunc:C8e};function k8e(t){let{inputs:e,backend:n}=t,{starts:r,limits:i,deltas:s}=e,a=n.readSync(r.dataId),o=n.readSync(i.dataId),l=n.readSync(s.dataId),[u,c]=A4e(a,r.shape,r.dtype,o,i.shape,l,s.shape),d=n.makeTensorInfo([u.length],"int32",u),h=n.makeTensorInfo([c.length],r.dtype,c);return[d,h]}var N8e={kernelName:fC,backendName:"webgl",kernelFunc:k8e};function R8e(t){let{inputs:e,backend:n,attrs:r}=t,{shape:i,values:s,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=r,u=n.readSync(i.dataId),c=n.readSync(s.dataId),d=n.readSync(a.dataId),h=o.map(y=>n.readSync(y.dataId)),p=o.map(y=>y.shape),[f,g]=E4e(u,i.shape,c,s.shape,s.dtype,d,a.shape,h,p,l);return n.makeTensorInfo(f,s.dtype,g)}var F8e={kernelName:mC,backendName:"webgl",kernelFunc:R8e},Dee=t=>{let{backend:e,attrs:n}=t,{start:r,stop:i,step:s,dtype:a}=n,o=I4e(r,i,s,a);return e.makeTensorInfo([o.length],a,o)},D8e={kernelName:fw,backendName:"webgl",kernelFunc:Dee},P8e="return 1.0 / x;",L8e=Zn({opSnippet:P8e}),O8e={kernelName:Sm,backendName:"webgl",kernelFunc:L8e},B8e=Xo+`
  return (x < 0.0) ? 0.0 : x;
`,U8e=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,$8e=Zn({opSnippet:B8e,packedOpSnippet:U8e}),z8e={kernelName:Am,backendName:"webgl",kernelFunc:$8e},G8e=Xo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,H8e=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,W8e=Zn({opSnippet:G8e,packedOpSnippet:H8e}),V8e={kernelName:Tm,backendName:"webgl",kernelFunc:W8e},j8e=class{constructor(t,e,n,r,i){this.variableNames=["A"],this.outputShape=[];let[s,a,o,l]=t;this.outputShape=[s,e,n,l];let u=[r&&e>1?a-1:a,r&&n>1?o-1:o],c=[r&&e>1?e-1:e,r&&n>1?n-1:n],d;i?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/c[0]},
          ${u[1]/c[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},X8e=class{constructor(t,e,n,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,a,o,l]=t;this.outputShape=[s,e,n,l];let u=[r&&e>1?a-1:a,r&&n>1?o-1:o],c=[r&&e>1?e-1:e,r&&n>1?n-1:n],d;i?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/c[0]},
          ${u[1]/c[1]},
          ${u[1]/c[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function K8e(t){let{inputs:e,backend:n,attrs:r}=t,{images:i}=e,{alignCorners:s,halfPixelCenters:a,size:o}=r,[l,u]=o,c=Ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new X8e(i.shape,l,u,s,a):new j8e(i.shape,l,u,s,a);return n.runWebGLProgram(c,[i],"float32")}var q8e={kernelName:Im,backendName:"webgl",kernelFunc:K8e},J8e=class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,r,i]=e,[,s,a]=t,o=[n&&s>1?r-1:r,n&&a>1?i-1:i],l=[n&&s>1?s-1:s,n&&a>1?a-1:a],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=Math.ceil(d)*2+2,f=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${c});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${h});

        const int winHeight = int(${p});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Y8e(t){let{inputs:e,backend:n,attrs:r}=t,{images:i,dy:s}=e,{alignCorners:a}=r,o=new J8e(s.shape,i.shape,a);return n.runWebGLProgram(o,[s],s.dtype)}var Z8e={kernelName:sv,backendName:"webgl",kernelFunc:Y8e},Q8e=class{constructor(t,e,n,r,i){this.variableNames=["A"],this.outputShape=[];let[s,a,o,l]=t;this.outputShape=[s,e,n,l];let u=[r&&e>1?a-1:a,r&&n>1?o-1:o],c=[r&&e>1?e-1:e,r&&n>1?n-1:n],d=r?"0.5":"0.0",h;i?h="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/c[0]},
          ${u[1]/c[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},eje=class{constructor(t,e,n,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,a,o,l]=t;this.outputShape=[s,e,n,l];let u=[r&&e>1?a-1:a,r&&n>1?o-1:o],c=[r&&e>1?e-1:e,r&&n>1?n-1:n],d=r?"0.5":"0.0",h;i?h="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/c[0]},
          ${u[1]/c[1]},
          ${u[1]/c[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function tje(t){let{inputs:e,backend:n,attrs:r}=t,{images:i}=e,{alignCorners:s,halfPixelCenters:a,size:o}=r,[l,u]=o,c=Ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new eje(i.shape,l,u,s,a):new Q8e(i.shape,l,u,s,a);return n.runWebGLProgram(c,[i],i.dtype)}var nje={kernelName:Em,backendName:"webgl",kernelFunc:tje},rje=class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,r,i]=e,[,s,a]=t,o=[n&&s>1?r-1:r,n&&a>1?i-1:i],l=[n&&s>1?s-1:s,n&&a>1?a-1:a],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=Math.ceil(d)*2+2,f=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${c});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${h});

        const int winHeight = int(${p});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function ije(t){let{inputs:e,backend:n,attrs:r}=t,{images:i,dy:s}=e,{alignCorners:a}=r,o=new rje(s.shape,i.shape,a);return n.runWebGLProgram(o,[s],s.dtype)}var sje={kernelName:iv,backendName:"webgl",kernelFunc:ije},aje=class{constructor(t,e){this.variableNames=["x"];let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}let r=a=>e.indexOf(a)!==-1&&t[a]!==1?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`,i=t.map((a,o)=>r(o)).join(","),s=Sr(n);this.userCode=`
      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}},oje=class{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;let r=Bs("rc",n),i=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,a=Sr(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o(r.slice())};
          if(${i}){
            result.g = ${l(r.slice())};
          }
          if(${s}) {
            result.b = ${u(r.slice())};
            if(${i}) {
              result.a = ${c(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function o(p){return d(p)}function l(p){return p[n-1]="("+p[n-1]+" + 1)",d(p)}function u(p){return p[n-2]="("+p[n-2]+" + 1)",d(p)}function c(p){return p[n-1]="("+p[n-1]+" + 1)",p[n-2]="("+p[n-2]+" + 1)",d(p)}function d(p){let f=t.map((m,b)=>h(b,p)),g=f.join(","),y=f.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function h(p,f){return e.indexOf(p)!==-1&&t[p]!==1?`${t[p]} - ${f[p]} - 1`:`${f[p]}`}}};function lje(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{dims:s}=r,a=i.shape.length,o=P.parseAxisParam(s,i.shape);if(a===0)return Ga({inputs:{x:i},backend:n});let l=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new oje(i.shape,o):new aje(i.shape,o);return n.runWebGLProgram(l,[i],i.dtype)}var uje={kernelName:Cm,backendName:"webgl",kernelFunc:lje},cje=class{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=t[1],r=t[2];this.outputShape=t;let i="";typeof e=="number"?i=`float outputValue = ${e.toFixed(2)};`:i=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},dje={kernelName:bv,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{let{image:r}=t,{radians:i,fillValue:s,center:a}=e,o=n,l=new cje(r.shape,s),[u,c]=W.getImageCenter(a,r.shape[1],r.shape[2]),d=[[u,c,Math.sin(i),Math.cos(i)]];return o.runWebGLProgram(l,[r],r.dtype,d)}},hje=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,pje=Zn({opSnippet:hje}),fje={kernelName:Mm,backendName:"webgl",kernelFunc:pje},mje="return inversesqrt(x);",gje=Zn({opSnippet:mje,cpuKernelImpl:T4e}),yje={kernelName:km,backendName:"webgl",kernelFunc:gje},fU=class{constructor(t,e,n,r,i,s,a=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let l=Sr(i.length),u=Sr(s.length),c="";n===1?c="i":n===2&&(c="i, j");let d=`getIndices(${c})`,h="";r===1?h="i":r===2&&(h="i, coords[1]");let p=`getUpdates(${h})`,f="";o&&(f="coords[0], coords[1]");let g=`getDefaultValue(${f})`,y=e>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${i});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}},vje=class{constructor(t,e,n,r,i,s,a=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let l=Sr(i.length),u=Sr(s.length),c="";n===1?c="i":n===2&&(c="i, j");let d=`getIndices(${c})`,h="";r===1?h="i":r===2&&(h="i, coords[1]");let p=`getUpdates(${h})`,f="";o&&(f="coords[0], coords[1]");let g=`getDefaultValue(${f})`,y=e>1?"strides[j]":"strides",m=e>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${i});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${e}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${e}) {
                flattenedIndex += index.yw * ${m};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${p};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}};function xje(t){let{inputs:e,backend:n,attrs:r}=t,{indices:i,updates:s}=e,{shape:a}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=W.calculateShapes(s,i,a),h=[d/u,u];if(d===0)return n.makeTensorInfo(a,i.dtype);let p=Nt({inputs:{x:i},backend:n,attrs:{shape:[l,o]}}),f=Nt({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0])),y;Ie().getBool("WEBGL_PACK")?y=new vje(l,o,p.shape.length,f.shape.length,c,h):y=new fU(l,o,p.shape.length,f.shape.length,c,h);let m=n.runWebGLProgram(y,[f,p,g],f.dtype),b=Nt({inputs:{x:m},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),b}var bje={kernelName:av,backendName:"webgl",kernelFunc:xje},wje=class{constructor(t,e,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,n];let i="while (left < right) {",s=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=Ie().getNumber("WEBGL_VERSION")===2?i:s,o=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${o} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function _je(t){let{inputs:e,backend:n,attrs:r}=t,{sortedSequence:i,values:s}=e,{side:a}=r,o=new wje(i.shape[0],i.shape[1],s.shape[1],a),l=[[i.shape[1]]];return n.runWebGLProgram(o,[i,s],"int32",l)}var Sje={kernelName:lv,backendName:"webgl",kernelFunc:_je},Aje=class{constructor(t,e,n){this.variableNames=["c","a","b"],this.outputShape=e;let r,i;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)i="resRC",r="resRC";else{let a=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],l=[];for(let u=0;u<e.length;u++)l.push(`${a[u]}`),u<t&&o.push(`${a[u]}`);r=o.join(),i=l.join()}let s=Sr(n);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}};function Eje(t){let{inputs:e,backend:n}=t,{condition:r,t:i,e:s}=e,a=new Aje(r.shape.length,i.shape,i.shape.length);return n.runWebGLProgram(a,[r,i,s],uo(i.dtype,s.dtype))}var Ije={kernelName:uv,backendName:"webgl",kernelFunc:Eje},Tje=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${W.SELU_SCALEALPHA};
  float scale = ${W.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Cje=Zn({opSnippet:Tje}),Mje={kernelName:Nm,backendName:"webgl",kernelFunc:Cje},kje=Uv+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Nje=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Rje=Zn({opSnippet:kje,packedOpSnippet:Nje,cpuKernelImpl:M4e}),Fje={kernelName:Pm,backendName:"webgl",kernelFunc:Rje},Dje=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Pje=Zn({opSnippet:Dje}),Lje={kernelName:Dm,backendName:"webgl",kernelFunc:Pje},Oje=Uv+`
  return sin(x);
`,Bje=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Qm}
  return result;
`,Uje=Zn({opSnippet:Oje,packedOpSnippet:Bje}),$je={kernelName:Rm,backendName:"webgl",kernelFunc:Uje},zje=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Gje=Zn({opSnippet:zje}),Hje={kernelName:Fm,backendName:"webgl",kernelFunc:Gje},Wje=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Vje=Zn({opSnippet:Wje}),jje={kernelName:Lm,backendName:"webgl",kernelFunc:Vje},Xje=t=>{let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:s,paddings:a}=r;P.assert(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((m,b)=>m*b),l=[[0,0]];l.push(...a);for(let m=1+s.length;m<i.shape.length;++m)l.push([0,0]);let u=[],c=Fee({inputs:{x:i},backend:n,attrs:{paddings:l,constantValue:0}}),d=W.getReshaped(c.shape,s,o,!1),h=W.getPermuted(d.length,s.length,!1),p=W.getReshapedPermuted(c.shape,s,o,!1),f=Nt({inputs:{x:c},backend:n,attrs:{shape:d}}),g=Gs({inputs:{x:f},backend:n,attrs:{perm:h}}),y=Nt({inputs:{x:g},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(g),u.forEach(m=>n.disposeIntermediateTensorInfo(m)),y},Kje={kernelName:dv,backendName:"webgl",kernelFunc:Xje};function qje(t){let{inputs:e,backend:n}=t,{indices:r,values:i,denseShape:s,defaultValue:a}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${i.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);let o=n.readSync(r.dataId),l=n.readSync(i.dataId),u=n.readSync(s.dataId),c=n.readSync(a.dataId)[0],[d,h,p,f,g]=N4e(o,r.shape,r.dtype,l,i.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],i.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(y=>Number(y)))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}var Jje={kernelName:mw,backendName:"webgl",kernelFunc:qje};function Yje(t){let{inputs:e,backend:n}=t,{inputIndices:r,inputShape:i,newShape:s}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=Array.from(n.readSync(i.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[u,c,d]=R4e(o,r.shape,r.dtype,a,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}var Zje={kernelName:pv,backendName:"webgl",kernelFunc:Yje};function Qje(t){let{inputs:e,backend:n}=t,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${i.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let a=n.readSync(r.dataId),o=n.readSync(i.dataId),l=n.readSync(s.dataId),[u,c]=nee(a,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}var e9e={kernelName:gw,backendName:"webgl",kernelFunc:Qje};function t9e(t){let{inputs:e,backend:n}=t,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${i.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let a=n.readSync(r.dataId),o=n.readSync(i.dataId),l=n.readSync(s.dataId),[u,c]=nee(a,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}var n9e={kernelName:yw,backendName:"webgl",kernelFunc:t9e};function r9e(t){let{inputs:e,backend:n,attrs:r}=t,{sparseIndices:i,sparseValues:s,defaultValue:a}=e,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=W.calculateShapes(s,i,o),p=!1;if(s.dtype==="string"){let m=n.bufferSync(i),b=n.bufferSync(s),w=P.decodeString(n.readSync(a.dataId)[0]),_=C4e(m,b,o,h,c,u,l,d,w,p);return n.makeTensorInfo(o,_.dtype,_.values)}let f=new fU(u,l,i.shape.length,s.shape.length,d,[h,1],p),g=n.runWebGLProgram(f,[s,i,a],s.dtype),y=Nt({inputs:{x:g},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(g),y}var i9e={kernelName:fv,backendName:"webgl",kernelFunc:r9e};function s9e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{numOrSizeSplits:s,axis:a}=r,o=P.parseAxisParam(a,i.shape)[0],l=W.prepareSplitSize(i,s,o),u=i.shape.length,c=new Array(u).fill(0),d=i.shape.slice();return l.map(h=>{let p=[...d];p[o]=h;let f=$v({inputs:{x:i},backend:n,attrs:{begin:c,size:p}});return c[o]+=h,f})}var a9e={kernelName:hv,backendName:"webgl",kernelFunc:s9e},x5="return sqrt(x);",o9e=Zn({opSnippet:x5,packedOpSnippet:x5,cpuKernelImpl:F4e}),l9e={kernelName:Om,backendName:"webgl",kernelFunc:o9e},u9e="return x * x;",c9e=Zn({opSnippet:u9e}),d9e={kernelName:vw,backendName:"webgl",kernelFunc:c9e},b5="return (a - b) * (a - b);",h9e=hs({opSnippet:b5,packedOpSnippet:b5}),p9e={kernelName:$m,backendName:"webgl",kernelFunc:h9e};function f9e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");let s=n.readSync(i.dataId),a=W.fromUint8ToStringArray(s),o=D4e(a,"string",r);return n.makeTensorInfo(i.shape,"string",o)}var m9e={kernelName:xw,backendName:"webgl",kernelFunc:f9e};function g9e({inputs:t,attrs:e,backend:n}){let{x:r}=t,i=Xo+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,s=new Ql(r.shape,i);return n.runWebGLProgram(s,[r],r.dtype)}var y9e={kernelName:ih,backendName:"webgl",kernelFunc:g9e},v9e=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,i=Sr(n.length),s=Sr(n.length),a="";if(r===1)a="coords * strides + begin";else{let o=0;a=n.map((l,u)=>(o++,n.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${o-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${t});
      ${i} strides = ${i}(${e});

      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};function x9e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{begin:s,end:a,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:y,isSimpleSlice:m,begin:b,end:w,strides:_}=Ni.sliceInfo(i.shape,s,a,o,l,u,c,d,h),S;if(g)S=Nt({inputs:{x:i},backend:n,attrs:{shape:f}});else if(y||m){P.assert(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);let C=Ni.computeOutShape(b,w,_),T=$v({inputs:{x:i},backend:n,attrs:{begin:b,size:C}});S=Nt({inputs:{x:T},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(T)}else if(n.shouldExecuteOnCPU([i])){let C=n.readSync(i.dataId),T=Rn(i.shape,i.dtype,C),M=P4e(p,T,_,b);S=n.makeTensorInfo(f,i.dtype,M.values)}else{let C=new v9e(b,_,p);S=n.runWebGLProgram(C,[i],i.dtype)}let E=Nt({inputs:{x:S},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(S),E}var b9e={kernelName:mv,backendName:"webgl",kernelFunc:x9e};function w9e(t){let{inputs:e,backend:n,attrs:r}=t,{separator:i,nGramWidths:s,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=e,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,g]=L4e(h,p,i,s,a,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",g)]}var _9e={kernelName:bw,backendName:"webgl",kernelFunc:w9e};function S9e(t){let{inputs:e,backend:n,attrs:r}=t,{skipEmpty:i}=r,{input:s,delimiter:a}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);let o=n.readSync(s.dataId),l=n.readSync(a.dataId)[0],[u,c,d]=O4e(o,l,i),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var A9e={kernelName:ww,backendName:"webgl",kernelFunc:S9e};function E9e(t){let{inputs:e,backend:n,attrs:r}=t,{numBuckets:i}=r,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");let a=n.readSync(s.dataId),o=B4e(a,i);return n.makeTensorInfo(s.shape,"int32",o)}var I9e={kernelName:_w,backendName:"webgl",kernelFunc:E9e},T9e="return tan(x);",C9e=Zn({opSnippet:T9e}),M9e={kernelName:Gm,backendName:"webgl",kernelFunc:C9e},k9e=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,N9e=Zn({opSnippet:k9e}),R9e={kernelName:Hm,backendName:"webgl",kernelFunc:N9e};function F9e(t){let{inputs:e,backend:n,attrs:r}=t,{tensor:i,indices:s,updates:a}=e,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=W.calculateShapes(a,s,i.shape),h=[d/u,u];if(d===0)return n.makeTensorInfo(i.shape,s.dtype);let p=Nt({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=Nt({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),g=Nt({inputs:{x:i},backend:n,attrs:{shape:h}}),y=new fU(l,o,p.shape.length,f.shape.length,c,h,!1,!0),m=n.runWebGLProgram(y,[f,p,g],g.dtype),b=Nt({inputs:{x:m},backend:n,attrs:{shape:i.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),b}var D9e={kernelName:ov,backendName:"webgl",kernelFunc:F9e},P9e=class{constructor(t,e){this.variableNames=["A"];let n=new Array(t.length);for(let s=0;s<n.length;s++)n[s]=t[s]*e[s];this.outputShape=n,this.rank=n.length;let r=Sr(this.rank),i=L9e(t);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}};function L9e(t){let e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${t[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let i=0;i<t.length;i++)r.push(`imod(${n[i]}, ${t[i]})`);return r.join()}function Pee(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{reps:s}=r;if(i.dtype==="string"||i.shape.length>5){let o=n.readSync(i.dataId),l=i.dtype==="string"?o.map(d=>P.decodeString(d)):o,u=Rn(i.shape,i.dtype,l),c=$4e(u,s);return n.makeTensorInfo(c.shape,c.dtype,c.values)}let a=new P9e(i.shape,s);return n.runWebGLProgram(a,[i],i.dtype)}var O9e={kernelName:rh,backendName:"webgl",kernelFunc:Pee},B9e=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},U9e=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function Wh(t,e){e!==null&&t.disposeIntermediateTensorInfo(e)}function w5(t){let e=1;for(;e<t;)e*=2;return e}function $9e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{k:s,sorted:a}=r,o=Ie().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Ie().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=i.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([i])||c<o||s>l){let M=n.readSync(i.dataId),[k,R]=z4e(M,u,i.dtype,s,a);return[n.makeTensorInfo(k.shape,k.dtype,k.values),n.makeTensorInfo(R.shape,R.dtype,R.values)]}if(s===0)return u[u.length-1]=0,[n.makeTensorInfo(u,i.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(c===1)return[i,r_({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let d=n.texData.get(i.dataId),h=d!==null&&d.isPacked,p=h?n.unpackTensor(i):i,f=P.sizeFromShape(u)/c,g=Nt({inputs:{x:p},attrs:{shape:[f,c]},backend:n});h&&Wh(n,p);let y=w5(s),m=w5(c),b=null,w=()=>b===null?[g,g]:[g,b],_=(M,k,R)=>{let N=w(),B=new B9e(R),z=[[c],[b===null?1:0],[Number.NEGATIVE_INFINITY],[M],[k]],V=b;b=n.runWebGLProgram(B,N,"int32",z),Wh(n,V)};for(let M=1;M<y;M*=2){let k=M*2;for(let R=M;R>=1;R/=2)_(k,R,[f,m])}for(let M=m;M>y;M/=2){let k=w(),R=new U9e([f,M/2]),N=[[c],[b===null?1:0],[y]],B=b;b=n.runWebGLProgram(R,k,"int32",N),Wh(n,B);let z=y/2,V=z*2;for(let K=z;K>=1;K/=2)_(V,K,b.shape)}let S=b;b=$v({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,s]}}),Wh(n,S);let E=Tee({inputs:{x:g,indices:b},backend:n,attrs:{axis:1,batchDims:1}});Wh(n,g);let C=u.slice(0,-1);C.push(s),S=b,b=Nt({inputs:{x:b},attrs:{shape:C},backend:n}),Wh(n,S);let T=E;return E=Nt({inputs:{x:E},attrs:{shape:C},backend:n}),Wh(n,T),[E,b]}var z9e={kernelName:gv,backendName:"webgl",kernelFunc:$9e},G9e=class{constructor(t,e,n,r,i,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let a=n==="nearest"?1:2,o;switch(r){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function H9e(t){let{inputs:e,backend:n,attrs:r}=t,{image:i,transforms:s}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=i.shape,[f,g]=u??[d,h],y=[c,f,g,p],m=new G9e(d,h,a,o,l,y);return n.runWebGLProgram(m,[i,s],"float32")}var W9e={kernelName:yv,backendName:"webgl",kernelFunc:H9e};function V9e(t){let{inputs:e,attrs:n,backend:r}=t,{axis:i}=n,{x:s}=e;Fv(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let a=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=G4e(a,i,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}var j9e={kernelName:Sw,backendName:"webgl",kernelFunc:V9e};function X9e(t){let{inputs:e,backend:n,attrs:r}=t,{value:i}=e,{axis:s}=r;s<0&&(s+=i.shape.length);let a=i,o=a.shape.length,l=i.shape[s],u=new Array(o-1),c=0;for(let g=0;g<o;g++)g!==s&&(u[c++]=a.shape[g]);let d=[],h=new Array(o).fill(0),p=a.shape.slice();p[s]=1;let f=new Array(l);for(let g=0;g<f.length;g++){h[s]=g;let y=$v({inputs:{x:a},backend:n,attrs:{begin:h,size:p}}),m=Nt({inputs:{x:y},backend:n,attrs:{shape:u}});f[g]=m,d.push(y)}return d.forEach(g=>n.disposeIntermediateTensorInfo(g)),f}var K9e={kernelName:vv,backendName:"webgl",kernelFunc:X9e},q9e=class{constructor(t,e){this.variableNames=["x","segmentIds"];let n=t.windowSize,r=t.batchSize,i=t.inSize,s=t.numSegments,a=s*Math.ceil(i/n);this.outputShape=[r,a];let o="0.0",l="sumValue",u=Math.floor(n/4)*4,c=n%4,d=`
        sumValue += dot(values, segFilter);
    `,h="";i%n>0&&(h=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let p="";i%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${o};

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${s})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${s})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${c===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function J9e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,segmentIds:s}=e,{numSegments:a}=r,o=i.shape.length,l=[],u=0,c=W.getAxesPermutation([u],o),d=i;c!=null&&(d=Gs({inputs:{x:i},backend:n,attrs:{perm:c}}),l.push(d),u=W.getInnerMostAxes(1,o)[0]);let h=W.segment_util.computeOutShape(d.shape,u,a),p=P.sizeFromShape([d.shape[u]]),f=Nt({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});l.push(f);let g=vC(i.dtype),y=(_,S,E,C,T)=>{let M=_.shape[0],k=_.shape[1],R=W.segment_util.segOpComputeOptimalWindowSize(k,T),N={windowSize:R,inSize:k,batchSize:M,numSegments:T},B=new q9e(N,S),z=n.compileAndRun(B,[_,E],C);if(l.push(z),z.shape[1]===T)return z;let V=Dee({backend:n,attrs:{start:0,stop:T,step:1,dtype:"float32"}}),K=Pee({inputs:{x:V},backend:n,attrs:{reps:[k/R]}});return l.push(V),l.push(K),y(z,S,K,C,T)},m=y(f,"unsortedSegmentSum",s,g,a),b=Nt({inputs:{x:m},backend:n,attrs:{shape:h}}),w=b;if(c!=null){l.push(b);let _=W.getUndoAxesPermutation(c);w=Gs({inputs:{x:w},backend:n,attrs:{perm:_}})}return l.forEach(_=>n.disposeIntermediateTensorInfo(_)),w}var Y9e={kernelName:Aw,backendName:"webgl",kernelFunc:J9e},Z9e=[PGe,OGe,$Ge,HGe,VGe,KGe,JGe,ZGe,nHe,iHe,oHe,cHe,pHe,yHe,bHe,_He,AHe,CHe,kHe,RHe,LHe,HHe,VHe,qHe,YHe,rWe,sWe,uWe,vGe,hWe,yWe,wWe,TWe,kWe,RWe,DWe,LWe,$We,HWe,jWe,KWe,JWe,ZWe,tVe,rVe,oVe,uVe,hVe,mVe,yVe,wVe,EVe,MVe,RVe,PVe,LVe,BVe,$Ve,GVe,WVe,jVe,JVe,QVe,n5e,i5e,o5e,c5e,f5e,v5e,yGe,b5e,mWe,S5e,I5e,M5e,bGe,F5e,O5e,U5e,H5e,j5e,J5e,Q5e,r6e,o6e,c6e,h6e,g6e,v6e,b6e,A6e,I6e,C6e,k6e,R6e,L6e,$6e,W6e,Z6e,SGe,n8e,s8e,l8e,d8e,QHe,f8e,g8e,v8e,w8e,E8e,_Ge,T8e,M8e,N8e,F8e,D8e,eWe,K6e,O8e,z8e,V8e,EGe,q8e,Z8e,nje,sje,uje,dje,fje,yje,bje,Sje,Ije,Mje,Fje,Lje,$je,Hje,zHe,J6e,jje,Kje,Jje,Zje,e9e,n9e,i9e,a9e,l9e,d9e,p9e,m9e,y9e,b9e,_9e,A9e,I9e,q6e,RGe,M9e,R9e,D9e,O9e,z9e,W9e,FGe,j9e,K9e,Y9e,m8e];for(let t of Z9e)Ew(t);var nr;(function(t){t[t.float32=0]="float32",t[t.int32=1]="int32",t[t.bool=2]="bool",t[t.string=3]="string",t[t.complex64=4]="complex64"})(nr||(nr={}));var k1;(function(t){t[t.linear=0]="linear",t[t.relu=1]="relu",t[t.relu6=2]="relu6",t[t.prelu=3]="prelu",t[t.leakyrelu=4]="leakyrelu",t[t.sigmoid=5]="sigmoid",t[t.elu=6]="elu"})(k1||(k1={}));var Lee;function Q9e(t){Lee=t.wasm.cwrap(Xp,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function eXe(t){let{inputs:e,backend:n,attrs:r}=t,{a:i,b:s,bias:a,preluActivationWeights:o}=e;if(i.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r,h=n.dataIdMap.get(i.dataId).id,p=n.dataIdMap.get(s.dataId).id,f=0;if(a!=null){let T=n.dataIdMap.get(a.dataId);if(T.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${T.shape.length}.`);f=T.id}let g=o==null?0:n.dataIdMap.get(o.dataId).id,y=k1[c];if(y==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let m=l?i.shape[2]:i.shape[1],b=u?s.shape[1]:s.shape[2],w=wv.assertAndGetBroadcastShape(i.shape.slice(0,-2),s.shape.slice(0,-2)),_=n.makeOutput([...w,m,b],i.dtype),S=n.dataIdMap.get(_.dataId).id,E=new Uint8Array(new Int32Array(i.shape).buffer),C=new Uint8Array(new Int32Array(s.shape).buffer);return Lee(h,E,i.shape.length,p,C,s.shape.length,l,u,y,f,g,d||0,S),_}var tXe={kernelName:Xp,backendName:"wasm",setupFunc:Q9e,kernelFunc:eXe};function Jn(t,e){let n;function r(s){n=s.wasm.cwrap(t,null,["number","number","number"])}function i(s){let{backend:a,inputs:{x:o}}=s,l=a.dataIdMap.get(o.dataId).id,u=a.makeOutput(o.shape,e||o.dtype),c=a.dataIdMap.get(u.dataId).id;return P.sizeFromShape(u.shape)===0||n(l,nr[o.dtype],c),u}return{kernelName:t,backendName:"wasm",setupFunc:r,kernelFunc:i}}var nXe=Jn(x0),rXe=Jn(If),iXe=Jn(Tf);function _i(t,e,n){let r;function i(a){r=a.wasm.cwrap(t,null,["number","array","number","number","array","number","number","number"])}function s(a){let{backend:o,inputs:l}=a,{a:u,b:c}=l,d=o.dataIdMap.get(u.dataId).id,h=o.dataIdMap.get(c.dataId).id,p=n??u.dtype,f=W.assertAndGetBroadcastShape(u.shape,c.shape),g=o.makeOutput(f,p);if(P.sizeFromShape(f)===0)return g;let y=new Uint8Array(new Int32Array(u.shape).buffer),m=new Uint8Array(new Int32Array(c.shape).buffer),b=o.dataIdMap.get(g.dataId).id;return r(d,y,u.shape.length,h,m,c.shape.length,nr[u.dtype],b),g}return{kernelName:t,backendName:"wasm",setupFunc:i,kernelFunc:s}}var sXe=_i(th),Oee;function aXe(t){Oee=t.wasm.cwrap(Cf,null,["array","number","number","number"])}function oXe(t){let{inputs:e,backend:n}=t,r=n.makeOutput(e[0].shape,e[0].dtype);if(P.sizeFromShape(r.shape)===0)return r;let i=e.map(o=>n.dataIdMap.get(o.dataId).id),s=new Uint8Array(new Int32Array(i).buffer),a=n.dataIdMap.get(r.dataId).id;return Oee(s,i.length,nr[r.dtype],a),r}var lXe={kernelName:Cf,backendName:"wasm",setupFunc:aXe,kernelFunc:oXe};function TM(t){let{inputs:{x:e},backend:n}=t;if(e.dtype==="string")return Us(n.readSync(e.dataId),e.shape,e.dtype);let r=n.makeOutput(e.shape,e.dtype),i=n.typedArrayFromHeap(e);return n.typedArrayFromHeap(r).set(i),r}var uXe={kernelName:tm,backendName:"wasm",kernelFunc:TM},Bee;function cXe(t){Bee=t.wasm.cwrap(Qu,null,["number","array","number","number","number","array","number"])}function Wd(t){let{inputs:e,backend:n,attrs:r}=t,[i,s]=hXe(e.x.shape,r.perm),a=!0;for(let f=0;f<s.length;f++)s[f]!==f&&(a=!1);let o=dXe(e.x.shape,r.perm),l={dataId:e.x.dataId,shape:i,dtype:e.x.dtype};if(a){let f=TM({inputs:e,backend:n});return f.shape=o,f}let u=n.makeOutput(o,l.dtype),c=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(u.dataId).id,h=new Uint8Array(new Int32Array(s).buffer),p=new Uint8Array(new Int32Array(l.shape).buffer);return Bee(c,p,l.shape.length,nr[l.dtype],d,h,s.length),u}function dXe(t,e){let n=new Array(t.length);for(let r=0;r<n.length;r++)n[r]=t[e[r]];return n}function hXe(t,e){let n=[],r=[];for(let i=0;i<t.length;++i)t[i]!==1&&n.push(t[i]),t[e[i]]!==1&&r.push(e[i]);for(let i=0;i<r.length;++i){let s=-1;for(let a=0;a<r.length;++a)r[a]>=i&&(s===-1||r[s]>r[a])&&(s=a);r[s]=i}return[n,r]}var pXe={kernelName:Qu,backendName:"wasm",kernelFunc:Wd,setupFunc:cXe};function hh(t,e,n){let r=t.shape,i=t.shape.length,s=P.parseAxisParam(e,r),a=s,o=W.getAxesPermutation(a,i),l=null,u=!1;if(o!=null){let c=new Array(i);for(let h=0;h<c.length;h++)c[h]=r[o[h]];a=W.getInnerMostAxes(a.length,i),l=Wd({inputs:{x:t},attrs:{perm:o},backend:n});let d=n.dataIdMap.get(t.dataId).id;n.dataIdMap.get(l.dataId).id!==d&&(u=!0)}return{transposed:l,originalAxes:s,axes:a,inputWasTransposed:u}}var Uee;function fXe(t){Uee=t.wasm.cwrap(b0,null,["number, number, number"])}function mXe(t){let{backend:e,inputs:n,attrs:r}=t,{axis:i,keepDims:s}=r,{x:a}=n,o=e.dataIdMap.get(a.dataId).id,l=a,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=hh(a,i,e);if(h){let b=e.dataIdMap.get(u.dataId).id;l=u,o=b}let p=l.shape.length;W.assertAxesAreInnerMostDims("all",c,p);let[f,g]=W.computeOutAndReduceShapes(l.shape,c),y=P.sizeFromShape(g),m=e.makeOutput(f,a.dtype);if(P.sizeFromShape(l.shape)!==0){let b=e.dataIdMap.get(m.dataId).id;Uee(o,y,b)}if(h&&e.disposeData(u.dataId),s){let b=W.expandShapeToKeepDim(m.shape,d);m.shape=b}return m}var gXe={kernelName:b0,backendName:"wasm",setupFunc:fXe,kernelFunc:mXe},$ee;function yXe(t){$ee=t.wasm.cwrap(w0,null,["number, number, number"])}function vXe(t){let{backend:e,inputs:n,attrs:r}=t,{axis:i,keepDims:s}=r,{x:a}=n,o=e.dataIdMap.get(a.dataId).id,l=a,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=hh(a,i,e);if(h){let b=e.dataIdMap.get(u.dataId).id;l=u,o=b}let p=l.shape.length;W.assertAxesAreInnerMostDims("any",c,p);let[f,g]=W.computeOutAndReduceShapes(l.shape,c),y=P.sizeFromShape(g),m=e.makeOutput(f,a.dtype);if(P.sizeFromShape(l.shape)!==0){let b=e.dataIdMap.get(m.dataId).id;$ee(o,y,b)}if(h&&e.disposeData(u.dataId),s){let b=W.expandShapeToKeepDim(m.shape,d);m.shape=b}return m}var xXe={kernelName:w0,backendName:"wasm",setupFunc:yXe,kernelFunc:vXe};function zee(t){let e;function n(i){e=i.wasm.cwrap(t,null,["number","number","number","number","number"])}function r(i){let{backend:s,inputs:a,attrs:o}=i,{axis:l}=o,{x:u}=a,c=s.dataIdMap.get(u.dataId).id,d=c,h=u,{transposed:p,axes:f,inputWasTransposed:g}=hh(u,l,s);if(g){let S=s.dataIdMap.get(p.dataId).id;S!==c&&(h=p,d=S)}let y=h.shape.slice(0,-1),m=s.makeOutput(y,"int32"),b=s.dataIdMap.get(m.dataId).id,w=P.sizeFromShape(m.shape),_=h.shape[f[0]];return e(d,nr[h.dtype],w,_,b),g&&s.disposeData(p.dataId),m}return{kernelName:t,backendName:"wasm",setupFunc:n,kernelFunc:r}}var bXe=zee(_0),wXe=zee(S0),_Xe=Jn(Mf),SXe=Jn(kf),AXe=Jn(Nf),EXe=_i(Ff),IXe=Jn(Rf),Gee;function TXe(t){Gee=t.wasm.cwrap(Df,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function CXe(t){let{inputs:e,attrs:n,backend:r}=t,i=e.x,s=r.dataIdMap.get(i.dataId).id,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=n,c=W.computePool2DInfo(i.shape,a,o,1,l,u),d=c.filterHeight,h=c.filterWidth,p=c.padInfo.top,f=c.padInfo.right,g=c.padInfo.bottom,y=c.padInfo.left,m=c.strideHeight,b=c.strideWidth,w=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let _=r.makeOutput(c.outShape,"float32"),S=r.dataIdMap.get(_.dataId).id;return Gee(s,i.shape[0],i.shape[1],i.shape[2],d,h,p,f,g,y,m,b,w,S),_}var MXe={kernelName:Df,backendName:"wasm",setupFunc:TXe,kernelFunc:CXe},Hee;function kXe(t){Hee=t.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function NXe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{filterSize:s,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=W.computePool3DInfo(i.shape,s,a,1,o,l,u),d=n.makeOutput(c.outShape,i.dtype);return Hee(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}var RXe={kernelName:A0,backendName:"wasm",setupFunc:kXe,kernelFunc:NXe},Wee;function FXe(t){Wee=t.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function DXe(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=r,c=W.computePool3DInfo(s.shape,a,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return Wee(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left,c.filterDepth,c.filterHeight,c.filterWidth),d}var PXe={kernelName:sw,backendName:"wasm",setupFunc:FXe,kernelFunc:DXe},Vee;function LXe(t){Vee=t.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function OXe(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,{filterSize:a,strides:o,pad:l}=r,u=W.computePool2DInfo(s.shape,a,o,1,l),c=n.makeOutput(s.shape,s.dtype);return Vee(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left,u.filterHeight,u.filterWidth),c}var BXe={kernelName:iw,backendName:"wasm",setupFunc:LXe,kernelFunc:OXe};function oa(t){let{inputs:e,attrs:n}=t,{x:r}=e,{shape:i}=n,s=P.sizeFromShape(r.shape),a=P.inferFromImplicitShape(i,s);return P.assert(s===P.sizeFromShape(a),()=>`new shape: ${a}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`),t.backend.incRef(r.dataId),{dataId:r.dataId,shape:a,dtype:r.dtype}}var UXe={kernelName:rv,backendName:"wasm",kernelFunc:oa},jee;function $Xe(t){jee=t.wasm.cwrap(Pf,null,["number","array","number","number","array","number","number","number","number"])}function zXe(t){let{inputs:e,backend:n,attrs:r}=t,{a:i,b:s}=e,{transposeA:a,transposeB:o}=r;if(i.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=i.shape.length,u=s.shape.length,c=a?i.shape[l-2]:i.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],h=a?i.shape[l-1]:i.shape[l-2],p=o?s.shape[u-2]:s.shape[u-1],f=i.shape.slice(0,-2),g=s.shape.slice(0,-2),y=P.sizeFromShape(f),m=P.sizeFromShape(g),b=wv.assertAndGetBroadcastShape(i.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,p]);P.assert(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${i.shape} and ${s.shape} and transposeA=${a} and transposeB=${o} must match.`);let w=a?[y,c,h]:[y,h,c],_=o?[m,p,d]:[m,d,p],S=oa({inputs:{x:i},backend:n,attrs:{shape:w}}),E=oa({inputs:{x:s},backend:n,attrs:{shape:_}}),C=n.dataIdMap.get(S.dataId).id,T=n.dataIdMap.get(E.dataId).id,M=a?S.shape[2]:S.shape[1],k=o?E.shape[1]:E.shape[2],R=Math.max(y,m),N=n.makeOutput([R,M,k],S.dtype),B=n.dataIdMap.get(N.dataId).id,z=new Uint8Array(new Int32Array(S.shape).buffer),V=new Uint8Array(new Int32Array(E.shape).buffer);return jee(C,z,S.shape.length,T,V,E.shape.length,a,o,B),n.disposeData(S.dataId),n.disposeData(E.dataId),N.shape=b,N}var GXe={kernelName:Pf,backendName:"wasm",setupFunc:$Xe,kernelFunc:zXe};function hf(t){let{inputs:{x:e},attrs:{begin:n,size:r},backend:i}=t,[s,a]=Ni.parseSliceParams(e,n,r),o=Ni.isSliceContinous(e.shape,s,a),l=i.readSync(e.dataId),u=i.makeOutput(a,e.dtype),c=P.computeStrides(e.shape),d=i.dataIdMap.get(u.dataId);if(o){let f=Ni.computeFlatOffset(s,c);return e.dtype==="string"?d.stringBytes=l.slice(f,f+P.sizeFromShape(a)):i.typedArrayFromHeap(u).set(l.subarray(f,f+P.sizeFromShape(a))),u}if(e.dtype==="string"){let f=VI(l,s,a,e.shape,e.dtype);return d.stringBytes=f,u}let h=i.typedArrayFromHeap(u),p=e.shape.length;if(p===2)HXe(l,c[0],h,s,a);else if(p===3)WXe(l,c[0],c[1],h,s,a);else if(p===4)VXe(l,c[0],c[1],c[2],h,s,a);else{let f=VI(l,s,a,e.shape,e.dtype);h.set(f)}return u}function HXe(t,e,n,r,i){let s=0,a=r[0],o=r[1],l=a+i[0];for(let u=a;u<l;u++){let c=u*e+o;n.set(t.subarray(c,c+i[1]),s),s+=i[1]}}function WXe(t,e,n,r,i,s){let a=0,o=i[0],l=i[1],u=i[2],c=o+s[0],d=l+s[1];for(let h=o;h<c;h++)for(let p=l;p<d;p++){let f=h*e+p*n+u;r.set(t.subarray(f,f+s[2]),a),a+=s[2]}}function VXe(t,e,n,r,i,s,a){let o=0,l=s[0],u=s[1],c=s[2],d=l+a[0],h=u+a[1],p=c+a[2],f=s[3];for(let g=l;g<d;g++)for(let y=u;y<h;y++)for(let m=c;m<p;m++){let b=g*e+y*n+m*r+f;i.set(t.subarray(b,b+a[3]),o),o+=a[3]}}var jXe={kernelName:cv,backendName:"wasm",kernelFunc:hf};function XXe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:s,crops:a}=r,o=s.reduce((m,b)=>m*b),l=W.getReshaped(i.shape,s,o),u=W.getPermuted(l.length,s.length),c=W.getReshapedPermuted(i.shape,s,o),d=W.getSliceBeginCoords(a,s.length),h=W.getSliceSize(c,a,s.length),p=oa({inputs:{x:i},backend:n,attrs:{shape:l}}),f=Wd({inputs:{x:p},backend:n,attrs:{perm:u}}),g=oa({inputs:{x:f},backend:n,attrs:{shape:c}}),y=hf({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(g.dataId),y}var KXe={kernelName:E0,backendName:"wasm",kernelFunc:XXe},Xee;function qXe(t){Xee=t.wasm.cwrap(I0,null,["number","number","boolean","number","number","number"])}function JXe(t){let{backend:e,inputs:n,attrs:r}=t,{x:i,weights:s}=n,{size:a}=r,o=s.shape.reduce((d,h)=>d*h,1)!==0,l=i.shape.length===1?[a]:[i.shape[0],a],u=e.makeOutput(l,s.dtype);function c(d){return e.dataIdMap.get(d.dataId).id}return Xee(c(i),a,o,c(s),nr[s.dtype],c(u)),u}var YXe={kernelName:I0,backendName:"wasm",setupFunc:qXe,kernelFunc:JXe},ZXe=_i(T0);function QXe(t){let{inputs:e,backend:n}=t,{s0:r,s1:i}=e,s=n.typedArrayFromHeap(r),a=n.typedArrayFromHeap(i),o=W.assertAndGetBroadcastShape(Array.from(s),Array.from(a));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}var e7e={kernelName:aw,backendName:"wasm",kernelFunc:QXe};function ph(t){let{inputs:{x:e},attrs:{dtype:n},backend:r}=t,i=r.makeOutput(e.shape,n),s=r.typedArrayFromHeap(e);return r.typedArrayFromHeap(i).set(s),i}var t7e={kernelName:Lf,backendName:"wasm",kernelFunc:ph},n7e=Jn(Of),Kee;function r7e(t){Kee=t.wasm.cwrap(nh,null,["number","number","number","number"])}function i7e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{clipValueMin:s,clipValueMax:a}=r,o=n.dataIdMap.get(i.dataId).id,l=n.makeOutput(i.shape,i.dtype),u=n.dataIdMap.get(l.dataId).id;return Kee(o,s,a,u),l}var s7e={kernelName:nh,backendName:"wasm",setupFunc:r7e,kernelFunc:i7e};function qee(t){let{inputs:e,backend:n}=t,r=P.parseAxisParam(t.attrs.axis,e[0].shape)[0],i=e.map(p=>p.shape);W.assertParamsConsistent(i,r);let s=W.computeOutShape(e.map(p=>p.shape),r),a=e.filter(p=>P.sizeFromShape(p.shape)>0);if(a.length===1)return TM({inputs:{x:a[0]},backend:n});let o=n.makeOutput(s,e[0].dtype);if(P.sizeFromShape(s)===0)return o;if(a[0].dtype==="string"){let p=a.map(w=>{let _=[-1,P.sizeFromShape(w.shape.slice(r))];return oa({inputs:{x:w},backend:n,attrs:{shape:_}})}),f=p.map(w=>({vals:n.readSync(w.dataId),shape:w.shape}));s=W.computeOutShape(p.map(w=>w.shape),1);let g=p[0].shape[0]===1,y=$B(f,s,e[0].dtype,g),m=W.computeOutShape(a.map(w=>w.shape),r);o.shape=m;let b=n.dataIdMap.get(o.dataId);return b.stringBytes=W.fromStringArrayToUint8(y),p.forEach(w=>n.disposeData(w.dataId)),o}let l=P.sizeFromShape(a[0].shape.slice(0,r)),u=0,c=a.map(p=>{let f=P.sizeFromShape(p.shape.slice(r));return u+=f,f}),d=a.map(p=>n.typedArrayFromHeap(p)),h=n.typedArrayFromHeap(o);for(let p=0;p<l;p++){let f=p*u;for(let g=0;g<d.length;g++){let y=c[g],m=p*y,b=d[g].subarray(m,m+y);h.set(b,f),f+=y}}return o}var a7e={kernelName:C0,backendName:"wasm",kernelFunc:qee},Jee;function o7e(t){Jee=t.wasm.cwrap(Bf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function l7e(t){let{inputs:e,attrs:n,backend:r}=t,{x:i,filter:s}=e,a=r.dataIdMap.get(i.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d,dataFormat:h}=n,p=W.convertConv2DDataFormat(h),f=W.computeConv2DInfo(i.shape,s.shape,l,u,c,d,!1,p),g=f.filterHeight,y=f.filterWidth,m=f.padInfo.top,b=f.padInfo.right,w=f.padInfo.bottom,_=f.padInfo.left,S=f.dilationHeight,E=f.dilationWidth,C=f.strideHeight,T=f.strideWidth,M=f.inChannels,k=f.outChannels,R=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let N=r.makeOutput(f.outShape,"float32"),B=r.dataIdMap.get(N.dataId).id;return Jee(a,i.shape[0],i.shape[1],i.shape[2],o,g,y,m,b,w,_,R,S,E,C,T,M,k,B),N}var u7e={kernelName:Bf,backendName:"wasm",setupFunc:o7e,kernelFunc:l7e},Yee;function c7e(t){Yee=t.wasm.cwrap(Uf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function d7e(t){let{backend:e,inputs:n,attrs:r}=t,{dy:i,filter:s}=n,{strides:a,pad:o,dataFormat:l,dimRoundingMode:u,inputShape:c}=r,d=1,h=W.convertConv2DDataFormat(l),p=W.computeConv2DInfo(c,s.shape,a,d,o,u,!1,h),{batchSize:f,filterHeight:g,filterWidth:y,inChannels:m,inHeight:b,inWidth:w,outChannels:_,outHeight:S,outWidth:E,strideHeight:C,strideWidth:T}=p,M=g-1-p.padInfo.top,k=y-1-p.padInfo.left,R=p.dataFormat==="channelsLast",N=P.computeStrides(p.inShape),B=P.computeStrides(i.shape),[z,V,K]=P.computeStrides(s.shape),Q=N[0],O=R?N[1]:N[2],j=R?N[2]:1,X=R?1:N[1],te=B[0],le=R?B[1]:B[2],ge=R?B[2]:1,ie=R?1:B[1],we=e.makeOutput(p.inShape,"float32"),Ce=e.dataIdMap.get(we.dataId).id,Re=e.dataIdMap.get(i.dataId).id,Le=e.dataIdMap.get(s.dataId).id;return Yee(Re,Le,f,g,y,b,w,m,S,E,_,C,T,M,k,z,V,K,Q,O,j,X,te,le,ge,ie,Ce),we}var h7e={kernelName:Uf,backendName:"wasm",setupFunc:c7e,kernelFunc:d7e},Zee;function p7e(t){Zee=t.wasm.cwrap($f,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function f7e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:a,pad:o,dilations:l}=r;if(i.dtype!=="float32")throw new Error(`Tensor x must have dtype float32, got ${i.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=W.computeConv3DInfo(i.shape,s.shape,a,l,o),c=n.makeOutput(u.outShape,i.dtype);return Zee(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var m7e={kernelName:$f,backendName:"wasm",setupFunc:p7e,kernelFunc:f7e},Qee;function g7e(t){Qee=t.wasm.cwrap(M0,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function y7e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,dy:s}=e,{strides:a,pad:o,filterShape:l}=r;if(i.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${i.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=W.computeConv3DInfo(i.shape,l,a,1,o),c=n.makeOutput(u.filterShape,s.dtype);return Qee(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var v7e={kernelName:M0,backendName:"wasm",setupFunc:g7e,kernelFunc:y7e},ete;function x7e(t){ete=t.wasm.cwrap(k0,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function b7e(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:s}=e,{pad:a,strides:o,inputShape:l}=r;if(i.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${i.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=W.computeConv3DInfo(l,s.shape,o,1,a),c=n.makeOutput(u.inShape,i.dtype);return ete(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var w7e={kernelName:k0,backendName:"wasm",setupFunc:x7e,kernelFunc:b7e},_7e=Jn(zf),S7e=Jn(Gf),rD;(function(t){t[t.bilinear=0]="bilinear",t[t.nearest=1]="nearest"})(rD||(rD={}));var tte;function A7e(t){tte=t.wasm.cwrap(R0,null,["number","number","number","number","array","number","number","number","number","number"])}function E7e(t){let{backend:e,inputs:n,attrs:r}=t,{method:i,extrapolationValue:s,cropSize:a}=r,{image:o,boxes:l,boxInd:u}=n,c=l.shape[0],[d,h]=a,p=[c,d,h,o.shape[3]],f=e.dataIdMap.get(o.dataId),g;o.dtype!=="float32"&&(g=ph({backend:e,inputs:{x:o},attrs:{dtype:"float32"}}),f=e.dataIdMap.get(g.dataId));let y=f.id,m=e.dataIdMap.get(l.dataId).id,b=e.dataIdMap.get(u.dataId).id,w=e.makeOutput(p,"float32"),_=e.dataIdMap.get(w.dataId).id,S=new Uint8Array(new Int32Array(o.shape).buffer);return tte(y,m,b,c,S,d,h,rD[i],s,_),g!=null&&e.disposeData(g.dataId),w}var I7e={kernelName:R0,backendName:"wasm",setupFunc:A7e,kernelFunc:E7e},nte;function T7e(t){nte=t.wasm.cwrap(N0,null,["number","number","number","number","number","number"])}function C7e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,exclusive:a,reverse:o}=r,l=i.shape.length;P.assert(i.dtype==="float32"||i.dtype==="int32",()=>`cumprod does not support ${i.dtype} tensors in the WASM backend`);let u=W.getAxesPermutation([s],l),c=i;u!==null&&(c=Wd({inputs:{x:i},attrs:{perm:u},backend:n}));let d=W.getInnerMostAxes(1,l)[0];W.assertAxesAreInnerMostDims("cumprod",[d],l);let h=n.makeOutput(c.shape,c.dtype),p=c.shape[d],f=n.dataIdMap.get(c.dataId).id,g=n.dataIdMap.get(h.dataId).id;nte(f,a?1:0,o?1:0,p,g,nr[i.dtype]);let y=h;if(u!==null){let m=W.getUndoAxesPermutation(u);y=Wd({inputs:{x:h},attrs:{perm:m},backend:n}),n.disposeData(c.dataId),n.disposeData(h.dataId)}return y}var M7e={kernelName:N0,backendName:"wasm",setupFunc:T7e,kernelFunc:C7e},rte;function k7e(t){rte=t.wasm.cwrap(Hf,null,["number","number","number","number","number","number"])}function N7e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,exclusive:a,reverse:o}=r,l=i.shape.length;P.assert(i.dtype==="float32"||i.dtype==="int32",()=>`cumsum does not support ${i.dtype} tensors in the WASM backend`);let u=W.getAxesPermutation([s],l),c=i;u!==null&&(c=Wd({inputs:{x:i},attrs:{perm:u},backend:n}));let d=W.getInnerMostAxes(1,l)[0];W.assertAxesAreInnerMostDims("cumsum",[d],l);let h=n.makeOutput(c.shape,c.dtype),p=c.shape[d],f=n.dataIdMap.get(c.dataId).id,g=n.dataIdMap.get(h.dataId).id;rte(f,a?1:0,o?1:0,p,g,nr[i.dtype]);let y=h;if(u!==null){let m=W.getUndoAxesPermutation(u);y=Wd({inputs:{x:h},attrs:{perm:m},backend:n}),n.disposeData(c.dataId),n.disposeData(h.dataId)}return y}var R7e={kernelName:Hf,backendName:"wasm",setupFunc:k7e,kernelFunc:N7e},ite;function F7e(t){ite=t.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function D7e(t){let{backend:e,inputs:n,attrs:r}=t,{x:i,weights:s}=n,{size:a,binaryOutput:o}=r,l=s.shape.reduce((h,p)=>h*p,1)!==0,u=i.shape.length===1?[a]:[i.shape[0],a],c=e.makeOutput(u,s.dtype);function d(h){return e.dataIdMap.get(h.dataId).id}return ite(d(i),new Uint8Array(new Int32Array(i.shape).buffer),i.shape.length,a,l,d(s),nr[s.dtype],o,d(c)),c}var P7e={kernelName:lw,backendName:"wasm",setupFunc:F7e,kernelFunc:D7e},ste;function L7e(t){ste=t.wasm.cwrap(F0,null,["number","number","number","array","number","array","array","number","number"])}function O7e(t){let{backend:e,inputs:n,attrs:r}=t,{x:i}=n,{blockSize:s,dataFormat:a}=r,o=i.shape[0],l=a==="NHWC"?i.shape[1]:i.shape[2],u=a==="NHWC"?i.shape[2]:i.shape[3],c=a==="NHWC"?i.shape[3]:i.shape[1],d=l*s,h=u*s,p=c/(s*s),f=a==="NHWC"?[o,d,h,p]:[o,p,d,h],g=e.makeOutput(f,"float32"),y=e.dataIdMap.get(i.dataId).id,m=new Uint8Array(new Int32Array(P.computeStrides(i.shape)).buffer),b=new Uint8Array(new Int32Array(f).buffer),w=new Uint8Array(new Int32Array(P.computeStrides(f)).buffer),_=e.dataIdMap.get(g.dataId).id;return ste(y,s,a==="NHWC"?1:0,m,i.shape.length-1,b,w,f.length,_),g}var B7e={kernelName:F0,backendName:"wasm",setupFunc:L7e,kernelFunc:O7e},ate;function U7e(t){ate=t.wasm.cwrap(Wf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function $7e(t){let{inputs:e,attrs:n,backend:r}=t,{x:i,filter:s}=e,a=r.dataIdMap.get(i.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d}=n,h=u??[1,1],p=W.computeConv2DInfo(i.shape,s.shape,l,h,c,d,!0),f=p.filterHeight,g=p.filterWidth,y=p.padInfo.top,m=p.padInfo.right,b=p.padInfo.bottom,w=p.padInfo.left,_=p.dilationHeight,S=p.dilationWidth,E=p.strideHeight,C=p.strideWidth,T=p.inChannels,M=p.outChannels,k=p.padInfo.type==="SAME"?1:0;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let R=r.makeOutput(p.outShape,"float32"),N=r.dataIdMap.get(R.dataId).id;return ate(a,i.shape[0],i.shape[1],i.shape[2],o,f,g,y,m,b,w,k,_,S,E,C,T,M,N),R}var z7e={kernelName:Wf,backendName:"wasm",setupFunc:U7e,kernelFunc:$7e},ote;function G7e(t){ote=t.wasm.cwrap("Diag",null,["number","number","number","number"])}function H7e(t){let{inputs:e,backend:n}=t,{x:r}=e,i=P.sizeFromShape(r.shape),s=n.makeOutput([...r.shape,...r.shape],r.dtype);return ote(n.dataIdMap.get(r.dataId).id,nr[r.dtype],i,n.dataIdMap.get(s.dataId).id),s}var W7e={kernelName:uw,backendName:"wasm",setupFunc:G7e,kernelFunc:H7e},lte;function V7e(t){lte=t.wasm.cwrap(Vf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function j7e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:a,pad:o,dilations:l}=r;if(i.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${i.dtype} and ${s.dtype}`);let u=W.computeDilation2DInfo(i.shape,s.shape,a,o,"NHWC",l),c=n.makeOutput(u.outShape,i.dtype);return lte(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,nr[i.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),c}var X7e={kernelName:Vf,backendName:"wasm",setupFunc:V7e,kernelFunc:j7e},ute;function K7e(t){ute=t.wasm.cwrap(Xy,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function q7e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s,dy:a}=e,{strides:o,pad:l,dilations:u}=r;if(i.dtype!==s.dtype||i.dtype!==a.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${i.dtype}, ${s.dtype}, and ${a.dtype}`);let c=W.computeDilation2DInfo(i.shape,s.shape,o,l,"NHWC",u),d=n.makeOutput(s.shape,s.dtype);return ute(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,nr[i.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),d}var J7e={kernelName:Xy,backendName:"wasm",setupFunc:K7e,kernelFunc:q7e},cte;function Y7e(t){cte=t.wasm.cwrap(jy,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Z7e(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s,dy:a}=e,{strides:o,pad:l,dilations:u}=r;if(i.dtype!==s.dtype||i.dtype!==a.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${i.dtype}, ${s.dtype}, and ${a.dtype}`);let c=W.computeDilation2DInfo(i.shape,s.shape,o,l,"NHWC",u),d=n.makeOutput(i.shape,i.dtype);return cte(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,nr[i.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),d}var Q7e={kernelName:jy,backendName:"wasm",setupFunc:Y7e,kernelFunc:Z7e},eKe=Jn(Xf),dte;function tKe(t){dte=t.wasm.cwrap(D0,null,["number","number","number"])}function nKe(t){let{inputs:e,backend:n}=t,{dy:r,y:i}=e,s=n.makeOutput(i.shape,"float32"),a=o=>n.dataIdMap.get(o.dataId).id;return dte(a(i),a(r),a(s)),s}var rKe={kernelName:D0,backendName:"wasm",setupFunc:tKe,kernelFunc:nKe},iKe=!1,sKe=_i(P0,iKe,"bool"),aKe=Jn(Kf),oKe=Jn(qf,"float32");function iD(t){let{inputs:e,attrs:n,backend:r}=t,{input:i}=e,{dim:s}=n,a=i.shape.length,o=i.shape.slice(),l=s;return s<0&&(P.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+s+1),o.splice(l,0,1),oa({inputs:{x:i},backend:r,attrs:{shape:o}})}var lKe={kernelName:L0,backendName:"wasm",kernelFunc:iD},uKe=Jn(Jf,"float32");function hte(t){let{attrs:{shape:e,value:n},backend:r}=t,{attrs:{dtype:i}}=t;i=i||P.inferDtype(n);let s=r.makeOutput(e,i);return r.typedArrayFromHeap(s).fill(n),s}var cKe={kernelName:cw,backendName:"wasm",kernelFunc:hte},pte;function dKe(t){pte=t.wasm.cwrap(O0,null,["number","number","number","number","number","number"])}function hKe(t){let{inputs:e,backend:n}=t,{image:r}=e,i=n.makeOutput(r.shape,r.dtype),s=n.dataIdMap.get(r.dataId).id,a=n.dataIdMap.get(i.dataId).id,[o,l,u,c]=r.shape;return pte(s,o,l,u,c,a),i}var pKe={kernelName:O0,backendName:"wasm",kernelFunc:hKe,setupFunc:dKe},fKe=Jn(Yf),mKe=_i(Zf),fte;function gKe(t){fte=t.wasm.cwrap(Qf,null,["number","number","number","number","number","number","number"])}function yKe(t){let{backend:e,inputs:n,attrs:r}=t,{varianceEpsilon:i}=r,{x:s,mean:a,variance:o,offset:l,scale:u}=n,c=e.dataIdMap.get(s.dataId).id,d=e.dataIdMap.get(a.dataId).id,h=e.dataIdMap.get(o.dataId).id,p=l!=null?e.dataIdMap.get(l.dataId).id:0,f=u!=null?e.dataIdMap.get(u.dataId).id:0,g=e.makeOutput(s.shape,s.dtype);if(P.sizeFromShape(s.shape)===0)return g;let y=e.dataIdMap.get(g.dataId).id;return fte(c,d,h,p,f,i,y),g}var vKe={kernelName:Qf,backendName:"wasm",setupFunc:gKe,kernelFunc:yKe},mte;function xKe(t){mte=t.wasm.cwrap(Kp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function bKe(t){let{inputs:e,attrs:n,backend:r}=t,{x:i,filter:s,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,g=W.computeConv2DInfo(i.shape,s.shape,l,c,u,h),y=k1[p];if(y==null)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let m=r.dataIdMap.get(i.dataId).id,b=r.dataIdMap.get(s.dataId).id,w=g.outChannels,_=0;if(a!=null){let ge=r.dataIdMap.get(a.dataId);if(ge.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${ge.shape.length}.`);if(ge.shape[0]!==w)throw new Error(`FusedConv2D bias shape (${ge.shape}) does not match the number of output channels (${w})`);_=ge.id}let S=g.filterHeight,E=g.filterWidth,C=g.padInfo.top,T=g.padInfo.right,M=g.padInfo.bottom,k=g.padInfo.left,R=g.dilationHeight,N=g.dilationWidth,B=g.strideHeight,z=g.strideWidth,V=g.inChannels,K=g.padInfo.type==="SAME"?1:0,Q=g.batchSize,O=g.inHeight,j=g.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let X=r.makeOutput(g.outShape,"float32"),te=r.dataIdMap.get(X.dataId).id,le=o==null?0:r.dataIdMap.get(o.dataId).id;return mte(m,Q,O,j,b,S,E,_,C,T,M,k,K,R,N,B,z,V,w,y,le,f||0,te),X}var wKe={kernelName:Kp,backendName:"wasm",setupFunc:xKe,kernelFunc:bKe},gte;function _Ke(t){gte=t.wasm.cwrap(qp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function SKe(t){let{inputs:e,attrs:n,backend:r}=t,{x:i,filter:s,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,g=W.computeConv2DInfo(i.shape,s.shape,l,c,u,h,!0),y=k1[p];if(y==null)throw new Error(`${p} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let m=r.dataIdMap.get(i.dataId).id,b=r.dataIdMap.get(s.dataId).id,w=g.outChannels,_=0;if(a!=null){let ge=r.dataIdMap.get(a.dataId);if(ge.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${ge.shape.length}.`);if(ge.shape[0]!==w)throw new Error(`FusedDepthwiseConv2D bias shape (${ge.shape}) does not match the number of output channels (${w})`);_=ge.id}let S=g.filterHeight,E=g.filterWidth,C=g.padInfo.top,T=g.padInfo.right,M=g.padInfo.bottom,k=g.padInfo.left,R=g.dilationHeight,N=g.dilationWidth,B=g.strideHeight,z=g.strideWidth,V=g.inChannels,K=g.padInfo.type==="SAME"?1:0,Q=g.batchSize,O=g.inHeight,j=g.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let X=r.makeOutput(g.outShape,"float32"),te=r.dataIdMap.get(X.dataId).id,le=o==null?0:r.dataIdMap.get(o.dataId).id;return gte(m,Q,O,j,b,S,E,_,C,T,M,k,K,R,N,B,z,V,w,y,le,f||0,te),X}var AKe={kernelName:qp,backendName:"wasm",setupFunc:_Ke,kernelFunc:SKe},yte;function EKe(t){yte=t.wasm.cwrap(U0,null,["number","number","number","number","number","number","array","number"])}function IKe(t){let{backend:e,inputs:n}=t,{params:r,indices:i}=n,[s,a,o,l]=ZL.prepareAndValidate(r,i),u=e.makeOutput(s,r.dtype);if(a===0)return u;let c=i.shape,d=c[c.length-1],h=e.dataIdMap.get(r.dataId).id,p=e.dataIdMap.get(i.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),g=e.dataIdMap.get(u.dataId).id;return yte(h,nr[r.dtype],p,a,d,o,f,g),u}var TKe={kernelName:U0,backendName:"wasm",setupFunc:EKe,kernelFunc:IKe},vte;function CKe(t){vte=t.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function MKe(t){let{backend:e,inputs:n,attrs:r}=t,{x:i,indices:s}=n,{axis:a,batchDims:o}=r,l=P.parseAxisParam(a,i.shape)[0],u=e.readSync(s.dataId),c=i.shape[l];for(let C=0;C<u.length;++C){let T=u[C];P.assert(T<=c-1&&T>=0,()=>`GatherV2: the index value ${T} is not in [0, ${c-1}]`)}let d=W.segment_util.collectGatherOpShapeInfo(i,s,l,o),h=oa({inputs:{x:i},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:e}),p=P.sizeFromShape(s.shape),f=oa({inputs:{x:s},attrs:{shape:[d.batchSize,p/d.batchSize]},backend:e}),g=[d.batchSize,d.outerSize,p/d.batchSize,d.sliceSize],y=e.makeOutput(g,i.dtype);if(P.sizeFromShape(i.shape)===0)return y;let m=h.shape.length-1,b=e.dataIdMap.get(h.dataId).id,w=e.dataIdMap.get(f.dataId).id,_=e.dataIdMap.get(y.dataId).id,S=new Uint8Array(new Int32Array(P.computeStrides(h.shape)).buffer),E=new Uint8Array(new Int32Array(P.computeStrides(g)).buffer);return vte(b,nr[i.dtype],S,m,w,d.batchSize,E,_),e.disposeData(h.dataId),e.disposeData(f.dataId),y.shape=d.outputShape,y}var kKe={kernelName:B0,backendName:"wasm",setupFunc:CKe,kernelFunc:MKe},NKe=!1,RKe=_i($0,NKe,"bool"),FKe=!1,DKe=_i(em,FKe,"bool"),PKe=Jn(nm,"bool"),LKe=Jn(rm,"bool"),OKe=Jn(im,"bool"),xte;function BKe(t){xte=t.wasm.cwrap(sm,null,["number","number","number","number"])}function UKe(t){let{inputs:{x:e},attrs:{alpha:n},backend:r}=t,i=r.dataIdMap.get(e.dataId).id,s=r.makeOutput(e.shape,"float32");if(P.sizeFromShape(e.shape)!==0){let a=r.dataIdMap.get(s.dataId).id;xte(i,nr[e.dtype],n,a)}return s}var $Ke={kernelName:sm,backendName:"wasm",setupFunc:BKe,kernelFunc:UKe},zKe=!1,GKe=_i(z0,zKe,"bool"),HKe=!1,WKe=_i(G0,HKe,"bool"),bte;function VKe(t){bte=t.wasm.cwrap(H0,null,["number","number","number","number"])}function jKe(t){let{attrs:e,backend:n}=t,{start:r,stop:i,num:s}=e,a=Math.floor(s),o=n.makeOutput([a],"float32");return bte(n.dataIdMap.get(o.dataId).id,r,i,a),o}var XKe={kernelName:H0,backendName:"wasm",setupFunc:VKe,kernelFunc:jKe},KKe=Jn(am),qKe=Jn(om),JKe=!1,YKe=_i(W0,JKe,"bool"),ZKe=Jn(V0),QKe=!1,eqe=_i(j0,QKe,"bool"),tqe=!1,nqe=_i(x7,tqe,"bool"),wte;function rqe(t){wte=t.wasm.cwrap(lm,null,["number","number","number","number","number","number","number"])}function iqe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{depthRadius:s,bias:a,alpha:o,beta:l}=r;if(i.dtype!=="float32")throw new Error("LRN error: x must have dtype float32");let u=n.makeOutput(i.shape,i.dtype);return wte(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(u.dataId).id,i.shape[3],s,a,o,l),u}var sqe={kernelName:lm,backendName:"wasm",setupFunc:rqe,kernelFunc:iqe},_te;function aqe(t){_te=t.wasm.cwrap(X0,null,["number","number","number","number","number","number","number","number","number"])}function oqe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i,y:s,dy:a}=e,{depthRadius:o,bias:l,alpha:u,beta:c}=r;if(i.dtype!=="float32"||s.dtype!=="float32"||a.dtype!=="float32")throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let d=n.makeOutput(i.shape,i.dtype);return _te(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,a.shape[3],o,l,u,c),d}var lqe={kernelName:X0,backendName:"wasm",setupFunc:aqe,kernelFunc:oqe},Ste;function uqe(t){Ste=t.wasm.cwrap(um,null,["number","number","number","number"])}function cqe(t){let{backend:e,inputs:n,attrs:r}=t,{reductionIndices:i,keepDims:s}=r,{x:a}=n,o=e.dataIdMap.get(a.dataId).id,l=a,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=hh(a,i,e);if(h){let b=e.dataIdMap.get(u.dataId).id;l=u,o=b}let p=l.shape.length;W.assertAxesAreInnerMostDims("max",c,p);let[f,g]=W.computeOutAndReduceShapes(l.shape,c),y=P.sizeFromShape(g),m=e.makeOutput(f,a.dtype);if(P.sizeFromShape(l.shape)!==0){let b=e.dataIdMap.get(m.dataId).id;Ste(o,nr[a.dtype],y,b)}if(h&&e.disposeData(u.dataId),s){let b=W.expandShapeToKeepDim(m.shape,d);m.shape=b}return m}var dqe={kernelName:um,backendName:"wasm",setupFunc:uqe,kernelFunc:cqe},hqe=_i(cm),Ate;function pqe(t){Ate=t.wasm.cwrap(dm,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function fqe(t){let{inputs:e,attrs:n,backend:r}=t,i=e.x,s=r.dataIdMap.get(i.dataId).id;P.assert(i.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${i.dtype}.`);let{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=n,c=W.computePool2DInfo(i.shape,a,o,1,l,u),d=c.filterHeight,h=c.filterWidth,p=c.padInfo.top,f=c.padInfo.right,g=c.padInfo.bottom,y=c.padInfo.left,m=c.dilationHeight,b=c.dilationWidth,w=c.strideHeight,_=c.strideWidth,S=c.inChannels,E=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let C=r.makeOutput(c.outShape,"float32"),T=r.dataIdMap.get(C.dataId).id;return Ate(s,i.shape[0],i.shape[1],i.shape[2],d,h,p,f,g,y,m,b,w,_,S,E,T),C}var mqe={kernelName:dm,backendName:"wasm",setupFunc:pqe,kernelFunc:fqe},Ete;function gqe(t){Ete=t.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function yqe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{filterSize:s,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=W.computePool3DInfo(i.shape,s,a,1,o,l,u),d=n.makeOutput(c.outShape,i.dtype);return Ete(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}var vqe={kernelName:K0,backendName:"wasm",setupFunc:gqe,kernelFunc:yqe},Ite;function xqe(t){Ite=t.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function bqe(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=r,c=W.computePool3DInfo(s.shape,a,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return Ite(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}var wqe={kernelName:hw,backendName:"wasm",setupFunc:xqe,kernelFunc:bqe},Tte;function _qe(t){Tte=t.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Sqe(t){let{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=r,c=W.computePool2DInfo(s.shape,a,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return Tte(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),d}var Aqe={kernelName:dw,backendName:"wasm",setupFunc:_qe,kernelFunc:Sqe},Cte;function Eqe(t){Cte=t.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Iqe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{filterSize:s,strides:a,pad:o,includeBatchInIndex:l}=r;P.assert(i.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.shape.length}.`);let u=[1,1];P.assert(W.eitherStridesOrDilationsAreOne(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=W.computePool2DInfo(i.shape,s,a,[1,1],o),d=n.makeOutput(c.outShape,i.dtype),h=n.makeOutput(c.outShape,"int32");return Cte(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,n.dataIdMap.get(h.dataId).id,nr[i.dtype],l,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),[d,h]}var Tqe={kernelName:pw,backendName:"wasm",setupFunc:Eqe,kernelFunc:Iqe},Mte;function Cqe(t){Mte=t.wasm.cwrap(hm,null,["number, number, number"])}function Mqe(t){let{backend:e,inputs:n,attrs:r}=t,{axis:i,keepDims:s}=r,{x:a}=n,o=e.dataIdMap.get(a.dataId).id,l=o,u=a,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=hh(a,i,e),f=d;if(p){let _=e.dataIdMap.get(c.dataId).id;_!==o&&(u=c,l=_,f=W.getInnerMostAxes(f.length,u.shape.length))}W.assertAxesAreInnerMostDims("mean",f,u.shape.length);let[g,y]=W.computeOutAndReduceShapes(u.shape,f),m=P.sizeFromShape(y),b=u;u.dtype!=="float32"&&(b=ph({backend:e,inputs:{x:u},attrs:{dtype:"float32"}}),l=e.dataIdMap.get(b.dataId).id);let w=e.makeOutput(g,"float32");if(P.sizeFromShape(u.shape)!==0){let _=e.dataIdMap.get(w.dataId).id;Mte(l,m,_)}if(p&&e.disposeData(c.dataId),s){let _=W.expandShapeToKeepDim(w.shape,h);w.shape=_}return u.dtype!=="float32"&&e.disposeData(b.dataId),w}var kqe={kernelName:hm,backendName:"wasm",setupFunc:Cqe,kernelFunc:Mqe},kte;function Nqe(t){kte=t.wasm.cwrap(pm,null,["number","number","number","number"])}function Rqe(t){let{backend:e,inputs:n,attrs:r}=t,{axis:i,keepDims:s}=r,{x:a}=n,o=e.dataIdMap.get(a.dataId).id,l=o,u=a,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=hh(a,i,e);if(p){let w=e.dataIdMap.get(c.dataId).id;w!==o&&(u=c,l=w)}let f=u.shape.length;W.assertAxesAreInnerMostDims("min",d,f);let[g,y]=W.computeOutAndReduceShapes(u.shape,d),m=P.sizeFromShape(y),b=e.makeOutput(g,u.dtype);if(P.sizeFromShape(u.shape)!==0){let w=e.dataIdMap.get(b.dataId).id;kte(l,nr[a.dtype],m,w)}if(p&&e.disposeData(c.dataId),s){let w=W.expandShapeToKeepDim(b.shape,h);b.shape=w}return b}var Fqe={kernelName:pm,backendName:"wasm",setupFunc:Nqe,kernelFunc:Rqe},Dqe=_i(fm),sD;(function(t){t[t.reflect=0]="reflect",t[t.symmetric=1]="symmetric"})(sD||(sD={}));var Nte;function Pqe(t){Nte=t.wasm.cwrap(mm,null,["number","array","number","number","array","array","number","number"])}function Lqe(t){let{inputs:{x:e},backend:n,attrs:{paddings:r,mode:i}}=t,s=r.map((f,g)=>f[0]+e.shape[g]+f[1]),a=n.dataIdMap.get(e.dataId).id,o=n.makeOutput(s,e.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(e.shape).buffer),c=r.map(f=>f[0]),d=r.map(f=>f[1]),h=new Uint8Array(new Int32Array(c).buffer),p=new Uint8Array(new Int32Array(d).buffer);return Nte(a,u,e.shape.length,nr[e.dtype],h,p,sD[i],l),o}var Oqe={kernelName:mm,backendName:"wasm",kernelFunc:Lqe,setupFunc:Pqe},Rte;function Bqe(t){Rte=t.wasm.cwrap(Um,null,["number","number","number","number"])}function Fte(t){let{backend:e,inputs:{logits:n},attrs:{dim:r}}=t,i=e.dataIdMap.get(n.dataId).id,s=e.makeOutput(n.shape,n.dtype),a=e.dataIdMap.get(s.dataId).id,o=n.shape[r],l=P.sizeFromShape(n.shape)/o;return P.sizeFromShape(s.shape)===0||Rte(i,a,o,l),s}var Uqe={kernelName:Um,backendName:"wasm",setupFunc:Bqe,kernelFunc:Fte},Dte;function $qe(t){Dte=t.wasm.cwrap(q0,null,["number","number","number","number","number","number"])}function zqe(t){let{inputs:e,backend:n,attrs:r}=t,{logits:i}=e,{numSamples:s,seed:a,normalized:o}=r;if(i.dtype!=="float32")throw new Error(`Tensor logits must have dtype float32, got ${i.dtype}`);let l=o?i:Fte({inputs:{logits:i},backend:n,attrs:{dim:i.shape.length-1}}),[u,c]=l.shape,d=n.makeOutput([u,s],"int32");return Dte(n.dataIdMap.get(l.dataId).id,u,c,s,a,n.dataIdMap.get(d.dataId).id),o||n.disposeData(l.dataId),d}var Gqe={kernelName:q0,backendName:"wasm",setupFunc:$qe,kernelFunc:zqe},Hqe=_i(gm),Wqe=_i(ym),Vqe=Jn(J0);function mU(t,e){let n=new Int32Array(t.wasm.HEAPU8.buffer,e,4),r=n[0],i=n[1],s=n[2],a=n[3];return t.wasm._free(e),{pSelectedIndices:r,selectedSize:i,pSelectedScores:s,pValidOutputs:a}}var Pte;function jqe(t){Pte=t.wasm.cwrap(Z0,"number",["number","number","number","number","number"])}function Xqe(t){let{backend:e,inputs:n,attrs:r}=t,{iouThreshold:i,maxOutputSize:s,scoreThreshold:a}=r,{boxes:o,scores:l}=n,u=e.dataIdMap.get(o.dataId).id,c=e.dataIdMap.get(l.dataId).id,d=Pte(u,c,s,i,a),{pSelectedIndices:h,selectedSize:p,pSelectedScores:f,pValidOutputs:g}=mU(e,d);return e.wasm._free(f),e.wasm._free(g),e.makeOutput([p],"int32",h)}var Kqe={kernelName:Z0,backendName:"wasm",setupFunc:jqe,kernelFunc:Xqe},Lte;function qqe(t){Lte=t.wasm.cwrap(Q0,"number",["number","number","number","number","number","bool"])}function Jqe(t){let{backend:e,inputs:n,attrs:r}=t,{iouThreshold:i,maxOutputSize:s,scoreThreshold:a,padToMaxOutputSize:o}=r,{boxes:l,scores:u}=n,c=e.dataIdMap.get(l.dataId).id,d=e.dataIdMap.get(u.dataId).id,h=Lte(c,d,s,i,a,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:g,pValidOutputs:y}=mU(e,h);e.wasm._free(g);let m=e.makeOutput([f],"int32",p),b=e.makeOutput([],"int32",y);return[m,b]}var Yqe={kernelName:Q0,backendName:"wasm",setupFunc:qqe,kernelFunc:Jqe},Ote;function Zqe(t){Ote=t.wasm.cwrap(ev,"number",["number","number","number","number","number","number"])}function Qqe(t){let{backend:e,inputs:n,attrs:r}=t,{iouThreshold:i,maxOutputSize:s,scoreThreshold:a,softNmsSigma:o}=r,{boxes:l,scores:u}=n,c=e.dataIdMap.get(l.dataId).id,d=e.dataIdMap.get(u.dataId).id,h=Ote(c,d,s,i,a,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:g,pValidOutputs:y}=mU(e,h);e.wasm._free(y);let m=e.makeOutput([f],"int32",p),b=e.makeOutput([f],"float32",g);return[m,b]}var eJe={kernelName:ev,backendName:"wasm",setupFunc:Zqe,kernelFunc:Qqe},tJe=!1,nJe=_i(Y0,tJe,"bool"),Bte;function rJe(t){Bte=t.wasm.cwrap(vm,null,["number","number","number","number","number"])}function iJe(t){let{inputs:e,backend:n,attrs:r}=t,{indices:i}=e,{dtype:s,depth:a,onValue:o,offValue:l}=r,u=n.makeOutput([...i.shape,a],s),c=n.dataIdMap.get(u.dataId).id,d=n.dataIdMap.get(i.dataId).id;return Bte(d,a,o,l,c),u}var sJe={kernelName:vm,backendName:"wasm",setupFunc:rJe,kernelFunc:iJe};function aJe(t){let{inputs:{x:e},backend:n}=t,r=n.makeOutput(e.shape,e.dtype);return n.typedArrayFromHeap(r).fill(1),r}var oJe={kernelName:tv,backendName:"wasm",kernelFunc:aJe};function lJe(t){let{inputs:e,backend:n,attrs:r}=t,{axis:i}=r;if(e.length===1)return iD({inputs:{input:e[0]},backend:n,attrs:{dim:i}});let s=e[0].shape,a=e[0].dtype;e.forEach(c=>{P.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),P.assert(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=e.map(c=>{let d=iD({inputs:{input:c},backend:n,attrs:{dim:i}});return o.push(d),d}),u=qee({inputs:l,backend:n,attrs:{axis:i}});return o.forEach(c=>n.disposeData(c.dataId)),u}var uJe={kernelName:nv,backendName:"wasm",kernelFunc:lJe},Ute;function cJe(t){Ute=t.wasm.cwrap(xm,null,["number","array","number","number","array","array","number","number"])}function dJe(t){let{inputs:{x:e},backend:n,attrs:{paddings:r,constantValue:i}}=t,s=r.map((f,g)=>f[0]+e.shape[g]+f[1]);if(P.sizeFromShape(e.shape)===0)return hte({backend:n,attrs:{shape:s,value:i,dtype:e.dtype}});let a=n.dataIdMap.get(e.dataId).id,o=n.makeOutput(s,e.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(e.shape).buffer),c=r.map(f=>f[0]),d=r.map(f=>f[1]),h=new Uint8Array(new Int32Array(c).buffer),p=new Uint8Array(new Int32Array(d).buffer);return Ute(a,u,e.shape.length,nr[e.dtype],h,p,i,l),o}var $te={kernelName:xm,backendName:"wasm",kernelFunc:dJe,setupFunc:cJe},hJe=_i(bm),zte;function pJe(t){zte=t.wasm.cwrap(wm,null,["number","number","number"])}function fJe(t){let{inputs:e,backend:n}=t,{x:r,alpha:i}=e,s=n.dataIdMap.get(r.dataId).id,a=n.dataIdMap.get(i.dataId).id,o=s,l=r,u=l;l.dtype!=="float32"&&(u=ph({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(u.dataId).id);let c=n.makeOutput(r.shape,"float32"),d=n.dataIdMap.get(c.dataId).id;return zte(o,a,d),l.dtype!=="float32"&&n.disposeData(u.dataId),c}var mJe={kernelName:wm,backendName:"wasm",setupFunc:pJe,kernelFunc:fJe},Gte;function gJe(t){Gte=t.wasm.cwrap(_m,null,["number","number","number","number"])}function yJe(t){let{backend:e,inputs:n,attrs:r}=t,{axis:i,keepDims:s}=r,{x:a}=n,o=e.dataIdMap.get(a.dataId).id,l=o,u=a,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=hh(a,i,e),f=d;if(p){let w=e.dataIdMap.get(c.dataId).id;w!==o&&(u=c,l=w,f=W.getInnerMostAxes(f.length,u.shape.length))}W.assertAxesAreInnerMostDims("prod",f,u.shape.length);let[g,y]=W.computeOutAndReduceShapes(u.shape,f),m=P.sizeFromShape(y),b=e.makeOutput(g,u.dtype);if(P.sizeFromShape(u.shape)!==0){let w=e.dataIdMap.get(b.dataId).id;Gte(l,m,nr[b.dtype],w)}if(p&&e.disposeData(c.dataId),s){let w=W.expandShapeToKeepDim(b.shape,h);b.shape=w}return b}var vJe={kernelName:_m,backendName:"wasm",setupFunc:gJe,kernelFunc:yJe},xJe=t=>{let{backend:e,attrs:n}=t,{start:r,stop:i,step:s,dtype:a}=n,o=HB(r,i,s,a),l=e.makeOutput([o.length],a);return e.typedArrayFromHeap(l).set(o),l},bJe={kernelName:fw,backendName:"wasm",kernelFunc:xJe},wJe=_i(jf),_Je=Jn(Sm),SJe=Jn(Am),AJe=Jn(Tm),Hte;function EJe(t){Hte=t.wasm.cwrap(Im,null,["number","number","number","number","number","number","number","number","number","number"])}function IJe(t){let{backend:e,inputs:n,attrs:r}=t,{images:i}=n,{alignCorners:s,halfPixelCenters:a,size:o}=r,[l,u]=o,[c,d,h,p]=i.shape,f=[c,l,u,p],g=e.dataIdMap.get(i.dataId),y;g.dtype!=="float32"&&(y=ph({backend:e,inputs:{x:i},attrs:{dtype:"float32"}}),g=e.dataIdMap.get(y.dataId));let m=g.id,b=e.makeOutput(f,"float32");if(P.sizeFromShape(i.shape)===0)return b;let w=e.dataIdMap.get(b.dataId).id;return Hte(m,c,d,h,p,l,u,s?1:0,a?1:0,w),y!=null&&e.disposeData(y.dataId),b}var TJe={kernelName:Im,backendName:"wasm",setupFunc:EJe,kernelFunc:IJe},Wte;function CJe(t){Wte=t.wasm.cwrap(sv,null,["number","number","number","array","array","boolean"])}function MJe(t){let{inputs:e,backend:n,attrs:r}=t,{images:i,dy:s}=e,{alignCorners:a}=r,o=n.makeOutput(i.shape,"float32"),l=n.dataIdMap.get(i.dataId),u;return l.dtype!=="float32"&&(u=ph({backend:n,inputs:{x:i},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(u.dataId)),Wte(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(i.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),a),u!=null&&n.disposeData(u.dataId),o}var kJe={kernelName:sv,backendName:"wasm",setupFunc:CJe,kernelFunc:MJe},Vte;function NJe(t){Vte=t.wasm.cwrap(Em,null,["number","number","number","number","number","number","number","number","number","number"])}function RJe(t){let{backend:e,inputs:n,attrs:r}=t,{images:i}=n,{alignCorners:s,halfPixelCenters:a,size:o}=r,[l,u]=o,[c,d,h,p]=i.shape,f=[c,l,u,p],g=e.makeOutput(f,"float32");if(P.sizeFromShape(i.shape)===0)return g;let y=e.dataIdMap.get(i.dataId),m;y.dtype!=="float32"&&(m=ph({backend:e,inputs:{x:i},attrs:{dtype:"float32"}}),y=e.dataIdMap.get(m.dataId));let b=y.id,w=e.dataIdMap.get(g.dataId).id;return Vte(b,c,d,h,p,l,u,s?1:0,a?1:0,w),m!=null&&e.disposeData(m.dataId),g}var FJe={kernelName:Em,backendName:"wasm",setupFunc:NJe,kernelFunc:RJe},jte;function DJe(t){jte=t.wasm.cwrap(iv,null,["number","number","number","array","array","boolean"])}function PJe(t){let{inputs:e,backend:n,attrs:r}=t,{images:i,dy:s}=e,{alignCorners:a}=r,o=n.makeOutput(i.shape,"float32"),l=n.dataIdMap.get(i.dataId),u;return l.dtype!=="float32"&&(u=ph({backend:n,inputs:{x:i},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(u.dataId)),jte(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(i.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),a),u!=null&&n.disposeData(u.dataId),o}var LJe={kernelName:iv,backendName:"wasm",setupFunc:DJe,kernelFunc:PJe},Xte;function OJe(t){Xte=t.wasm.cwrap(Cm,null,["number","array","number","array","number","number"])}function BJe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{dims:s}=r,a=P.parseAxisParam(s,i.shape);if(i.shape.length===0)return TM({inputs:{x:i},backend:n});let o=n.makeOutput(i.shape,i.dtype),l=n.dataIdMap.get(i.dataId).id,u=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(a).buffer),d=new Uint8Array(new Int32Array(i.shape).buffer);Xte(l,c,a.length,d,i.shape.length,u);let h=oa({inputs:{x:o},attrs:{shape:i.shape},backend:n});return n.disposeData(o.dataId),h}var UJe={kernelName:Cm,backendName:"wasm",kernelFunc:BJe,setupFunc:OJe},Kte;function $Je(t){Kte=t.wasm.cwrap(bv,null,["number","number","number","number","number","number","number","number","array","number","number"])}function zJe(t){let{inputs:e,backend:n,attrs:r}=t,{image:i}=e,{radians:s,fillValue:a,center:o}=r,l=n.makeOutput(i.shape,i.dtype),u=n.dataIdMap.get(i.dataId).id,c=n.dataIdMap.get(l.dataId).id,[d,h,p,f]=i.shape,[g,y]=W.getImageCenter(o,h,p),m=a===0,b=255,w=typeof a=="number"?[a,a,a,m?0:b]:[...a,b],_=new Uint8Array(new Int32Array(w).buffer);return Kte(u,d,h,p,f,s,g,y,_,w.length,c),l}var GJe={kernelName:bv,backendName:"wasm",kernelFunc:zJe,setupFunc:$Je},HJe=Jn(Mm),WJe=Jn(km),qte;function VJe(t){qte=t.wasm.cwrap(av,null,["number","number","number","number","number","number","array","number","number"])}function jJe(t){let{backend:e,inputs:n,attrs:r}=t,{indices:i,updates:s}=n,{shape:a}=r,o=e.makeOutput(a,s.dtype);if(P.sizeFromShape(a)===0)return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=HC.calculateShapes(s,i,a),p=e.dataIdMap.get(i.dataId).id,f=e.dataIdMap.get(s.dataId).id,g=new Uint8Array(new Int32Array(d).buffer),y=e.dataIdMap.get(o.dataId).id;return qte(p,f,nr[s.dtype],l,u,c,g,h,y),o}var XJe={kernelName:av,backendName:"wasm",setupFunc:VJe,kernelFunc:jJe},Jte;function KJe(t){Jte=t.wasm.cwrap(lv,null,["number","number","number","number","number","number","bool","number"])}function qJe(t){let{inputs:e,backend:n,attrs:r}=t,{sortedSequence:i,values:s}=e,{side:a}=r;if(i.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${i.dtype} and ${s.dtype}`);let o=n.makeOutput(s.shape,"int32");function l(u){return n.dataIdMap.get(u.dataId).id}return Jte(l(i),l(s),i.shape[0],i.shape[1],s.shape[1],nr[i.dtype],a==="left",l(o)),o}var JJe={kernelName:lv,backendName:"wasm",setupFunc:KJe,kernelFunc:qJe},Yte;function YJe(t){Yte=t.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function ZJe(t){let{inputs:e,backend:n}=t,{condition:r,t:i,e:s}=e,a=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(i.dataId).id,l=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(i.shape,i.dtype),c=n.dataIdMap.get(u.dataId).id,d=r.shape.length,h=i.shape.length,p=d===0||d>1||h===1?1:P.sizeFromShape(i.shape.slice(1));return Yte(a,o,l,p,c),u}var QJe={kernelName:uv,backendName:"wasm",kernelFunc:ZJe,setupFunc:YJe},eYe=Jn(Nm),Zte;function tYe(t){Zte=t.wasm.cwrap(Pm,null,["number","number"])}function nYe(t){let{backend:e,inputs:{x:n}}=t,r=e.dataIdMap.get(n.dataId).id,i=e.makeOutput(n.shape,n.dtype),s=e.dataIdMap.get(i.dataId).id;return P.sizeFromShape(i.shape)===0||Zte(r,s),i}var rYe={kernelName:"Sigmoid",backendName:"wasm",setupFunc:tYe,kernelFunc:nYe},iYe=Jn(Dm),sYe=Jn(Rm),aYe=Jn(Fm),oYe=Jn(Lm);function lYe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:s,paddings:a}=r,o=P.sizeFromShape(s),l=[[0,0]];l.push(...a);for(let y=1+s.length;y<i.shape.length;++y)l.push([0,0]);let u=$te.kernelFunc({inputs:{x:i},backend:n,attrs:{paddings:l,constantValue:0}}),c=W.getReshaped(u.shape,s,o,!1),d=W.getPermuted(c.length,s.length,!1),h=W.getReshapedPermuted(u.shape,s,o,!1),p=oa({inputs:{x:u},backend:n,attrs:{shape:c}}),f=Wd({inputs:{x:p},backend:n,attrs:{perm:d}}),g=oa({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeData(u.dataId),n.disposeData(p.dataId),n.disposeData(f.dataId),g}var uYe={kernelName:dv,backendName:"wasm",kernelFunc:lYe},Qte;function cYe(t){Qte=t.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function dYe(t){let{backend:e,inputs:n}=t,{indices:r,values:i,denseShape:s,defaultValue:a}=n,o=r.shape[0],l=r.shape[1],u=e.readSync(s.dataId)[0],c=[o+u,l],d=e.dataIdMap.get(r.dataId).id,h=e.dataIdMap.get(i.dataId).id,p=e.dataIdMap.get(a.dataId).id,f=e.makeOutput(c,r.dtype),g=e.dataIdMap.get(f.dataId).id,y=e.makeOutput(c.slice(0,1),i.dtype),m=e.dataIdMap.get(y.dataId).id,b=e.makeOutput([u],"bool"),w=e.dataIdMap.get(b.dataId).id,_=e.makeOutput([o],r.dtype),S=e.dataIdMap.get(_.dataId).id,E=e.makeOutput([4],"int32"),C=e.dataIdMap.get(E.dataId).id,T=Qte(d,h,nr[i.dtype],o,u,l,p,g,m,w,S,C),M=e.readSync(E.dataId),k;switch(M[0]){case 1:{k=W.getSparseFillEmptyRowsIndicesDenseShapeMismatch(M[1]);break}case 2:{k=W.getSparseFillEmptyRowsNegativeIndexErrorMessage(M[1],M[2]);break}case 3:k=W.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(M[1],M[2],M[3]);break;default:k=""}if(e.disposeData(E.dataId),k)throw e.disposeData(f.dataId),e.disposeData(y.dataId),e.disposeData(b.dataId),e.disposeData(_.dataId),new Error(k);let R=f,N=y;return T!==c[0]&&(R=hf({inputs:{x:f},attrs:{begin:0,size:[T,l]},backend:e}),N=hf({inputs:{x:y},attrs:{begin:0,size:T},backend:e}),e.disposeData(f.dataId),e.disposeData(y.dataId)),[R,N,b,_]}var hYe={kernelName:mw,backendName:"wasm",setupFunc:cYe,kernelFunc:dYe},ene;function pYe(t){ene=t.wasm.cwrap(pv,null,["number","number","number","number","number","number","number"])}function fYe(t){let{backend:e,inputs:n}=t,{inputIndices:r,inputShape:i,newShape:s}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=e.dataIdMap.get(r.dataId).id,o=e.dataIdMap.get(i.dataId).id,l=e.dataIdMap.get(s.dataId).id,u=r.shape[0],c=P.sizeFromShape(s.shape),d=e.makeOutput([u,c],r.dtype),h=e.dataIdMap.get(d.dataId).id,p=e.makeOutput([c],s.dtype),f=e.dataIdMap.get(p.dataId).id,g=e.makeOutput([3],"int32"),y=e.dataIdMap.get(g.dataId).id;ene(a,o,l,u,h,f,y);let m=e.readSync(g.dataId),b;switch(m[0]){case 0:{b=W.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(m[1],m[2]);break}case 1:{b=W.getSparseReshapeNegativeOutputDimErrorMessage(m[1],m[2]);break}case 2:b=W.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let w=Array.from(e.readSync(i.dataId)),_=Array.from(e.readSync(p.dataId));b=W.getSparseReshapeInputOutputMultipleErrorMessage(w,_);break}case 4:{let w=Array.from(e.readSync(i.dataId)),_=Array.from(e.readSync(p.dataId));b=W.getSparseReshapeInputOutputMismatchErrorMessage(w,_);break}default:b=""}if(e.disposeData(g.dataId),b)throw e.disposeData(d.dataId),e.disposeData(p.dataId),new Error(b);return[d,p]}var mYe={kernelName:pv,backendName:"wasm",setupFunc:pYe,kernelFunc:fYe},tne;function nne(t){tne=t.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function rne(t,e){let{backend:n,inputs:r}=t,{data:i,indices:s,segmentIds:a}=r,o=s.shape[0],l=n.readSync(a.dataId,o-1,o)[0],u=o>0?l+1:0;if(u<0)throw new Error(W.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=i.shape.slice();c[0]=u;let d=n.dataIdMap.get(i.dataId).id,h=n.dataIdMap.get(s.dataId).id,p=n.dataIdMap.get(a.dataId).id,f=n.makeOutput(c,i.dtype),g=n.dataIdMap.get(f.dataId).id,y=n.makeOutput([4],"int32"),m=n.dataIdMap.get(y.dataId).id;tne(d,nr[i.dtype],i.shape[0],h,p,g,m,e,0);let b=n.readSync(y.dataId),w;switch(b[0]){case 0:{w=W.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{w=W.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:w=W.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b[1],b[2]);break;case 3:w=W.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(b[1],b[2],b[3]);break;default:w=""}if(n.disposeData(y.dataId),w)throw n.disposeData(f.dataId),new Error(w);return f}function gYe(t){return rne(t,!0)}var yYe={kernelName:gw,backendName:"wasm",setupFunc:nne,kernelFunc:gYe};function vYe(t){return rne(t,!1)}var xYe={kernelName:yw,backendName:"wasm",setupFunc:nne,kernelFunc:vYe},ine;function bYe(t){ine=t.wasm.cwrap(fv,null,["number","number","number","number","number","number","number","number","array","number","number"])}function wYe(t){let{backend:e,inputs:n,attrs:r}=t,{sparseIndices:i,sparseValues:s,defaultValue:a}=n,{outputShape:o}=r,l=e.makeOutput(o,a.dtype);if(P.sizeFromShape(o)===0)return l;let{sliceRank:u,numUpdates:c,sliceSize:d,strides:h,outputSize:p}=W.calculateShapes(s,i,o),f=e.dataIdMap.get(i.dataId).id,g=e.dataIdMap.get(s.dataId).id,y=e.dataIdMap.get(a.dataId).id,m=new Uint8Array(new Int32Array(h).buffer),b=e.dataIdMap.get(l.dataId).id;return ine(f,g,s.shape.length,y,nr[a.dtype],u,c,d,m,p,b),l}var _Ye={kernelName:fv,backendName:"wasm",setupFunc:bYe,kernelFunc:wYe};function SYe(t){let{inputs:e,attrs:n,backend:r}=t,{x:i}=e,{numOrSizeSplits:s,axis:a}=n,o=P.parseAxisParam(a,i.shape)[0],l=W.prepareSplitSize(i,s,o),u=new Array(i.shape.length).fill(0),c=i.shape.slice();return l.map(d=>{let h=[...c];h[o]=d;let p=hf({inputs:{x:i},attrs:{begin:u,size:h},backend:r});return u[o]+=d,p})}var AYe={kernelName:hv,backendName:"wasm",kernelFunc:SYe},EYe=Jn(Om),IYe=Jn(vw),TYe=_i($m),sne;function CYe(t){sne=t.wasm.cwrap(ih,null,["number","number","number","number"])}function MYe(t){let{backend:e,inputs:n,attrs:r}=t,{alpha:i}=r,{x:s}=n,a=e.dataIdMap.get(s.dataId).id,o=e.makeOutput(s.shape,s.dtype),l=e.dataIdMap.get(o.dataId).id;return sne(a,i,nr[s.dtype],l),o}var kYe={kernelName:ih,backendName:"wasm",setupFunc:CYe,kernelFunc:MYe},ane;function NYe(t){ane=t.wasm.cwrap(mv,null,["number","array","number","array","array","array","array","array","number","number"])}function RYe(t){let{backend:e,inputs:n,attrs:r}=t,{x:i}=n,{begin:s,end:a,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:y,isSimpleSlice:m,begin:b,end:w,strides:_}=Ni.sliceInfo(i.shape,s,a,o,l,u,c,d,h),S;if(g)S=oa({inputs:{x:i},backend:e,attrs:{shape:f}});else if(y||m){P.assert(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);let E=Ni.computeOutShape(b,w,_),C=hf({inputs:{x:i},backend:e,attrs:{begin:b,size:E}});S=oa({inputs:{x:C},backend:e,attrs:{shape:f}}),e.disposeData(C.dataId)}else{let E=e.makeOutput(p,"float32"),C=e.dataIdMap.get(i.dataId).id,T=new Uint8Array(new Int32Array(P.computeStrides(i.shape)).buffer),M=new Uint8Array(new Int32Array(b).buffer),k=new Uint8Array(new Int32Array(w).buffer),R=new Uint8Array(new Int32Array(_).buffer),N=new Uint8Array(new Int32Array(p).buffer),B=new Uint8Array(new Int32Array(P.computeStrides(p)).buffer),z=e.dataIdMap.get(E.dataId).id;ane(C,T,i.shape.length,M,k,R,N,B,p.length,z),S=oa({inputs:{x:E},backend:e,attrs:{shape:f}}),e.disposeData(E.dataId)}return S}var FYe={kernelName:mv,backendName:"wasm",setupFunc:NYe,kernelFunc:RYe};function DYe(t){let{backend:e,inputs:n,attrs:r}=t,{data:i,dataSplits:s}=n,{separator:a,nGramWidths:o,leftPad:l,rightPad:u,padWidth:c,preserveShortSequences:d}=r,h=e.readSync(i.dataId),p=e.readSync(s.dataId),[f,g]=VB(h,p,a,o,l,u,c,d),y=e.makeOutput([f.length],"string"),m=e.dataIdMap.get(y.dataId);m.stringBytes=f;let b=e.makeOutput(s.shape,"int32");return e.typedArrayFromHeap(b).set(g),[y,b]}var PYe={kernelName:bw,backendName:"wasm",kernelFunc:DYe};function LYe(t){let{backend:e,inputs:n,attrs:r}=t,{input:i,delimiter:s}=n,{skipEmpty:a}=r,o=e.readSync(i.dataId),l=e.readSync(s.dataId),[u,c,d]=jB(o,l[0],a),h=c.length,p=e.makeOutput([h,2],"int32");e.typedArrayFromHeap(p).set(u);let f=e.makeOutput([h],"string"),g=e.dataIdMap.get(f.dataId);g.stringBytes=c;let y=e.makeOutput([2],"int32");return e.typedArrayFromHeap(y).set(d),[p,f,y]}var OYe={kernelName:ww,backendName:"wasm",kernelFunc:LYe};function BYe(t){let{backend:e,inputs:n,attrs:r}=t,{input:i}=n,{numBuckets:s}=r,a=e.readSync(i.dataId),o=XB(a,s),l=e.makeOutput(i.shape,"int32");return e.typedArrayFromHeap(l).set(o),l}var UYe={kernelName:_w,backendName:"wasm",kernelFunc:BYe},$Ye=_i(zm),one;function zYe(t){one=t.wasm.cwrap(Bm,null,["number","number","number","number"])}function GYe(t){let{backend:e,inputs:n,attrs:r}=t,{axis:i,keepDims:s}=r,{x:a}=n,o=e.dataIdMap.get(a.dataId).id,l=o,u=a,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=hh(a,i,e),f=d;if(p){let w=e.dataIdMap.get(c.dataId).id;w!==o&&(u=c,l=w,f=W.getInnerMostAxes(f.length,u.shape.length))}W.assertAxesAreInnerMostDims("sum",f,u.shape.length);let[g,y]=W.computeOutAndReduceShapes(u.shape,f),m=P.sizeFromShape(y),b=e.makeOutput(g,u.dtype);if(P.sizeFromShape(u.shape)!==0){let w=e.dataIdMap.get(b.dataId).id;one(l,m,nr[b.dtype],w)}if(p&&e.disposeData(c.dataId),s){let w=W.expandShapeToKeepDim(b.shape,h);b.shape=w}return b}var HYe={kernelName:Bm,backendName:"wasm",setupFunc:zYe,kernelFunc:GYe},WYe=Jn(Gm),VYe=Jn(Hm),lne;function jYe(t){lne=t.wasm.cwrap(ov,null,["number","number","number","number","number","number","array","number","number","number"])}function XYe(t){let{backend:e,inputs:n,attrs:r}=t,{tensor:i,indices:s,updates:a}=n,o=e.makeOutput(i.shape,i.dtype);if(P.sizeFromShape(i.shape)===0)return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=HC.calculateShapes(a,s,i.shape),p=e.dataIdMap.get(s.dataId).id,f=e.dataIdMap.get(a.dataId).id,g=e.dataIdMap.get(i.dataId).id,y=new Uint8Array(new Int32Array(d).buffer),m=e.dataIdMap.get(o.dataId).id;return lne(p,f,nr[a.dtype],l,u,c,y,h,m,g),o}var KYe={kernelName:ov,backendName:"wasm",setupFunc:jYe,kernelFunc:XYe},une;function qYe(t){une=t.wasm.cwrap(rh,null,["number","array","number","array","number","number"])}function JYe(t){let{inputs:e,backend:n,attrs:r}=t,{x:i}=e,s=n.dataIdMap.get(i.dataId).id,{reps:a}=r,o=new Array(i.shape.length);for(let h=0;h<o.length;h++)o[h]=i.shape[h]*a[h];let l=new Uint8Array(new Int32Array(i.shape).buffer),u=new Uint8Array(new Int32Array(o).buffer),c=n.makeOutput(o,i.dtype),d=n.dataIdMap.get(c.dataId).id;return une(s,l,i.shape.length,u,o.length,nr[c.dtype],d),c}var YYe={kernelName:rh,backendName:"wasm",setupFunc:qYe,kernelFunc:JYe},cne;function ZYe(t){cne=t.wasm.cwrap(gv,null,["number","array","number","number","number","bool","number","number"])}var QYe=({inputs:t,backend:e,attrs:n})=>{let{x:r}=t,{k:i,sorted:s}=n,a=e.dataIdMap.get(r.dataId).id,o=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=i;let u=e.makeOutput(l,r.dtype),c=e.dataIdMap.get(u.dataId).id,d=e.makeOutput(l,"int32"),h=e.dataIdMap.get(d.dataId).id;return cne(a,o,r.shape.length,nr[r.dtype],i,s,c,h),[u,d]},eZe={kernelName:gv,backendName:"wasm",setupFunc:ZYe,kernelFunc:QYe},dne;function tZe(t){dne=t.wasm.cwrap(yv,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function nZe(t){let{backend:e,inputs:n,attrs:r}=t,{image:i,transforms:s}=n,{interpolation:a,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=i.shape,[f,g]=u??[d,h],y=[c,f,g,p],m=new Uint8Array(new Int32Array(P.computeStrides(i.shape)).buffer),b=new Uint8Array(new Int32Array(P.computeStrides(y)).buffer),w=e.makeOutput(y,i.dtype),_=e.dataIdMap.get(w.dataId).id,S=e.dataIdMap.get(i.dataId).id,E=e.dataIdMap.get(s.dataId).id,C=a==="nearest"?1:2,T;switch(o){case"constant":T=1;break;case"reflect":T=2;break;case"wrap":T=3;break;case"nearest":T=4;break;default:T=1;break}return dne(S,E,s.shape[0]>1,c,f,g,p,h,d,m,i.shape.length-1,b,y.length-1,C,T,l,_),w}var rZe={kernelName:yv,backendName:"wasm",setupFunc:tZe,kernelFunc:nZe};function iZe(t){let{inputs:e,attrs:n,backend:r}=t,{axis:i}=n,{x:s}=e,{outputValues:a,outputShape:o,indices:l}=qB(r.readSync(s.dataId),i,s.shape,s.dtype);return[r.makeOutput(o,s.dtype,void 0,a),r.makeOutput([l.length],"int32",void 0,l)]}var sZe={kernelName:Sw,backendName:"wasm",kernelFunc:iZe};function aZe(t){let{inputs:e,backend:n,attrs:r}=t,{value:i}=e,{axis:s}=r;s<0&&(s+=i.shape.length);let a=i.shape[s],o=i.shape.length,l=new Array(o-1),u=0;for(let p=0;p<o;p++)p!==s&&(l[u++]=i.shape[p]);let c=new Array(a),d=new Array(o).fill(0),h=i.shape.slice();h[s]=1;for(let p=0;p<c.length;p++)d[s]=p,c[p]=hf({inputs:{x:i},attrs:{begin:d,size:h},backend:n});return c.map(({dataId:p,dtype:f})=>({dataId:p,dtype:f,shape:l}))}var oZe={kernelName:vv,backendName:"wasm",kernelFunc:aZe};function lZe(t){let{inputs:{x:e},backend:n}=t,r=n.makeOutput(e.shape,e.dtype);return n.typedArrayFromHeap(r).fill(0),r}var uZe={kernelName:xv,backendName:"wasm",kernelFunc:lZe},cZe=[tXe,nXe,rXe,iXe,sXe,lXe,gXe,xXe,bXe,wXe,_Xe,SXe,AXe,EXe,IXe,MXe,BXe,RXe,PXe,GXe,KXe,YXe,ZXe,e7e,t7e,n7e,s7e,a7e,u7e,h7e,m7e,v7e,w7e,_7e,S7e,I7e,M7e,R7e,P7e,B7e,z7e,W7e,X7e,J7e,Q7e,eKe,rKe,sKe,aKe,oKe,lKe,uKe,cKe,pKe,fKe,mKe,vKe,wKe,AKe,TKe,kKe,RKe,DKe,uXe,PKe,LKe,OKe,$Ke,GKe,WKe,XKe,qKe,KKe,YKe,ZKe,eqe,nqe,sqe,lqe,dqe,hqe,mqe,vqe,wqe,Aqe,Tqe,kqe,Fqe,Dqe,Oqe,Gqe,Hqe,Wqe,Vqe,Kqe,Yqe,eJe,nJe,sJe,oJe,uJe,$te,hJe,mJe,vJe,bJe,wJe,_Je,SJe,AJe,UXe,TJe,kJe,FJe,LJe,UJe,GJe,HJe,WJe,XJe,JJe,QJe,eYe,rYe,iYe,sYe,aYe,jXe,Uqe,oYe,uYe,hYe,mYe,yYe,xYe,_Ye,AYe,EYe,IYe,TYe,kYe,FYe,PYe,OYe,UYe,$Ye,HYe,WYe,VYe,KYe,YYe,eZe,rZe,pXe,sZe,oZe,uZe];for(let t of cZe)Ew(t);var aD=Ie();aD.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});aD.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(aD.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var _5=eh(Vxe()),dZe=eh(jxe()),S5=eh(Xxe()),A5=_5.default||_5,hZe=S5.default||S5,hne=class extends nw{constructor(t){super(),this.wasm=t,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(pne),oD=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new tC(this,No())}write(t,e,n){let r={id:this.dataIdNextNumber++};return this.move(r,t,e,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(t){let e=P.now();return t(),{kernelMs:P.now()-e}}move(t,e,n,r,i){let s=this.dataIdNextNumber++;if(r==="string"){let u=e;this.dataIdMap.set(t,{id:s,stringBytes:u,shape:n,dtype:r,memoryOffset:null,refCount:i});return}let a=P.sizeFromShape(n),o=a*P.bytesPerElement(r),l=this.wasm._malloc(o)>>>0;this.dataIdMap.set(t,{id:s,memoryOffset:l,shape:n,dtype:r,refCount:i}),this.wasm.tfjs.registerTensor(s,a,l),e!=null&&this.wasm.HEAPU8.set(new Uint8Array(e.buffer,e.byteOffset,o),l)}async read(t){return this.readSync(t)}readSync(t,e,n){let{memoryOffset:r,dtype:i,shape:s,stringBytes:a}=this.dataIdMap.get(t);if(i==="string")return(e==null||e===0)&&(n==null||n>=a.length)?a:a.slice(e,n);e=e||0,n=n||P.sizeFromShape(s);let o=P.bytesPerElement(i),l=this.wasm.HEAPU8.slice(r+e*o,r+n*o);return mZe(l.buffer,i)}disposeData(t,e=!1){if(this.dataIdMap.has(t)){let n=this.dataIdMap.get(t);if(n.refCount--,!e&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(t)}return!0}refCount(t){return this.dataIdMap.has(t)?this.dataIdMap.get(t).refCount:0}incRef(t){let e=this.dataIdMap.get(t);e!=null&&e.refCount++}floatPrecision(){return 32}getMemoryOffset(t){return this.dataIdMap.get(t).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(t,e,n,r){let i;if(n==null)i=this.write(r??null,t,e);else{let s=this.dataIdNextNumber++;i={id:s},this.dataIdMap.set(i,{id:s,memoryOffset:n,shape:t,dtype:e,refCount:1});let a=P.sizeFromShape(t);this.wasm.tfjs.registerTensor(s,a,n)}return{dataId:i,shape:t,dtype:e}}typedArrayFromHeap({shape:t,dtype:e,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:i}=this.dataIdMap.get(n),s=P.sizeFromShape(t);switch(e){case"float32":return new Float32Array(r,i,s);case"int32":return new Int32Array(r,i,s);case"bool":return new Uint8Array(r,i,s);default:throw new Error(`Unknown dtype ${e}`)}}};function pZe(t){return(e,n)=>(P.fetch(t,{credentials:"same-origin"}).then(r=>{r.ok||e.env.a(`failed to load wasm binary file at '${t}'`),r.arrayBuffer().then(i=>{WebAssembly.instantiate(i,e).then(s=>{n(s.instance,s.module)})})}),{})}function E5(t,e,n){if(ZI!=null)return ZI;let r="tfjs-backend-wasm.wasm";return t&&e?r="tfjs-backend-wasm-threaded-simd.wasm":t&&(r="tfjs-backend-wasm-simd.wasm"),Nb!=null&&Nb[r]!=null?Nb[r]:n+r}async function fZe(){let[t,e]=await Promise.all([Ie().getAsync("WASM_HAS_SIMD_SUPPORT"),Ie().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,r)=>{let i={};i.locateFile=(o,l)=>{if(o.endsWith(".worker.js")){let u=dZe.wasmWorkerContents.replace(/\n/g,"\\n"),c=new Blob([u],{type:"application/javascript"});return URL.createObjectURL(c)}return o.endsWith(".wasm")?E5(t,e,lb??l):l+o},gU&&(i.instantiateWasm=pZe(E5(t,e,lb??"")));let s=!1;i.onAbort=()=>{s||Rb||(Rb=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))};let a;e&&t&&ZI==null?(i.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+A5.toString()],{type:"text/javascript"}),a=A5(i)):a=hZe(i),a.then(o=>{s=!0,Rb=!1;let l=null;o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",l,["number"]),dispose:o.cwrap("dispose",l,[])},n({wasm:o})}).catch(r)})}function mZe(t,e){switch(e){case"float32":return new Float32Array(t);case"int32":return new Int32Array(t);case"bool":return new Uint8Array(t);default:throw new Error(`Unknown dtype ${e}`)}}var gZe=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],ZI=null,lb=null,Nb={},Rb=!1,gU=!1;function yZe(t,e=!1){if(D7("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Rb)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");ZI=t,gU=e}function vZe(t,e=!1){if(Rb)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof t=="string")lb=t;else{Nb=t;let n=gZe.filter(r=>Nb[r]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}gU=e}var pne=-1,oD=-1;function xZe(t){pne=t}function bZe(){if(oD===-1)throw new Error("WASM backend not initialized.");return oD}var wZe="4.22.0",_Ze=2;xC("wasm",async()=>{let{wasm:t}=await fZe();return new hne(t)},_Ze);var I5="4.22.0",SZe="4.22.0",AZe="4.22.0",EZe="4.22.0",IZe="4.22.0",TZe={tfjs:I5,"tfjs-core":I5,"tfjs-converter":SZe,"tfjs-backend-cpu":AZe,"tfjs-backend-webgl":EZe,"tfjs-backend-wasm":IZe},CZe={};A3(CZe,{AnchorPosition:()=>Mne,DrawBox:()=>Rne,DrawBoxOptions:()=>Nne,DrawFaceLandmarks:()=>qne,DrawFaceLandmarksOptions:()=>Kne,DrawTextField:()=>SU,DrawTextFieldOptions:()=>_U,drawContour:()=>Kc,drawDetections:()=>zZe,drawFaceExpressions:()=>eQe,drawFaceLandmarks:()=>nQe});function Kc(t,e,n=!1){if(t.beginPath(),e.slice(1).forEach(({x:r,y:i},s)=>{let a=e[s];t.moveTo(a.x,a.y),t.lineTo(r,i)}),n){let r=e[e.length-1],i=e[0];if(!r||!i)return;t.moveTo(r.x,r.y),t.lineTo(i.x,i.y)}t.stroke()}var MZe={};A3(MZe,{computeReshapedDimensions:()=>yne,getCenterPoint:()=>vU,isDimensions:()=>uD,isEven:()=>lD,isFloat:()=>gne,isTensor:()=>zv,isTensor1D:()=>kZe,isTensor2D:()=>mne,isTensor3D:()=>i_,isTensor4D:()=>tc,isValidNumber:()=>Rp,isValidProbablitiy:()=>NZe,range:()=>l0,round:()=>yU});var Ey=class fne{constructor(e,n){if(!Rp(e)||!Rp(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:e,height:n})}`);this._width=e,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new fne(1/this.width,1/this.height)}};function zv(t,e){return t instanceof In&&t.shape.length===e}function kZe(t){return zv(t,1)}function mne(t){return zv(t,2)}function i_(t){return zv(t,3)}function tc(t){return zv(t,4)}function gne(t){return t%1!==0}function lD(t){return t%2===0}function yU(t,e=2){let n=10**e;return Math.floor(t*n)/n}function uD(t){return t&&t.width&&t.height}function yne({width:t,height:e},n){let r=n/Math.max(e,t);return new Ey(Math.round(t*r),Math.round(e*r))}function vU(t){return t.reduce((e,n)=>e.add(n),new vr(0,0)).div(new vr(t.length,t.length))}function l0(t,e,n){return Array(t).fill(0).map((r,i)=>e+i*n)}function Rp(t){return!!t&&t!==1/0&&t!==-1/0&&!Number.isNaN(t)||t===0}function NZe(t){return Rp(t)&&t>=0&&t<=1}var vr=class ep{constructor(e,n){this._x=e,this._y=n}get x(){return this._x}get y(){return this._y}add(e){return new ep(this.x+e.x,this.y+e.y)}sub(e){return new ep(this.x-e.x,this.y-e.y)}mul(e){return new ep(this.x*e.x,this.y*e.y)}div(e){return new ep(this.x/e.x,this.y/e.y)}abs(){return new ep(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new ep(Math.floor(this.x),Math.floor(this.y))}},pf=class ol{static isRect(e){return!!e&&[e.x,e.y,e.width,e.height].every(Rp)}static assertIsValidBox(e,n,r=!1){if(!ol.isRect(e))throw new Error(`${n} - invalid box: ${JSON.stringify(e)}, expected object with properties x, y, width, height`);if(!r&&(e.width<0||e.height<0))throw new Error(`${n} - width (${e.width}) and height (${e.height}) must be positive numbers`)}constructor(e,n=!0){let r=e||{},i=[r.left,r.top,r.right,r.bottom].every(Rp),s=[r.x,r.y,r.width,r.height].every(Rp);if(!s&&!i)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(r)}`);let[a,o,l,u]=s?[r.x,r.y,r.width,r.height]:[r.left,r.top,r.right-r.left,r.bottom-r.top];ol.assertIsValidBox({x:a,y:o,width:l,height:u},"Box.constructor",n),this._x=a,this._y=o,this._width=l,this._height=u}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new vr(this.left,this.top)}get topRight(){return new vr(this.right,this.top)}get bottomLeft(){return new vr(this.left,this.bottom)}get bottomRight(){return new vr(this.right,this.bottom)}round(){let[e,n,r,i]=[this.x,this.y,this.width,this.height].map(s=>Math.round(s));return new ol({x:e,y:n,width:r,height:i})}floor(){let[e,n,r,i]=[this.x,this.y,this.width,this.height].map(s=>Math.floor(s));return new ol({x:e,y:n,width:r,height:i})}toSquare(){let{x:e,y:n,width:r,height:i}=this,s=Math.abs(r-i);return r<i&&(e-=s/2,r+=s),i<r&&(n-=s/2,i+=s),new ol({x:e,y:n,width:r,height:i})}rescale(e){let n=uD(e)?e.width:e,r=uD(e)?e.height:e;return new ol({x:this.x*n,y:this.y*r,width:this.width*n,height:this.height*r})}pad(e,n){let[r,i,s,a]=[this.x-e/2,this.y-n/2,this.width+e,this.height+n];return new ol({x:r,y:i,width:s,height:a})}clipAtImageBorders(e,n){let{x:r,y:i,right:s,bottom:a}=this,o=Math.max(r,0),l=Math.max(i,0),u=s-o,c=a-l,d=Math.min(u,e-o),h=Math.min(c,n-l);return new ol({x:o,y:l,width:d,height:h}).floor()}shift(e,n){let{width:r,height:i}=this,s=this.x+e,a=this.y+n;return new ol({x:s,y:a,width:r,height:i})}padAtBorders(e,n){let r=this.width+1,i=this.height+1,s=1,a=1,o=r,l=i,u=this.left,c=this.top,d=this.right,h=this.bottom;return d>n&&(o=-d+n+r,d=n),h>e&&(l=-h+e+i,h=e),u<1&&(l=2-u,u=1),c<1&&(l=2-c,c=1),{dy:a,edy:l,dx:s,edx:o,y:c,ey:h,x:u,ex:d,w:r,h:i}}calibrate(e){return new ol({left:this.left+e.left*this.width,top:this.top+e.top*this.height,right:this.right+e.right*this.width,bottom:this.bottom+e.bottom*this.height}).toSquare().round()}},vne=class extends pf{constructor(t,e,n,r,i=!1){super({left:t,top:e,right:n,bottom:r},i)}},xne=class bne{constructor(e,n,r,i,s){this._imageDims=new Ey(s.width,s.height),this._score=e,this._classScore=n,this._className=r,this._box=new pf(i).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new pf(this._box).rescale(this.imageDims.reverse())}forSize(e,n){return new bne(this.score,this.classScore,this.className,this.relativeBox,{width:e,height:n})}},Il=class wne extends xne{constructor(e,n,r){super(e,e,"",n,r)}forSize(e,n){let{score:r,relativeBox:i,imageDims:s}=super.forSize(e,n);return new wne(r,i,s)}};function RZe(t,e,n=!0){let r=Math.max(0,Math.min(t.right,e.right)-Math.max(t.left,e.left)),i=Math.max(0,Math.min(t.bottom,e.bottom)-Math.max(t.top,e.top)),s=r*i;return n?s/(t.area+e.area-s):s/Math.min(t.area,e.area)}function FZe(t){let e=t.map(o=>o.x),n=t.map(o=>o.y),r=e.reduce((o,l)=>l<o?l:o,1/0),i=n.reduce((o,l)=>l<o?l:o,1/0),s=e.reduce((o,l)=>o<l?l:o,0),a=n.reduce((o,l)=>o<l?l:o,0);return new vne(r,i,s,a)}function DZe(t,e,n,r=!0){let i=e.map((a,o)=>({score:a,boxIndex:o})).sort((a,o)=>a.score-o.score).map(a=>a.boxIndex),s=[];for(;i.length>0;){let a=i.pop();s.push(a);let o=i,l=[];for(let u=0;u<o.length;u++){let c=o[u],d=t[a],h=t[c];l.push(RZe(d,h,r))}i=i.filter((u,c)=>l[c]<=n)}return s}function s_(t,e){return xe(()=>{let[n,r,i]=e,s=Pa([...t.shape.slice(0,3),1],n,"float32"),a=Pa([...t.shape.slice(0,3),1],r,"float32"),o=Pa([...t.shape.slice(0,3),1],i,"float32"),l=wr([s,a,o],3);return Dt(t,l)})}function PZe(t,e=!1){return xe(()=>{let[n,r]=t.shape.slice(1);if(n===r)return t;let i=Math.abs(n-r),s=Math.round(i*(e?.5:1)),a=n>r?2:1,o=d=>{let h=t.shape.slice();return h[a]=d,Pa(h,0,"float32")},l=o(s),u=i-l.shape[a],c=[e&&u?o(u):null,t,l].filter(d=>!!d).map(d=>ft(d,"float32"));return wr(c,a)})}function FN(t){return 1/(1+Math.exp(-t))}var _ne=class extends pf{constructor(t,e,n,r,i=!1){super({x:t,y:e,width:n,height:r},i)}},LZe=.5,OZe=.43,BZe=.45,QI=class{constructor(t,e,n=new vr(0,0)){let{width:r,height:i}=e;this._imgDims=new Ey(r,i),this._shift=n,this._positions=t.map(s=>s.mul(new vr(r,i)).add(n))}get shift(){return new vr(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(t=>t.sub(this._shift).div(new vr(this.imageWidth,this.imageHeight)))}forSize(t,e){return new this.constructor(this.relativePositions,{width:t,height:e})}shiftBy(t,e){return new this.constructor(this.relativePositions,this._imgDims,new vr(t,e))}shiftByPoint(t){return this.shiftBy(t.x,t.y)}align(t,e={}){if(t){let i=t instanceof Il?t.box.floor():new pf(t);return this.shiftBy(i.x,i.y).align(null,e)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...e};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let t=this.getRefPointsForAlignment(),[e,n,r]=t,i=c=>r.sub(c).magnitude(),s=(i(e)+i(n))/2,a=Math.floor(s/BZe),o=vU(t),l=Math.floor(Math.max(0,o.x-LZe*a)),u=Math.floor(Math.max(0,o.y-OZe*a));return new _ne(l,u,Math.min(a,this.imageWidth+l),Math.min(a,this.imageHeight+u))}alignMinBbox(t){let e=FZe(this.positions);return e.pad(e.width*t,e.height*t)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},Sne=class extends QI{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(vU)}};function eT(t){return t.detection instanceof Il}function Ane(t,e){return{...t,detection:e}}function Ene(){let t=window.fetch;if(!t)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:t,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function xU(){return typeof global=="object"&&typeof process<"u"&&process.versions!=null&&process.versions.node!=null}function Ine(t){let e="";if(!t&&xU())try{t=Axe("fs")}catch(n){e=n.toString()}return{readFile:t?n=>new Promise((r,i)=>{t.readFile(n,(s,a)=>s?i(s):r(a))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${e}`)}}}function Tne(){let t=global.Canvas||global.HTMLCanvasElement,e=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,r=()=>{if(t)return new t;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},i=()=>{if(e)return new e;throw new Error("createImageElement - missing Image implementation for nodejs environment")},s=()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},a=global.fetch,o=Ine();return{Canvas:t||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:e||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:r,createImageElement:i,createVideoElement:s,fetch:a,...o}}function Cne(){return typeof window=="object"&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}var Li;function UZe(){if(!Li)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return Li}function cD(t){Li=t}function bU(){return Cne()?cD(Ene()):xU()?cD(Tne()):null}function $Ze(t){if(Li||bU(),!Li)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:e=Li.Canvas,Image:n=Li.Image}=t;Li.Canvas=e,Li.Image=n,Li.createCanvasElement=t.createCanvasElement||(()=>new e),Li.createImageElement=t.createImageElement||(()=>new n),Li.ImageData=t.ImageData||Li.ImageData,Li.Video=t.Video||Li.Video,Li.fetch=t.fetch||Li.fetch,Li.readFile=t.readFile||Li.readFile}var pa={getEnv:UZe,setEnv:cD,initialize:bU,createBrowserEnv:Ene,createFileSystem:Ine,createNodejsEnv:Tne,monkeyPatch:$Ze,isBrowser:Cne,isNodejs:xU};bU();function wU(t){return!pa.isNodejs()&&typeof t=="string"?document.getElementById(t):t}function Vd(t){let{Canvas:e,CanvasRenderingContext2D:n}=pa.getEnv();if(t instanceof n)return t;let r=wU(t);if(!(r instanceof e))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let i=r.getContext("2d",{willReadFrequently:!0});if(!i)throw new Error("resolveContext2d - canvas 2d context is null");return i}var Mne=(t=>(t.TOP_LEFT="TOP_LEFT",t.TOP_RIGHT="TOP_RIGHT",t.BOTTOM_LEFT="BOTTOM_LEFT",t.BOTTOM_RIGHT="BOTTOM_RIGHT",t))(Mne||{}),_U=class{constructor(t={}){let{anchorPosition:e,backgroundColor:n,fontColor:r,fontSize:i,fontStyle:s,padding:a}=t;this.anchorPosition=e||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=i||14,this.fontStyle=s||"Georgia",this.padding=a||4}},SU=class kne{constructor(e,n,r={}){this.text=typeof e=="string"?[e]:e instanceof kne?e.text:e,this.anchor=n,this.options=new _U(r)}measureWidth(e){let{padding:n}=this.options;return this.text.map(r=>e.measureText(r).width).reduce((r,i)=>r<i?i:r,0)+2*n}measureHeight(){let{fontSize:e,padding:n}=this.options;return this.text.length*e+2*n}getUpperLeft(e,n){let{anchorPosition:r}=this.options,i=r==="BOTTOM_RIGHT"||r==="TOP_RIGHT",s=r==="BOTTOM_LEFT"||r==="BOTTOM_RIGHT",a=this.measureWidth(e),o=this.measureHeight(),l=i?this.anchor.x-a:this.anchor.x,u=s?this.anchor.y-o:this.anchor.y;if(n){let{width:c,height:d}=n,h=Math.max(Math.min(l,c-a),0),p=Math.max(Math.min(u,d-o),0);return{x:h,y:p}}return{x:l,y:u}}draw(e){let n=wU(e),r=Vd(n),{backgroundColor:i,fontColor:s,fontSize:a,fontStyle:o,padding:l}=this.options;r.font=`${a}px ${o}`;let u=this.measureWidth(r),c=this.measureHeight();r.fillStyle=i;let d=this.getUpperLeft(r,n);r.fillRect(d.x,d.y,u,c),r.fillStyle=s,this.text.forEach((h,p)=>{let f=l+d.x,g=l+d.y+(p+1)*a;r.fillText(h,f,g)})}},Nne=class{constructor(t={}){let{boxColor:e,lineWidth:n,label:r,drawLabelOptions:i}=t;this.boxColor=e||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new _U({...s,...i})}},Rne=class{constructor(t,e={}){this.box=new pf(t),this.options=new Nne(e)}draw(t){let e=Vd(t),{boxColor:n,lineWidth:r}=this.options,{x:i,y:s,width:a,height:o}=this.box;e.strokeStyle=n,e.lineWidth=r,e.strokeRect(i,s,a,o);let{label:l}=this.options;l&&new SU([l],{x:i-r/2,y:s},this.options.drawLabelOptions).draw(t)}};function zZe(t,e){(Array.isArray(e)?e:[e]).forEach(n=>{let r=n instanceof Il?n.score:eT(n)?n.detection.score:void 0,i=n instanceof Il?n.box:eT(n)?n.detection.box:new pf(n),s=r?`${yU(r)}`:void 0;new Rne(i,{label:s}).draw(t)})}function Fne(t){let{Image:e,Video:n}=pa.getEnv();return t instanceof e&&t.complete||t instanceof n&&t.readyState>=3}function GZe(t){return new Promise((e,n)=>{if(t instanceof pa.getEnv().Canvas||Fne(t)){e(null);return}function r(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",i),s.currentTarget.removeEventListener("error",r),n(s))}function i(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",i),s.currentTarget.removeEventListener("error",r),e(s))}t.addEventListener("load",i),t.addEventListener("error",r)})}function Dne(t){let{Image:e,Video:n}=pa.getEnv();return t instanceof e?new Ey(t.naturalWidth,t.naturalHeight):t instanceof n?new Ey(t.videoWidth,t.videoHeight):new Ey(t.width,t.height)}function tT({width:t,height:e}){let{createCanvasElement:n}=pa.getEnv(),r=n();return r.width=t,r.height=e,r}function Pne(t,e){let{ImageData:n}=pa.getEnv();if(!(t instanceof n)&&!Fne(t))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:i}=Dne(t),s=tT({width:r,height:i});return t instanceof n?Vd(s).putImageData(t,0,0):Vd(s).drawImage(t,0,0,r,i),s}async function HZe(t,e){let n=e||pa.getEnv().createCanvasElement(),[r,i,s]=t.shape.slice(tc(t)?1:0),a=xe(()=>t.as3D(r,i,s).toInt());return await Ww.toPixels(a,n),a.dispose(),n}function T5(t){let{Image:e,Canvas:n,Video:r}=pa.getEnv();return t instanceof e||t instanceof n||t instanceof r}function WZe(t,e,n=!1){let{Image:r,Canvas:i}=pa.getEnv();if(!(t instanceof r||t instanceof i))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(e<=0)return tT({width:1,height:1});let s=Dne(t),a=e/Math.max(s.height,s.width),o=a*s.width,l=a*s.height,u=tT({width:e,height:e}),c=t instanceof i?t:Pne(t),d=Math.abs(o-l)/2,h=n&&o<l?d:0,p=n&&l<o?d:0;return c.width>0&&c.height>0&&Vd(u).drawImage(c,h,p,o,l),u}var nT=class{constructor(t,e=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(t))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${t}`);this._treatAsBatchInput=e,this._batchSize=t.length,t.forEach((n,r)=>{if(i_(n)){this._imageTensors[r]=n,this._inputDimensions[r]=n.shape;return}if(tc(n)){let s=n.shape[0];if(s!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${s} passed, but not supported in input array`);this._imageTensors[r]=n,this._inputDimensions[r]=n.shape.slice(1);return}let i=n instanceof pa.getEnv().Canvas?n:Pne(n);this._canvases[r]=i,this._inputDimensions[r]=[i.height,i.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return l0(this.batchSize,0,1).map((t,e)=>this.getReshapedInputDimensions(e))}getInput(t){return this.canvases[t]||this.imageTensors[t]}getInputDimensions(t){return this._inputDimensions[t]}getInputHeight(t){return this._inputDimensions[t][0]}getInputWidth(t){return this._inputDimensions[t][1]}getReshapedInputDimensions(t){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let e=this.getInputWidth(t),n=this.getInputHeight(t);return yne({width:e,height:n},this.inputSize)}toBatchTensor(t,e=!0){return this._inputSize=t,xe(()=>{let n=l0(this.batchSize,0,1).map(r=>{let i=this.getInput(r);if(i instanceof In){let s=tc(i)?i:Gi(i);return s=PZe(s,e),(s.shape[1]!==t||s.shape[2]!==t)&&(s=to.resizeBilinear(s,[t,t],!1,!1)),s.as3D(t,t,3)}if(i instanceof pa.getEnv().Canvas)return Ww.fromPixels(WZe(i,t,e));throw new Error(`toBatchTensor - at batchIdx ${r}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${i}`)});return xi(n.map(r=>ft(r,"float32"))).as4D(this.batchSize,t,t,3)})}};async function Hs(t){if(t instanceof nT)return t;let e=Array.isArray(t)?t:[t];if(!e.length)throw new Error("toNetInput - empty array passed as input");let n=i=>Array.isArray(t)?` at input index ${i}:`:"",r=e.map(wU);return r.forEach((i,s)=>{if(!T5(i)&&!i_(i)&&!tc(i))throw typeof e[s]=="string"?new Error(`toNetInput -${n(s)} string passed, but could not resolve HTMLElement for element id ${e[s]}`):new Error(`toNetInput -${n(s)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(tc(i)){let a=i.shape[0];if(a!==1)throw new Error(`toNetInput -${n(s)} tf.Tensor4D with batchSize ${a} passed, but not supported in input array`)}}),await Promise.all(r.map(i=>T5(i)&&GZe(i))),new nT(r,Array.isArray(t))}async function AU(t,e){let{Canvas:n}=pa.getEnv(),r=t;if(!(t instanceof n)){let s=await Hs(t);if(s.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let a=s.getInput(0);r=a instanceof n?a:await HZe(a)}let i=Vd(r);return e.map(s=>s instanceof Il?s.forSize(r.width,r.height).box.floor():s).map(s=>s.clipAtImageBorders(r.width,r.height)).map(({x:s,y:a,width:o,height:l})=>{let u=tT({width:o,height:l});return o>0&&l>0&&Vd(u).putImageData(i.getImageData(s,a,o,l),0,0),u})}async function EU(t,e){if(!i_(t)&&!tc(t))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(tc(t)&&t.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return xe(()=>{let[n,r,i]=t.shape.slice(tc(t)?1:0);return e.map(s=>s instanceof Il?s.forSize(r,n).box:s).map(s=>s.clipAtImageBorders(r,n)).filter(s=>s.width>0&&s.height>0).map(({x:s,y:a,width:o,height:l})=>Tv(t.as3D(n,r,i),[a,s,0],[l,o,i]))})}async function VZe(t,e){let{fetch:n}=pa.getEnv(),r=await n(t,e);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function jZe(t){return(await VZe(t)).json()}function Lne(t,e){let n=`${e}-weights_manifest.json`;if(!t)return{modelBaseUri:"",manifestUri:n};if(t==="/")return{modelBaseUri:"/",manifestUri:`/${n}`};let r=t.startsWith("http://")?"http://":t.startsWith("https://")?"https://":"";t=t.replace(r,"");let i=t.split("/").filter(o=>o),s=t.endsWith(".json")?i[i.length-1]:n,a=r+(t.endsWith(".json")?i.slice(0,i.length-1):i).join("/");return a=t.startsWith("/")?`/${a}`:a,{modelBaseUri:a,manifestUri:a==="/"?`/${s}`:`${a}/${s}`}}async function XZe(t,e){let{manifestUri:n,modelBaseUri:r}=Lne(t,e),i=await jZe(n);return us.loadWeights(i,r)}var fh=class{constructor(t){this._params=void 0,this._paramMappings=[],this._name=t}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(t){let{obj:e,objProp:n}=this.traversePropertyPath(t);return e[n]}reassignParamFromPath(t,e){let{obj:n,objProp:r}=this.traversePropertyPath(t);n[r].dispose(),n[r]=e}getParamList(){return this._paramMappings.map(({paramPath:t})=>({path:t,tensor:this.getParamFromPath(t)}))}getTrainableParams(){return this.getParamList().filter(t=>t.tensor instanceof Jp)}getFrozenParams(){return this.getParamList().filter(t=>!(t.tensor instanceof Jp))}variable(){this.getFrozenParams().forEach(({path:t,tensor:e})=>{this.reassignParamFromPath(t,e.variable())})}freeze(){this.getTrainableParams().forEach(({path:t,tensor:e})=>{let n=Us(e.dataSync());e.dispose(),this.reassignParamFromPath(t,n)})}dispose(t=!0){this.getParamList().forEach(e=>{if(t&&e.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${e.path}`);e.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:t})=>Array.from(t.dataSync())).reduce((t,e)=>t.concat(e)))}async load(t){if(t instanceof Float32Array){this.extractWeights(t);return}await this.loadFromUri(t)}async loadFromUri(t){if(t&&typeof t!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let e=await XZe(t,this.getDefaultModelName());this.loadFromWeightMap(e)}async loadFromDisk(t){if(t&&typeof t!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:e}=pa.getEnv(),{manifestUri:n,modelBaseUri:r}=Lne(t,this.getDefaultModelName()),i=l=>Promise.all(l.map(u=>e(u).then(c=>typeof c=="string"?Buffer.from(c):c.buffer))),s=us.weightsLoaderFactory(i),a=JSON.parse((await e(n)).toString()),o=await s(a,r);this.loadFromWeightMap(o)}loadFromWeightMap(t){let{paramMappings:e,params:n}=this.extractParamsFromWeightMap(t);this._paramMappings=e,this._params=n}extractWeights(t){let{paramMappings:e,params:n}=this.extractParams(t);this._paramMappings=e,this._params=n}traversePropertyPath(t){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let e=t.split("/").reduce((i,s)=>{if(!i.nextObj.hasOwnProperty(s))throw new Error(`traversePropertyPath - object does not have property ${s}, for path ${t}`);return{obj:i.nextObj,objProp:s,nextObj:i.nextObj[s]}},{nextObj:this.params}),{obj:n,objProp:r}=e;if(!n||!r||!(n[r]instanceof In))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${t}`);return{obj:n,objProp:r}}};function io(t,e,n){return xe(()=>{let r=Iv(t,e.depthwise_filter,e.pointwise_filter,n,"same");return r=ze(r,e.bias),r})}function DN(t,e,n=!1){return xe(()=>{let r=pr(n?ze(zs(t,e.conv0.filters,[2,2],"same"),e.conv0.bias):io(t,e.conv0,[2,2])),i=io(r,e.conv1,[1,1]),s=pr(ze(r,i)),a=io(s,e.conv2,[1,1]);return pr(ze(r,ze(i,a)))})}function kA(t,e,n=!1,r=!0){return xe(()=>{let i=pr(n?ze(zs(t,e.conv0.filters,r?[2,2]:[1,1],"same"),e.conv0.bias):io(t,e.conv0,r?[2,2]:[1,1])),s=io(i,e.conv1,[1,1]),a=pr(ze(i,s)),o=io(a,e.conv2,[1,1]),l=pr(ze(i,ze(s,o))),u=io(l,e.conv3,[1,1]);return pr(ze(i,ze(s,ze(o,u))))})}function Fb(t,e,n="same",r=!1){return xe(()=>{let i=ze(zs(t,e.filters,[1,1],n),e.bias);return r?pr(i):i})}function mh(t,e){Object.keys(t).forEach(n=>{e.some(r=>r.originalPath===n)||t[n].dispose()})}function IU(t,e){return(n,r,i,s)=>{let a=Bd(t(n*r*i*i),[i,i,n,r]),o=cr(t(r));return e.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:a,bias:o}}}function One(t,e){return(n,r,i)=>{let s=au(t(n*r),[n,r]),a=cr(t(r));return e.push({paramPath:`${i}/weights`},{paramPath:`${i}/bias`}),{weights:s,bias:a}}}var Bne=class{constructor(t,e,n){this.depthwise_filter=t,this.pointwise_filter=e,this.bias=n}};function TU(t,e){return(n,r,i)=>{let s=Bd(t(9*n),[3,3,n,1]),a=Bd(t(n*r),[1,1,n,r]),o=cr(t(r));return e.push({paramPath:`${i}/depthwise_filter`},{paramPath:`${i}/pointwise_filter`},{paramPath:`${i}/bias`}),new Bne(s,a,o)}}function CU(t){return e=>{let n=t(`${e}/depthwise_filter`,4),r=t(`${e}/pointwise_filter`,4),i=t(`${e}/bias`,1);return new Bne(n,r,i)}}function tg(t,e){return(n,r,i)=>{let s=t[n];if(!zv(s,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${s}`);return e.push({originalPath:n,paramPath:i||n}),s}}function gh(t){let e=t;function n(i){let s=e.slice(0,i);return e=e.slice(i),s}function r(){return e}return{extractWeights:n,getRemainingWeights:r}}function Une(t,e){let n=IU(t,e),r=TU(t,e);function i(a,o,l,u=!1){let c=u?n(a,o,3,`${l}/conv0`):r(a,o,`${l}/conv0`),d=r(o,o,`${l}/conv1`),h=r(o,o,`${l}/conv2`);return{conv0:c,conv1:d,conv2:h}}function s(a,o,l,u=!1){let{conv0:c,conv1:d,conv2:h}=i(a,o,l,u),p=r(o,o,`${l}/conv3`);return{conv0:c,conv1:d,conv2:h,conv3:p}}return{extractDenseBlock3Params:i,extractDenseBlock4Params:s}}function KZe(t){let e=[],{extractWeights:n,getRemainingWeights:r}=gh(t),{extractDenseBlock4Params:i}=Une(n,e),s=i(3,32,"dense0",!0),a=i(32,64,"dense1"),o=i(64,128,"dense2"),l=i(128,256,"dense3");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:e,params:{dense0:s,dense1:a,dense2:o,dense3:l}}}function $ne(t){return e=>{let n=t(`${e}/filters`,4),r=t(`${e}/bias`,1);return{filters:n,bias:r}}}function zne(t,e){let n=tg(t,e),r=$ne(n),i=CU(n);function s(o,l=!1){let u=l?r(`${o}/conv0`):i(`${o}/conv0`),c=i(`${o}/conv1`),d=i(`${o}/conv2`);return{conv0:u,conv1:c,conv2:d}}function a(o,l=!1){let u=l?r(`${o}/conv0`):i(`${o}/conv0`),c=i(`${o}/conv1`),d=i(`${o}/conv2`),h=i(`${o}/conv3`);return{conv0:u,conv1:c,conv2:d,conv3:h}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:a}}function qZe(t){let e=[],{extractDenseBlock4Params:n}=zne(t,e),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return mh(t,e),{params:r,paramMappings:e}}var Gne=class extends fh{constructor(){super("FaceFeatureExtractor")}forwardInput(t){let{params:e}=this;if(!e)throw new Error("FaceFeatureExtractor - load model before inference");return xe(()=>{let n=ft(t.toBatchTensor(112,!0),"float32"),r=s_(n,[122.782,117.001,104.298]).div(255),i=kA(r,e.dense0,!0);return i=kA(i,e.dense1),i=kA(i,e.dense2),i=kA(i,e.dense3),i=mc(i,[7,7],[2,2],"valid"),i})}async forward(t){return this.forwardInput(await Hs(t))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(t){return qZe(t)}extractParams(t){return KZe(t)}};function dD(t,e){return xe(()=>ze(kn(t,e.weights),e.bias))}function JZe(t,e,n){let r=[],{extractWeights:i,getRemainingWeights:s}=gh(t),a=One(i,r)(e,n,"fc");if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:r,params:{fc:a}}}function YZe(t){let e=[],n=tg(t,e);function r(s){let a=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:a,bias:o}}let i={fc:r("fc")};return mh(t,e),{params:i,paramMappings:e}}function Hne(t){let e={},n={};return Object.keys(t).forEach(r=>{let i=r.startsWith("fc")?n:e;i[r]=t[r]}),{featureExtractorMap:e,classifierMap:n}}var Wne=class extends fh{constructor(t,e){super(t),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(t){let{params:e}=this;if(!e)throw new Error(`${this._name} - load model before inference`);return xe(()=>{let n=t instanceof nT?this.faceFeatureExtractor.forwardInput(t):t;return dD(n.as2D(n.shape[0],-1),e.fc)})}dispose(t=!0){this.faceFeatureExtractor.dispose(t),super.dispose(t)}loadClassifierParams(t){let{params:e,paramMappings:n}=this.extractClassifierParams(t);this._params=e,this._paramMappings=n}extractClassifierParams(t){return JZe(t,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(t){let{featureExtractorMap:e,classifierMap:n}=Hne(t);return this.faceFeatureExtractor.loadFromWeightMap(e),YZe(n)}extractParams(t){let e=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*e+n,i=t.slice(0,t.length-r),s=t.slice(t.length-r);return this.faceFeatureExtractor.extractWeights(i),this.extractClassifierParams(s)}},C5=["neutral","happy","sad","angry","fearful","disgusted","surprised"],MU=class{constructor(t){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,t.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${t.length}`);C5.forEach((e,n)=>{this[e]=t[n]})}asSortedArray(){return C5.map(t=>({expression:t,probability:this[t]})).sort((t,e)=>e.probability-t.probability)}},ZZe=class extends Wne{constructor(t=new Gne){super("FaceExpressionNet",t)}forwardInput(t){return xe(()=>lh(this.runNet(t)))}async forward(t){return this.forwardInput(await Hs(t))}async predictExpressions(t){let e=await Hs(t),n=await this.forwardInput(e),r=await Promise.all(ii(n).map(async s=>{let a=s.dataSync();return s.dispose(),a}));n.dispose();let i=r.map(s=>new MU(s));return e.isBatchInput?i:i[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function QZe(t){return t.expressions instanceof MU}function Vne(t,e){return{...t,expressions:e}}function eQe(t,e,n=.1,r){(Array.isArray(e)?e:[e]).forEach(i=>{let s=i instanceof MU?i:QZe(i)?i.expressions:void 0;if(!s)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let a=s.asSortedArray().filter(l=>l.probability>n),o=eT(i)?i.detection.box.bottomLeft:r||new vr(0,0);new SU(a.map(l=>`${l.expression} (${yU(l.probability)})`),o).draw(t)})}function jne(t){return eT(t)&&t.landmarks instanceof QI&&t.unshiftedLandmarks instanceof QI&&t.alignedRect instanceof Il}function tQe(t){let e=l=>l*180/Math.PI,n=(l,u)=>Math.sqrt((l.x-u.x)**2+(l.y-u.y)**2),r={roll:void 0,pitch:void 0,yaw:void 0},i=(l,u,c)=>{let d=Math.floor(l.x-u.x),h=Math.floor(u.x-c.x);return d-h},s=(l,u)=>{let c=Math.hypot(u.x-l.x,u.y-l.y),d=u.y-l.y,h=Math.asin(d/c),p=e(h),f=Math.floor(90-p),g=u.x-l.x<0?-1:1;return f*g},a=(l,u,c)=>{let d=n(l,c),h=new vr((l.x+c.x)/2,(l.y+c.y)/2),p=n(u,h),f=Math.atan(p/d),g=Math.floor(e(f)),y=h.y-u.y<0?-1:1;return g*y};if(!t||!t.positions||t.positions.length!==68)return r;let o=t.positions;return r.roll=s(o[27],o[66]),r.pitch=a(o[14],o[30],o[2]),r.yaw=i(o[14],o[33],o[2]),r}function Xne(t,e){let{box:n}=t.detection,r=e.shiftBy(n.x,n.y),i=r.align(),{imageDims:s}=t.detection,a=new Il(t.detection.score,i.rescale(s.reverse()),s),o=tQe(e);return{...t,landmarks:r,unshiftedLandmarks:e,alignedRect:a,angle:o}}var Kne=class{constructor(t={}){let{drawLines:e=!0,drawPoints:n=!0,lineWidth:r,lineColor:i,pointSize:s,pointColor:a}=t;this.drawLines=e,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=s||2,this.lineColor=i||"rgba(0, 255, 255, 1)",this.pointColor=a||"rgba(255, 0, 255, 1)"}},qne=class{constructor(t,e={}){this.faceLandmarks=t,this.options=new Kne(e)}draw(t){let e=Vd(t),{drawLines:n,drawPoints:r,lineWidth:i,lineColor:s,pointSize:a,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof Sne&&(e.strokeStyle=s,e.lineWidth=i,Kc(e,this.faceLandmarks.getJawOutline()),Kc(e,this.faceLandmarks.getLeftEyeBrow()),Kc(e,this.faceLandmarks.getRightEyeBrow()),Kc(e,this.faceLandmarks.getNose()),Kc(e,this.faceLandmarks.getLeftEye(),!0),Kc(e,this.faceLandmarks.getRightEye(),!0),Kc(e,this.faceLandmarks.getMouth(),!0)),r){e.strokeStyle=o,e.fillStyle=o;let l=u=>{e.beginPath(),e.arc(u.x,u.y,a,0,2*Math.PI),e.fill()};this.faceLandmarks.positions.forEach(l)}}};function nQe(t,e){(Array.isArray(e)?e:[e]).forEach(n=>{let r=n instanceof QI?n:jne(n)?n.landmarks:void 0;if(!r)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new qne(r).draw(t)})}function rQe(t,e){let n=IU(t,e),r=TU(t,e);function i(a,o,l){let u=r(a,o,`${l}/separable_conv0`),c=r(o,o,`${l}/separable_conv1`),d=n(a,o,1,`${l}/expansion_conv`);return{separable_conv0:u,separable_conv1:c,expansion_conv:d}}function s(a,o){let l=r(a,a,`${o}/separable_conv0`),u=r(a,a,`${o}/separable_conv1`),c=r(a,a,`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:u,separable_conv2:c}}return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:i,extractMainBlockParams:s}}function iQe(t,e){let n=[],{extractWeights:r,getRemainingWeights:i}=gh(t),{extractConvParams:s,extractSeparableConvParams:a,extractReductionBlockParams:o,extractMainBlockParams:l}=rQe(r,n),u=s(3,32,3,"entry_flow/conv_in"),c=o(32,64,"entry_flow/reduction_block_0"),d=o(64,128,"entry_flow/reduction_block_1"),h={conv_in:u,reduction_block_0:c,reduction_block_1:d},p={};l0(e,0,1).forEach(m=>{p[`main_block_${m}`]=l(128,`middle_flow/main_block_${m}`)});let f=o(128,256,"exit_flow/reduction_block"),g=a(256,512,"exit_flow/separable_conv"),y={reduction_block:f,separable_conv:g};if(i().length!==0)throw new Error(`weights remaing after extract: ${i().length}`);return{paramMappings:n,params:{entry_flow:h,middle_flow:p,exit_flow:y}}}function sQe(t,e){let n=tg(t,e),r=$ne(n),i=CU(n);function s(o){let l=i(`${o}/separable_conv0`),u=i(`${o}/separable_conv1`),c=r(`${o}/expansion_conv`);return{separable_conv0:l,separable_conv1:u,expansion_conv:c}}function a(o){let l=i(`${o}/separable_conv0`),u=i(`${o}/separable_conv1`),c=i(`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:u,separable_conv2:c}}return{extractConvParams:r,extractSeparableConvParams:i,extractReductionBlockParams:s,extractMainBlockParams:a}}function aQe(t,e){let n=[],{extractConvParams:r,extractSeparableConvParams:i,extractReductionBlockParams:s,extractMainBlockParams:a}=sQe(t,n),o=r("entry_flow/conv_in"),l=s("entry_flow/reduction_block_0"),u=s("entry_flow/reduction_block_1"),c={conv_in:o,reduction_block_0:l,reduction_block_1:u},d={};l0(e,0,1).forEach(g=>{d[`main_block_${g}`]=a(`middle_flow/main_block_${g}`)});let h=s("exit_flow/reduction_block"),p=i("exit_flow/separable_conv"),f={reduction_block:h,separable_conv:p};return mh(t,n),{params:{entry_flow:c,middle_flow:d,exit_flow:f},paramMappings:n}}function Jne(t,e,n){return ze(zs(t,e.filters,n,"same"),e.bias)}function PN(t,e,n=!0){let r=n?pr(t):t;return r=io(r,e.separable_conv0,[1,1]),r=io(pr(r),e.separable_conv1,[1,1]),r=Oi(r,[3,3],[2,2],"same"),r=ze(r,Jne(t,e.expansion_conv,[2,2])),r}function oQe(t,e){let n=io(pr(t),e.separable_conv0,[1,1]);return n=io(pr(n),e.separable_conv1,[1,1]),n=io(pr(n),e.separable_conv2,[1,1]),n=ze(n,t),n}var lQe=class extends fh{constructor(t){super("TinyXception"),this._numMainBlocks=t}forwardInput(t){let{params:e}=this;if(!e)throw new Error("TinyXception - load model before inference");return xe(()=>{let n=ft(t.toBatchTensor(112,!0),"float32"),r=s_(n,[122.782,117.001,104.298]).div(255),i=pr(Jne(r,e.entry_flow.conv_in,[2,2]));return i=PN(i,e.entry_flow.reduction_block_0,!1),i=PN(i,e.entry_flow.reduction_block_1),l0(this._numMainBlocks,0,1).forEach(s=>{i=oQe(i,e.middle_flow[`main_block_${s}`])}),i=PN(i,e.exit_flow.reduction_block),i=pr(io(i,e.exit_flow.separable_conv,[1,1])),i})}async forward(t){return this.forwardInput(await Hs(t))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(t){return aQe(t,this._numMainBlocks)}extractParams(t){return iQe(t,this._numMainBlocks)}};function uQe(t){let e=[],{extractWeights:n,getRemainingWeights:r}=gh(t),i=One(n,e),s=i(512,1,"fc/age"),a=i(512,2,"fc/gender");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:e,params:{fc:{age:s,gender:a}}}}function cQe(t){let e=[],n=tg(t,e);function r(s){let a=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:a,bias:o}}let i={fc:{age:r("fc/age"),gender:r("fc/gender")}};return mh(t,e),{params:i,paramMappings:e}}var dQe=(t=>(t.FEMALE="female",t.MALE="male",t))(dQe||{}),hQe=class extends fh{constructor(t=new lQe(2)){super("AgeGenderNet"),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(t){let{params:e}=this;if(!e)throw new Error(`${this._name} - load model before inference`);return xe(()=>{let n=t instanceof nT?this.faceFeatureExtractor.forwardInput(t):t,r=mc(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),i=dD(r,e.fc.age).as1D(),s=dD(r,e.fc.gender);return{age:i,gender:s}})}forwardInput(t){return xe(()=>{let{age:e,gender:n}=this.runNet(t);return{age:e,gender:lh(n)}})}async forward(t){return this.forwardInput(await Hs(t))}async predictAgeAndGender(t){let e=await Hs(t),n=await this.forwardInput(e),r=ii(n.age),i=ii(n.gender),s=r.map((o,l)=>({ageTensor:o,genderTensor:i[l]})),a=await Promise.all(s.map(async({ageTensor:o,genderTensor:l})=>{let u=o.dataSync()[0],c=l.dataSync()[0],d=c>.5,h=d?"male":"female",p=d?c:1-c;return o.dispose(),l.dispose(),{age:u,gender:h,genderProbability:p}}));return n.age.dispose(),n.gender.dispose(),e.isBatchInput?a:a[0]}getDefaultModelName(){return"age_gender_model"}dispose(t=!0){this.faceFeatureExtractor.dispose(t),super.dispose(t)}loadClassifierParams(t){let{params:e,paramMappings:n}=this.extractClassifierParams(t);this._params=e,this._paramMappings=n}extractClassifierParams(t){return uQe(t)}extractParamsFromWeightMap(t){let{featureExtractorMap:e,classifierMap:n}=Hne(t);return this.faceFeatureExtractor.loadFromWeightMap(e),cQe(n)}extractParams(t){let e=t.slice(0,t.length-1539),n=t.slice(t.length-1539);return this.faceFeatureExtractor.extractWeights(e),this.extractClassifierParams(n)}},Yne=class extends Wne{postProcess(t,e,n){let r=n.map(({width:s,height:a})=>{let o=e/Math.max(a,s);return{width:s*o,height:a*o}}),i=r.length;return xe(()=>{let s=(u,c)=>xi([Pa([68],u,"float32"),Pa([68],c,"float32")],1).as2D(1,136).as1D(),a=(u,c)=>{let{width:d,height:h}=r[u];return c(d,h)?Math.abs(d-h)/2:0},o=u=>a(u,(c,d)=>c<d),l=u=>a(u,(c,d)=>d<c);return t.mul(Pa([i,136],e,"float32")).sub(xi(Array.from(Array(i),(u,c)=>s(o(c),l(c))))).div(xi(Array.from(Array(i),(u,c)=>s(r[c].width,r[c].height))))})}forwardInput(t){return xe(()=>{let e=this.runNet(t);return this.postProcess(e,t.inputSize,t.inputDimensions.map(([n,r])=>({height:n,width:r})))})}async forward(t){return this.forwardInput(await Hs(t))}async detectLandmarks(t){let e=await Hs(t),n=xe(()=>ii(this.forwardInput(e))),r=await Promise.all(n.map(async(i,s)=>{let a=Array.from(i.dataSync()),o=a.filter((u,c)=>lD(c)),l=a.filter((u,c)=>!lD(c));return new Sne(Array(68).fill(0).map((u,c)=>new vr(o[c],l[c])),{height:e.getInputHeight(s),width:e.getInputWidth(s)})}));return n.forEach(i=>i.dispose()),e.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},pQe=class extends Yne{constructor(t=new Gne){super("FaceLandmark68Net",t)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function fQe(t){let e=[],{extractDenseBlock3Params:n}=zne(t,e),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return mh(t,e),{params:r,paramMappings:e}}function mQe(t){let e=[],{extractWeights:n,getRemainingWeights:r}=gh(t),{extractDenseBlock3Params:i}=Une(n,e),s=i(3,32,"dense0",!0),a=i(32,64,"dense1"),o=i(64,128,"dense2");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:e,params:{dense0:s,dense1:a,dense2:o}}}var gQe=class extends fh{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(t){let{params:e}=this;if(!e)throw new Error("TinyFaceFeatureExtractor - load model before inference");return xe(()=>{let n=ft(t.toBatchTensor(112,!0),"float32"),r=s_(n,[122.782,117.001,104.298]).div(255),i=DN(r,e.dense0,!0);return i=DN(i,e.dense1),i=DN(i,e.dense2),i=mc(i,[14,14],[2,2],"valid"),i})}async forward(t){return this.forwardInput(await Hs(t))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(t){return fQe(t)}extractParams(t){return mQe(t)}},yQe=class extends Yne{constructor(t=new gQe){super("FaceLandmark68TinyNet",t)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function vQe(t,e){return ze(fe(t,e.weights),e.biases)}function kU(t,e,n,r,i="same"){let{filters:s,bias:a}=e.conv,o=zs(t,s,n,i);return o=ze(o,a),o=vQe(o,e.scale),r?pr(o):o}function xQe(t,e){return kU(t,e,[1,1],!0)}function Zne(t,e){return kU(t,e,[1,1],!1)}function Qne(t,e){return kU(t,e,[2,2],!0,"valid")}function bQe(t,e){function n(o,l,u){let c=t(o),d=c.length/(l*u*u);if(gne(d))throw new Error(`depth has to be an integer: ${d}, weights.length: ${c.length}, numFilters: ${l}, filterSize: ${u}`);return xe(()=>Nn(Bd(c,[l,d,u,u]),[2,3,1,0]))}function r(o,l,u,c){let d=n(o,l,u),h=cr(t(l));return e.push({paramPath:`${c}/filters`},{paramPath:`${c}/bias`}),{filters:d,bias:h}}function i(o,l){let u=cr(t(o)),c=cr(t(o));return e.push({paramPath:`${l}/weights`},{paramPath:`${l}/biases`}),{weights:u,biases:c}}function s(o,l,u,c){let d=r(o,l,u,`${c}/conv`),h=i(l,`${c}/scale`);return{conv:d,scale:h}}function a(o,l,u,c,d=!1){let h=s((d?.5:1)*o,l,u,`${c}/conv1`),p=s(o,l,u,`${c}/conv2`);return{conv1:h,conv2:p}}return{extractConvLayerParams:s,extractResidualLayerParams:a}}function wQe(t){let{extractWeights:e,getRemainingWeights:n}=gh(t),r=[],{extractConvLayerParams:i,extractResidualLayerParams:s}=bQe(e,r),a=i(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),l=s(9216,32,3,"conv32_2"),u=s(9216,32,3,"conv32_3"),c=s(36864,64,3,"conv64_down",!0),d=s(36864,64,3,"conv64_1"),h=s(36864,64,3,"conv64_2"),p=s(36864,64,3,"conv64_3"),f=s(147456,128,3,"conv128_down",!0),g=s(147456,128,3,"conv128_1"),y=s(147456,128,3,"conv128_2"),m=s(589824,256,3,"conv256_down",!0),b=s(589824,256,3,"conv256_1"),w=s(589824,256,3,"conv256_2"),_=s(589824,256,3,"conv256_down_out"),S=xe(()=>Nn(au(e(256*128),[128,256]),[1,0]));if(r.push({paramPath:"fc"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:a,conv32_1:o,conv32_2:l,conv32_3:u,conv64_down:c,conv64_1:d,conv64_2:h,conv64_3:p,conv128_down:f,conv128_1:g,conv128_2:y,conv256_down:m,conv256_1:b,conv256_2:w,conv256_down_out:_,fc:S},paramMappings:r}}function _Qe(t,e){let n=tg(t,e);function r(a){let o=n(`${a}/scale/weights`,1),l=n(`${a}/scale/biases`,1);return{weights:o,biases:l}}function i(a){let o=n(`${a}/conv/filters`,4),l=n(`${a}/conv/bias`,1),u=r(a);return{conv:{filters:o,bias:l},scale:u}}function s(a){return{conv1:i(`${a}/conv1`),conv2:i(`${a}/conv2`)}}return{extractConvLayerParams:i,extractResidualLayerParams:s}}function SQe(t){let e=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=_Qe(t,e),i=n("conv32_down"),s=r("conv32_1"),a=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),u=r("conv64_1"),c=r("conv64_2"),d=r("conv64_3"),h=r("conv128_down"),p=r("conv128_1"),f=r("conv128_2"),g=r("conv256_down"),y=r("conv256_1"),m=r("conv256_2"),b=r("conv256_down_out"),{fc:w}=t;if(e.push({originalPath:"fc",paramPath:"fc"}),!mne(w))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${w}`);let _={conv32_down:i,conv32_1:s,conv32_2:a,conv32_3:o,conv64_down:l,conv64_1:u,conv64_2:c,conv64_3:d,conv128_down:h,conv128_1:p,conv128_2:f,conv256_down:g,conv256_1:y,conv256_2:m,conv256_down_out:b,fc:w};return mh(t,e),{params:_,paramMappings:e}}function $l(t,e){let n=xQe(t,e.conv1);return n=Zne(n,e.conv2),n=ze(n,t),n=pr(n),n}function NA(t,e){let n=Qne(t,e.conv1);n=Zne(n,e.conv2);let r=mc(t,2,2,"valid"),i=Vr(r.shape),s=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let a=[...n.shape];a[1]=1;let o=Vr(a);n=wr([n,o],1);let l=[...n.shape];l[2]=1;let u=Vr(l);n=wr([n,u],2)}return r=s?wr([r,i],3):r,n=ze(r,n),n=pr(n),n}var AQe=class extends fh{constructor(){super("FaceRecognitionNet")}forwardInput(t){let{params:e}=this;if(!e)throw new Error("FaceRecognitionNet - load model before inference");return xe(()=>{let n=ft(t.toBatchTensor(150,!0),"float32"),r=s_(n,[122.782,117.001,104.298]).div(255),i=Qne(r,e.conv32_down);i=Oi(i,3,2,"valid"),i=$l(i,e.conv32_1),i=$l(i,e.conv32_2),i=$l(i,e.conv32_3),i=NA(i,e.conv64_down),i=$l(i,e.conv64_1),i=$l(i,e.conv64_2),i=$l(i,e.conv64_3),i=NA(i,e.conv128_down),i=$l(i,e.conv128_1),i=$l(i,e.conv128_2),i=NA(i,e.conv256_down),i=$l(i,e.conv256_1),i=$l(i,e.conv256_2),i=NA(i,e.conv256_down_out);let s=i.mean([1,2]);return kn(s,e.fc)})}async forward(t){return this.forwardInput(await Hs(t))}async computeFaceDescriptor(t){var e;if((e=t==null?void 0:t.shape)!=null&&e.some(s=>s<=0))return new Float32Array(128);let n=await Hs(t),r=xe(()=>ii(this.forwardInput(n))),i=await Promise.all(r.map(s=>s.data()));return r.forEach(s=>s.dispose()),n.isBatchInput?i:i[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(t){return SQe(t)}extractParams(t){return wQe(t)}};function ere(t,e){return{...t,descriptor:e}}function tre(t,e){return{...t,age:e}}function nre(t,e,n){return{...t,gender:e,genderProbability:n}}function EQe(t,e){function n(l,u){let c=Bd(t(9*l),[3,3,l,1]),d=cr(t(l)),h=cr(t(l)),p=cr(t(l)),f=cr(t(l));return e.push({paramPath:`${u}/filters`},{paramPath:`${u}/batch_norm_scale`},{paramPath:`${u}/batch_norm_offset`},{paramPath:`${u}/batch_norm_mean`},{paramPath:`${u}/batch_norm_variance`}),{filters:c,batch_norm_scale:d,batch_norm_offset:h,batch_norm_mean:p,batch_norm_variance:f}}function r(l,u,c,d,h){let p=Bd(t(l*u*c*c),[c,c,l,u]),f=cr(t(u));return e.push({paramPath:`${d}/filters`},{paramPath:`${d}/${h?"batch_norm_offset":"bias"}`}),{filters:p,bias:f}}function i(l,u,c,d){let{filters:h,bias:p}=r(l,u,c,d,!0);return{filters:h,batch_norm_offset:p}}function s(l,u,c){let d=n(l,`${c}/depthwise_conv`),h=i(l,u,1,`${c}/pointwise_conv`);return{depthwise_conv:d,pointwise_conv:h}}function a(){let l=i(3,32,3,"mobilenetv1/conv_0"),u=s(32,64,"mobilenetv1/conv_1"),c=s(64,128,"mobilenetv1/conv_2"),d=s(128,128,"mobilenetv1/conv_3"),h=s(128,256,"mobilenetv1/conv_4"),p=s(256,256,"mobilenetv1/conv_5"),f=s(256,512,"mobilenetv1/conv_6"),g=s(512,512,"mobilenetv1/conv_7"),y=s(512,512,"mobilenetv1/conv_8"),m=s(512,512,"mobilenetv1/conv_9"),b=s(512,512,"mobilenetv1/conv_10"),w=s(512,512,"mobilenetv1/conv_11"),_=s(512,1024,"mobilenetv1/conv_12"),S=s(1024,1024,"mobilenetv1/conv_13");return{conv_0:l,conv_1:u,conv_2:c,conv_3:d,conv_4:h,conv_5:p,conv_6:f,conv_7:g,conv_8:y,conv_9:m,conv_10:b,conv_11:w,conv_12:_,conv_13:S}}function o(){let l=i(1024,256,1,"prediction_layer/conv_0"),u=i(256,512,3,"prediction_layer/conv_1"),c=i(512,128,1,"prediction_layer/conv_2"),d=i(128,256,3,"prediction_layer/conv_3"),h=i(256,128,1,"prediction_layer/conv_4"),p=i(128,256,3,"prediction_layer/conv_5"),f=i(256,64,1,"prediction_layer/conv_6"),g=i(64,128,3,"prediction_layer/conv_7"),y=r(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),m=r(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),b=r(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),w=r(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),_=r(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),S=r(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),E=r(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),C=r(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),T=r(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),M=r(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),k=r(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),R=r(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:l,conv_1:u,conv_2:c,conv_3:d,conv_4:h,conv_5:p,conv_6:f,conv_7:g,box_predictor_0:{box_encoding_predictor:y,class_predictor:m},box_predictor_1:{box_encoding_predictor:b,class_predictor:w},box_predictor_2:{box_encoding_predictor:_,class_predictor:S},box_predictor_3:{box_encoding_predictor:E,class_predictor:C},box_predictor_4:{box_encoding_predictor:T,class_predictor:M},box_predictor_5:{box_encoding_predictor:k,class_predictor:R}}}return{extractMobilenetV1Params:a,extractPredictionLayerParams:o}}function IQe(t){let e=[],{extractWeights:n,getRemainingWeights:r}=gh(t),{extractMobilenetV1Params:i,extractPredictionLayerParams:s}=EQe(n,e),a=i(),o=s(),l={extra_dim:GC(n(5118*4),[1,5118,4])};if(e.push({paramPath:"output_layer/extra_dim"}),r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:a,prediction_layer:o,output_layer:l},paramMappings:e}}function TQe(t,e){let n=tg(t,e);function r(u,c,d){let h=n(`${u}/Conv2d_${c}_pointwise/weights`,4,`${d}/filters`),p=n(`${u}/Conv2d_${c}_pointwise/convolution_bn_offset`,1,`${d}/batch_norm_offset`);return{filters:h,batch_norm_offset:p}}function i(u){let c=`mobilenetv1/conv_${u}`,d=`MobilenetV1/Conv2d_${u}_depthwise`,h=`${c}/depthwise_conv`,p=`${c}/pointwise_conv`,f=n(`${d}/depthwise_weights`,4,`${h}/filters`),g=n(`${d}/BatchNorm/gamma`,1,`${h}/batch_norm_scale`),y=n(`${d}/BatchNorm/beta`,1,`${h}/batch_norm_offset`),m=n(`${d}/BatchNorm/moving_mean`,1,`${h}/batch_norm_mean`),b=n(`${d}/BatchNorm/moving_variance`,1,`${h}/batch_norm_variance`);return{depthwise_conv:{filters:f,batch_norm_scale:g,batch_norm_offset:y,batch_norm_mean:m,batch_norm_variance:b},pointwise_conv:r("MobilenetV1",u,p)}}function s(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:i(1),conv_2:i(2),conv_3:i(3),conv_4:i(4),conv_5:i(5),conv_6:i(6),conv_7:i(7),conv_8:i(8),conv_9:i(9),conv_10:i(10),conv_11:i(11),conv_12:i(12),conv_13:i(13)}}function a(u,c){let d=n(`${u}/weights`,4,`${c}/filters`),h=n(`${u}/biases`,1,`${c}/bias`);return{filters:d,bias:h}}function o(u){let c=a(`Prediction/BoxPredictor_${u}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${u}/box_encoding_predictor`),d=a(`Prediction/BoxPredictor_${u}/ClassPredictor`,`prediction_layer/box_predictor_${u}/class_predictor`);return{box_encoding_predictor:c,class_predictor:d}}function l(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:s,extractPredictionLayerParams:l}}function CQe(t){let e=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=TQe(t,e),i=t["Output/extra_dim"];if(e.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!i_(i))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${i}`);let s={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:i}};return mh(t,e),{params:s,paramMappings:e}}function Wl(t,e,n){return xe(()=>{let r=zs(t,e.filters,n,"same");return r=ze(r,e.batch_norm_offset),bs(r,0,6)})}var MQe=.0010000000474974513;function kQe(t,e,n){return xe(()=>{let r=Vm(t,e.filters,n,"same");return r=Wm(r,e.batch_norm_mean,e.batch_norm_variance,e.batch_norm_offset,e.batch_norm_scale,MQe),bs(r,0,6)})}function NQe(t){return[2,4,6,12].some(e=>e===t)?[2,2]:[1,1]}function RQe(t,e){return xe(()=>{let n,r=Wl(t,e.conv_0,[2,2]);if([e.conv_1,e.conv_2,e.conv_3,e.conv_4,e.conv_5,e.conv_6,e.conv_7,e.conv_8,e.conv_9,e.conv_10,e.conv_11,e.conv_12,e.conv_13].forEach((i,s)=>{let a=s+1,o=NQe(a);r=kQe(r,i.depthwise_conv,o),r=Wl(r,i.pointwise_conv,[1,1]),a===11&&(n=r)}),n===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}})}function FQe(t,e,n){let r=t.arraySync(),i=Math.min(r[e][0],r[e][2]),s=Math.min(r[e][1],r[e][3]),a=Math.max(r[e][0],r[e][2]),o=Math.max(r[e][1],r[e][3]),l=Math.min(r[n][0],r[n][2]),u=Math.min(r[n][1],r[n][3]),c=Math.max(r[n][0],r[n][2]),d=Math.max(r[n][1],r[n][3]),h=(a-i)*(o-s),p=(c-l)*(d-u);if(h<=0||p<=0)return 0;let f=Math.max(i,l),g=Math.max(s,u),y=Math.min(a,c),m=Math.min(o,d),b=Math.max(y-f,0)*Math.max(m-g,0);return b/(h+p-b)}function DQe(t,e,n,r,i){let s=t.shape[0],a=Math.min(n,s),o=e.map((c,d)=>({score:c,boxIndex:d})).filter(c=>c.score>i).sort((c,d)=>d.score-c.score),l=c=>c<=r?1:0,u=[];return o.forEach(c=>{if(u.length>=a)return;let d=c.score;for(let h=u.length-1;h>=0;--h){let p=FQe(t,c.boxIndex,u[h]);if(p!==0&&(c.score*=l(p),c.score<=i))break}d===c.score&&u.push(c.boxIndex)}),u}function PQe(t){let e=ii(Nn(t,[1,0])),n=[Dt(e[2],e[0]),Dt(e[3],e[1])],r=[ze(e[0],zt(n[0],2)),ze(e[1],zt(n[1],2))];return{sizes:n,centers:r}}function LQe(t,e){let{sizes:n,centers:r}=PQe(t),i=ii(Nn(e,[1,0])),s=zt(fe(ws(zt(i[2],5)),n[0]),2),a=ze(fe(zt(i[0],10),n[0]),r[0]),o=zt(fe(ws(zt(i[3],5)),n[1]),2),l=ze(fe(zt(i[1],10),n[1]),r[1]);return Nn(xi([Dt(a,s),Dt(l,o),ze(a,s),ze(l,o)]),[1,0])}function OQe(t,e,n){return xe(()=>{let r=t.shape[0],i=LQe(ve(Na(n.extra_dim,[r,1,1]),[-1,4]),ve(t,[-1,4]));i=ve(i,[r,i.shape[0]/r,4]);let s=Uo(Gn(e,[0,0,1],[-1,-1,-1])),a=Gn(s,[0,0,0],[-1,-1,1]);a=ve(a,[r,a.shape[1]]);let o=ii(i),l=ii(a);return{boxes:o,scores:l}})}function zg(t,e){return xe(()=>{let n=t.shape[0],r=ve(Fb(t,e.box_encoding_predictor),[n,-1,1,4]),i=ve(Fb(t,e.class_predictor),[n,-1,3]);return{boxPredictionEncoding:r,classPrediction:i}})}function BQe(t,e,n){return xe(()=>{let r=Wl(t,n.conv_0,[1,1]),i=Wl(r,n.conv_1,[2,2]),s=Wl(i,n.conv_2,[1,1]),a=Wl(s,n.conv_3,[2,2]),o=Wl(a,n.conv_4,[1,1]),l=Wl(o,n.conv_5,[2,2]),u=Wl(l,n.conv_6,[1,1]),c=Wl(u,n.conv_7,[2,2]),d=zg(e,n.box_predictor_0),h=zg(t,n.box_predictor_1),p=zg(i,n.box_predictor_2),f=zg(a,n.box_predictor_3),g=zg(l,n.box_predictor_4),y=zg(c,n.box_predictor_5),m=wr([d.boxPredictionEncoding,h.boxPredictionEncoding,p.boxPredictionEncoding,f.boxPredictionEncoding,g.boxPredictionEncoding,y.boxPredictionEncoding],1),b=wr([d.classPrediction,h.classPrediction,p.classPrediction,f.classPrediction,g.classPrediction,y.classPrediction],1);return{boxPredictions:m,classPredictions:b}})}var CM=class{constructor({minConfidence:t,maxResults:e}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=t||.5,this._maxResults=e||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},UQe=class extends fh{constructor(){super("SsdMobilenetv1")}forwardInput(t){let{params:e}=this;if(!e)throw new Error("SsdMobilenetv1 - load model before inference");return xe(()=>{let n=ft(t.toBatchTensor(512,!1),"float32"),r=Dt(zt(n,127.5),1),i=RQe(r,e.mobilenetv1),{boxPredictions:s,classPredictions:a}=BQe(i.out,i.conv11,e.prediction_layer);return OQe(s,a,e.output_layer)})}async forward(t){return this.forwardInput(await Hs(t))}async locateFaces(t,e={}){let{maxResults:n,minConfidence:r}=new CM(e),i=await Hs(t),{boxes:s,scores:a}=this.forwardInput(i),o=s[0],l=a[0];for(let m=1;m<s.length;m++)s[m].dispose(),a[m].dispose();let u=Array.from(l.dataSync()),c=DQe(o,u,n,.5,r),d=i.getReshapedInputDimensions(0),h=i.inputSize,p=h/d.width,f=h/d.height,g=o.arraySync(),y=c.map(m=>{let[b,w]=[Math.max(0,g[m][0]),Math.min(1,g[m][2])].map(E=>E*f),[_,S]=[Math.max(0,g[m][1]),Math.min(1,g[m][3])].map(E=>E*p);return new Il(u[m],new _ne(_,b,S-_,w-b),{height:i.getInputHeight(0),width:i.getInputWidth(0)})});return o.dispose(),l.dispose(),y}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(t){return CQe(t)}extractParams(t){return IQe(t)}},$Qe=.4,zQe=[new vr(.738768,.874946),new vr(2.42204,2.65704),new vr(4.30971,7.04493),new vr(10.246,4.59428),new vr(12.6868,11.8741)],GQe=[new vr(1.603231,2.094468),new vr(6.041143,7.080126),new vr(2.882459,3.518061),new vr(4.266906,5.178857),new vr(9.041765,10.66308)],HQe=[117.001,114.697,97.404],WQe="tiny_yolov2_model",VQe="tiny_yolov2_separable_conv_model",RA=t=>typeof t=="number";function jQe(t){if(!t)throw new Error(`invalid config: ${t}`);if(typeof t.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${t.withSeparableConvs}`);if(!RA(t.iouThreshold)||t.iouThreshold<0||t.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${t.iouThreshold}`);if(!Array.isArray(t.classes)||!t.classes.length||!t.classes.every(e=>typeof e=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(t.classes)}`);if(!Array.isArray(t.anchors)||!t.anchors.length||!t.anchors.map(e=>e||{}).every(e=>RA(e.x)&&RA(e.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(t.anchors)}`);if(t.meanRgb&&(!Array.isArray(t.meanRgb)||t.meanRgb.length!==3||!t.meanRgb.every(RA)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(t.meanRgb)}`)}function NU(t){return xe(()=>{let e=fe(t,rn(.10000000149011612));return ze(pr(Dt(t,e)),e)})}function Hc(t,e){return xe(()=>{let n=Ml(t,[[0,0],[1,1],[1,1],[0,0]]);return n=zs(n,e.conv.filters,[1,1],"valid"),n=Dt(n,e.bn.sub),n=fe(n,e.bn.truediv),n=ze(n,e.conv.bias),NU(n)})}function Wc(t,e){return xe(()=>{let n=Ml(t,[[0,0],[1,1],[1,1],[0,0]]);return n=Iv(n,e.depthwise_filter,e.pointwise_filter,[1,1],"valid"),n=ze(n,e.bias),NU(n)})}function XQe(t,e){let n=IU(t,e);function r(a,o){let l=cr(t(a)),u=cr(t(a));return e.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:l,truediv:u}}function i(a,o,l){let u=n(a,o,3,`${l}/conv`),c=r(o,`${l}/bn`);return{conv:u,bn:c}}let s=TU(t,e);return{extractConvParams:n,extractConvWithBatchNormParams:i,extractSeparableConvParams:s}}function KQe(t,e,n,r){let{extractWeights:i,getRemainingWeights:s}=gh(t),a=[],{extractConvParams:o,extractConvWithBatchNormParams:l,extractSeparableConvParams:u}=XQe(i,a),c;if(e.withSeparableConvs){let[d,h,p,f,g,y,m,b,w]=r,_=e.isFirstLayerConv2d?o(d,h,3,"conv0"):u(d,h,"conv0"),S=u(h,p,"conv1"),E=u(p,f,"conv2"),C=u(f,g,"conv3"),T=u(g,y,"conv4"),M=u(y,m,"conv5"),k=b?u(m,b,"conv6"):void 0,R=w?u(b,w,"conv7"):void 0,N=o(w||b||m,5*n,1,"conv8");c={conv0:_,conv1:S,conv2:E,conv3:C,conv4:T,conv5:M,conv6:k,conv7:R,conv8:N}}else{let[d,h,p,f,g,y,m,b,w]=r,_=l(d,h,"conv0"),S=l(h,p,"conv1"),E=l(p,f,"conv2"),C=l(f,g,"conv3"),T=l(g,y,"conv4"),M=l(y,m,"conv5"),k=l(m,b,"conv6"),R=l(b,w,"conv7"),N=o(w,5*n,1,"conv8");c={conv0:_,conv1:S,conv2:E,conv3:C,conv4:T,conv5:M,conv6:k,conv7:R,conv8:N}}if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{params:c,paramMappings:a}}function qQe(t,e){let n=tg(t,e);function r(o){let l=n(`${o}/sub`,1),u=n(`${o}/truediv`,1);return{sub:l,truediv:u}}function i(o){let l=n(`${o}/filters`,4),u=n(`${o}/bias`,1);return{filters:l,bias:u}}function s(o){let l=i(`${o}/conv`),u=r(`${o}/bn`);return{conv:l,bn:u}}let a=CU(n);return{extractConvParams:i,extractConvWithBatchNormParams:s,extractSeparableConvParams:a}}function JQe(t,e){let n=[],{extractConvParams:r,extractConvWithBatchNormParams:i,extractSeparableConvParams:s}=qQe(t,n),a;if(e.withSeparableConvs){let o=e.filterSizes&&e.filterSizes.length||9;a={conv0:e.isFirstLayerConv2d?r("conv0"):s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:o>7?s("conv6"):void 0,conv7:o>8?s("conv7"):void 0,conv8:r("conv8")}}else a={conv0:i("conv0"),conv1:i("conv1"),conv2:i("conv2"),conv3:i("conv3"),conv4:i("conv4"),conv5:i("conv5"),conv6:i("conv6"),conv7:i("conv7"),conv8:r("conv8")};return mh(t,n),{params:a,paramMappings:n}}var RU=class{constructor({inputSize:t,scoreThreshold:e}={}){if(this._name="TinyYolov2Options",this._inputSize=t||416,this._scoreThreshold=e||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},rre=class ire extends fh{constructor(e){super("TinyYolov2"),jQe(e),this._config=e}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(e,n){let r=Hc(e,n.conv0);return r=Oi(r,[2,2],[2,2],"same"),r=Hc(r,n.conv1),r=Oi(r,[2,2],[2,2],"same"),r=Hc(r,n.conv2),r=Oi(r,[2,2],[2,2],"same"),r=Hc(r,n.conv3),r=Oi(r,[2,2],[2,2],"same"),r=Hc(r,n.conv4),r=Oi(r,[2,2],[2,2],"same"),r=Hc(r,n.conv5),r=Oi(r,[2,2],[1,1],"same"),r=Hc(r,n.conv6),r=Hc(r,n.conv7),Fb(r,n.conv8,"valid",!1)}runMobilenet(e,n){let r=this.config.isFirstLayerConv2d?NU(Fb(e,n.conv0,"valid",!1)):Wc(e,n.conv0);return r=Oi(r,[2,2],[2,2],"same"),r=Wc(r,n.conv1),r=Oi(r,[2,2],[2,2],"same"),r=Wc(r,n.conv2),r=Oi(r,[2,2],[2,2],"same"),r=Wc(r,n.conv3),r=Oi(r,[2,2],[2,2],"same"),r=Wc(r,n.conv4),r=Oi(r,[2,2],[2,2],"same"),r=Wc(r,n.conv5),r=Oi(r,[2,2],[1,1],"same"),r=n.conv6?Wc(r,n.conv6):r,r=n.conv7?Wc(r,n.conv7):r,Fb(r,n.conv8,"valid",!1)}forwardInput(e,n){let{params:r}=this;if(!r)throw new Error("TinyYolov2 - load model before inference");return xe(()=>{let i=ft(e.toBatchTensor(n,!1),"float32");return i=this.config.meanRgb?s_(i,this.config.meanRgb):i,i=i.div(255),this.config.withSeparableConvs?this.runMobilenet(i,r):this.runTinyYolov2(i,r)})}async forward(e,n){return this.forwardInput(await Hs(e),n)}async detect(e,n={}){let{inputSize:r,scoreThreshold:i}=new RU(n),s=await Hs(e),a=await this.forwardInput(s,r),o=xe(()=>ii(a)[0].expandDims()),l={width:s.getInputWidth(0),height:s.getInputHeight(0)},u=await this.extractBoxes(o,s.getReshapedInputDimensions(0),i);a.dispose(),o.dispose();let c=u.map(f=>f.box),d=u.map(f=>f.score),h=u.map(f=>f.classScore),p=u.map(f=>this.config.classes[f.label]);return DZe(c.map(f=>f.rescale(r)),d,this.config.iouThreshold,!0).map(f=>new xne(d[f],h[f],p[f],c[f],l))}getDefaultModelName(){return""}extractParamsFromWeightMap(e){return JQe(e,this.config)}extractParams(e){let n=this.config.filterSizes||ire.DEFAULT_FILTER_SIZES,r=n?n.length:void 0;if(r!==7&&r!==8&&r!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${r} filterSizes in config`);return KQe(e,this.config,this.boxEncodingSize,n)}async extractBoxes(e,n,r){let{width:i,height:s}=n,a=Math.max(i,s),o=a/i,l=a/s,u=e.shape[1],c=this.config.anchors.length,[d,h,p]=xe(()=>{let m=e.reshape([u,u,c,this.boxEncodingSize]),b=m.slice([0,0,0,0],[u,u,c,4]),w=m.slice([0,0,0,4],[u,u,c,1]),_=this.withClassScores?lh(m.slice([0,0,0,5],[u,u,c,this.config.classes.length]),3):rn(0);return[b,w,_]}),f=[],g=await h.array(),y=await d.array();for(let m=0;m<u;m++)for(let b=0;b<u;b++)for(let w=0;w<c;w++){let _=FN(g[m][b][w][0]);if(!r||_>r){let S=(b+FN(y[m][b][w][0]))/u*o,E=(m+FN(y[m][b][w][1]))/u*l,C=Math.exp(y[m][b][w][2])*this.config.anchors[w].x/u*o,T=Math.exp(y[m][b][w][3])*this.config.anchors[w].y/u*l,M=S-C/2,k=E-T/2,R={row:m,col:b,anchor:w},{classScore:N,label:B}=this.withClassScores?await this.extractPredictedClass(p,R):{classScore:1,label:0};f.push({box:new vne(M,k,M+C,k+T),score:_,classScore:_*N,label:B,...R})}}return d.dispose(),h.dispose(),p.dispose(),f}async extractPredictedClass(e,n){let{row:r,col:i,anchor:s}=n,a=await e.array();return Array(this.config.classes.length).fill(0).map((o,l)=>a[r][i][s][l]).map((o,l)=>({classScore:o,label:l})).reduce((o,l)=>o.classScore>l.classScore?o:l)}};rre.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var sre=rre,YQe=class extends sre{constructor(t=!0){let e={withSeparableConvs:t,iouThreshold:$Qe,classes:["face"],...t?{anchors:GQe,meanRgb:HQe}:{anchors:zQe,withClassScores:!0}};super(e)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(t,e){return(await this.detect(t,e)).map(n=>new Il(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?VQe:WQe}extractParamsFromWeightMap(t){return super.extractParamsFromWeightMap(t)}},aE=class extends RU{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},a_=class{async then(t){return t(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function MM(t,e,n,r,i=({alignedRect:s})=>s){let s=t.map(l=>jne(l)?i(l):l.detection),a=r||(e instanceof In?await EU(e,s):await AU(e,s)),o=await n(a);return a.forEach(l=>l instanceof In&&l.dispose()),o}async function FU(t,e,n,r,i){return MM([t],e,async s=>n(s[0]),r,i)}var ZQe=.4,QQe=[new vr(1.603231,2.094468),new vr(6.041143,7.080126),new vr(2.882459,3.518061),new vr(4.266906,5.178857),new vr(9.041765,10.66308)],eet=[117.001,114.697,97.404],tet=class extends sre{constructor(){let t={withSeparableConvs:!0,iouThreshold:ZQe,classes:["face"],anchors:QQe,meanRgb:eet,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(t)}get anchors(){return this.config.anchors}async locateFaces(t,e){return(await this.detect(t,e)).map(n=>new Il(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(t){return super.extractParamsFromWeightMap(t)}},La={ssdMobilenetv1:new UQe,tinyFaceDetector:new tet,tinyYolov2:new YQe,faceLandmark68Net:new pQe,faceLandmark68TinyNet:new yQe,faceRecognitionNet:new AQe,faceExpressionNet:new ZZe,ageGenderNet:new hQe},are=class extends a_{constructor(t,e,n){super(),this.parentTask=t,this.input=e,this.extractedFaces=n}},DU=class extends are{async run(){let t=await this.parentTask,e=await MM(t,this.input,async n=>Promise.all(n.map(r=>La.faceExpressionNet.predictExpressions(r))),this.extractedFaces);return t.map((n,r)=>Vne(n,e[r]))}withAgeAndGender(){return new BU(this,this.input)}},PU=class extends are{async run(){let t=await this.parentTask;if(!t)return;let e=await FU(t,this.input,n=>La.faceExpressionNet.predictExpressions(n),this.extractedFaces);return Vne(t,e)}withAgeAndGender(){return new UU(this,this.input)}},LU=class extends DU{withAgeAndGender(){return new $U(this,this.input)}withFaceDescriptors(){return new GU(this,this.input)}},OU=class extends PU{withAgeAndGender(){return new zU(this,this.input)}withFaceDescriptor(){return new HU(this,this.input)}},ore=class extends a_{constructor(t,e,n){super(),this.parentTask=t,this.input=e,this.extractedFaces=n}},BU=class extends ore{async run(){let t=await this.parentTask,e=await MM(t,this.input,async n=>Promise.all(n.map(r=>La.ageGenderNet.predictAgeAndGender(r))),this.extractedFaces);return t.map((n,r)=>{let{age:i,gender:s,genderProbability:a}=e[r];return tre(nre(n,s,a),i)})}withFaceExpressions(){return new DU(this,this.input)}},UU=class extends ore{async run(){let t=await this.parentTask;if(!t)return;let{age:e,gender:n,genderProbability:r}=await FU(t,this.input,i=>La.ageGenderNet.predictAgeAndGender(i),this.extractedFaces);return tre(nre(t,n,r),e)}withFaceExpressions(){return new PU(this,this.input)}},$U=class extends BU{withFaceExpressions(){return new LU(this,this.input)}withFaceDescriptors(){return new GU(this,this.input)}},zU=class extends UU{withFaceExpressions(){return new OU(this,this.input)}withFaceDescriptor(){return new HU(this,this.input)}},lre=class extends a_{constructor(t,e){super(),this.parentTask=t,this.input=e}},GU=class extends lre{async run(){let t=await this.parentTask;return(await MM(t,this.input,e=>Promise.all(e.map(n=>La.faceRecognitionNet.computeFaceDescriptor(n))),null,e=>e.landmarks.align(null,{useDlibAlignment:!0}))).map((e,n)=>ere(t[n],e))}withFaceExpressions(){return new LU(this,this.input)}withAgeAndGender(){return new $U(this,this.input)}},HU=class extends lre{async run(){let t=await this.parentTask;if(!t)return;let e=await FU(t,this.input,n=>La.faceRecognitionNet.computeFaceDescriptor(n),null,n=>n.landmarks.align(null,{useDlibAlignment:!0}));return ere(t,e)}withFaceExpressions(){return new OU(this,this.input)}withAgeAndGender(){return new zU(this,this.input)}},ure=class extends a_{constructor(t,e,n){super(),this.parentTask=t,this.input=e,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?La.faceLandmark68TinyNet:La.faceLandmark68Net}},net=class extends ure{async run(){let t=await this.parentTask,e=t.map(i=>i.detection),n=this.input instanceof In?await EU(this.input,e):await AU(this.input,e),r=await Promise.all(n.map(i=>this.landmarkNet.detectLandmarks(i)));return n.forEach(i=>i instanceof In&&i.dispose()),t.filter((i,s)=>r[s]).map((i,s)=>Xne(i,r[s]))}withFaceExpressions(){return new LU(this,this.input)}withAgeAndGender(){return new $U(this,this.input)}withFaceDescriptors(){return new GU(this,this.input)}},ret=class extends ure{async run(){let t=await this.parentTask;if(!t)return;let{detection:e}=t,n=this.input instanceof In?await EU(this.input,[e]):await AU(this.input,[e]),r=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach(i=>i instanceof In&&i.dispose()),Xne(t,r)}withFaceExpressions(){return new OU(this,this.input)}withAgeAndGender(){return new zU(this,this.input)}withFaceDescriptor(){return new HU(this,this.input)}},cre=class extends a_{constructor(t,e=new CM){super(),this.input=t,this.options=e}},iet=class extends cre{async run(){let{input:t,options:e}=this,n;if(e instanceof aE)n=La.tinyFaceDetector.locateFaces(t,e);else if(e instanceof CM)n=La.ssdMobilenetv1.locateFaces(t,e);else if(e instanceof RU)n=La.tinyYolov2.locateFaces(t,e);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return n}runAndExtendWithFaceDetections(){return new Promise((t,e)=>{this.run().then(n=>t(n.map(r=>Ane({},r)))).catch(n=>e(n))})}withFaceLandmarks(t=!1){return new net(this.runAndExtendWithFaceDetections(),this.input,t)}withFaceExpressions(){return new DU(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new BU(this.runAndExtendWithFaceDetections(),this.input)}},set=class extends cre{async run(){let t=await new iet(this.input,this.options),e=t[0];return t.forEach(n=>{n.score>e.score&&(e=n)}),e}runAndExtendWithFaceDetection(){return new Promise(async t=>{let e=await this.run();t(e?Ane({},e):void 0)})}withFaceLandmarks(t=!1){return new ret(this.runAndExtendWithFaceDetection(),this.input,t)}withFaceExpressions(){return new PU(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new UU(this.runAndExtendWithFaceDetection(),this.input)}};function LN(t,e=new CM){return new set(t,e)}async function aet(t,e){console.log("Creating GLB from texture...");const n=new Zd({map:t,side:ta,roughness:.5,metalness:.1});t.flipY=!1,t.colorSpace=Ui,t.needsUpdate=!0;const r=e,i=1;let s;const a=window.lastFaceLandmarks;if(a&&Array.isArray(a)){console.log("Creating 3D face mesh from",a.length,"landmarks");const m=[],b=[],w=[];for(const _ of a){const S=Math.sqrt(Math.pow(_.x/t.image.width-.5,2)+Math.pow(_.y/t.image.height-.5,2)),E=.2*Math.exp(-S*5)+_.z;m.push((_.x/t.image.width-.5)*r,-(_.y/t.image.height-.5)*i,E),w.push(_.x/t.image.width,1-_.y/t.image.height)}for(let _=0;_<16;_++)b.push(_,_+1,36);b.push(36,37,41),b.push(37,38,41),b.push(38,39,41),b.push(39,40,41),b.push(42,43,47),b.push(43,44,47),b.push(44,45,47),b.push(45,46,47),b.push(27,28,29),b.push(28,29,30),b.push(29,30,31),b.push(30,31,32),b.push(31,32,33),b.push(31,33,34),b.push(33,34,35);for(let _=48;_<59;_++)b.push(_,_+1,66);b.push(59,48,66);for(let _=60;_<67;_++)b.push(_,_+1,66);b.push(67,60,66),s=new An,s.setAttribute("position",new Jt(m,3)),s.setAttribute("uv",new Jt(w,2)),s.setIndex(b)}else console.warn("No face landmarks available, falling back to simple plane geometry"),s=new yu(r,i);s.computeVertexNormals();const o=new Cr(s,n);o.name="CapturedFace",o.rotation.y=Math.PI,o.castShadow=!0,o.receiveShadow=!0;const l=s.getAttribute("position"),u=s.getAttribute("normal"),c=l.array,d=u.array,h=new Map;for(let m=0;m<l.count;m++){const b=[Math.round(c[m*3]*1e3)/1e3,Math.round(c[m*3+1]*1e3)/1e3,Math.round(c[m*3+2]*1e3)/1e3].join(","),w=h.get(b)||[];w.push(m),h.set(b,w)}h.forEach(m=>{if(m.length>1){const b=new Z;m.forEach(w=>{b.add(new Z(d[w*3],d[w*3+1],d[w*3+2]))}),b.divideScalar(m.length).normalize(),m.forEach(w=>{d[w*3]=b.x,d[w*3+1]=b.y,d[w*3+2]=b.z})}}),u.needsUpdate=!0;const p=new oc,f=new JT(16777215,.3);p.add(f);const g=new Q1(16777215,1);g.position.set(0,0,1),g.target.position.set(0,0,0),p.add(g.target),p.add(g),p.add(o);const y=new Qr(45,r/i,.1,1e3);return y.position.z=2,p.add(y),new Promise((m,b)=>{new h1().parse(p,_=>{const S=new Blob([_],{type:"model/gltf-binary"}),E=URL.createObjectURL(S);m(E)},_=>{console.error("Error exporting GLB:",_),b(_)},{binary:!0,includeCustomExtensions:!0,onlyVisible:!0})})}const lp=class lp{constructor(){Zo(this,"videoElement",null);Zo(this,"analysisCanvas");Zo(this,"analysisContext");Zo(this,"debugCanvas",null);Zo(this,"debugContext",null);Zo(this,"isAnalyzing",!1);Zo(this,"lastAnalysis",null);Zo(this,"onFrameAnalyzed",null);Zo(this,"modelsLoaded",!1);this.analysisCanvas=document.createElement("canvas");const e=this.analysisCanvas.getContext("2d");if(!e)throw new Error("Failed to get 2D context");this.analysisContext=e}static getInstance(){return lp.instance||(lp.instance=new lp),lp.instance}async loadFaceDetectionModels(){if(this.modelsLoaded){console.log("Models already loaded, skipping");return}console.log("Starting face detection model loading...");try{try{if(console.log("Attempting to reset TensorFlow engine..."),Vc&&typeof Vc.engine=="function"){const a=Vc.engine();a&&typeof a.reset=="function"&&(a.reset(),console.log("TensorFlow engine reset successful"))}Vc&&"setBackend"in Vc&&typeof Vc.setBackend=="function"&&(await Vc.setBackend("webgl"),console.log("Set TensorFlow backend to WebGL"))}catch(a){console.warn("Could not reset TensorFlow engine:",a)}const e=["https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.15/model","https://unpkg.com/@vladmandic/face-api@1.7.15/model","https://vladmandic.github.io/face-api/model","/models","/TexWeb/models"],n=a=>{console.log(a),window&&typeof window.updateModelLoadingStatus=="function"&&window.updateModelLoadingStatus(a)},r=async(a,o,l,u=2e4)=>new Promise((c,d)=>{const h=setTimeout(()=>{console.error(`Timeout: Loading ${o} from ${l} timed out after ${u/1e3} seconds`),d(new Error(`Loading ${o} from ${l} timed out after ${u/1e3} seconds`))},u);try{console.log(`Starting to load ${o} from ${l}...`),n(`Loading ${o} from ${l}...`),a.loadFromUri(l).then(()=>{console.log(`SUCCESS: ${o} loaded successfully from ${l}`),n(`${o} loaded successfully from ${l}`),clearTimeout(h),c()}).catch(p=>{console.error(`ERROR: Failed to load ${o} from ${l}:`,p),clearTimeout(h),d(p)})}catch(p){console.error(`EXCEPTION: Error loading ${o} from ${l}:`,p),clearTimeout(h),d(p)}});let i=null;for(const a of e){console.log(`Attempting to load models from: ${a}`);try{await r(La.tinyFaceDetector,"TinyFaceDetector",a),await r(La.faceLandmark68Net,"FaceLandmark68",a),await r(La.faceRecognitionNet,"FaceRecognition",a),console.log(`All face detection models loaded successfully from ${a}`),this.modelsLoaded=!0;return}catch(o){console.warn(`Failed to load models from ${a}:`,o),i=o}}console.error("Failed to load models from all paths:",i);const s=i instanceof Error?i.message:String(i);throw new Error(`Failed to load face detection models from all paths: ${s||"Unknown error"}`)}catch(e){throw console.error("Error during model loading:",e),new Error("Failed to load face detection models. Please ensure model files are correctly installed.")}}async initializeCamera(e){this.videoElement=e,await this.loadFaceDetectionModels();try{const n=await navigator.mediaDevices.getUserMedia({video:{facingMode:"user",width:{ideal:1280},height:{ideal:720}}});this.videoElement.srcObject=n,await new Promise(r=>{this.videoElement&&(this.videoElement.onloadedmetadata=()=>{this.videoElement&&(this.videoElement.play(),this.analysisCanvas.width=this.videoElement.videoWidth,this.analysisCanvas.height=this.videoElement.videoHeight,this.debugCanvas&&(this.debugCanvas.width=this.videoElement.videoWidth,this.debugCanvas.height=this.videoElement.videoHeight)),r()})})}catch(n){throw console.error("Error initializing camera:",n),n}}setDebugCanvas(e){if(this.debugCanvas=e,e){const n=e.getContext("2d");if(!n)throw new Error("Failed to get debug canvas 2D context");this.debugContext=n,this.videoElement&&(e.width=this.videoElement.videoWidth,e.height=this.videoElement.videoHeight)}else this.debugContext=null}startAnalysis(e){this.isAnalyzing||(this.isAnalyzing=!0,this.onFrameAnalyzed=e||null,requestAnimationFrame(()=>this.analyze()))}stopAnalysis(){this.isAnalyzing=!1,this.onFrameAnalyzed=null}validateFacePosition(e){if(!e||!this.analysisCanvas)return!1;const{box:n}=e,r=this.analysisCanvas.width,i=this.analysisCanvas.height,s={min:r*.25,max:r*.75},a={min:i*.25,max:i*.75},o={x:n.x+n.width/2,y:n.y+n.height/2},l=i*.2,u=n.height>=l,c=o.x>=s.min&&o.x<=s.max&&o.y>=a.min&&o.y<=a.max;return u||console.log(`Face too small: ${n.height.toFixed(0)}px, minimum required: ${l.toFixed(0)}px`),c||console.log(`Face not centered: position (${o.x.toFixed(0)}, ${o.y.toFixed(0)}), 
        valid X range: ${s.min.toFixed(0)}-${s.max.toFixed(0)}, 
        valid Y range: ${a.min.toFixed(0)}-${a.max.toFixed(0)}`),u&&c}async detectFace(e){try{console.log("Starting face detection process...");try{console.log("Attempting face detection with TinyFaceDetector...");const r=new aE({inputSize:416,scoreThreshold:.5});console.log("Detector options:",JSON.stringify(r));const i=await LN(e,r).withFaceLandmarks().withFaceDescriptor();if(console.log("Detection result:",i?"Found face":"No face found"),i){console.log("Face landmarks found:",i.landmarks.positions.length);const s=i==null?void 0:i.detection;if(s){console.log("Face detected with score:",s.score,"at position:",JSON.stringify(s.box));const a=this.validateFacePosition(s);return console.log("Face position valid:",a),a?s:(console.log("Face detected but position is invalid"),null)}}}catch(r){console.warn("Face landmark detection failed:",r)}console.log("Falling back to basic face detection...");const n=await LN(e,new aE({inputSize:320,scoreThreshold:.4}));return n?(console.log("Face detected with basic detection"),this.validateFacePosition(n)?n:(console.log("Face detected but position is invalid"),null)):(console.log("No face detected"),null)}catch(n){return console.error("Error in face detection pipeline:",n),null}}async analyze(){if(!(!this.isAnalyzing||!this.videoElement)){try{this.analysisContext.drawImage(this.videoElement,0,0,this.analysisCanvas.width,this.analysisCanvas.height);const e=await this.detectFace(this.analysisCanvas),n=!!e,r=this.analysisContext.getImageData(0,0,this.analysisCanvas.width,this.analysisCanvas.height),i=await this.getFaceLandmarks(this.analysisCanvas);i&&(window.lastFaceLandmarks=i),this.lastAnalysis={imageData:r,aspectRatio:this.analysisCanvas.width/this.analysisCanvas.height,hasValidPose:n,faceDetection:e??void 0,faceLandmarks:i??void 0},this.drawDebugView(),this.onFrameAnalyzed&&this.onFrameAnalyzed(n)}catch(e){console.error("Error in analysis:",e)}requestAnimationFrame(()=>this.analyze())}}drawDebugView(){if(!(!this.debugContext||!this.lastAnalysis))if(this.debugContext.clearRect(0,0,this.debugCanvas.width,this.debugCanvas.height),this.debugContext.drawImage(this.analysisCanvas,0,0),this.lastAnalysis.faceDetection){const{box:e}=this.lastAnalysis.faceDetection;this.debugContext.strokeStyle="#00ff00",this.debugContext.lineWidth=2,this.debugContext.strokeRect(e.x,e.y,e.width,e.height),this.debugContext.fillStyle="#00ff00",this.debugContext.font="20px Arial",this.debugContext.fillText("Face Detected",10,30)}else this.debugContext.fillStyle="#ff0000",this.debugContext.font="20px Arial",this.debugContext.fillText("No Face Detected",10,30)}async captureAndCreateGLB(){if(!this.lastAnalysis||!this.lastAnalysis.hasValidPose)return console.warn("No valid pose detected for capture"),null;try{console.log("Starting GLB creation...");const e=await new Promise(i=>{this.analysisCanvas.toBlob(s=>i(s),"image/jpeg",.95)});console.log("Created image blob:",e.size,"bytes");const n=URL.createObjectURL(e);let r=null;try{r=await this.createTextureFromUrl(n),console.log("Texture created successfully");const i=await aet(r,this.lastAnalysis.aspectRatio);return console.log("GLB processing complete"),i}finally{URL.revokeObjectURL(n),r&&r.dispose()}}catch(e){throw console.error("Error creating GLB from camera:",e),e}}async createTextureFromUrl(e){return new Promise((n,r)=>{const i=new qT;i.setCrossOrigin("anonymous");const s=setTimeout(()=>{r(new Error("Texture loading timed out after 10 seconds"))},1e4);i.load(e,a=>{clearTimeout(s),a.colorSpace=Ui,"encoding"in a&&(a.encoding=void 0),a.needsUpdate=!0,a.generateMipmaps=!0,a.minFilter=Ma,a.magFilter=er,a.wrapS=jr,a.wrapT=jr,console.log("Texture loaded successfully with dimensions:",a.image.width,"x",a.image.height),n(a)},a=>{console.log(`Texture loading: ${Math.round(a.loaded/a.total*100)}%`)},a=>{clearTimeout(s),console.error("Error loading texture:",a),r(a)})})}async getFaceLandmarks(e){try{const n=await LN(e,new aE).withFaceLandmarks();return n?n.landmarks.positions.map(s=>{const a=this.estimateDepthFromLandmark(s,n.landmarks);return{x:s.x,y:s.y,z:a}}):null}catch(n){return console.error("Error getting face landmarks:",n),null}}estimateDepthFromLandmark(e,n){const i=n.getNose()[3],s=e.x-i.x,a=e.y-i.y,o=Math.sqrt(s*s+a*a),l=.2,u=100;return l*Math.exp(-(o*o)/(2*u*u))}cleanup(){var e;this.stopAnalysis(),(e=this.videoElement)!=null&&e.srcObject&&this.videoElement.srcObject.getTracks().forEach(r=>r.stop()),this.videoElement=null,this.debugCanvas=null,this.debugContext=null,this.lastAnalysis=null}};Zo(lp,"instance");let hD=lp;function oet({isOpen:t,onClose:e,onCapture:n}){const r=ne.useRef(null),i=ne.useRef(null),s=ne.useRef(null),[a,o]=ne.useState(!1),[l,u]=ne.useState(null),[c,d]=ne.useState(!1),[h,p]=ne.useState(!1),[f,g]=ne.useState("Loading face detection models..."),[y,m]=ne.useState("models");ne.useEffect(()=>{if(t&&r.current&&i.current)return(async()=>{p(!0),u(null),m("models");try{console.log("Initializing camera..."),s.current=hD.getInstance(),window.updateModelLoadingStatus=_=>{console.log("Model loading status:",_),g(_)},s.current.setDebugCanvas(i.current);try{m("models"),g("Loading face detection models..."),await s.current.initializeCamera(r.current),console.log("Camera initialized, starting analysis..."),m("camera"),g("Camera initialized, starting face detection..."),s.current.startAnalysis(_=>{o(_),_&&y!=="ready"&&m("ready")}),console.log("Analysis started")}catch(_){console.error("Failed to initialize face models:",_),u(`Failed to load face detection models: ${(_==null?void 0:_.message)||"Unknown error"}. 
              Try reloading the page or using a different browser.`),m("error"),setTimeout(e,5e3);return}}catch(_){console.error("Failed to initialize camera:",_),u((_==null?void 0:_.message)||"Failed to access camera. Please ensure camera permissions are granted."),m("error"),setTimeout(e,5e3)}finally{p(!1)}})(),()=>{window.updateModelLoadingStatus=void 0,s.current&&(s.current.cleanup(),s.current=null)}},[t,e]);const b=async()=>{if(!(!s.current||!a)){u(null),d(!0);try{console.log("Starting capture process...");const w=await s.current.captureAndCreateGLB();if(w)console.log("Capture successful, GLB URL length:",w.length),n(w),e();else throw new Error("Failed to create GLB - no URL returned")}catch(w){console.error("Capture failed:",w),u("Failed to process image. Please try again.")}finally{d(!1)}}};return t?D.jsxs("div",{className:"fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm",children:["      ",D.jsxs("div",{className:"relative w-full max-w-2xl bg-white rounded-lg shadow-xl overflow-hidden",children:[D.jsxs("div",{className:"relative aspect-video",children:[(c||h)&&D.jsx("div",{className:"absolute inset-0 bg-black/50 flex items-center justify-center z-10",children:D.jsxs("div",{className:"text-white text-center p-4 max-w-md",children:[D.jsx("div",{className:"animate-spin rounded-full h-12 w-12 border-4 border-white border-t-transparent mx-auto mb-3"}),c?D.jsx("p",{className:"text-lg font-medium",children:"Processing capture..."}):D.jsxs(D.Fragment,{children:[D.jsx("p",{className:"text-lg font-medium mb-2",children:y==="models"?"Loading face detection models...":y==="camera"?"Initializing camera...":"Starting face detection..."}),D.jsx("p",{className:"text-sm opacity-80",children:f}),y==="models"&&D.jsx("p",{className:"text-xs mt-4 opacity-70",children:"This may take a moment on first load. If it takes too long, try refreshing the page."})]})]})}),D.jsx("video",{ref:r,autoPlay:!0,playsInline:!0,muted:!0,className:"hidden"}),D.jsx("canvas",{ref:i,className:"absolute inset-0 w-full h-full object-cover"}),!h&&!c&&D.jsx("div",{className:"absolute inset-0 flex items-center justify-center pointer-events-none",children:D.jsx("div",{className:`w-1/2 h-1/2 border-2 rounded-lg ${a?"border-green-500":"border-yellow-500"} transition-colors`,children:D.jsx("div",{className:"absolute inset-0 flex items-center justify-center",children:D.jsx("p",{className:"text-lg font-medium text-white text-center bg-black/50 px-4 py-2 rounded-lg",children:a?"Perfect! Click capture.":"Position your face in the frame"})})})}),D.jsx("button",{onClick:e,className:"absolute top-4 right-4 p-2 bg-white/90 rounded-full hover:bg-white transition-colors",children:D.jsx(Fy,{className:"w-6 h-6"})})]}),"        ",l&&D.jsx("div",{className:"p-4 bg-red-50 border-t border-red-100",children:D.jsxs("div",{className:"flex items-start",children:[D.jsx(ile,{className:"w-5 h-5 text-red-500 mt-0.5 mr-2 flex-shrink-0"}),D.jsxs("div",{children:[D.jsx("h4",{className:"text-red-700 font-medium mb-1",children:"Error"}),D.jsx("p",{className:"text-red-600 text-sm whitespace-pre-line",children:l}),l.includes("models")&&D.jsxs("div",{className:"mt-2 text-xs text-red-500",children:[D.jsx("p",{children:"Possible solutions:"}),D.jsxs("ul",{className:"list-disc pl-4 mt-1 space-y-1",children:[D.jsx("li",{children:"Try refreshing the page"}),D.jsx("li",{children:"Try using a different browser (Chrome or Edge recommended)"}),D.jsx("li",{children:"Check your internet connection"}),D.jsx("li",{children:"Temporarily disable any content blockers"})]})]}),l.includes("camera")&&D.jsxs("div",{className:"mt-2 text-xs text-red-500",children:[D.jsx("p",{children:"Possible solutions:"}),D.jsxs("ul",{className:"list-disc pl-4 mt-1 space-y-1",children:[D.jsx("li",{children:"Make sure your camera is connected and working"}),D.jsx("li",{children:"Allow camera permissions in your browser"}),D.jsx("li",{children:"Close other apps that might be using your camera"})]})]})]})]})}),D.jsx("div",{className:"p-4 bg-gray-50 border-t border-gray-100",children:D.jsxs("button",{onClick:b,disabled:!a||c||h,className:`
              w-full py-3 px-4 rounded-lg flex items-center justify-center space-x-2
              ${a&&!c&&!h?"bg-rose-600 hover:bg-rose-700 text-white":"bg-gray-100 text-gray-400 cursor-not-allowed"}
              transition-colors
            `,children:[D.jsx(pj,{className:"w-5 h-5"}),D.jsx("span",{children:h?"Initializing...":c?"Processing...":"Capture"})]})})]})]}):null}function uet({onImageSelected:t}){const e=ne.useRef(null),n=ne.useRef(null),r=ne.useRef(null),[i,s]=ne.useState(!1),[a,o]=ne.useState(!1),l=ne.useCallback(async d=>{var p;const h=(p=d.target.files)==null?void 0:p[0];if(h&&gN.isValidImageFile(h)){o(!0);try{const f=await gN.convertImageToTexture(h);f&&t(f)}finally{o(!1)}}},[t]),u=ne.useCallback(async()=>{try{const d=await navigator.mediaDevices.getUserMedia({video:!0});r.current=d,s(!0)}catch(d){console.error("Error accessing camera:",d)}},[]),c=ne.useCallback(async()=>{if(n.current){o(!0);try{const d=document.createElement("canvas");d.width=n.current.videoWidth,d.height=n.current.videoHeight;const h=d.getContext("2d");if(h){h.drawImage(n.current,0,0);const p=await new Promise(f=>d.toBlob(f,"image/jpeg"));if(p){const f=new File([p],"photo.jpg",{type:"image/jpeg"}),g=await gN.convertImageToTexture(f);g&&t(g)}}}finally{r.current&&(r.current.getTracks().forEach(d=>d.stop()),r.current=null),o(!1),s(!1)}}},[t]);return D.jsxs(D.Fragment,{children:["      ",D.jsxs("div",{className:"absolute top-4 right-4 z-20 flex items-center gap-2",children:[D.jsx("input",{ref:e,type:"file",accept:"image/*",onChange:l,className:"hidden"}),a&&D.jsxs("div",{className:"px-3 py-1 bg-white/90 rounded-full text-sm text-gray-700 shadow-lg backdrop-blur-sm flex items-center gap-2",children:[D.jsx(K4,{className:"w-4 h-4 animate-spin"}),"Processing image..."]}),D.jsx("button",{onClick:()=>{var d;return(d=e.current)==null?void 0:d.click()},className:"p-2 bg-white rounded-full shadow-lg hover:bg-gray-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed",title:"Upload image",disabled:a,children:a?D.jsx(K4,{className:"w-5 h-5 text-gray-700 animate-spin"}):D.jsx(_le,{className:"w-5 h-5 text-gray-700"})}),D.jsx("button",{onClick:u,className:"p-2 bg-white rounded-full shadow-lg hover:bg-gray-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed",title:"Take photo",disabled:a,children:D.jsx(pj,{className:"w-5 h-5 text-gray-700"})})]}),D.jsx(oet,{isOpen:i,onClose:()=>{r.current&&(r.current.getTracks().forEach(d=>d.stop()),r.current=null),s(!1)},onCapture:c,isLoading:a}),D.jsx("video",{ref:n,className:"hidden",autoPlay:!0,playsInline:!0})]})}const cet={itemType:"T-shirt",color:"#000000",standardSize:"M",measurements:S3.M,zoom:1};function M5(){const[t,e]=ne.useState(cet),[n,r]=ne.useState(!1),[i,s]=ne.useState(null),a=h0(),o=O1();ne.useEffect(()=>{o.pathname.includes("/design/")&&a("/design",{replace:!0})},[o.pathname,a]);const l=d=>{if(console.log("Settings changed:",d),d.itemType==="Full Body"){const h=d.standardSize;e({...d,measurements:{...d.measurements,height:S3[h].height}})}else e(d)},u=()=>{requestAnimationFrame(()=>{r(d=>!d)})},c=(d,h)=>{e(p=>({...p,measurements:{...p.measurements,[d]:h}}))};return D.jsxs("div",{className:"design-container",children:[D.jsx(Zve,{settings:t,isPanelOpen:n,onPanelToggle:u,onSettingsChange:l,onMeasurementChange:c}),D.jsx("div",{className:"design-preview",children:D.jsxs("div",{className:"model-container relative",children:[D.jsx(Xve,{modelUrl:i,modelType:t.itemType,color:t.color,zoom:t.zoom||1,...t.measurements}),D.jsx("div",{className:"absolute top-4 right-4 z-10",children:D.jsx(uet,{onImageSelected:s})})]})})]})}const det=()=>{const{loginWithRedirect:t,logout:e,user:n,isAuthenticated:r,isLoading:i}=hj();return h0(),i?D.jsx("div",{className:"min-h-screen flex items-center justify-center",children:D.jsx("div",{className:"animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-rose-600"})}):r?D.jsx("div",{className:"min-h-screen flex items-center justify-center bg-gray-50",children:D.jsxs("div",{className:"z-10 max-w-md w-full space-y-8 p-8 bg-white rounded-xl shadow-2xl",children:[D.jsxs("div",{className:"text-center",children:[D.jsx("img",{src:n==null?void 0:n.picture,alt:n==null?void 0:n.name,className:"mx-auto h-24 w-24 rounded-full"}),D.jsxs("h2",{className:"mt-6 text-3xl font-extrabold text-gray-900",children:["Welcome, ",n==null?void 0:n.name,"!"]}),D.jsx("p",{className:"mt-2 text-sm text-gray-600",children:n==null?void 0:n.email})]}),D.jsx("div",{className:"mt-8",children:D.jsx("button",{onClick:()=>e({logoutParams:{returnTo:window.location.origin}}),className:"w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-rose-600 hover:bg-rose-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-rose-500 transition-colors duration-200",children:"Sign Out"})})]})}):D.jsxs("div",{className:"min-h-screen flex items-center justify-center bg-gray-50",children:[D.jsx("div",{className:"absolute inset-0 bg-cover bg-center opacity-30",style:{backgroundImage:'url("https://images.unsplash.com/photo-1528578950694-9f79b45a3397?auto=format&fit=crop&q=80")'}}),D.jsxs("div",{className:"z-10 max-w-md w-full space-y-8 p-8 bg-white rounded-xl shadow-2xl",children:[D.jsxs("div",{children:[D.jsx("h2",{className:"mt-6 text-center text-3xl font-extrabold text-gray-900",children:"Welcome to TexWeb"}),D.jsx("p",{className:"mt-2 text-center text-sm text-gray-600",children:"Please sign in to continue"})]}),D.jsx("div",{className:"mt-8",children:D.jsx("button",{onClick:()=>t(),className:"w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-rose-600 hover:bg-rose-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-rose-500 transition-colors duration-200",children:"Sign In / Sign Up with Auth0"})})]})]})},dre=ne.createContext(void 0),het=({children:t})=>{const[e,n]=ne.useState([]),r=o=>{s(o.id)||n(l=>[...l,{...o,createdAt:new Date}])},i=o=>{n(l=>l.filter(u=>u.id!==o))},s=o=>e.some(l=>l.id===o),a=()=>{n([])};return D.jsx(dre.Provider,{value:{wishlistItems:e,addToWishlist:r,removeFromWishlist:i,isInWishlist:s,clearWishlist:a},children:t})},pet=()=>{const t=ne.useContext(dre);if(t===void 0)throw new Error("useWishlist must be used within a WishlistProvider");return t},fet=()=>D.jsx("div",{className:"max-w-7xl mx-auto",children:D.jsx("div",{className:"bg-white rounded-lg shadow min-h-[calc(100vh-4rem)]",children:D.jsx(doe,{})})}),met=()=>{const t=[{id:"ORD-2025-001",date:"2025-06-20",status:"delivered",total:149.99,items:2},{id:"ORD-2025-002",date:"2025-06-18",status:"shipped",total:89.99,items:1}],e=n=>({pending:"bg-yellow-100 text-yellow-800",processing:"bg-blue-100 text-blue-800",shipped:"bg-purple-100 text-purple-800",delivered:"bg-green-100 text-green-800"})[n];return D.jsx("div",{className:"max-w-7xl mx-auto px-4 py-8",children:D.jsxs("div",{className:"bg-white rounded-lg shadow",children:[D.jsxs("div",{className:"border-b border-gray-200 px-6 py-4",children:[D.jsxs("div",{className:"flex items-center space-x-3",children:[D.jsx(DR,{className:"h-6 w-6 text-rose-600"}),D.jsx("h1",{className:"text-2xl font-semibold text-gray-900",children:"My Orders"})]}),D.jsxs("div",{className:"mt-4 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4",children:[D.jsxs("div",{className:"relative flex-1 max-w-md",children:[D.jsx("input",{type:"text",placeholder:"Search orders...",className:"w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-rose-500 focus:border-transparent"}),D.jsx(yle,{className:"absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400"})]}),D.jsxs("button",{className:"inline-flex items-center px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium text-gray-700 hover:bg-gray-50",children:[D.jsx(dle,{className:"h-4 w-4 mr-2"}),"Filter"]})]})]}),D.jsx("div",{className:"divide-y divide-gray-200",children:t.length===0?D.jsxs("div",{className:"text-center py-12",children:[D.jsx(DR,{className:"h-16 w-16 text-gray-400 mx-auto mb-4"}),D.jsx("h3",{className:"text-lg font-medium text-gray-900",children:"No orders yet"}),D.jsx("p",{className:"mt-1 text-gray-500",children:"When you place an order, it will appear here"}),D.jsx("div",{className:"mt-6",children:D.jsx("a",{href:"/",className:"inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-rose-600 hover:bg-rose-700",children:"Start Shopping"})})]}):t.map(n=>D.jsx("div",{className:"p-6 hover:bg-gray-50 transition-colors duration-150 cursor-pointer",children:D.jsx("div",{className:"flex items-center justify-between",children:D.jsxs("div",{className:"flex-1",children:[D.jsxs("div",{className:"flex items-center justify-between",children:[D.jsx("h3",{className:"text-lg font-medium text-gray-900",children:n.id}),D.jsx(ule,{className:"h-5 w-5 text-gray-400"})]}),D.jsxs("div",{className:"mt-2 flex items-center justify-between",children:[D.jsxs("div",{className:"flex items-center space-x-4",children:[D.jsx("span",{className:"text-sm text-gray-500",children:new Date(n.date).toLocaleDateString()}),D.jsx("span",{className:`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${e(n.status)}`,children:n.status.charAt(0).toUpperCase()+n.status.slice(1)})]}),D.jsxs("div",{className:"text-right",children:[D.jsxs("p",{className:"text-sm font-medium text-gray-900",children:["$",n.total.toFixed(2)]}),D.jsxs("p",{className:"text-sm text-gray-500",children:[n.items," ",n.items===1?"item":"items"]})]})]})]})})},n.id))})]})})},get=()=>{const[t,e]=ne.useState(!1),[n,r]=ne.useState(null),[i,s]=ne.useState({type:"home",name:"",address:"",city:"",state:"",pincode:"",phone:"",isDefault:!1}),[a,o]=ne.useState([{id:"1",type:"home",name:"John Doe",address:"123 Main Street",city:"New York",state:"NY",pincode:"10001",phone:"123-456-7890",isDefault:!0}]),l=p=>{switch(p){case"home":return D.jsx(hle,{className:"h-5 w-5"});case"office":return D.jsx(ole,{className:"h-5 w-5"});default:return D.jsx(lle,{className:"h-5 w-5"})}},u=p=>{o(a.filter(f=>f.id!==p))},c=p=>{o(a.map(f=>({...f,isDefault:f.id===p})))},d=()=>{e(!1),r(null),s({type:"home",name:"",address:"",city:"",state:"",pincode:"",phone:"",isDefault:!1})},h=p=>{p.preventDefault();const f={...i,id:n?n.id:Math.random().toString(36).substr(2,9)};n?o(a.map(g=>g.id===n.id?{...f,isDefault:n.isDefault||f.isDefault}:f.isDefault?{...g,isDefault:!1}:g)):f.isDefault?o(a.map(g=>({...g,isDefault:!1})).concat(f)):(a.length===0&&(f.isDefault=!0),o([...a,f])),d()};return D.jsxs("div",{className:"flex flex-col min-h-[calc(100vh-4rem)] bg-white",children:[D.jsx("header",{className:"sticky top-0 z-10 bg-white border-b border-gray-200",children:D.jsx("div",{className:"px-4 sm:px-6 py-4",children:D.jsxs("div",{className:"flex items-center justify-between",children:[D.jsxs("div",{className:"flex items-center space-x-3",children:[D.jsx(jA,{className:"h-5 w-5 sm:h-6 sm:w-6 text-rose-600"}),D.jsx("h1",{className:"text-lg sm:text-xl font-semibold text-gray-900",children:"Saved Addresses"})]}),D.jsxs("button",{onClick:()=>e(!0),className:"inline-flex items-center px-3 sm:px-4 py-2 border border-transparent text-sm font-medium rounded-lg shadow-sm text-white bg-rose-600 hover:bg-rose-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-rose-500",children:[D.jsx(fj,{className:"h-4 w-4 sm:h-5 sm:w-5 mr-1 sm:mr-2"}),D.jsx("span",{className:"hidden sm:inline",children:"Add New"}),D.jsx("span",{className:"sm:hidden",children:"Add"})]})]})})}),D.jsx("div",{className:"flex-1 overflow-y-auto",children:D.jsx("div",{className:"px-4 sm:px-6 py-4 sm:py-6",children:a.length===0?D.jsxs("div",{className:"text-center py-12",children:[D.jsx(jA,{className:"h-16 w-16 text-gray-400 mx-auto mb-4"}),D.jsx("h3",{className:"text-lg font-medium text-gray-900",children:"No addresses saved"}),D.jsx("p",{className:"mt-1 text-sm sm:text-base text-gray-500",children:"Add a new address to save it for future purchases"})]}):D.jsx("div",{className:"grid gap-3 sm:gap-4 md:gap-6 md:grid-cols-2",children:a.map(p=>D.jsxs("div",{className:"relative bg-white sm:bg-gray-50 rounded-lg p-3 sm:p-4 border border-gray-200 hover:border-gray-300 transition-colors shadow-sm hover:shadow",children:[p.isDefault&&D.jsx("div",{className:"absolute right-0 top-0 p-3",children:D.jsx("span",{className:"px-2 py-1 bg-rose-100 text-rose-700 text-xs font-medium rounded-full",children:"Default"})}),D.jsxs("div",{className:"flex items-start space-x-3",children:[D.jsx("div",{className:"mt-1 text-gray-500 flex-shrink-0",children:l(p.type)}),D.jsxs("div",{className:"flex-1 min-w-0",children:[D.jsx("h3",{className:"text-base font-medium text-gray-900 truncate pr-16",children:p.name}),D.jsx("p",{className:"mt-1 text-sm text-gray-600 break-words",children:p.address}),D.jsxs("p",{className:"text-sm text-gray-600",children:[p.city,", ",p.state," ",p.pincode]}),D.jsxs("p",{className:"mt-2 text-sm text-gray-600",children:["Phone: ",p.phone]}),D.jsxs("div",{className:"mt-3 pt-3 border-t border-gray-100 flex flex-wrap items-center gap-3 sm:gap-4",children:[D.jsxs("button",{onClick:()=>{r(p),s(p),e(!0)},className:"inline-flex items-center px-2 py-1 text-sm text-gray-600 hover:text-gray-900 rounded-md hover:bg-gray-100",children:[D.jsx(ble,{className:"h-4 w-4 mr-1"}),"Edit"]}),!p.isDefault&&D.jsxs(D.Fragment,{children:[D.jsxs("button",{onClick:()=>u(p.id),className:"inline-flex items-center px-2 py-1 text-sm text-red-600 hover:text-red-700 rounded-md hover:bg-red-50",children:[D.jsx(wle,{className:"h-4 w-4 mr-1"}),"Delete"]}),D.jsxs("button",{onClick:()=>c(p.id),className:"inline-flex items-center px-2 py-1 text-sm text-rose-600 hover:text-rose-700 rounded-md hover:bg-rose-50",children:[D.jsx(jA,{className:"h-4 w-4 mr-1"}),"Set as Default"]})]})]})]})]})]},p.id))})})}),(t||n)&&D.jsx("div",{className:"fixed inset-0 z-50 overflow-hidden",children:D.jsxs("div",{className:"flex min-h-screen items-center justify-center px-4 pt-4 pb-20 text-center sm:block sm:p-0",children:[D.jsx("div",{className:"fixed inset-0 bg-black bg-opacity-40 transition-opacity","aria-hidden":"true",onClick:d}),D.jsx("span",{className:"hidden sm:inline-block sm:h-screen sm:align-middle","aria-hidden":"true",children:""}),D.jsx("div",{className:"relative inline-block w-full transform overflow-hidden rounded-t-xl bg-white text-left align-bottom shadow-xl transition-all sm:my-8 sm:w-full sm:max-w-lg sm:rounded-xl sm:align-middle",children:D.jsx("div",{className:"bg-white",children:D.jsxs("div",{className:"px-4 pt-5 pb-4 sm:p-6 sm:pb-4",children:[D.jsxs("div",{className:"flex items-center justify-between mb-5",children:[D.jsx("h3",{className:"text-xl font-semibold text-gray-900",children:n?"Edit Address":"Add New Address"}),D.jsxs("button",{onClick:d,className:"rounded-md text-gray-400 hover:text-gray-500 focus:outline-none focus:ring-2 focus:ring-rose-500",children:[D.jsx("span",{className:"sr-only",children:"Close"}),D.jsx(Fy,{className:"h-6 w-6"})]})]}),D.jsxs("form",{onSubmit:h,className:"mt-3",children:[D.jsxs("div",{children:[D.jsx("label",{className:"block text-sm font-medium text-gray-700",children:"Full Name"}),D.jsx("input",{type:"text",value:i.name||"",onChange:p=>s({...i,name:p.target.value}),className:"mt-1 block w-full border-gray-300 rounded-lg shadow-sm focus:ring-rose-500 focus:border-rose-500 text-base",placeholder:"Enter your full name",required:!0})]}),D.jsxs("div",{children:[D.jsx("label",{className:"block text-sm font-medium text-gray-700",children:"Phone Number"}),D.jsx("input",{type:"tel",value:i.phone||"",onChange:p=>s({...i,phone:p.target.value}),className:"mt-1 block w-full border-gray-300 rounded-lg shadow-sm focus:ring-rose-500 focus:border-rose-500 text-base",placeholder:"Enter phone number",required:!0})]}),D.jsxs("div",{children:[D.jsx("label",{className:"block text-sm font-medium text-gray-700",children:"Address Type"}),D.jsxs("select",{value:i.type||"home",onChange:p=>s({...i,type:p.target.value}),className:"mt-1 block w-full border-gray-300 rounded-lg shadow-sm focus:ring-rose-500 focus:border-rose-500 text-base",required:!0,children:[D.jsx("option",{value:"home",children:"Home"}),D.jsx("option",{value:"office",children:"Office"}),D.jsx("option",{value:"other",children:"Other"})]})]}),D.jsxs("div",{children:[D.jsx("label",{className:"block text-sm font-medium text-gray-700",children:"Street Address"}),D.jsx("input",{type:"text",value:i.address||"",onChange:p=>s({...i,address:p.target.value}),className:"mt-1 block w-full border-gray-300 rounded-lg shadow-sm focus:ring-rose-500 focus:border-rose-500 text-base",placeholder:"Enter street address",required:!0})]}),D.jsxs("div",{className:"grid grid-cols-1 sm:grid-cols-2 gap-4",children:[D.jsxs("div",{children:[D.jsx("label",{className:"block text-sm font-medium text-gray-700",children:"City"}),D.jsx("input",{type:"text",value:i.city||"",onChange:p=>s({...i,city:p.target.value}),className:"mt-1 block w-full border-gray-300 rounded-lg shadow-sm focus:ring-rose-500 focus:border-rose-500 text-base",placeholder:"Enter city",required:!0})]}),D.jsxs("div",{children:[D.jsx("label",{className:"block text-sm font-medium text-gray-700",children:"State"}),D.jsx("input",{type:"text",value:i.state||"",onChange:p=>s({...i,state:p.target.value}),className:"mt-1 block w-full border-gray-300 rounded-lg shadow-sm focus:ring-rose-500 focus:border-rose-500 text-base",placeholder:"Enter state",required:!0})]})]}),D.jsxs("div",{children:[D.jsx("label",{className:"block text-sm font-medium text-gray-700",children:"PIN Code"}),D.jsx("input",{type:"text",value:i.pincode||"",onChange:p=>s({...i,pincode:p.target.value}),className:"mt-1 block w-full border-gray-300 rounded-lg shadow-sm focus:ring-rose-500 focus:border-rose-500 text-base",placeholder:"Enter PIN code",required:!0})]}),!(n!=null&&n.isDefault)&&D.jsxs("div",{className:"flex items-center pt-2",children:[D.jsx("input",{type:"checkbox",id:"isDefault",checked:i.isDefault||!1,onChange:p=>s({...i,isDefault:p.target.checked}),className:"h-5 w-5 text-rose-600 focus:ring-rose-500 border-gray-300 rounded"}),D.jsx("label",{htmlFor:"isDefault",className:"ml-2 block text-base text-gray-900",children:"Set as default address"})]}),D.jsx("div",{className:"mt-6 sm:mt-8 border-t border-gray-200 pt-4",children:D.jsxs("div",{className:"flex flex-col-reverse sm:flex-row sm:space-x-3",children:[D.jsx("button",{type:"button",onClick:d,className:"mt-3 sm:mt-0 w-full sm:w-1/2 inline-flex justify-center px-4 py-2.5 border border-gray-300 shadow-sm text-base font-medium rounded-lg text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-rose-500",children:"Cancel"}),D.jsx("button",{type:"submit",className:"w-full sm:w-1/2 inline-flex justify-center px-4 py-2.5 border border-transparent text-base font-medium rounded-lg text-white bg-rose-600 hover:bg-rose-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-rose-500",children:n?"Save Changes":"Add Address"})]})})]})]})})})]})})]})},yet=()=>{const{wishlistItems:t,removeFromWishlist:e,clearWishlist:n}=pet(),{addItem:r}=B1(),i=h0(),[s,a]=ne.useState(!1),o=u=>{r({id:u.id,name:u.name,price:u.price,image:u.image}),e(u.id)},l=u=>{u&&i(`/design/${u}`)};return D.jsxs("div",{className:"flex flex-col min-h-full bg-white",children:[D.jsx("header",{className:"sticky top-0 z-20 bg-white border-b border-gray-200",children:D.jsx("div",{className:"px-4 sm:px-6 py-4",children:D.jsxs("div",{className:"flex items-center justify-between",children:[D.jsxs("div",{className:"flex items-center space-x-2",children:[D.jsx(FE,{className:"h-5 w-5 text-rose-600"}),D.jsx("h1",{className:"text-lg font-semibold text-gray-900",children:"My Wishlist"})]}),t.length>0&&D.jsxs("button",{onClick:()=>a(!0),className:"inline-flex items-center px-3 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-rose-500 focus:ring-offset-2",children:[D.jsx(sk,{className:"h-4 w-4 mr-1.5"}),D.jsx("span",{className:"hidden sm:inline",children:"Clear Wishlist"}),D.jsx("span",{className:"sm:hidden",children:"Clear"})]})]})})}),D.jsx("div",{className:"flex-1 overflow-y-auto",children:D.jsx("div",{className:"px-4 sm:px-6 py-4 sm:py-6",children:t.length===0?D.jsxs("div",{className:"text-center py-12",children:[D.jsx(FE,{className:"h-16 w-16 text-gray-400 mx-auto mb-4"}),D.jsx("h3",{className:"text-lg font-medium text-gray-900",children:"Your wishlist is empty"}),D.jsx("p",{className:"mt-1 text-sm sm:text-base text-gray-500",children:"Start adding items you love to your wishlist"})]}):D.jsx("div",{className:"grid gap-4 sm:gap-6 md:grid-cols-2 lg:grid-cols-3",children:t.map(u=>D.jsxs("div",{className:"relative bg-white sm:bg-gray-50 rounded-lg border border-gray-200 hover:border-gray-300 transition-colors shadow-sm hover:shadow overflow-hidden",children:[D.jsx("div",{className:"aspect-w-4 aspect-h-3 bg-gray-200 cursor-pointer",onClick:()=>l(u.designId),children:D.jsx("img",{src:u.image,alt:u.name,className:"object-cover w-full h-full"})}),D.jsxs("div",{className:"p-4",children:[D.jsx("h3",{className:"font-medium text-gray-900 truncate",children:u.name}),D.jsxs("p",{className:"mt-1 text-sm text-gray-700",children:["",u.price.toFixed(2)]}),D.jsxs("div",{className:"mt-4 flex items-center gap-3",children:[D.jsxs("button",{onClick:()=>o(u),className:"flex-1 inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-lg text-white bg-rose-600 hover:bg-rose-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-rose-500",children:[D.jsx(mP,{className:"h-4 w-4 mr-1.5"}),"Add to Cart"]}),D.jsx("button",{onClick:()=>e(u.id),className:"inline-flex items-center p-2 border border-gray-300 rounded-lg text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-rose-500",children:D.jsx(sk,{className:"h-4 w-4"})})]})]})]},u.id))})})}),s&&D.jsx("div",{className:"fixed inset-0 z-50 overflow-y-auto",children:D.jsxs("div",{className:"flex min-h-screen items-end justify-center px-4 pt-4 pb-20 text-center sm:block sm:p-0",children:[D.jsx("div",{className:"fixed inset-0 bg-black bg-opacity-40 transition-opacity","aria-hidden":"true",onClick:()=>a(!1)}),D.jsx("span",{className:"hidden sm:inline-block sm:h-screen sm:align-middle","aria-hidden":"true",children:""}),D.jsxs("div",{className:"relative inline-block transform overflow-hidden rounded-lg bg-white text-left align-bottom shadow-xl transition-all sm:my-8 sm:w-full sm:max-w-lg sm:align-middle",children:[D.jsx("div",{className:"bg-white px-4 pt-5 pb-4 sm:p-6 sm:pb-4",children:D.jsxs("div",{className:"sm:flex sm:items-start",children:[D.jsx("div",{className:"mx-auto flex h-12 w-12 flex-shrink-0 items-center justify-center rounded-full bg-red-100 sm:mx-0 sm:h-10 sm:w-10",children:D.jsx(sk,{className:"h-6 w-6 text-red-600"})}),D.jsxs("div",{className:"mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left",children:[D.jsx("h3",{className:"text-lg font-medium text-gray-900",children:"Clear Wishlist"}),D.jsx("div",{className:"mt-2",children:D.jsx("p",{className:"text-sm text-gray-500",children:"Are you sure you want to clear your wishlist? This action cannot be undone."})})]})]})}),D.jsxs("div",{className:"bg-gray-50 px-4 py-3 sm:flex sm:flex-row-reverse sm:px-6",children:[D.jsx("button",{type:"button",onClick:()=>{n(),a(!1)},className:"inline-flex w-full justify-center rounded-lg bg-red-600 px-4 py-2 text-base font-medium text-white shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 sm:ml-3 sm:w-auto sm:text-sm",children:"Clear Wishlist"}),D.jsx("button",{type:"button",onClick:()=>a(!1),className:"mt-3 inline-flex w-full justify-center rounded-lg border border-gray-300 bg-white px-4 py-2 text-base font-medium text-gray-700 shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-rose-500 focus:ring-offset-2 sm:mt-0 sm:w-auto sm:text-sm",children:"Cancel"})]})]})]})})]})},vet="dev-arrows.au.auth0.com",xet="wyCAzyDQa7umHNaXCColuKkLtx0pkX0G",k5={redirect_uri:"http://localhost:4173",audience:"https://dev-arrows.au.auth0.com/api/v2/"},bet={v7_startTransition:!0,v7_relativeSplatPath:!0};function wet(){const[t]=ne.useTransition();return D.jsxs(boe,{future:bet,children:[" ",D.jsxs(tle,{domain:vet,clientId:xet,authorizationParams:{redirect_uri:k5.redirect_uri,audience:k5.audience},cacheLocation:"localstorage",children:["        ",D.jsx(Ale,{children:D.jsx(Ele,{children:D.jsx(het,{children:D.jsxs("div",{className:"min-h-screen bg-white",children:[D.jsx(Tle,{}),t&&D.jsx("div",{className:"fixed top-0 left-0 w-full h-1",children:D.jsx("div",{className:"h-full bg-rose-600 animate-[loading_1s_ease-in-out_infinite]",style:{width:"25%"}})})," ",D.jsxs(poe,{children:[D.jsx(Mo,{path:"/",element:D.jsx(Nle,{})}),D.jsx(Mo,{path:"/about",element:D.jsx(kle,{})}),D.jsx(Mo,{path:"/design/*",element:D.jsx(M5,{})})," ",D.jsx(Mo,{path:"/auth",element:D.jsx(det,{})}),D.jsx(Mo,{path:"/orders",element:D.jsx(met,{})}),D.jsxs(Mo,{path:"/profile",element:D.jsx(fet,{}),children:[D.jsx(Mo,{path:"my-designs",element:D.jsx(M5,{})}),"                  ",D.jsx(Mo,{path:"wishlist",element:D.jsx(yet,{})}),D.jsx(Mo,{path:"payments",element:D.jsx("div",{children:"Payments Coming Soon"})}),D.jsx(Mo,{path:"addresses",element:D.jsx(get,{})}),D.jsx(Mo,{path:"settings",element:D.jsx("div",{children:"Settings Coming Soon"})})]})]}),"              ",D.jsx(Mle,{}),D.jsx(Cle,{})," "]})})})})]})]})}V8(document.getElementById("root")).render(D.jsx(ne.StrictMode,{children:D.jsx(wet,{})}));
